; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30137.0 

	TITLE	C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Distribute\Type.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	__snprintf
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z ; NSound::LoadSoundInformationPiece
PUBLIC	?SaveSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@@Z ; NSound::SaveSoundInformationPiece
PUBLIC	?DataToInstance@NSound@@YAXABV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@PAV?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@3@@Z ; NSound::DataToInstance
PUBLIC	?GetResultString@NSound@@YAPBDXZ		; NSound::GetResultString
PUBLIC	?SetResultString@NSound@@YAXPBD@Z		; NSound::SetResultString
PUBLIC	?_Xrange@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xrange
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Ufill@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEPAUSSoundData@NSound@@PAU34@IU_Value_init_tag@2@@Z ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Ufill
PUBLIC	?_Xlength@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@CAXXZ ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Xlength
PUBLIC	?_Ufill@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEPAUSSoundInstance@NSound@@PAU34@IU_Value_init_tag@2@@Z ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Ufill
PUBLIC	?_Xlength@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@CAXXZ ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Xlength
PUBLIC	?_Xrange@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@CAXXZ ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Xrange
PUBLIC	??$_Destroy_range@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAXPAUSSoundInstance@NSound@@QAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundInstance> >
PUBLIC	??$_Destroy_range@V?$allocator@USSoundData@NSound@@@std@@@std@@YAXPAUSSoundData@NSound@@QAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundData> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	?strResult@NSound@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; NSound::strResult
PUBLIC	??_C@_0BP@LLPPICEF@?5Can?5not?5open?5file?5for?5reading@ ; `string'
PUBLIC	??_C@_0P@DFMHJMOB@sounddatacount@		; `string'
PUBLIC	??_C@_0DD@IKAPCMKK@?5File?5format?5error?0?5SoundDataCo@ ; `string'
PUBLIC	??_C@_0O@OOLLGPNP@sounddata?$CF02d@		; `string'
PUBLIC	??_C@_0BA@EHBCCDFO@?5Unable?5to?5find@		; `string'
PUBLIC	??_C@_0BF@LPIKLLAN@?5File?5format?5error?3?5@	; `string'
PUBLIC	??_C@_0DE@ECJCCDPG@?5File?5format?5error?3?5The?5size?5of@ ; `string'
PUBLIC	??_C@_07EGDJHJID@?5Loaded@			; `string'
PUBLIC	??_C@_02BKFDOEMK@wt@				; `string'
PUBLIC	??_C@_0FN@PJPGJAJH@Failed?5to?5save?5file?5?$CI?$CFs?$CJ?4?6Pleas@ ; `string'
PUBLIC	??_C@_05NAOIJFC@Error@				; `string'
PUBLIC	??_C@_0BO@MLNNILFP@?5Cannot?5open?5file?5for?5writing@ ; `string'
PUBLIC	??_C@_0CN@NJIDENFN@ScriptType?5?5?5?5?5?5?5?5CharacterSoun@ ; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0BG@JEIKAJIN@SoundDataCount?5?5?5?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BN@FNDBKONF@SoundData?$CF02d?5?5?5?5?5?5?5?$CFf?5?$CC?$CFs?$CC?6@ ; `string'
PUBLIC	??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@	; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3c888889
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_atof:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	__unlink:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?IsFile@@YA_NPBD@Z:PROC				; IsFile
EXTRN	?LogBox@@YAXPBD0PAUHWND__@@@Z:PROC		; LogBox
EXTRN	?Cache@CTextFileLoader@@SAPAV1@PBD@Z:PROC	; CTextFileLoader::Cache
EXTRN	?IsEmpty@CTextFileLoader@@QAE_NXZ:PROC		; CTextFileLoader::IsEmpty
EXTRN	?SetTop@CTextFileLoader@@QAEXXZ:PROC		; CTextFileLoader::SetTop
EXTRN	?GetTokenVector@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z:PROC ; CTextFileLoader::GetTokenVector
EXTRN	?GetTokenInteger@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z:PROC ; CTextFileLoader::GetTokenInteger
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__ftoui3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
CRT$XCU	SEGMENT
?strResult$initializer$@NSound@@3P6AXXZA DD FLAT:??__EstrResult@NSound@@YAXXZ ; NSound::strResult$initializer$
CRT$XCU	ENDS
;	COMDAT __real@3c888889
CONST	SEGMENT
__real@3c888889 DD 03c888889r			; 0.0166667
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@
CONST	SEGMENT
??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@ DB 'invalid vector subscri'
	DB	'pt', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FNDBKONF@SoundData?$CF02d?5?5?5?5?5?5?5?$CFf?5?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0BN@FNDBKONF@SoundData?$CF02d?5?5?5?5?5?5?5?$CFf?5?$CC?$CFs?$CC?6@ DB 'S'
	DB	'oundData%02d       %f "%s"', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JEIKAJIN@SoundDataCount?5?5?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0BG@JEIKAJIN@SoundDataCount?5?5?5?5?$CFd?6@ DB 'SoundDataCount    %'
	DB	'd', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@NJIDENFN@ScriptType?5?5?5?5?5?5?5?5CharacterSoun@
CONST	SEGMENT
??_C@_0CN@NJIDENFN@ScriptType?5?5?5?5?5?5?5?5CharacterSoun@ DB 'ScriptTyp'
	DB	'e        CharacterSoundInformation', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MLNNILFP@?5Cannot?5open?5file?5for?5writing@
CONST	SEGMENT
??_C@_0BO@MLNNILFP@?5Cannot?5open?5file?5for?5writing@ DB ' Cannot open f'
	DB	'ile for writing', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05NAOIJFC@Error@
CONST	SEGMENT
??_C@_05NAOIJFC@Error@ DB 'Error', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FN@PJPGJAJH@Failed?5to?5save?5file?5?$CI?$CFs?$CJ?4?6Pleas@
CONST	SEGMENT
??_C@_0FN@PJPGJAJH@Failed?5to?5save?5file?5?$CI?$CFs?$CJ?4?6Pleas@ DB 'Fa'
	DB	'iled to save file (%s).', 0aH, 'Please check if it is read-on'
	DB	'ly or you have no space on the disk.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02BKFDOEMK@wt@
CONST	SEGMENT
??_C@_02BKFDOEMK@wt@ DB 'wt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07EGDJHJID@?5Loaded@
CONST	SEGMENT
??_C@_07EGDJHJID@?5Loaded@ DB ' Loaded', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@ECJCCDPG@?5File?5format?5error?3?5The?5size?5of@
CONST	SEGMENT
??_C@_0DE@ECJCCDPG@?5File?5format?5error?3?5The?5size?5of@ DB ' File form'
	DB	'at error: The size of the vector is not 2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LPIKLLAN@?5File?5format?5error?3?5@
CONST	SEGMENT
??_C@_0BF@LPIKLLAN@?5File?5format?5error?3?5@ DB ' File format error: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EHBCCDFO@?5Unable?5to?5find@
CONST	SEGMENT
??_C@_0BA@EHBCCDFO@?5Unable?5to?5find@ DB ' Unable to find', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OOLLGPNP@sounddata?$CF02d@
CONST	SEGMENT
??_C@_0O@OOLLGPNP@sounddata?$CF02d@ DB 'sounddata%02d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@IKAPCMKK@?5File?5format?5error?0?5SoundDataCo@
CONST	SEGMENT
??_C@_0DD@IKAPCMKK@?5File?5format?5error?0?5SoundDataCo@ DB ' File format'
	DB	' error, SoundDataCount Unable to find.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DFMHJMOB@sounddatacount@
CONST	SEGMENT
??_C@_0P@DFMHJMOB@sounddatacount@ DB 'sounddatacount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LLPPICEF@?5Can?5not?5open?5file?5for?5reading@
CONST	SEGMENT
??_C@_0BP@LLPPICEF@?5Can?5not?5open?5file?5for?5reading@ DB ' Can not ope'
	DB	'n file for reading', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
?strResult@NSound@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 014H DUP (?)
	DD	0fH					; NSound::strResult
_DATA	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SaveSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SaveSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SaveSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@@Z$1
__ehfuncinfo$?SaveSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SaveSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$8
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$9
xdata$x	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 134  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 135  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 137  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 85   :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 138  :         _Throw_bad_array_new_length(); // add overflow
; 139  :     }
; 140  : 
; 141  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 85   :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 145  : 
; 146  : #ifdef _DEBUG
; 147  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 148  : #endif // _DEBUG
; 149  :     return _Ptr;
; 150  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Oldsize$1$ = -16					; size = 4
_this$1$ = -12						; size = 4
tv715 = -8						; size = 4
$T2 = -4						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1229 :     _CONSTEXPR20_CONTAINER void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 1230 :         if (_Newsize > max_size()) {

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Newsize$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	89 7d f4	 mov	 DWORD PTR _this$1$[ebp], edi
  00011	81 fb 49 92 24
	09		 cmp	 ebx, 153391689		; 09249249H
  00017	0f 87 cd 01 00
	00		 ja	 $LN107@Resize_rea

; 1232 :         }
; 1233 : 
; 1234 :         auto& _My_data    = _Mypair._Myval2;
; 1235 :         pointer& _Myfirst = _My_data._Myfirst;
; 1236 :         pointer& _Mylast  = _My_data._Mylast;
; 1237 : 
; 1238 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  0001d	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00020	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00025	2b 0f		 sub	 ecx, DWORD PTR [edi]
  00027	f7 e9		 imul	 ecx
  00029	03 d1		 add	 edx, ecx

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002b	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0002e	2b 0f		 sub	 ecx, DWORD PTR [edi]

; 1232 :         }
; 1233 : 
; 1234 :         auto& _My_data    = _Mypair._Myval2;
; 1235 :         pointer& _Myfirst = _My_data._Myfirst;
; 1236 :         pointer& _Mylast  = _My_data._Mylast;
; 1237 : 
; 1238 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  00030	c1 fa 04	 sar	 edx, 4
  00033	8b c2		 mov	 eax, edx
  00035	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00038	03 c2		 add	 eax, edx
  0003a	89 45 f0	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0003d	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00042	f7 e9		 imul	 ecx

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00044	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00049	03 d1		 add	 edx, ecx
  0004b	c1 fa 04	 sar	 edx, 4
  0004e	8b ca		 mov	 ecx, edx
  00050	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00053	03 ca		 add	 ecx, edx

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00055	8b d1		 mov	 edx, ecx
  00057	d1 ea		 shr	 edx, 1
  00059	2b c2		 sub	 eax, edx
  0005b	3b c8		 cmp	 ecx, eax
  0005d	76 15		 jbe	 SHORT $LN10@Resize_rea

; 1689 :             return _Max; // geometric growth would overflow

  0005f	bb fc ff ff ff	 mov	 ebx, -4			; fffffffcH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00064	53		 push	 ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1689 :             return _Max; // geometric growth would overflow

  00065	89 5d f8	 mov	 DWORD PTR tv715[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00068	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0006d	83 c4 04	 add	 esp, 4
  00070	8b f0		 mov	 esi, eax
  00072	eb 50		 jmp	 SHORT $LN105@Resize_rea
$LN10@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00074	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1693 : 
; 1694 :         if (_Geometric < _Newsize) {

  00077	3b c3		 cmp	 eax, ebx
  00079	73 26		 jae	 SHORT $LN11@Resize_rea

; 1695 :             return _Newsize; // geometric growth would be insufficient

  0007b	8b c3		 mov	 eax, ebx
$LN102@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 69   :     return _Count * _Ty_size;

  0007d	8d 1c c5 00 00
	00 00		 lea	 ebx, DWORD PTR [eax*8]
  00084	2b d8		 sub	 ebx, eax
  00086	c1 e3 02	 shl	 ebx, 2
  00089	89 5d f8	 mov	 DWORD PTR tv715[ebp], ebx

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0008c	81 fb 00 10 00
	00		 cmp	 ebx, 4096		; 00001000H
  00092	72 1a		 jb	 SHORT $LN22@Resize_rea

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00094	53		 push	 ebx
  00095	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0009a	83 c4 04	 add	 esp, 4
  0009d	8b f0		 mov	 esi, eax
  0009f	eb 23		 jmp	 SHORT $LN105@Resize_rea
$LN11@Resize_rea:

; 64   :         if (_Count > _Max_possible) {

  000a1	3d 49 92 24 09	 cmp	 eax, 153391689		; 09249249H
  000a6	0f 87 43 01 00
	00		 ja	 $LN108@Resize_rea
  000ac	eb cf		 jmp	 SHORT $LN102@Resize_rea
$LN22@Resize_rea:

; 243  :     if (_Bytes != 0) {

  000ae	85 db		 test	 ebx, ebx
  000b0	74 10		 je	 SHORT $LN23@Resize_rea

; 85   :         return ::operator new(_Bytes);

  000b2	53		 push	 ebx
  000b3	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000b8	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  000bb	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
  000be	8b f0		 mov	 esi, eax
  000c0	eb 05		 jmp	 SHORT $LN21@Resize_rea
$LN23@Resize_rea:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000c2	33 f6		 xor	 esi, esi
$LN105@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1246 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  000c4	89 75 fc	 mov	 DWORD PTR $T2[ebp], esi
$LN21@Resize_rea:
  000c7	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  000ca	8b 4d f0	 mov	 ecx, DWORD PTR __Oldsize$1$[ebp]
  000cd	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  000d0	50		 push	 eax
  000d1	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000d4	2b c1		 sub	 eax, ecx
  000d6	50		 push	 eax
  000d7	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  000de	2b c1		 sub	 eax, ecx
  000e0	8b cf		 mov	 ecx, edi
  000e2	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ?_Ufill@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEPAUSSoundData@NSound@@PAU34@IU_Value_init_tag@2@@Z ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Ufill
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1718 :     const auto _ULast = _Get_unwrapped(_Last);

  000eb	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  000ee	8b fe		 mov	 edi, esi

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000f0	8b 75 f4	 mov	 esi, DWORD PTR _this$1$[ebp]
  000f3	8b 36		 mov	 esi, DWORD PTR [esi]

; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  000f5	3b f0		 cmp	 esi, eax
  000f7	74 5b		 je	 SHORT $LN34@Resize_rea
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1246 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  000f9	8b 4d fc	 mov	 ecx, DWORD PTR $T2[ebp]
  000fc	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  000ff	83 c1 04	 add	 ecx, 4
  00102	8b d8		 mov	 ebx, eax
$LL35@Resize_rea:
  00104	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1632 :         ++_Last;

  00106	8d 49 1c	 lea	 ecx, DWORD PTR [ecx+28]
  00109	89 07		 mov	 DWORD PTR [edi], eax

; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  0010b	8d 52 1c	 lea	 edx, DWORD PTR [edx+28]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0010e	c7 41 e4 00 00
	00 00		 mov	 DWORD PTR [ecx-28], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  00115	83 c6 1c	 add	 esi, 28			; 0000001cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2355 :     size_type _Mysize = 0; // current length of string

  00118	c7 41 f4 00 00
	00 00		 mov	 DWORD PTR [ecx-12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1632 :         ++_Last;

  0011f	83 c7 1c	 add	 edi, 28			; 0000001cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2356 :     size_type _Myres  = 0; // current storage reserved for string

  00122	c7 41 f8 00 00
	00 00		 mov	 DWORD PTR [ecx-8], 0

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00129	0f 10 42 e4	 movups	 xmm0, XMMWORD PTR [edx-28]
  0012d	0f 11 41 e4	 movups	 XMMWORD PTR [ecx-28], xmm0
  00131	f3 0f 7e 42 f4	 movq	 xmm0, QWORD PTR [edx-12]
  00136	66 0f d6 41 f4	 movq	 QWORD PTR [ecx-12], xmm0

; 4596 :         _My_data._Mysize = 0;

  0013b	c7 42 f4 00 00
	00 00		 mov	 DWORD PTR [edx-12], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00142	c7 42 f8 0f 00
	00 00		 mov	 DWORD PTR [edx-8], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00149	c6 42 e4 00	 mov	 BYTE PTR [edx-28], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  0014d	3b f3		 cmp	 esi, ebx
  0014f	75 b3		 jne	 SHORT $LL35@Resize_rea
  00151	8b 5d f8	 mov	 ebx, DWORD PTR tv715[ebp]
$LN34@Resize_rea:

; 1626 :         _Destroy_range(_First, _Last, _Al);

  00154	8b 75 f4	 mov	 esi, DWORD PTR _this$1$[ebp]
  00157	56		 push	 esi
  00158	57		 push	 edi
  00159	57		 push	 edi
  0015a	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USSoundData@NSound@@@std@@@std@@YAXPAUSSoundData@NSound@@QAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundData> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

  0015f	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1626 :         _Destroy_range(_First, _Last, _Al);

  00161	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

  00164	85 c9		 test	 ecx, ecx
  00166	74 57		 je	 SHORT $LN84@Resize_rea

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00168	56		 push	 esi
  00169	ff 76 04	 push	 DWORD PTR [esi+4]
  0016c	51		 push	 ecx
  0016d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USSoundData@NSound@@@std@@@std@@YAXPAUSSoundData@NSound@@QAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundData> >

; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00172	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00175	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0017a	8b 3e		 mov	 edi, DWORD PTR [esi]

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  0017c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0017f	2b cf		 sub	 ecx, edi
  00181	f7 e9		 imul	 ecx
  00183	03 d1		 add	 edx, ecx
  00185	c1 fa 04	 sar	 edx, 4
  00188	8b c2		 mov	 eax, edx
  0018a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0018d	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0018f	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  00196	2b c8		 sub	 ecx, eax
  00198	c1 e1 02	 shl	 ecx, 2

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0019b	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  001a1	72 12		 jb	 SHORT $LN94@Resize_rea

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001a3	8b 57 fc	 mov	 edx, DWORD PTR [edi-4]
  001a6	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  001a9	2b fa		 sub	 edi, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001ab	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  001ae	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001b1	77 32		 ja	 SHORT $LN91@Resize_rea

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  001b3	8b fa		 mov	 edi, edx
$LN94@Resize_rea:

; 264  :         ::operator delete(_Ptr, _Bytes);

  001b5	51		 push	 ecx
  001b6	57		 push	 edi
  001b7	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001bc	83 c4 08	 add	 esp, 8
$LN84@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1751 :         _Mylast  = _Newvec + _Newsize;

  001bf	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  001c2	8b 4d fc	 mov	 ecx, DWORD PTR $T2[ebp]
  001c5	89 0e		 mov	 DWORD PTR [esi], ecx

; 1752 :         _Myend   = _Newvec + _Newcapacity;

  001c7	5f		 pop	 edi
  001c8	8d 04 d5 00 00
	00 00		 lea	 eax, DWORD PTR [edx*8]
  001cf	2b c2		 sub	 eax, edx
  001d1	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  001d4	89 46 04	 mov	 DWORD PTR [esi+4], eax
  001d7	8d 04 0b	 lea	 eax, DWORD PTR [ebx+ecx]
  001da	89 46 08	 mov	 DWORD PTR [esi+8], eax
  001dd	5e		 pop	 esi
  001de	5b		 pop	 ebx

; 1255 :     }

  001df	8b e5		 mov	 esp, ebp
  001e1	5d		 pop	 ebp
  001e2	c2 08 00	 ret	 8
$LN91@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001e5	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN107@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1231 :             _Xlength();

  001ea	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@CAXXZ ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Xlength
$LN108@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  001ef	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN104@Resize_rea:
  001f4	cc		 int	 3
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Oldsize$1$ = -16					; size = 4
_this$1$ = -12						; size = 4
tv715 = -8						; size = 4
$T2 = -4						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1229 :     _CONSTEXPR20_CONTAINER void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 1230 :         if (_Newsize > max_size()) {

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Newsize$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	89 7d f4	 mov	 DWORD PTR _this$1$[ebp], edi
  00011	81 fb 49 92 24
	09		 cmp	 ebx, 153391689		; 09249249H
  00017	0f 87 cd 01 00
	00		 ja	 $LN107@Resize_rea

; 1232 :         }
; 1233 : 
; 1234 :         auto& _My_data    = _Mypair._Myval2;
; 1235 :         pointer& _Myfirst = _My_data._Myfirst;
; 1236 :         pointer& _Mylast  = _My_data._Mylast;
; 1237 : 
; 1238 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  0001d	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00020	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00025	2b 0f		 sub	 ecx, DWORD PTR [edi]
  00027	f7 e9		 imul	 ecx
  00029	03 d1		 add	 edx, ecx

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002b	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0002e	2b 0f		 sub	 ecx, DWORD PTR [edi]

; 1232 :         }
; 1233 : 
; 1234 :         auto& _My_data    = _Mypair._Myval2;
; 1235 :         pointer& _Myfirst = _My_data._Myfirst;
; 1236 :         pointer& _Mylast  = _My_data._Mylast;
; 1237 : 
; 1238 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  00030	c1 fa 04	 sar	 edx, 4
  00033	8b c2		 mov	 eax, edx
  00035	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00038	03 c2		 add	 eax, edx
  0003a	89 45 f0	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0003d	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00042	f7 e9		 imul	 ecx

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00044	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00049	03 d1		 add	 edx, ecx
  0004b	c1 fa 04	 sar	 edx, 4
  0004e	8b ca		 mov	 ecx, edx
  00050	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00053	03 ca		 add	 ecx, edx

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00055	8b d1		 mov	 edx, ecx
  00057	d1 ea		 shr	 edx, 1
  00059	2b c2		 sub	 eax, edx
  0005b	3b c8		 cmp	 ecx, eax
  0005d	76 15		 jbe	 SHORT $LN10@Resize_rea

; 1689 :             return _Max; // geometric growth would overflow

  0005f	bb fc ff ff ff	 mov	 ebx, -4			; fffffffcH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00064	53		 push	 ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1689 :             return _Max; // geometric growth would overflow

  00065	89 5d f8	 mov	 DWORD PTR tv715[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00068	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0006d	83 c4 04	 add	 esp, 4
  00070	8b f0		 mov	 esi, eax
  00072	eb 50		 jmp	 SHORT $LN105@Resize_rea
$LN10@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00074	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1693 : 
; 1694 :         if (_Geometric < _Newsize) {

  00077	3b c3		 cmp	 eax, ebx
  00079	73 26		 jae	 SHORT $LN11@Resize_rea

; 1695 :             return _Newsize; // geometric growth would be insufficient

  0007b	8b c3		 mov	 eax, ebx
$LN102@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 69   :     return _Count * _Ty_size;

  0007d	8d 1c c5 00 00
	00 00		 lea	 ebx, DWORD PTR [eax*8]
  00084	2b d8		 sub	 ebx, eax
  00086	c1 e3 02	 shl	 ebx, 2
  00089	89 5d f8	 mov	 DWORD PTR tv715[ebp], ebx

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0008c	81 fb 00 10 00
	00		 cmp	 ebx, 4096		; 00001000H
  00092	72 1a		 jb	 SHORT $LN22@Resize_rea

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00094	53		 push	 ebx
  00095	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0009a	83 c4 04	 add	 esp, 4
  0009d	8b f0		 mov	 esi, eax
  0009f	eb 23		 jmp	 SHORT $LN105@Resize_rea
$LN11@Resize_rea:

; 64   :         if (_Count > _Max_possible) {

  000a1	3d 49 92 24 09	 cmp	 eax, 153391689		; 09249249H
  000a6	0f 87 43 01 00
	00		 ja	 $LN108@Resize_rea
  000ac	eb cf		 jmp	 SHORT $LN102@Resize_rea
$LN22@Resize_rea:

; 243  :     if (_Bytes != 0) {

  000ae	85 db		 test	 ebx, ebx
  000b0	74 10		 je	 SHORT $LN23@Resize_rea

; 85   :         return ::operator new(_Bytes);

  000b2	53		 push	 ebx
  000b3	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000b8	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  000bb	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
  000be	8b f0		 mov	 esi, eax
  000c0	eb 05		 jmp	 SHORT $LN21@Resize_rea
$LN23@Resize_rea:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000c2	33 f6		 xor	 esi, esi
$LN105@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1246 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  000c4	89 75 fc	 mov	 DWORD PTR $T2[ebp], esi
$LN21@Resize_rea:
  000c7	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  000ca	8b 4d f0	 mov	 ecx, DWORD PTR __Oldsize$1$[ebp]
  000cd	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  000d0	50		 push	 eax
  000d1	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000d4	2b c1		 sub	 eax, ecx
  000d6	50		 push	 eax
  000d7	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  000de	2b c1		 sub	 eax, ecx
  000e0	8b cf		 mov	 ecx, edi
  000e2	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ?_Ufill@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEPAUSSoundInstance@NSound@@PAU34@IU_Value_init_tag@2@@Z ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Ufill
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1718 :     const auto _ULast = _Get_unwrapped(_Last);

  000eb	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  000ee	8b fe		 mov	 edi, esi

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000f0	8b 75 f4	 mov	 esi, DWORD PTR _this$1$[ebp]
  000f3	8b 36		 mov	 esi, DWORD PTR [esi]

; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  000f5	3b f0		 cmp	 esi, eax
  000f7	74 5b		 je	 SHORT $LN34@Resize_rea
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1246 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  000f9	8b 4d fc	 mov	 ecx, DWORD PTR $T2[ebp]
  000fc	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  000ff	83 c1 04	 add	 ecx, 4
  00102	8b d8		 mov	 ebx, eax
$LL35@Resize_rea:
  00104	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1632 :         ++_Last;

  00106	8d 49 1c	 lea	 ecx, DWORD PTR [ecx+28]
  00109	89 07		 mov	 DWORD PTR [edi], eax

; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  0010b	8d 52 1c	 lea	 edx, DWORD PTR [edx+28]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0010e	c7 41 e4 00 00
	00 00		 mov	 DWORD PTR [ecx-28], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  00115	83 c6 1c	 add	 esi, 28			; 0000001cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2355 :     size_type _Mysize = 0; // current length of string

  00118	c7 41 f4 00 00
	00 00		 mov	 DWORD PTR [ecx-12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1632 :         ++_Last;

  0011f	83 c7 1c	 add	 edi, 28			; 0000001cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2356 :     size_type _Myres  = 0; // current storage reserved for string

  00122	c7 41 f8 00 00
	00 00		 mov	 DWORD PTR [ecx-8], 0

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00129	0f 10 42 e4	 movups	 xmm0, XMMWORD PTR [edx-28]
  0012d	0f 11 41 e4	 movups	 XMMWORD PTR [ecx-28], xmm0
  00131	f3 0f 7e 42 f4	 movq	 xmm0, QWORD PTR [edx-12]
  00136	66 0f d6 41 f4	 movq	 QWORD PTR [ecx-12], xmm0

; 4596 :         _My_data._Mysize = 0;

  0013b	c7 42 f4 00 00
	00 00		 mov	 DWORD PTR [edx-12], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00142	c7 42 f8 0f 00
	00 00		 mov	 DWORD PTR [edx-8], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00149	c6 42 e4 00	 mov	 BYTE PTR [edx-28], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  0014d	3b f3		 cmp	 esi, ebx
  0014f	75 b3		 jne	 SHORT $LL35@Resize_rea
  00151	8b 5d f8	 mov	 ebx, DWORD PTR tv715[ebp]
$LN34@Resize_rea:

; 1626 :         _Destroy_range(_First, _Last, _Al);

  00154	8b 75 f4	 mov	 esi, DWORD PTR _this$1$[ebp]
  00157	56		 push	 esi
  00158	57		 push	 edi
  00159	57		 push	 edi
  0015a	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAXPAUSSoundInstance@NSound@@QAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundInstance> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

  0015f	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1626 :         _Destroy_range(_First, _Last, _Al);

  00161	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

  00164	85 c9		 test	 ecx, ecx
  00166	74 57		 je	 SHORT $LN84@Resize_rea

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00168	56		 push	 esi
  00169	ff 76 04	 push	 DWORD PTR [esi+4]
  0016c	51		 push	 ecx
  0016d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAXPAUSSoundInstance@NSound@@QAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundInstance> >

; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00172	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00175	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0017a	8b 3e		 mov	 edi, DWORD PTR [esi]

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  0017c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0017f	2b cf		 sub	 ecx, edi
  00181	f7 e9		 imul	 ecx
  00183	03 d1		 add	 edx, ecx
  00185	c1 fa 04	 sar	 edx, 4
  00188	8b c2		 mov	 eax, edx
  0018a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0018d	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0018f	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  00196	2b c8		 sub	 ecx, eax
  00198	c1 e1 02	 shl	 ecx, 2

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0019b	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  001a1	72 12		 jb	 SHORT $LN94@Resize_rea

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001a3	8b 57 fc	 mov	 edx, DWORD PTR [edi-4]
  001a6	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  001a9	2b fa		 sub	 edi, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001ab	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  001ae	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001b1	77 32		 ja	 SHORT $LN91@Resize_rea

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  001b3	8b fa		 mov	 edi, edx
$LN94@Resize_rea:

; 264  :         ::operator delete(_Ptr, _Bytes);

  001b5	51		 push	 ecx
  001b6	57		 push	 edi
  001b7	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001bc	83 c4 08	 add	 esp, 8
$LN84@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1751 :         _Mylast  = _Newvec + _Newsize;

  001bf	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  001c2	8b 4d fc	 mov	 ecx, DWORD PTR $T2[ebp]
  001c5	89 0e		 mov	 DWORD PTR [esi], ecx

; 1752 :         _Myend   = _Newvec + _Newcapacity;

  001c7	5f		 pop	 edi
  001c8	8d 04 d5 00 00
	00 00		 lea	 eax, DWORD PTR [edx*8]
  001cf	2b c2		 sub	 eax, edx
  001d1	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  001d4	89 46 04	 mov	 DWORD PTR [esi+4], eax
  001d7	8d 04 0b	 lea	 eax, DWORD PTR [ebx+ecx]
  001da	89 46 08	 mov	 DWORD PTR [esi+8], eax
  001dd	5e		 pop	 esi
  001de	5b		 pop	 ebx

; 1255 :     }

  001df	8b e5		 mov	 esp, ebp
  001e1	5d		 pop	 ebp
  001e2	c2 08 00	 ret	 8
$LN91@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001e5	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN107@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1231 :             _Xlength();

  001ea	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@CAXXZ ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Xlength
$LN108@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  001ef	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN104@Resize_rea:
  001f4	cc		 int	 3
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@USSoundData@NSound@@@std@@@std@@YAXPAUSSoundData@NSound@@QAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@USSoundData@NSound@@@std@@@std@@YAXPAUSSoundData@NSound@@QAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NSound::SSoundData> >, COMDAT

; 945  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 949  :         for (; _First != _Last; ++_First) {

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 4d		 je	 SHORT $LN49@Destroy_ra
  0000f	83 c6 18	 add	 esi, 24			; 00000018H
$LL4@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00012	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00014	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00017	72 28		 jb	 SHORT $LN26@Destroy_ra
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00019	8b 46 ec	 mov	 eax, DWORD PTR [esi-20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0001c	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0001d	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00023	72 12		 jb	 SHORT $LN36@Destroy_ra

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00025	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00028	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0002b	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0002d	83 c0 fc	 add	 eax, -4			; fffffffcH
  00030	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00033	77 2b		 ja	 SHORT $LN33@Destroy_ra

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00035	8b c2		 mov	 eax, edx
$LN36@Destroy_ra:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00037	51		 push	 ecx
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003e	83 c4 08	 add	 esp, 8
$LN26@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  00041	c7 46 fc 00 00
	00 00		 mov	 DWORD PTR [esi-4], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00048	c7 06 0f 00 00
	00		 mov	 DWORD PTR [esi], 15	; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0004e	c6 46 ec 00	 mov	 BYTE PTR [esi-20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 949  :         for (; _First != _Last; ++_First) {

  00052	83 c6 1c	 add	 esi, 28			; 0000001cH
  00055	8d 46 e8	 lea	 eax, DWORD PTR [esi-24]
  00058	3b c7		 cmp	 eax, edi
  0005a	75 b6		 jne	 SHORT $LL4@Destroy_ra
$LN49@Destroy_ra:
  0005c	5f		 pop	 edi

; 950  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 951  :         }
; 952  :     }
; 953  : }

  0005d	5e		 pop	 esi
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
$LN33@Destroy_ra:

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00060	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN50@Destroy_ra:
  00065	cc		 int	 3
??$_Destroy_range@V?$allocator@USSoundData@NSound@@@std@@@std@@YAXPAUSSoundData@NSound@@QAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NSound::SSoundData> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAXPAUSSoundInstance@NSound@@QAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAXPAUSSoundInstance@NSound@@QAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NSound::SSoundInstance> >, COMDAT

; 945  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 949  :         for (; _First != _Last; ++_First) {

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 4d		 je	 SHORT $LN49@Destroy_ra
  0000f	83 c6 18	 add	 esi, 24			; 00000018H
$LL4@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00012	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00014	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00017	72 28		 jb	 SHORT $LN26@Destroy_ra
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00019	8b 46 ec	 mov	 eax, DWORD PTR [esi-20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0001c	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0001d	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00023	72 12		 jb	 SHORT $LN36@Destroy_ra

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00025	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00028	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0002b	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0002d	83 c0 fc	 add	 eax, -4			; fffffffcH
  00030	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00033	77 2b		 ja	 SHORT $LN33@Destroy_ra

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00035	8b c2		 mov	 eax, edx
$LN36@Destroy_ra:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00037	51		 push	 ecx
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003e	83 c4 08	 add	 esp, 8
$LN26@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  00041	c7 46 fc 00 00
	00 00		 mov	 DWORD PTR [esi-4], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00048	c7 06 0f 00 00
	00		 mov	 DWORD PTR [esi], 15	; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0004e	c6 46 ec 00	 mov	 BYTE PTR [esi-20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 949  :         for (; _First != _Last; ++_First) {

  00052	83 c6 1c	 add	 esi, 28			; 0000001cH
  00055	8d 46 e8	 lea	 eax, DWORD PTR [esi-24]
  00058	3b c7		 cmp	 eax, edi
  0005a	75 b6		 jne	 SHORT $LL4@Destroy_ra
$LN49@Destroy_ra:
  0005c	5f		 pop	 edi

; 950  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 951  :         }
; 952  :     }
; 953  : }

  0005d	5e		 pop	 esi
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
$LN33@Destroy_ra:

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00060	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN50@Destroy_ra:
  00065	cc		 int	 3
??$_Destroy_range@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAXPAUSSoundInstance@NSound@@QAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NSound::SSoundInstance> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xrange@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xrange@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@CAXXZ PROC ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Xrange, COMDAT

; 1778 :         _Xout_of_range("invalid vector subscript");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN3@Xrange:
  0000a	cc		 int	 3
?_Xrange@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@CAXXZ ENDP ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Xrange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@CAXXZ PROC ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Xlength, COMDAT

; 1774 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@CAXXZ ENDP ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Ufill@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEPAUSSoundInstance@NSound@@PAU34@IU_Value_init_tag@2@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 1
?_Ufill@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEPAUSSoundInstance@NSound@@PAU34@IU_Value_init_tag@2@@Z PROC ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Ufill, COMDAT
; _this$ = ecx

; 1646 :     _CONSTEXPR20_CONTAINER pointer _Ufill(pointer _Dest, const size_type _Count, _Value_init_tag) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1648 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00007	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]

; 1830 :     for (; 0 < _Count; --_Count) {

  0000a	85 c0		 test	 eax, eax
  0000c	74 41		 je	 SHORT $LN5@Ufill
  0000e	66 90		 npad	 2
$LL6@Ufill:

; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

  00010	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00016	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001d	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00024	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0002b	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00032	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 4596 :         _My_data._Mysize = 0;

  00039	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00040	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1632 :         ++_Last;

  00047	83 c6 1c	 add	 esi, 28			; 0000001cH

; 1830 :     for (; 0 < _Count; --_Count) {

  0004a	83 e8 01	 sub	 eax, 1
  0004d	75 c1		 jne	 SHORT $LL6@Ufill
$LN5@Ufill:

; 1626 :         _Destroy_range(_First, _Last, _Al);

  0004f	51		 push	 ecx
  00050	56		 push	 esi
  00051	56		 push	 esi
  00052	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAXPAUSSoundInstance@NSound@@QAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundInstance> >
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1648 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  0005a	8b c6		 mov	 eax, esi
  0005c	5e		 pop	 esi

; 1649 :     }

  0005d	5d		 pop	 ebp
  0005e	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEPAUSSoundInstance@NSound@@PAU34@IU_Value_init_tag@2@@Z ENDP ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@CAXXZ PROC ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Xlength, COMDAT

; 1774 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@CAXXZ ENDP ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Ufill@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEPAUSSoundData@NSound@@PAU34@IU_Value_init_tag@2@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 1
?_Ufill@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEPAUSSoundData@NSound@@PAU34@IU_Value_init_tag@2@@Z PROC ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Ufill, COMDAT
; _this$ = ecx

; 1646 :     _CONSTEXPR20_CONTAINER pointer _Ufill(pointer _Dest, const size_type _Count, _Value_init_tag) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1648 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00007	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]

; 1830 :     for (; 0 < _Count; --_Count) {

  0000a	85 c0		 test	 eax, eax
  0000c	74 41		 je	 SHORT $LN5@Ufill
  0000e	66 90		 npad	 2
$LL6@Ufill:

; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

  00010	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00016	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001d	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00024	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0002b	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00032	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 4596 :         _My_data._Mysize = 0;

  00039	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00040	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1632 :         ++_Last;

  00047	83 c6 1c	 add	 esi, 28			; 0000001cH

; 1830 :     for (; 0 < _Count; --_Count) {

  0004a	83 e8 01	 sub	 eax, 1
  0004d	75 c1		 jne	 SHORT $LL6@Ufill
$LN5@Ufill:

; 1626 :         _Destroy_range(_First, _Last, _Al);

  0004f	51		 push	 ecx
  00050	56		 push	 esi
  00051	56		 push	 esi
  00052	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USSoundData@NSound@@@std@@@std@@YAXPAUSSoundData@NSound@@QAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundData> >
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1648 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  0005a	8b c6		 mov	 eax, esi
  0005c	5e		 pop	 esi

; 1649 :     }

  0005d	5d		 pop	 ebp
  0005e	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEPAUSSoundData@NSound@@PAU34@IU_Value_init_tag@2@@Z ENDP ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z
_TEXT	SEGMENT
__New_size$1$ = -8					; size = 4
__Left_size$1$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4722 :     const basic_string<_Elem, _Traits, _Alloc>& _Left, _In_z_ const _Elem* const _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 4723 :     using _Size_type       = typename basic_string<_Elem, _Traits, _Alloc>::size_type;
; 4724 :     const auto _Left_size  = _Left.size();

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0000b	8b 75 10	 mov	 esi, DWORD PTR __Right$[ebp]

; 4723 :     using _Size_type       = typename basic_string<_Elem, _Traits, _Alloc>::size_type;
; 4724 :     const auto _Left_size  = _Left.size();

  0000e	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00011	57		 push	 edi
  00012	89 55 fc	 mov	 DWORD PTR __Left_size$1$[ebp], edx

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00015	8d 7e 01	 lea	 edi, DWORD PTR [esi+1]
$LL47@operator:
  00018	8a 06		 mov	 al, BYTE PTR [esi]
  0001a	46		 inc	 esi
  0001b	84 c0		 test	 al, al
  0001d	75 f9		 jne	 SHORT $LL47@operator

; 4725 :     const auto _Right_size = _Convert_size<_Size_type>(_Traits::length(_Right));
; 4726 :     if (_Left.max_size() - _Left_size < _Right_size) {

  0001f	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00024	2b f7		 sub	 esi, edi

; 4725 :     const auto _Right_size = _Convert_size<_Size_type>(_Traits::length(_Right));
; 4726 :     if (_Left.max_size() - _Left_size < _Right_size) {

  00026	2b c2		 sub	 eax, edx
  00028	3b c6		 cmp	 eax, esi
  0002a	0f 82 d5 00 00
	00		 jb	 $LN50@operator

; 2319 :         return _BUF_SIZE <= _Myres;

  00030	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 2306 :         if (_Large_string_engaged()) {

  00034	72 05		 jb	 SHORT $LN11@operator

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  00036	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00038	89 4d 0c	 mov	 DWORD PTR __Left$[ebp], ecx
$LN11@operator:

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0003b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2635 :         const auto _New_size    = static_cast<size_type>(_Left_size + _Right_size);

  0003e	8d 1c 16	 lea	 ebx, DWORD PTR [esi+edx]

; 2636 :         size_type _New_capacity = _BUF_SIZE - 1;

  00041	bf 0f 00 00 00	 mov	 edi, 15			; 0000000fH
  00046	89 5d f8	 mov	 DWORD PTR __New_size$1$[ebp], ebx

; 2637 :         auto& _My_data          = _Mypair._Myval2;
; 2638 :         _Elem* _Ptr             = _My_data._Bx._Buf;

  00049	8d 0c 16	 lea	 ecx, DWORD PTR [esi+edx]
  0004c	8b d8		 mov	 ebx, eax

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0004e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 2355 :     size_type _Mysize = 0; // current length of string

  00054	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 2356 :     size_type _Myres  = 0; // current storage reserved for string

  0005b	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 2638 :         _Elem* _Ptr             = _My_data._Bx._Buf;

  00062	3b cf		 cmp	 ecx, edi

; 2639 :         auto&& _Alproxy         = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2640 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws
; 2641 : 
; 2642 : #ifdef __cpp_lib_constexpr_string
; 2643 :         const bool _Activate_large_mode = _New_capacity < _New_size || _STD is_constant_evaluated();
; 2644 : #else // ^^^ __cpp_lib_constexpr_string / !__cpp_lib_constexpr_string vvv
; 2645 :         const bool _Activate_large_mode = _New_capacity < _New_size;
; 2646 : #endif // __cpp_lib_constexpr_string
; 2647 : 
; 2648 :         if (_Activate_large_mode) {

  00064	76 68		 jbe	 SHORT $LN16@operator

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00066	8b 7d f8	 mov	 edi, DWORD PTR __New_size$1$[ebp]
  00069	83 cf 0f	 or	 edi, 15			; 0000000fH
  0006c	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH

; 4489 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00072	76 1a		 jbe	 SHORT $LN29@operator

; 4490 :             return _Max;

  00074	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  00079	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0007e	52		 push	 edx
  0007f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00084	8b d8		 mov	 ebx, eax
  00086	83 c4 04	 add	 esp, 4
  00089	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0008c	eb 3b		 jmp	 SHORT $LN36@operator
$LN29@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  0008e	ba 16 00 00 00	 mov	 edx, 22			; 00000016H
  00093	3b fa		 cmp	 edi, edx
  00095	0f 42 fa	 cmovb	 edi, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2652 :             const pointer _Fancyptr         = _Getal().allocate(_New_capacity + 1); // throws

  00098	8d 57 01	 lea	 edx, DWORD PTR [edi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0009b	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  000a1	72 10		 jb	 SHORT $LN37@operator

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a3	52		 push	 edx
  000a4	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a9	8b d8		 mov	 ebx, eax
  000ab	83 c4 04	 add	 esp, 4
  000ae	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000b1	eb 16		 jmp	 SHORT $LN36@operator
$LN37@operator:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  000b3	85 d2		 test	 edx, edx
  000b5	74 10		 je	 SHORT $LN38@operator

; 85   :         return ::operator new(_Bytes);

  000b7	52		 push	 edx
  000b8	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 244  :         return _Traits::_Allocate(_Bytes);

  000bd	8b d8		 mov	 ebx, eax

; 85   :         return ::operator new(_Bytes);

  000bf	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  000c2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000c5	eb 02		 jmp	 SHORT $LN36@operator
$LN38@operator:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000c7	33 db		 xor	 ebx, ebx
$LN36@operator:
  000c9	8b 55 fc	 mov	 edx, DWORD PTR __Left_size$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2654 :             _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);

  000cc	89 18		 mov	 DWORD PTR [eax], ebx
$LN16@operator:

; 2655 :         }
; 2656 : 
; 2657 : #ifdef __cpp_lib_constexpr_string
; 2658 :         if (_STD is_constant_evaluated()) { // Begin the lifetimes of the objects before copying to avoid UB
; 2659 :             _Traits::assign(_Ptr, _New_capacity + 1, _Elem());
; 2660 :         }
; 2661 : #endif // __cpp_lib_constexpr_string
; 2662 : 
; 2663 :         _My_data._Mysize = _New_size;

  000ce	8d 0c 16	 lea	 ecx, DWORD PTR [esi+edx]

; 2664 :         _My_data._Myres  = _New_capacity;

  000d1	89 78 14	 mov	 DWORD PTR [eax+20], edi

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000d4	52		 push	 edx

; 2663 :         _My_data._Mysize = _New_size;

  000d5	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000d8	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  000db	51		 push	 ecx
  000dc	53		 push	 ebx
  000dd	e8 00 00 00 00	 call	 _memcpy

; 2666 :         _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);

  000e2	8b 4d fc	 mov	 ecx, DWORD PTR __Left_size$1$[ebp]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000e5	56		 push	 esi
  000e6	ff 75 10	 push	 DWORD PTR __Right$[ebp]

; 2666 :         _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);

  000e9	03 cb		 add	 ecx, ebx

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000eb	51		 push	 ecx
  000ec	e8 00 00 00 00	 call	 _memcpy

; 2667 :         _Traits::assign(_Ptr[_New_size], _Elem());

  000f1	8b 45 f8	 mov	 eax, DWORD PTR __New_size$1$[ebp]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000f4	83 c4 18	 add	 esp, 24			; 00000018H

; 4728 :     }
; 4729 : 
; 4730 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

  000f7	5f		 pop	 edi

; 2667 :         _Traits::assign(_Ptr[_New_size], _Elem());

  000f8	c6 04 03 00	 mov	 BYTE PTR [ebx+eax], 0

; 4728 :     }
; 4729 : 
; 4730 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

  000fc	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000ff	5e		 pop	 esi
  00100	5b		 pop	 ebx

; 4731 : }

  00101	8b e5		 mov	 esp, ebp
  00103	5d		 pop	 ebp
  00104	c3		 ret	 0
$LN50@operator:

; 4727 :         _Xlen_string();

  00105	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN48@operator:
  0010a	cc		 int	 3
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??__FstrResult@NSound@@YAXXZ
text$yd	SEGMENT
??__FstrResult@NSound@@YAXXZ PROC			; NSound::`dynamic atexit destructor for 'strResult'', COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00000	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?strResult@NSound@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 2a		 jb	 SHORT $LN15@dynamic
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?strResult@NSound@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00010	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00011	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN25@dynamic

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00019	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001c	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 28		 ja	 SHORT $LN22@dynamic

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00029	8b c2		 mov	 eax, edx
$LN25@dynamic:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0002b	51		 push	 ecx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00032	83 c4 08	 add	 esp, 8
$LN15@dynamic:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  00035	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?strResult@NSound@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0003f	c7 05 14 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?strResult@NSound@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00049	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?strResult@NSound@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, 0
  00050	c3		 ret	 0
$LN22@dynamic:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00051	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??__FstrResult@NSound@@YAXXZ ENDP			; NSound::`dynamic atexit destructor for 'strResult''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
;	COMDAT ??__EstrResult@NSound@@YAXXZ
text$di	SEGMENT
??__EstrResult@NSound@@YAXXZ PROC			; NSound::`dynamic initializer for 'strResult'', COMDAT

; 5    : std::string NSound::strResult;

  00000	68 00 00 00 00	 push	 OFFSET ??__FstrResult@NSound@@YAXXZ ; NSound::`dynamic atexit destructor for 'strResult''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__EstrResult@NSound@@YAXXZ ENDP			; NSound::`dynamic initializer for 'strResult''
text$di	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xrange@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xrange@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xrange, COMDAT

; 1778 :         _Xout_of_range("invalid vector subscript");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN3@Xrange:
  0000a	cc		 int	 3
?_Xrange@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xrange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
;	COMDAT ?SetResultString@NSound@@YAXPBD@Z
_TEXT	SEGMENT
_c_pszStr$ = 8						; size = 4
?SetResultString@NSound@@YAXPBD@Z PROC			; NSound::SetResultString, COMDAT

; 13   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00003	8b 55 08	 mov	 edx, DWORD PTR _c_pszStr$[ebp]
  00006	8b c2		 mov	 eax, edx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 13   : {

  00008	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00009	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0000c	0f 1f 40 00	 npad	 4
$LL7@SetResultS:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL7@SetResultS
  00017	2b c6		 sub	 eax, esi

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00019	b9 00 00 00 00	 mov	 ecx, OFFSET ?strResult@NSound@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; NSound::strResult
  0001e	50		 push	 eax
  0001f	52		 push	 edx
  00020	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00025	5e		 pop	 esi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 15   : }

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?SetResultString@NSound@@YAXPBD@Z ENDP			; NSound::SetResultString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
;	COMDAT ?GetResultString@NSound@@YAPBDXZ
_TEXT	SEGMENT
?GetResultString@NSound@@YAPBDXZ PROC			; NSound::GetResultString, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00000	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?strResult@NSound@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H

; 2305 :         const value_type* _Result = _Bx._Buf;

  00007	b8 00 00 00 00	 mov	 eax, OFFSET ?strResult@NSound@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; NSound::strResult

; 2306 :         if (_Large_string_engaged()) {

  0000c	0f 43 05 00 00
	00 00		 cmovae	 eax, DWORD PTR ?strResult@NSound@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 10   : }

  00013	c3		 ret	 0
?GetResultString@NSound@@YAPBDXZ ENDP			; NSound::GetResultString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
;	COMDAT ?DataToInstance@NSound@@YAXABV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@PAV?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@3@@Z
_TEXT	SEGMENT
tv512 = -4						; size = 4
__Oldlast$1$ = 8					; size = 4
_i$1$ = 8						; size = 4
$T1 = 8							; size = 1
_c_rSoundDataVector$ = 8				; size = 4
_pSoundInstanceVector$ = 12				; size = 4
?DataToInstance@NSound@@YAXABV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@PAV?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@3@@Z PROC ; NSound::DataToInstance, COMDAT

; 119  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _c_rSoundDataVector$[ebp]
  00008	8b 03		 mov	 eax, DWORD PTR [ebx]
  0000a	3b 43 04	 cmp	 eax, DWORD PTR [ebx+4]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 120  : 	if (c_rSoundDataVector.empty())

  0000d	0f 84 26 01 00
	00		 je	 $LN3@DataToInst
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00013	56		 push	 esi
  00014	8b 75 0c	 mov	 esi, DWORD PTR _pSoundInstanceVector$[ebp]
  00017	57		 push	 edi
  00018	56		 push	 esi
  00019	ff 76 04	 push	 DWORD PTR [esi+4]
  0001c	ff 36		 push	 DWORD PTR [esi]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAXPAUSSoundInstance@NSound@@QAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundInstance> >

; 1456 :         _Mylast = _Myfirst;

  00023	8b 06		 mov	 eax, DWORD PTR [esi]

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00025	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1456 :         _Mylast = _Myfirst;

  00028	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0002b	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0002e	2b 0b		 sub	 ecx, DWORD PTR [ebx]

; 1456 :         _Mylast = _Myfirst;

  00030	89 45 08	 mov	 DWORD PTR __Oldlast$1$[ebp], eax

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00033	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00038	f7 e9		 imul	 ecx
  0003a	03 d1		 add	 edx, ecx
  0003c	c1 fa 04	 sar	 edx, 4
  0003f	8b fa		 mov	 edi, edx
  00041	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00044	03 fa		 add	 edi, edx

; 1272 :         if (_Newsize > _Oldsize) { // append

  00046	74 3a		 je	 SHORT $LN19@DataToInst

; 1273 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  00048	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0004b	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00050	2b 4d 08	 sub	 ecx, DWORD PTR __Oldlast$1$[ebp]
  00053	f7 e9		 imul	 ecx
  00055	03 d1		 add	 edx, ecx

; 1274 :             if (_Newsize > _Oldcapacity) { // reallocate

  00057	8b ce		 mov	 ecx, esi
  00059	c1 fa 04	 sar	 edx, 4
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00061	03 c2		 add	 eax, edx
  00063	3b f8		 cmp	 edi, eax
  00065	76 0c		 jbe	 SHORT $LN20@DataToInst

; 1275 :                 _Resize_reallocate(_Newsize, _Val);

  00067	8d 45 08	 lea	 eax, DWORD PTR $T1[ebp]
  0006a	50		 push	 eax
  0006b	57		 push	 edi
  0006c	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Resize_reallocate<std::_Value_init_tag>

; 1276 :                 return;

  00071	eb 0f		 jmp	 SHORT $LN19@DataToInst
$LN20@DataToInst:

; 1277 :             }
; 1278 : 
; 1279 :             const pointer _Oldlast = _Mylast;
; 1280 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  00073	ff 75 08	 push	 DWORD PTR $T1[ebp]
  00076	57		 push	 edi
  00077	ff 75 08	 push	 DWORD PTR __Oldlast$1$[ebp]
  0007a	e8 00 00 00 00	 call	 ?_Ufill@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEPAUSSoundInstance@NSound@@PAU34@IU_Value_init_tag@2@@Z ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Ufill
  0007f	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN19@DataToInst:

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00082	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00085	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0008a	8b 3b		 mov	 edi, DWORD PTR [ebx]
  0008c	2b cf		 sub	 ecx, edi
  0008e	f7 e9		 imul	 ecx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 128  : 	for (DWORD i = 0; i < c_rSoundDataVector.size(); ++i)

  00090	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _i$1$[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00097	03 d1		 add	 edx, ecx
  00099	c1 fa 04	 sar	 edx, 4
  0009c	8b c2		 mov	 eax, edx
  0009e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000a1	03 c2		 add	 eax, edx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 128  : 	for (DWORD i = 0; i < c_rSoundDataVector.size(); ++i)

  000a3	0f 84 8e 00 00
	00		 je	 $LN47@DataToInst
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1548 :         auto& _My_data = _Mypair._Myval2;

  000a9	33 f6		 xor	 esi, esi
  000ab	0f 1f 44 00 00	 npad	 5
$LL4@DataToInst:

; 1584 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {

  000b0	8b 4d 0c	 mov	 ecx, DWORD PTR _pSoundInstanceVector$[ebp]
  000b3	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b5	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000b8	2b c8		 sub	 ecx, eax
  000ba	89 45 fc	 mov	 DWORD PTR tv512[ebp], eax
  000bd	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  000c2	f7 e9		 imul	 ecx
  000c4	03 d1		 add	 edx, ecx
  000c6	c1 fa 04	 sar	 edx, 4
  000c9	8b c2		 mov	 eax, edx
  000cb	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000ce	03 c2		 add	 eax, edx
  000d0	3b 45 08	 cmp	 eax, DWORD PTR _i$1$[ebp]
  000d3	76 69		 jbe	 SHORT $LN43@DataToInst
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 133  : 		rSoundInstance.dwFrame = (DWORD) (c_rSoundData.fTime / c_fFrameTime);

  000d5	f3 0f 10 04 3e	 movss	 xmm0, DWORD PTR [esi+edi]
  000da	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@3c888889
  000e2	e8 00 00 00 00	 call	 __ftoui3
  000e7	8b 4d fc	 mov	 ecx, DWORD PTR tv512[ebp]
  000ea	89 04 0e	 mov	 DWORD PTR [esi+ecx], eax

; 134  : 		rSoundInstance.strSoundFileName = c_rSoundData.strSoundFileName;

  000ed	83 c1 04	 add	 ecx, 4
  000f0	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  000f3	03 ce		 add	 ecx, esi
  000f5	03 c6		 add	 eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3077 :         if (this != _STD addressof(_Right)) {

  000f7	3b c8		 cmp	 ecx, eax
  000f9	74 13		 je	 SHORT $LN2@DataToInst

; 2319 :         return _BUF_SIZE <= _Myres;

  000fb	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 2305 :         const value_type* _Result = _Bx._Buf;

  000ff	8b d0		 mov	 edx, eax

; 2306 :         if (_Large_string_engaged()) {

  00101	72 02		 jb	 SHORT $LN38@DataToInst

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  00103	8b 10		 mov	 edx, DWORD PTR [eax]
$LN38@DataToInst:

; 3035 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00105	ff 70 10	 push	 DWORD PTR [eax+16]
  00108	52		 push	 edx
  00109	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN2@DataToInst:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0010e	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00111	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00116	8b 3b		 mov	 edi, DWORD PTR [ebx]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 128  : 	for (DWORD i = 0; i < c_rSoundDataVector.size(); ++i)

  00118	83 c6 1c	 add	 esi, 28			; 0000001cH
  0011b	ff 45 08	 inc	 DWORD PTR _i$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0011e	2b cf		 sub	 ecx, edi
  00120	f7 e9		 imul	 ecx
  00122	03 d1		 add	 edx, ecx
  00124	c1 fa 04	 sar	 edx, 4
  00127	8b c2		 mov	 eax, edx
  00129	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0012c	03 c2		 add	 eax, edx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 128  : 	for (DWORD i = 0; i < c_rSoundDataVector.size(); ++i)

  0012e	39 45 08	 cmp	 DWORD PTR _i$1$[ebp], eax
  00131	0f 82 79 ff ff
	ff		 jb	 $LL4@DataToInst
$LN47@DataToInst:
  00137	5f		 pop	 edi
  00138	5e		 pop	 esi
$LN3@DataToInst:
  00139	5b		 pop	 ebx

; 136  : }

  0013a	8b e5		 mov	 esp, ebp
  0013c	5d		 pop	 ebp
  0013d	c3		 ret	 0
$LN43@DataToInst:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1585 :             _Xrange();

  0013e	e8 00 00 00 00	 call	 ?_Xrange@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@CAXXZ ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Xrange
$LN49@DataToInst:
  00143	cc		 int	 3
?DataToInstance@NSound@@YAXABV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@PAV?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@3@@Z ENDP ; NSound::DataToInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
;	COMDAT ?SaveSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@@Z
_TEXT	SEGMENT
_File$1$ = -332						; size = 4
_i$1$ = -328						; size = 4
$T2 = -324						; size = 24
_strResult$ = -300					; size = 24
_szErrorText$3 = -276					; size = 257
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_c_szFileName$ = 8					; size = 4
_rSoundDataVector$ = 12					; size = 4
?SaveSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@@Z PROC ; NSound::SaveSoundInformationPiece, COMDAT

; 79   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SaveSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 40 01 00
	00		 sub	 esp, 320		; 00000140H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b 7d 0c	 mov	 edi, DWORD PTR _rSoundDataVector$[ebp]
  00031	8b 75 08	 mov	 esi, DWORD PTR _c_szFileName$[ebp]

; 80   : 	if (rSoundDataVector.empty())	//    

  00034	8b 07		 mov	 eax, DWORD PTR [edi]
  00036	3b 47 04	 cmp	 eax, DWORD PTR [edi+4]
  00039	75 1d		 jne	 SHORT $LN5@SaveSoundI

; 81   : 	{
; 82   : 		if (IsFile(c_szFileName))	//    

  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 ?IsFile@@YA_NPBD@Z	; IsFile
  00041	83 c4 04	 add	 esp, 4
  00044	84 c0		 test	 al, al
  00046	74 09		 je	 SHORT $LN6@SaveSoundI

; 83   : 		{
; 84   : 			_unlink(c_szFileName);		// .

  00048	56		 push	 esi
  00049	e8 00 00 00 00	 call	 __unlink
  0004e	83 c4 04	 add	 esp, 4
$LN6@SaveSoundI:

; 85   : 		}
; 86   : 		return true;

  00051	b0 01		 mov	 al, 1
  00053	e9 e4 01 00 00	 jmp	 $LN1@SaveSoundI
$LN5@SaveSoundI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00058	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _strResult$[ebp], 0

; 4596 :         _My_data._Mysize = 0;

  00062	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _strResult$[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0006c	c7 85 e8 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR _strResult$[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00076	c6 85 d4 fe ff
	ff 00		 mov	 BYTE PTR _strResult$[ebp], 0

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0007d	8b ce		 mov	 ecx, esi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 89   : 	std::string strResult;

  0007f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00086	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  00089	0f 1f 80 00 00
	00 00		 npad	 7
$LL112@SaveSoundI:
  00090	8a 01		 mov	 al, BYTE PTR [ecx]
  00092	41		 inc	 ecx
  00093	84 c0		 test	 al, al
  00095	75 f9		 jne	 SHORT $LL112@SaveSoundI
  00097	2b ca		 sub	 ecx, edx

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00099	51		 push	 ecx
  0009a	56		 push	 esi
  0009b	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _strResult$[ebp]
  000a1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 92   : 	FILE * File = fopen(c_szFileName, "wt");

  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_02BKFDOEMK@wt@
  000ab	56		 push	 esi
  000ac	e8 00 00 00 00	 call	 _fopen
  000b1	8b d8		 mov	 ebx, eax
  000b3	83 c4 08	 add	 esp, 8
  000b6	89 9d b4 fe ff
	ff		 mov	 DWORD PTR _File$1$[ebp], ebx

; 93   : 
; 94   : 	if (!File)

  000bc	85 db		 test	 ebx, ebx
  000be	75 6b		 jne	 SHORT $LN7@SaveSoundI

; 95   : 	{
; 96   : 		char szErrorText[256+1];
; 97   : 		_snprintf(szErrorText, sizeof(szErrorText), "Failed to save file (%s).\nPlease check if it is read-only or you have no space on the disk.\n", c_szFileName);

  000c0	56		 push	 esi
  000c1	68 00 00 00 00	 push	 OFFSET ??_C@_0FN@PJPGJAJH@Failed?5to?5save?5file?5?$CI?$CFs?$CJ?4?6Pleas@
  000c6	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szErrorText$3[ebp]
  000cc	68 01 01 00 00	 push	 257			; 00000101H
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 __snprintf

; 98   : 		LogBox(szErrorText, "Error");

  000d7	53		 push	 ebx
  000d8	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szErrorText$3[ebp]
  000de	68 00 00 00 00	 push	 OFFSET ??_C@_05NAOIJFC@Error@
  000e3	50		 push	 eax
  000e4	e8 00 00 00 00	 call	 ?LogBox@@YAXPBD0PAUHWND__@@@Z ; LogBox

; 99   : 		SetResultString((strResult + " Cannot open file for writing").c_str());

  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@MLNNILFP@?5Cannot?5open?5file?5for?5writing@
  000ee	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _strResult$[ebp]
  000f4	50		 push	 eax
  000f5	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  000fb	50		 push	 eax
  000fc	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00101	83 c4 28	 add	 esp, 40			; 00000028H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00104	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 99   : 		SetResultString((strResult + " Cannot open file for writing").c_str());

  00108	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2306 :         if (_Large_string_engaged()) {

  0010c	72 02		 jb	 SHORT $LN36@SaveSoundI

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  0010e	8b 00		 mov	 eax, DWORD PTR [eax]
$LN36@SaveSoundI:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 99   : 		SetResultString((strResult + " Cannot open file for writing").c_str());

  00110	50		 push	 eax
  00111	e8 00 00 00 00	 call	 ?SetResultString@NSound@@YAXPBD@Z ; NSound::SetResultString
  00116	83 c4 04	 add	 esp, 4
  00119	8d 8d bc fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0011f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00124	32 db		 xor	 bl, bl
  00126	e9 d9 00 00 00	 jmp	 $LN11@SaveSoundI
$LN7@SaveSoundI:

; 100  : 		return false;
; 101  : 	}
; 102  : 
; 103  : 	fprintf(File, "ScriptType        CharacterSoundInformation\n");

  0012b	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@NJIDENFN@ScriptType?5?5?5?5?5?5?5?5CharacterSoun@
  00130	53		 push	 ebx
  00131	e8 00 00 00 00	 call	 _fprintf

; 104  : 	fprintf(File, "\n");

  00136	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  0013b	53		 push	 ebx
  0013c	e8 00 00 00 00	 call	 _fprintf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00141	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00144	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00149	2b 0f		 sub	 ecx, DWORD PTR [edi]
  0014b	f7 e9		 imul	 ecx
  0014d	03 d1		 add	 edx, ecx
  0014f	c1 fa 04	 sar	 edx, 4
  00152	8b c2		 mov	 eax, edx
  00154	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00157	03 c2		 add	 eax, edx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 106  : 	fprintf(File, "SoundDataCount    %d\n", rSoundDataVector.size());

  00159	50		 push	 eax
  0015a	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@JEIKAJIN@SoundDataCount?5?5?5?5?$CFd?6@
  0015f	53		 push	 ebx
  00160	e8 00 00 00 00	 call	 _fprintf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00165	8b 1f		 mov	 ebx, DWORD PTR [edi]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 108  : 	for (DWORD i = 0; i < rSoundDataVector.size(); ++i)

  00167	33 c9		 xor	 ecx, ecx
  00169	89 8d b8 fe ff
	ff		 mov	 DWORD PTR _i$1$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0016f	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00174	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 106  : 	fprintf(File, "SoundDataCount    %d\n", rSoundDataVector.size());

  00177	83 c4 1c	 add	 esp, 28			; 0000001cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0017a	2b cb		 sub	 ecx, ebx
  0017c	f7 e9		 imul	 ecx
  0017e	03 d1		 add	 edx, ecx
  00180	c1 fa 04	 sar	 edx, 4
  00183	8b c2		 mov	 eax, edx
  00185	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00188	03 c2		 add	 eax, edx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 108  : 	for (DWORD i = 0; i < rSoundDataVector.size(); ++i)

  0018a	74 68		 je	 SHORT $LN3@SaveSoundI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1548 :         auto& _My_data = _Mypair._Myval2;

  0018c	33 f6		 xor	 esi, esi
  0018e	66 90		 npad	 2
$LL4@SaveSoundI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3922 :         return _Mypair._Myval2._Myptr();

  00190	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  00193	03 c6		 add	 eax, esi

; 2319 :         return _BUF_SIZE <= _Myres;

  00195	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 2306 :         if (_Large_string_engaged()) {

  00199	72 02		 jb	 SHORT $LN77@SaveSoundI

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  0019b	8b 00		 mov	 eax, DWORD PTR [eax]
$LN77@SaveSoundI:
  0019d	f3 0f 10 04 1e	 movss	 xmm0, DWORD PTR [esi+ebx]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 111  : 		fprintf(File, "SoundData%02d       %f \"%s\"\n", i, rSoundData.fTime, rSoundData.strSoundFileName.c_str());

  001a2	8b 9d b8 fe ff
	ff		 mov	 ebx, DWORD PTR _i$1$[ebp]
  001a8	50		 push	 eax
  001a9	0f 5a c0	 cvtps2pd xmm0, xmm0
  001ac	83 ec 08	 sub	 esp, 8
  001af	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  001b4	53		 push	 ebx
  001b5	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@FNDBKONF@SoundData?$CF02d?5?5?5?5?5?5?5?$CFf?5?$CC?$CFs?$CC?6@
  001ba	ff b5 b4 fe ff
	ff		 push	 DWORD PTR _File$1$[ebp]
  001c0	e8 00 00 00 00	 call	 _fprintf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  001c5	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 108  : 	for (DWORD i = 0; i < rSoundDataVector.size(); ++i)

  001c8	43		 inc	 ebx
  001c9	89 9d b8 fe ff
	ff		 mov	 DWORD PTR _i$1$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  001cf	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  001d4	8b 1f		 mov	 ebx, DWORD PTR [edi]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 111  : 		fprintf(File, "SoundData%02d       %f \"%s\"\n", i, rSoundData.fTime, rSoundData.strSoundFileName.c_str());

  001d6	83 c4 18	 add	 esp, 24			; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  001d9	2b cb		 sub	 ecx, ebx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 108  : 	for (DWORD i = 0; i < rSoundDataVector.size(); ++i)

  001db	83 c6 1c	 add	 esi, 28			; 0000001cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  001de	f7 e9		 imul	 ecx
  001e0	03 d1		 add	 edx, ecx
  001e2	c1 fa 04	 sar	 edx, 4
  001e5	8b c2		 mov	 eax, edx
  001e7	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001ea	03 c2		 add	 eax, edx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 108  : 	for (DWORD i = 0; i < rSoundDataVector.size(); ++i)

  001ec	39 85 b8 fe ff
	ff		 cmp	 DWORD PTR _i$1$[ebp], eax
  001f2	72 9c		 jb	 SHORT $LL4@SaveSoundI
$LN3@SaveSoundI:

; 112  : 	}
; 113  : 
; 114  : 	fclose(File);

  001f4	ff b5 b4 fe ff
	ff		 push	 DWORD PTR _File$1$[ebp]
  001fa	e8 00 00 00 00	 call	 _fclose
  001ff	83 c4 04	 add	 esp, 4

; 115  : 	return true;

  00202	b3 01		 mov	 bl, 1
$LN11@SaveSoundI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00204	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _strResult$[ebp+20]
  0020a	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0020d	72 2b		 jb	 SHORT $LN93@SaveSoundI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0020f	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _strResult$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00215	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00216	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00218	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0021e	72 10		 jb	 SHORT $LN103@SaveSoundI

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00220	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00223	83 c2 23	 add	 edx, 35			; 00000023H
  00226	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00228	83 c0 fc	 add	 eax, -4			; fffffffcH
  0022b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0022e	77 28		 ja	 SHORT $LN116@SaveSoundI
$LN103@SaveSoundI:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00230	52		 push	 edx
  00231	51		 push	 ecx
  00232	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00237	83 c4 08	 add	 esp, 8
$LN93@SaveSoundI:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 115  : 	return true;

  0023a	8a c3		 mov	 al, bl
$LN1@SaveSoundI:

; 116  : }

  0023c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0023f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00246	59		 pop	 ecx
  00247	5f		 pop	 edi
  00248	5e		 pop	 esi
  00249	5b		 pop	 ebx
  0024a	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0024d	33 cd		 xor	 ecx, ebp
  0024f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00254	8b e5		 mov	 esp, ebp
  00256	5d		 pop	 ebp
  00257	c3		 ret	 0
$LN116@SaveSoundI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00258	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN114@SaveSoundI:
  0025d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SaveSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@@Z$0:
  00000	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _strResult$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SaveSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@@Z$1:
  0000b	8d 8d bc fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00016	cc		 int	 3
  00017	cc		 int	 3
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
__ehhandler$?SaveSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@@Z:
  0001b	90		 npad	 1
  0001c	90		 npad	 1
  0001d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00021	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00024	8b 8a b0 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-336]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00034	33 c8		 xor	 ecx, eax
  00036	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SaveSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@@Z
  00040	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SaveSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@@Z ENDP ; NSound::SaveSoundInformationPiece
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp
;	COMDAT ?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z
_TEXT	SEGMENT
_pkTextFileLoader$1$ = -184				; size = 4
_iCount$ = -180						; size = 4
_rSoundDataVector$GSCopy$1$ = -176			; size = 4
_c_szPathHeader$GSCopy$1$ = -172			; size = 4
_pTokenVector$2 = -168					; size = 4
tv2722 = -164						; size = 4
tv2719 = -164						; size = 4
__Oldlast$1$ = -160					; size = 4
_i$1$ = -160						; size = 4
$T3 = -160						; size = 1
tv2711 = -156						; size = 4
tv2735 = -149						; size = 1
tv2732 = -149						; size = 1
$T4 = -149						; size = 1
$T5 = -148						; size = 24
_strResult$ = -124					; size = 24
$T6 = -100						; size = 24
$T7 = -100						; size = 24
$T8 = -100						; size = 24
$T9 = -100						; size = 24
$T10 = -100						; size = 24
$T11 = -76						; size = 24
$T12 = -76						; size = 24
$T13 = -76						; size = 24
_szSoundDataHeader$ = -52				; size = 33
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_c_szFileName$ = 8					; size = 4
_rSoundDataVector$ = 12					; size = 4
_c_szPathHeader$ = 16					; size = 4
?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z PROC ; NSound::LoadSoundInformationPiece, COMDAT

; 18   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b 75 0c	 mov	 esi, DWORD PTR _rSoundDataVector$[ebp]
  00030	8b 45 10	 mov	 eax, DWORD PTR _c_szPathHeader$[ebp]
  00033	8b 7d 08	 mov	 edi, DWORD PTR _c_szFileName$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00036	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _strResult$[ebp], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 18   : {

  0003d	89 b5 50 ff ff
	ff		 mov	 DWORD PTR _rSoundDataVector$GSCopy$1$[ebp], esi
  00043	89 85 54 ff ff
	ff		 mov	 DWORD PTR _c_szPathHeader$GSCopy$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4596 :         _My_data._Mysize = 0;

  00049	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _strResult$[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00050	c7 45 98 0f 00
	00 00		 mov	 DWORD PTR _strResult$[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00057	c6 45 84 00	 mov	 BYTE PTR _strResult$[ebp], 0

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0005b	8b cf		 mov	 ecx, edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 19   : 	std::string strResult;

  0005d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00064	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL617@LoadSoundI:
  00067	8a 01		 mov	 al, BYTE PTR [ecx]
  00069	41		 inc	 ecx
  0006a	84 c0		 test	 al, al
  0006c	75 f9		 jne	 SHORT $LL617@LoadSoundI
  0006e	2b ca		 sub	 ecx, edx

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00070	51		 push	 ecx
  00071	57		 push	 edi
  00072	8d 4d 84	 lea	 ecx, DWORD PTR _strResult$[ebp]
  00075	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 22   : 	CTextFileLoader* pkTextFileLoader=CTextFileLoader::Cache(c_szFileName);

  0007a	57		 push	 edi
  0007b	e8 00 00 00 00	 call	 ?Cache@CTextFileLoader@@SAPAV1@PBD@Z ; CTextFileLoader::Cache
  00080	8b f8		 mov	 edi, eax
  00082	83 c4 04	 add	 esp, 4
  00085	89 bd 48 ff ff
	ff		 mov	 DWORD PTR _pkTextFileLoader$1$[ebp], edi

; 23   : 	if (!pkTextFileLoader)

  0008b	85 ff		 test	 edi, edi
  0008d	74 3d		 je	 SHORT $LN26@LoadSoundI

; 24   : 		return false;
; 25   : 
; 26   : 	CTextFileLoader& rkTextFileLoader=*pkTextFileLoader;
; 27   : 	if (rkTextFileLoader.IsEmpty())

  0008f	8b cf		 mov	 ecx, edi
  00091	e8 00 00 00 00	 call	 ?IsEmpty@CTextFileLoader@@QAE_NXZ ; CTextFileLoader::IsEmpty
  00096	84 c0		 test	 al, al
  00098	74 70		 je	 SHORT $LN6@LoadSoundI

; 29   : 		SetResultString((strResult + " Can not open file for reading").c_str());

  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@LLPPICEF@?5Can?5not?5open?5file?5for?5reading@
  0009f	8d 45 84	 lea	 eax, DWORD PTR _strResult$[ebp]
  000a2	50		 push	 eax
  000a3	8d 45 9c	 lea	 eax, DWORD PTR $T10[ebp]
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH
  000af	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
$LN628@LoadSoundI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  000b3	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  000b7	72 02		 jb	 SHORT $LN78@LoadSoundI
  000b9	8b 00		 mov	 eax, DWORD PTR [eax]
$LN78@LoadSoundI:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 29   : 		SetResultString((strResult + " Can not open file for reading").c_str());

  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 ?SetResultString@NSound@@YAXPBD@Z ; NSound::SetResultString
  000c1	83 c4 04	 add	 esp, 4
  000c4	8d 4d 9c	 lea	 ecx, DWORD PTR $T10[ebp]
$LN626@LoadSoundI:
  000c7	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN26@LoadSoundI:
  000cc	c6 85 6b ff ff
	ff 00		 mov	 BYTE PTR $T4[ebp], 0
$LN27@LoadSoundI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  000d3	8b 55 98	 mov	 edx, DWORD PTR _strResult$[ebp+20]
  000d6	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  000d9	0f 82 80 05 00
	00		 jb	 $LN592@LoadSoundI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000df	8b 4d 84	 mov	 ecx, DWORD PTR _strResult$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  000e2	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e3	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000e5	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  000eb	0f 82 64 05 00
	00		 jb	 $LN602@LoadSoundI

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f1	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  000f4	83 c2 23	 add	 edx, 35			; 00000023H
  000f7	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000f9	83 c0 fc	 add	 eax, -4			; fffffffcH
  000fc	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000ff	0f 87 7b 05 00
	00		 ja	 $LN630@LoadSoundI
  00105	e9 4b 05 00 00	 jmp	 $LN602@LoadSoundI
$LN6@LoadSoundI:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 33   : 	rkTextFileLoader.SetTop();

  0010a	8b cf		 mov	 ecx, edi
  0010c	e8 00 00 00 00	 call	 ?SetTop@CTextFileLoader@@QAEXXZ ; CTextFileLoader::SetTop
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00111	a1 08 00 00 00	 mov	 eax, DWORD PTR ??_C@_0P@DFMHJMOB@sounddatacount@+8
  00116	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0P@DFMHJMOB@sounddatacount@
  0011e	89 45 bc	 mov	 DWORD PTR $T13[ebp+8], eax
  00121	66 a1 0c 00 00
	00		 mov	 ax, WORD PTR ??_C@_0P@DFMHJMOB@sounddatacount@+12

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00127	c7 45 c8 0f 00
	00 00		 mov	 DWORD PTR $T13[ebp+20], 15 ; 0000000fH

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  0012e	c7 45 c4 0e 00
	00 00		 mov	 DWORD PTR $T13[ebp+16], 14 ; 0000000eH

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00135	66 0f d6 45 b4	 movq	 QWORD PTR $T13[ebp], xmm0
  0013a	66 89 45 c0	 mov	 WORD PTR $T13[ebp+12], ax

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0013e	c6 45 c2 00	 mov	 BYTE PTR $T13[ebp+14], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 36   : 	if (!rkTextFileLoader.GetTokenInteger("sounddatacount", &iCount))

  00142	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _iCount$[ebp]
  00148	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0014c	50		 push	 eax
  0014d	8d 45 b4	 lea	 eax, DWORD PTR $T13[ebp]
  00150	8b cf		 mov	 ecx, edi
  00152	50		 push	 eax
  00153	e8 00 00 00 00	 call	 ?GetTokenInteger@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z ; CTextFileLoader::GetTokenInteger
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00158	8b 55 c8	 mov	 edx, DWORD PTR $T13[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 36   : 	if (!rkTextFileLoader.GetTokenInteger("sounddatacount", &iCount))

  0015b	85 c0		 test	 eax, eax
  0015d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00161	0f 94 c0	 sete	 al
  00164	88 85 6b ff ff
	ff		 mov	 BYTE PTR tv2735[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0016a	83 fa 10	 cmp	 edx, 16			; 00000010H
  0016d	72 32		 jb	 SHORT $LN193@LoadSoundI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0016f	8b 4d b4	 mov	 ecx, DWORD PTR $T13[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00172	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00173	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00175	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0017b	72 14		 jb	 SHORT $LN203@LoadSoundI

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0017d	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00180	83 c2 23	 add	 edx, 35			; 00000023H
  00183	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00185	83 c0 fc	 add	 eax, -4			; fffffffcH
  00188	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0018b	0f 87 f4 04 00
	00		 ja	 $LN292@LoadSoundI
$LN203@LoadSoundI:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00191	52		 push	 edx
  00192	51		 push	 ecx
  00193	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00198	8a 85 6b ff ff
	ff		 mov	 al, BYTE PTR tv2735[ebp]
  0019e	83 c4 08	 add	 esp, 8
$LN193@LoadSoundI:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 36   : 	if (!rkTextFileLoader.GetTokenInteger("sounddatacount", &iCount))

  001a1	84 c0		 test	 al, al
  001a3	74 1e		 je	 SHORT $LN7@LoadSoundI

; 37   : 	{
; 38   : 		SetResultString((strResult + " File format error, SoundDataCount Unable to find.").c_str());

  001a5	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@IKAPCMKK@?5File?5format?5error?0?5SoundDataCo@
  001aa	8d 45 84	 lea	 eax, DWORD PTR _strResult$[ebp]
  001ad	50		 push	 eax
  001ae	8d 45 9c	 lea	 eax, DWORD PTR $T9[ebp]
  001b1	50		 push	 eax
  001b2	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  001b7	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ba	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  001be	e9 f0 fe ff ff	 jmp	 $LN628@LoadSoundI
$LN7@LoadSoundI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  001c3	56		 push	 esi
  001c4	ff 76 04	 push	 DWORD PTR [esi+4]
  001c7	ff 36		 push	 DWORD PTR [esi]
  001c9	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USSoundData@NSound@@@std@@@std@@YAXPAUSSoundData@NSound@@QAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundData> >

; 1456 :         _Mylast = _Myfirst;

  001ce	8b 06		 mov	 eax, DWORD PTR [esi]

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  001d0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1272 :         if (_Newsize > _Oldsize) { // append

  001d3	8b bd 4c ff ff
	ff		 mov	 edi, DWORD PTR _iCount$[ebp]

; 1456 :         _Mylast = _Myfirst;

  001d9	89 85 60 ff ff
	ff		 mov	 DWORD PTR __Oldlast$1$[ebp], eax
  001df	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1272 :         if (_Newsize > _Oldsize) { // append

  001e2	85 ff		 test	 edi, edi
  001e4	74 42		 je	 SHORT $LN250@LoadSoundI

; 1273 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  001e6	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001e9	2b c8		 sub	 ecx, eax
  001eb	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  001f0	f7 e9		 imul	 ecx
  001f2	03 d1		 add	 edx, ecx

; 1274 :             if (_Newsize > _Oldcapacity) { // reallocate

  001f4	8b ce		 mov	 ecx, esi
  001f6	c1 fa 04	 sar	 edx, 4
  001f9	8b c2		 mov	 eax, edx
  001fb	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001fe	03 c2		 add	 eax, edx
  00200	3b f8		 cmp	 edi, eax
  00202	76 0f		 jbe	 SHORT $LN251@LoadSoundI

; 1275 :                 _Resize_reallocate(_Newsize, _Val);

  00204	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0020a	50		 push	 eax
  0020b	57		 push	 edi
  0020c	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Resize_reallocate<std::_Value_init_tag>

; 1276 :                 return;

  00211	eb 15		 jmp	 SHORT $LN250@LoadSoundI
$LN251@LoadSoundI:

; 1277 :             }
; 1278 : 
; 1279 :             const pointer _Oldlast = _Mylast;
; 1280 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  00213	ff b5 60 ff ff
	ff		 push	 DWORD PTR $T3[ebp]
  00219	57		 push	 edi
  0021a	ff b5 60 ff ff
	ff		 push	 DWORD PTR __Oldlast$1$[ebp]
  00220	e8 00 00 00 00	 call	 ?_Ufill@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEPAUSSoundData@NSound@@PAU34@IU_Value_init_tag@2@@Z ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Ufill
  00225	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN250@LoadSoundI:

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00228	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0022b	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00230	2b 0e		 sub	 ecx, DWORD PTR [esi]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 46   : 	for (DWORD i = 0; i < rSoundDataVector.size(); ++i)

  00232	33 ff		 xor	 edi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00234	f7 e9		 imul	 ecx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 46   : 	for (DWORD i = 0; i < rSoundDataVector.size(); ++i)

  00236	89 bd 60 ff ff
	ff		 mov	 DWORD PTR _i$1$[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0023c	03 d1		 add	 edx, ecx
  0023e	c1 fa 04	 sar	 edx, 4
  00241	8b c2		 mov	 eax, edx
  00243	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00246	03 c2		 add	 eax, edx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 46   : 	for (DWORD i = 0; i < rSoundDataVector.size(); ++i)

  00248	0f 84 31 02 00
	00		 je	 $LN3@LoadSoundI
  0024e	89 bd 64 ff ff
	ff		 mov	 DWORD PTR tv2711[ebp], edi
$LL4@LoadSoundI:

; 48   : 		_snprintf(szSoundDataHeader, sizeof(szSoundDataHeader), "sounddata%02d", i);

  00254	57		 push	 edi
  00255	68 00 00 00 00	 push	 OFFSET ??_C@_0O@OOLLGPNP@sounddata?$CF02d@
  0025a	8d 45 cc	 lea	 eax, DWORD PTR _szSoundDataHeader$[ebp]
  0025d	6a 21		 push	 33			; 00000021H
  0025f	50		 push	 eax
  00260	e8 00 00 00 00	 call	 __snprintf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00265	8d 4d cc	 lea	 ecx, DWORD PTR _szSoundDataHeader$[ebp]

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00268	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR $T12[ebp], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 48   : 		_snprintf(szSoundDataHeader, sizeof(szSoundDataHeader), "sounddata%02d", i);

  0026f	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4596 :         _My_data._Mysize = 0;

  00272	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T12[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00279	c7 45 c8 0f 00
	00 00		 mov	 DWORD PTR $T12[ebp+20], 15 ; 0000000fH

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00280	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]

; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00283	c6 45 b4 00	 mov	 BYTE PTR $T12[ebp], 0
$LL618@LoadSoundI:

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00287	8a 01		 mov	 al, BYTE PTR [ecx]
  00289	41		 inc	 ecx
  0028a	84 c0		 test	 al, al
  0028c	75 f9		 jne	 SHORT $LL618@LoadSoundI
  0028e	2b ca		 sub	 ecx, edx

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00290	8d 45 cc	 lea	 eax, DWORD PTR _szSoundDataHeader$[ebp]
  00293	51		 push	 ecx
  00294	50		 push	 eax
  00295	8d 4d b4	 lea	 ecx, DWORD PTR $T12[ebp]
  00298	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 50   : 		if (!rkTextFileLoader.GetTokenVector(szSoundDataHeader, &pTokenVector))

  0029d	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _pkTextFileLoader$1$[ebp]
  002a3	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _pTokenVector$2[ebp]
  002a9	50		 push	 eax
  002aa	8d 45 b4	 lea	 eax, DWORD PTR $T12[ebp]
  002ad	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  002b1	50		 push	 eax
  002b2	e8 00 00 00 00	 call	 ?GetTokenVector@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z ; CTextFileLoader::GetTokenVector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  002b7	8b 55 c8	 mov	 edx, DWORD PTR $T12[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 50   : 		if (!rkTextFileLoader.GetTokenVector(szSoundDataHeader, &pTokenVector))

  002ba	85 c0		 test	 eax, eax
  002bc	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  002c0	0f 94 c0	 sete	 al
  002c3	88 85 6b ff ff
	ff		 mov	 BYTE PTR tv2732[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  002c9	83 fa 10	 cmp	 edx, 16			; 00000010H
  002cc	72 32		 jb	 SHORT $LN285@LoadSoundI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002ce	8b 4d b4	 mov	 ecx, DWORD PTR $T12[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  002d1	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002d2	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  002d4	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  002da	72 14		 jb	 SHORT $LN295@LoadSoundI

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  002dc	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  002df	83 c2 23	 add	 edx, 35			; 00000023H
  002e2	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  002e4	83 c0 fc	 add	 eax, -4			; fffffffcH
  002e7	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  002ea	0f 87 95 03 00
	00		 ja	 $LN292@LoadSoundI
$LN295@LoadSoundI:

; 264  :         ::operator delete(_Ptr, _Bytes);

  002f0	52		 push	 edx
  002f1	51		 push	 ecx
  002f2	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  002f7	8a 85 6b ff ff
	ff		 mov	 al, BYTE PTR tv2732[ebp]
  002fd	83 c4 08	 add	 esp, 8
$LN285@LoadSoundI:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 50   : 		if (!rkTextFileLoader.GetTokenVector(szSoundDataHeader, &pTokenVector))

  00300	84 c0		 test	 al, al
  00302	0f 85 f6 01 00
	00		 jne	 $LN608@LoadSoundI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00308	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _pTokenVector$2[ebp]
  0030e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00311	8b 38		 mov	 edi, DWORD PTR [eax]
  00313	2b cf		 sub	 ecx, edi
  00315	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0031a	f7 e9		 imul	 ecx
  0031c	c1 fa 02	 sar	 edx, 2
  0031f	8b c2		 mov	 eax, edx
  00321	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00324	03 c2		 add	 eax, edx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 56   : 		if (2 != pTokenVector->size())

  00326	83 f8 02	 cmp	 eax, 2
  00329	0f 85 b1 01 00
	00		 jne	 $LN609@LoadSoundI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2306 :         if (_Large_string_engaged()) {

  0032f	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  00333	72 02		 jb	 SHORT $LN496@LoadSoundI

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  00335	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN496@LoadSoundI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  00337	8b 36		 mov	 esi, DWORD PTR [esi]
  00339	03 b5 64 ff ff
	ff		 add	 esi, DWORD PTR tv2711[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 62   : 		rSoundDataVector[i].fTime = (float) atof(pTokenVector->at(0).c_str());

  0033f	57		 push	 edi
  00340	e8 00 00 00 00	 call	 _atof

; 63   : 		if (c_szPathHeader)

  00345	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _c_szPathHeader$GSCopy$1$[ebp]
  0034b	83 c4 04	 add	 esp, 4
  0034e	d9 1e		 fstp	 DWORD PTR [esi]
  00350	85 c0		 test	 eax, eax
  00352	0f 84 91 00 00
	00		 je	 $LN10@LoadSoundI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  00358	8b b5 50 ff ff
	ff		 mov	 esi, DWORD PTR _rSoundDataVector$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0035e	8b c8		 mov	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  00360	8b 16		 mov	 edx, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00362	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  00365	03 95 64 ff ff
	ff		 add	 edx, DWORD PTR tv2711[ebp]
  0036b	0f 1f 44 00 00	 npad	 5
$LL619@LoadSoundI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00370	8a 01		 mov	 al, BYTE PTR [ecx]
  00372	41		 inc	 ecx
  00373	84 c0		 test	 al, al
  00375	75 f9		 jne	 SHORT $LL619@LoadSoundI

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00377	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _c_szPathHeader$GSCopy$1$[ebp]

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0037d	2b cf		 sub	 ecx, edi

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0037f	51		 push	 ecx
  00380	50		 push	 eax
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 65   : 			rSoundDataVector[i].strSoundFileName = c_szPathHeader;

  00381	8d 4a 04	 lea	 ecx, DWORD PTR [edx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00384	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1584 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {

  00389	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _pTokenVector$2[ebp]
  0038f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00392	8b 38		 mov	 edi, DWORD PTR [eax]
  00394	2b cf		 sub	 ecx, edi
  00396	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0039b	f7 e9		 imul	 ecx
  0039d	c1 fa 02	 sar	 edx, 2
  003a0	8b c2		 mov	 eax, edx
  003a2	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  003a5	03 c2		 add	 eax, edx
  003a7	83 f8 01	 cmp	 eax, 1
  003aa	0f 86 df 02 00
	00		 jbe	 $LN612@LoadSoundI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2306 :         if (_Large_string_engaged()) {

  003b0	83 7f 2c 10	 cmp	 DWORD PTR [edi+44], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1588 :         return _My_data._Myfirst[_Pos];

  003b4	8d 57 18	 lea	 edx, DWORD PTR [edi+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2306 :         if (_Large_string_engaged()) {

  003b7	72 02		 jb	 SHORT $LN516@LoadSoundI

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  003b9	8b 12		 mov	 edx, DWORD PTR [edx]
$LN516@LoadSoundI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  003bb	8b 3e		 mov	 edi, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  003bd	8b ca		 mov	 ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  003bf	03 bd 64 ff ff
	ff		 add	 edi, DWORD PTR tv2711[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  003c5	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  003c8	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv2719[ebp], eax
  003ce	66 90		 npad	 2
$LL620@LoadSoundI:
  003d0	8a 01		 mov	 al, BYTE PTR [ecx]
  003d2	41		 inc	 ecx
  003d3	84 c0		 test	 al, al
  003d5	75 f9		 jne	 SHORT $LL620@LoadSoundI
  003d7	2b 8d 5c ff ff
	ff		 sub	 ecx, DWORD PTR tv2719[ebp]

; 3175 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  003dd	51		 push	 ecx
  003de	52		 push	 edx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 66   : 			rSoundDataVector[i].strSoundFileName += pTokenVector->at(1).c_str();

  003df	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3175 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  003e2	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 67   : 		}

  003e7	eb 62		 jmp	 SHORT $LN2@LoadSoundI
$LN10@LoadSoundI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1584 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {

  003e9	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _pTokenVector$2[ebp]
  003ef	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  003f2	8b 30		 mov	 esi, DWORD PTR [eax]
  003f4	2b ce		 sub	 ecx, esi
  003f6	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  003fb	f7 e9		 imul	 ecx
  003fd	c1 fa 02	 sar	 edx, 2
  00400	8b c2		 mov	 eax, edx
  00402	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00405	03 c2		 add	 eax, edx
  00407	83 f8 01	 cmp	 eax, 1
  0040a	0f 86 7f 02 00
	00		 jbe	 $LN612@LoadSoundI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2306 :         if (_Large_string_engaged()) {

  00410	83 7e 2c 10	 cmp	 DWORD PTR [esi+44], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1588 :         return _My_data._Myfirst[_Pos];

  00414	8d 56 18	 lea	 edx, DWORD PTR [esi+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2306 :         if (_Large_string_engaged()) {

  00417	72 02		 jb	 SHORT $LN534@LoadSoundI

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  00419	8b 12		 mov	 edx, DWORD PTR [edx]
$LN534@LoadSoundI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  0041b	8b b5 50 ff ff
	ff		 mov	 esi, DWORD PTR _rSoundDataVector$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00421	8b ca		 mov	 ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  00423	8b 3e		 mov	 edi, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00425	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  00428	03 bd 64 ff ff
	ff		 add	 edi, DWORD PTR tv2711[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0042e	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv2722[ebp], eax
$LL621@LoadSoundI:
  00434	8a 01		 mov	 al, BYTE PTR [ecx]
  00436	41		 inc	 ecx
  00437	84 c0		 test	 al, al
  00439	75 f9		 jne	 SHORT $LL621@LoadSoundI
  0043b	2b 8d 5c ff ff
	ff		 sub	 ecx, DWORD PTR tv2722[ebp]

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00441	51		 push	 ecx
  00442	52		 push	 edx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 70   : 			rSoundDataVector[i].strSoundFileName = pTokenVector->at(1).c_str();

  00443	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00446	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN2@LoadSoundI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0044b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0044e	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00453	2b 0e		 sub	 ecx, DWORD PTR [esi]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 46   : 	for (DWORD i = 0; i < rSoundDataVector.size(); ++i)

  00455	8b bd 60 ff ff
	ff		 mov	 edi, DWORD PTR _i$1$[ebp]
  0045b	83 85 64 ff ff
	ff 1c		 add	 DWORD PTR tv2711[ebp], 28 ; 0000001cH
  00462	47		 inc	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00463	f7 e9		 imul	 ecx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 46   : 	for (DWORD i = 0; i < rSoundDataVector.size(); ++i)

  00465	89 bd 60 ff ff
	ff		 mov	 DWORD PTR _i$1$[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0046b	03 d1		 add	 edx, ecx
  0046d	c1 fa 04	 sar	 edx, 4
  00470	8b c2		 mov	 eax, edx
  00472	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00475	03 c2		 add	 eax, edx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 46   : 	for (DWORD i = 0; i < rSoundDataVector.size(); ++i)

  00477	3b f8		 cmp	 edi, eax
  00479	0f 82 d5 fd ff
	ff		 jb	 $LL4@LoadSoundI
$LN3@LoadSoundI:

; 74   : 	SetResultString((strResult + " Loaded").c_str());

  0047f	68 00 00 00 00	 push	 OFFSET ??_C@_07EGDJHJID@?5Loaded@
  00484	8d 45 84	 lea	 eax, DWORD PTR _strResult$[ebp]
  00487	50		 push	 eax
  00488	8d 45 9c	 lea	 eax, DWORD PTR $T6[ebp]
  0048b	50		 push	 eax
  0048c	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00491	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00494	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 74   : 	SetResultString((strResult + " Loaded").c_str());

  00498	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2306 :         if (_Large_string_engaged()) {

  0049c	72 02		 jb	 SHORT $LN549@LoadSoundI

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  0049e	8b 00		 mov	 eax, DWORD PTR [eax]
$LN549@LoadSoundI:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 74   : 	SetResultString((strResult + " Loaded").c_str());

  004a0	50		 push	 eax
  004a1	e8 00 00 00 00	 call	 ?SetResultString@NSound@@YAXPBD@Z ; NSound::SetResultString
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  004a6	8b 55 b0	 mov	 edx, DWORD PTR $T6[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 74   : 	SetResultString((strResult + " Loaded").c_str());

  004a9	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  004ac	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  004af	0f 82 94 01 00
	00		 jb	 $LN565@LoadSoundI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  004b5	8b 4d 9c	 mov	 ecx, DWORD PTR $T6[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  004b8	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  004b9	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  004bb	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  004c1	0f 82 78 01 00
	00		 jb	 $LN575@LoadSoundI

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  004c7	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  004ca	83 c2 23	 add	 edx, 35			; 00000023H
  004cd	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  004cf	83 c0 fc	 add	 eax, -4			; fffffffcH
  004d2	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  004d5	0f 87 af 01 00
	00		 ja	 $LN631@LoadSoundI
  004db	e9 5f 01 00 00	 jmp	 $LN575@LoadSoundI
$LN609@LoadSoundI:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 58   : 			SetResultString((strResult + " File format error: The size of the vector is not 2").c_str());

  004e0	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@ECJCCDPG@?5File?5format?5error?3?5The?5size?5of@
  004e5	8d 45 84	 lea	 eax, DWORD PTR _strResult$[ebp]
  004e8	50		 push	 eax
  004e9	8d 45 9c	 lea	 eax, DWORD PTR $T7[ebp]
  004ec	50		 push	 eax
  004ed	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  004f2	83 c4 0c	 add	 esp, 12			; 0000000cH
  004f5	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  004f9	e9 b5 fb ff ff	 jmp	 $LN628@LoadSoundI
$LN608@LoadSoundI:

; 52   : 			SetResultString((strResult + " File format error: " + szSoundDataHeader + " Unable to find").c_str());

  004fe	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@LPIKLLAN@?5File?5format?5error?3?5@
  00503	8d 45 84	 lea	 eax, DWORD PTR _strResult$[ebp]
  00506	50		 push	 eax
  00507	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  0050d	50		 push	 eax
  0050e	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00513	83 c4 0c	 add	 esp, 12			; 0000000cH
  00516	8b d0		 mov	 edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00518	8d 4d cc	 lea	 ecx, DWORD PTR _szSoundDataHeader$[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 52   : 			SetResultString((strResult + " File format error: " + szSoundDataHeader + " Unable to find").c_str());

  0051b	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0051f	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$LL622@LoadSoundI:
  00522	8a 01		 mov	 al, BYTE PTR [ecx]
  00524	41		 inc	 ecx
  00525	84 c0		 test	 al, al
  00527	75 f9		 jne	 SHORT $LL622@LoadSoundI
  00529	2b ce		 sub	 ecx, esi

; 3175 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0052b	8d 45 cc	 lea	 eax, DWORD PTR _szSoundDataHeader$[ebp]
  0052e	51		 push	 ecx
  0052f	50		 push	 eax
  00530	8b ca		 mov	 ecx, edx
  00532	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00537	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR $T11[ebp], 0

; 2355 :     size_type _Mysize = 0; // current length of string

  0053e	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T11[ebp+16], 0

; 2356 :     size_type _Myres  = 0; // current storage reserved for string

  00545	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR $T11[ebp+20], 0

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0054c	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0054f	0f 11 45 b4	 movups	 XMMWORD PTR $T11[ebp], xmm0
  00553	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00558	66 0f d6 45 c4	 movq	 QWORD PTR $T11[ebp+16], xmm0

; 4596 :         _My_data._Mysize = 0;

  0055d	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00564	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0056b	c6 00 00	 mov	 BYTE PTR [eax], 0

; 3175 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0056e	6a 0f		 push	 15			; 0000000fH
  00570	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@EHBCCDFO@?5Unable?5to?5find@
  00575	8d 4d b4	 lea	 ecx, DWORD PTR $T11[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 52   : 			SetResultString((strResult + " File format error: " + szSoundDataHeader + " Unable to find").c_str());

  00578	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3175 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0057c	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00581	0f 10 08	 movups	 xmm1, XMMWORD PTR [eax]
  00584	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00589	0f 11 4d 9c	 movups	 XMMWORD PTR $T8[ebp], xmm1

; 4596 :         _My_data._Mysize = 0;

  0058d	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00594	66 0f d6 45 ac	 movq	 QWORD PTR $T8[ebp+16], xmm0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00599	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  005a0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 2319 :         return _BUF_SIZE <= _Myres;

  005a3	83 7d b0 10	 cmp	 DWORD PTR $T8[ebp+20], 16 ; 00000010H

; 2305 :         const value_type* _Result = _Bx._Buf;

  005a7	8d 4d 9c	 lea	 ecx, DWORD PTR $T8[ebp]

; 2306 :         if (_Large_string_engaged()) {

  005aa	66 0f 7e c8	 movd	 eax, xmm1
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 52   : 			SetResultString((strResult + " File format error: " + szSoundDataHeader + " Unable to find").c_str());

  005ae	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2306 :         if (_Large_string_engaged()) {

  005b2	0f 43 c8	 cmovae	 ecx, eax
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 52   : 			SetResultString((strResult + " File format error: " + szSoundDataHeader + " Unable to find").c_str());

  005b5	51		 push	 ecx
  005b6	e8 00 00 00 00	 call	 ?SetResultString@NSound@@YAXPBD@Z ; NSound::SetResultString
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  005bb	8b 55 b0	 mov	 edx, DWORD PTR $T8[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 52   : 			SetResultString((strResult + " File format error: " + szSoundDataHeader + " Unable to find").c_str());

  005be	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  005c1	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  005c4	72 2c		 jb	 SHORT $LN385@LoadSoundI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  005c6	8b 4d 9c	 mov	 ecx, DWORD PTR $T8[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  005c9	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  005ca	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  005cc	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  005d2	72 14		 jb	 SHORT $LN395@LoadSoundI

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  005d4	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  005d7	83 c2 23	 add	 edx, 35			; 00000023H
  005da	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  005dc	83 c0 fc	 add	 eax, -4			; fffffffcH
  005df	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  005e2	0f 87 ac 00 00
	00		 ja	 $LN419@LoadSoundI
$LN395@LoadSoundI:

; 264  :         ::operator delete(_Ptr, _Bytes);

  005e8	52		 push	 edx
  005e9	51		 push	 ecx
  005ea	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  005ef	83 c4 08	 add	 esp, 8
$LN385@LoadSoundI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  005f2	8b 55 c8	 mov	 edx, DWORD PTR $T11[ebp+20]
  005f5	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  005f8	72 28		 jb	 SHORT $LN412@LoadSoundI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  005fa	8b 4d b4	 mov	 ecx, DWORD PTR $T11[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  005fd	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  005fe	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00600	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00606	72 10		 jb	 SHORT $LN422@LoadSoundI

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00608	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0060b	83 c2 23	 add	 edx, 35			; 00000023H
  0060e	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00610	83 c0 fc	 add	 eax, -4			; fffffffcH
  00613	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00616	77 7c		 ja	 SHORT $LN419@LoadSoundI
$LN422@LoadSoundI:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00618	52		 push	 edx
  00619	51		 push	 ecx
  0061a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0061f	83 c4 08	 add	 esp, 8
$LN412@LoadSoundI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  00622	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T11[ebp+16], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 52   : 			SetResultString((strResult + " File format error: " + szSoundDataHeader + " Unable to find").c_str());

  00629	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0062f	c7 45 c8 0f 00
	00 00		 mov	 DWORD PTR $T11[ebp+20], 15 ; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00636	c6 45 b4 00	 mov	 BYTE PTR $T11[ebp], 0
  0063a	e9 88 fa ff ff	 jmp	 $LN626@LoadSoundI
$LN575@LoadSoundI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  0063f	52		 push	 edx
  00640	51		 push	 ecx
  00641	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00646	83 c4 08	 add	 esp, 8
$LN565@LoadSoundI:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 75   : 	return true;

  00649	c6 85 6b ff ff
	ff 01		 mov	 BYTE PTR $T4[ebp], 1
  00650	e9 7e fa ff ff	 jmp	 $LN27@LoadSoundI
$LN602@LoadSoundI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00655	52		 push	 edx
  00656	51		 push	 ecx
  00657	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0065c	83 c4 08	 add	 esp, 8
$LN592@LoadSoundI:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 75   : 	return true;

  0065f	8a 85 6b ff ff
	ff		 mov	 al, BYTE PTR $T4[ebp]

; 76   : }

  00665	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00668	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0066f	59		 pop	 ecx
  00670	5f		 pop	 edi
  00671	5e		 pop	 esi
  00672	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00675	33 cd		 xor	 ecx, ebp
  00677	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0067c	8b e5		 mov	 esp, ebp
  0067e	5d		 pop	 ebp
  0067f	c3		 ret	 0
$LN630@LoadSoundI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00680	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN292@LoadSoundI:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\MilesLib\Type.cpp

; 76   : }

  00685	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN631@LoadSoundI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0068a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN612@LoadSoundI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1585 :             _Xrange();

  0068f	e8 00 00 00 00	 call	 ?_Xrange@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xrange
$LN419@LoadSoundI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00694	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN624@LoadSoundI:
  00699	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$0:
  00000	8d 4d 84	 lea	 ecx, DWORD PTR _strResult$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$1:
  00008	8d 4d 9c	 lea	 ecx, DWORD PTR $T10[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$2:
  00010	8d 4d b4	 lea	 ecx, DWORD PTR $T13[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$3:
  00018	8d 4d 9c	 lea	 ecx, DWORD PTR $T9[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$4:
  00020	8d 4d b4	 lea	 ecx, DWORD PTR $T12[ebp]
  00023	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$9:
  00028	8d 4d 9c	 lea	 ecx, DWORD PTR $T6[ebp]
  0002b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$8:
  00030	8d 4d 9c	 lea	 ecx, DWORD PTR $T7[ebp]
  00033	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$5:
  00038	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  0003e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$6:
  00043	8d 4d b4	 lea	 ecx, DWORD PTR $T11[ebp]
  00046	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$7:
  0004b	8d 4d 9c	 lea	 ecx, DWORD PTR $T8[ebp]
  0004e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00053	cc		 int	 3
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
__ehhandler$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z:
  00058	90		 npad	 1
  00059	90		 npad	 1
  0005a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0005e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00061	8b 8a 48 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-184]
  00067	33 c8		 xor	 ecx, eax
  00069	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006e	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00071	33 c8		 xor	 ecx, eax
  00073	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00078	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z
  0007d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z ENDP ; NSound::LoadSoundInformationPiece
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Old$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
$T1 = 12						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3244 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 3245 :         // assign [_Ptr, _Ptr + _Count)
; 3246 :         if (_Count <= _Mypair._Myval2._Myres) {

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	57		 push	 edi
  0000c	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0000f	89 4d fc	 mov	 DWORD PTR __Old$1$[ebp], ecx
  00012	3b d9		 cmp	 ebx, ecx
  00014	77 28		 ja	 SHORT $LN2@assign

; 2296 :         value_type* _Result = _Bx._Buf;

  00016	8b fe		 mov	 edi, esi

; 2319 :         return _BUF_SIZE <= _Myres;

  00018	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 2297 :         if (_Large_string_engaged()) {

  0001b	72 02		 jb	 SHORT $LN5@assign

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  0001d	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN5@assign:

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0001f	53		 push	 ebx
  00020	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 3247 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3248 :             _Mypair._Myval2._Mysize = _Count;

  00023	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00026	57		 push	 edi
  00027	e8 00 00 00 00	 call	 _memmove
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3249 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0002f	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 3259 :             },
; 3260 :             _Ptr);
; 3261 :     }

  00033	8b c6		 mov	 eax, esi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
$LN2@assign:

; 4508 :         if (_New_size > max_size()) {

  0003e	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  00044	0f 87 d4 00 00
	00		 ja	 $LN60@assign

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0004a	8b fb		 mov	 edi, ebx
  0004c	83 cf 0f	 or	 edi, 15			; 0000000fH
  0004f	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH

; 4489 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00055	76 15		 jbe	 SHORT $LN19@assign

; 4490 :             return _Max;

  00057	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0005c	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00067	83 c4 04	 add	 esp, 4
  0006a	eb 52		 jmp	 SHORT $LN58@assign
$LN19@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4493 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0006c	8b d1		 mov	 edx, ecx
  0006e	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00073	d1 ea		 shr	 edx, 1
  00075	2b c2		 sub	 eax, edx
  00077	3b c8		 cmp	 ecx, eax
  00079	76 15		 jbe	 SHORT $LN20@assign

; 4494 :             return _Max;

  0007b	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00080	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0008b	83 c4 04	 add	 esp, 4
  0008e	eb 2e		 jmp	 SHORT $LN58@assign
$LN20@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4497 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00090	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00093	3b f8		 cmp	 edi, eax
  00095	0f 42 f8	 cmovb	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4515 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00098	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0009b	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000a0	72 0b		 jb	 SHORT $LN27@assign

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a8	83 c4 04	 add	 esp, 4
  000ab	eb 11		 jmp	 SHORT $LN58@assign
$LN27@assign:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  000ad	85 c0		 test	 eax, eax
  000af	74 0b		 je	 SHORT $LN28@assign

; 85   :         return ::operator new(_Bytes);

  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000b7	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  000ba	eb 02		 jmp	 SHORT $LN58@assign
$LN28@assign:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000bc	33 c0		 xor	 eax, eax
$LN58@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000be	53		 push	 ebx
  000bf	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 4523 :         _Mypair._Myval2._Mysize = _New_size;

  000c2	89 45 0c	 mov	 DWORD PTR $T1[ebp], eax

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c5	50		 push	 eax

; 4523 :         _Mypair._Myval2._Mysize = _New_size;

  000c6	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 4524 :         _Mypair._Myval2._Myres  = _New_capacity;

  000c9	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000cc	e8 00 00 00 00	 call	 _memcpy

; 3258 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000d1	8b 7d 0c	 mov	 edi, DWORD PTR $T1[ebp]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4526 :         if (_BUF_SIZE <= _Old_capacity) {

  000d7	8b 45 fc	 mov	 eax, DWORD PTR __Old$1$[ebp]

; 3258 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000da	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 4526 :         if (_BUF_SIZE <= _Old_capacity) {

  000de	83 f8 10	 cmp	 eax, 16			; 00000010H
  000e1	72 29		 jb	 SHORT $LN13@assign

; 4527 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  000e3	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e6	8b 06		 mov	 eax, DWORD PTR [esi]

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000e8	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000ee	72 12		 jb	 SHORT $LN50@assign

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f0	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000f3	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000f6	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000f8	83 c0 fc	 add	 eax, -4			; fffffffcH
  000fb	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000fe	77 19		 ja	 SHORT $LN47@assign

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00100	8b c2		 mov	 eax, edx
$LN50@assign:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00102	51		 push	 ecx
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00109	83 c4 08	 add	 esp, 8
$LN13@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3254 :         return _Reallocate_for(

  0010c	89 3e		 mov	 DWORD PTR [esi], edi

; 3259 :             },
; 3260 :             _Ptr);
; 3261 :     }

  0010e	8b c6		 mov	 eax, esi
  00110	5f		 pop	 edi
  00111	5e		 pop	 esi
  00112	5b		 pop	 ebx
  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c2 08 00	 ret	 8
$LN47@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00119	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN60@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4509 :             _Xlen_string(); // result too long

  0011e	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN56@assign:
  00123	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
tv533 = -12						; size = 4
__Old$1$ = -8						; size = 4
tv534 = -4						; size = 4
__Old_size$1$ = -4					; size = 4
__Ptr$ = 8						; size = 4
tv537 = 12						; size = 4
$T1 = 12						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 3152 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 3153 :         // append [_Ptr, _Ptr + _Count)
; 3154 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3155 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  00011	8b c2		 mov	 eax, edx
  00013	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00016	2b c1		 sub	 eax, ecx
  00018	89 4d fc	 mov	 DWORD PTR __Old_size$1$[ebp], ecx
  0001b	89 55 f8	 mov	 DWORD PTR __Old$1$[ebp], edx
  0001e	3b d8		 cmp	 ebx, eax
  00020	77 2e		 ja	 SHORT $LN2@append

; 3156 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00022	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00025	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 2296 :         value_type* _Result = _Bx._Buf;

  00028	8b c7		 mov	 eax, edi

; 2319 :         return _BUF_SIZE <= _Myres;

  0002a	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2297 :         if (_Large_string_engaged()) {

  0002d	72 02		 jb	 SHORT $LN5@append

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  0002f	8b 07		 mov	 eax, DWORD PTR [edi]
$LN5@append:

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00031	53		 push	 ebx
  00032	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 3157 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3158 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00035	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00038	56		 push	 esi
  00039	e8 00 00 00 00	 call	 _memmove
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3159 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00041	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0

; 3172 :     }

  00045	8b c7		 mov	 eax, edi
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8
$LN2@append:

; 4543 :         if (max_size() - _Old_size < _Size_increase) {

  00050	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00055	2b c1		 sub	 eax, ecx
  00057	3b c3		 cmp	 eax, ebx
  00059	0f 82 26 01 00
	00		 jb	 $LN68@append

; 4545 :         }
; 4546 : 
; 4547 :         const size_type _New_size     = _Old_size + _Size_increase;

  0005f	8d 34 19	 lea	 esi, DWORD PTR [ecx+ebx]

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00062	83 ce 0f	 or	 esi, 15			; 0000000fH
  00065	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 4489 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0006b	76 18		 jbe	 SHORT $LN19@append

; 4490 :             return _Max;

  0006d	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00072	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  00080	83 c4 04	 add	 esp, 4
  00083	eb 61		 jmp	 SHORT $LN66@append
$LN19@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4493 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00085	8b c2		 mov	 eax, edx
  00087	d1 e8		 shr	 eax, 1
  00089	89 45 0c	 mov	 DWORD PTR tv537[ebp], eax
  0008c	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00091	2b 45 0c	 sub	 eax, DWORD PTR tv537[ebp]
  00094	3b d0		 cmp	 edx, eax
  00096	76 18		 jbe	 SHORT $LN20@append

; 4494 :             return _Max;

  00098	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0009d	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  000ab	83 c4 04	 add	 esp, 4
  000ae	eb 36		 jmp	 SHORT $LN66@append
$LN20@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4497 :         return (_STD max)(_Masked, _Old + _Old / 2);

  000b0	8b 45 0c	 mov	 eax, DWORD PTR tv537[ebp]
  000b3	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  000b5	3b f0		 cmp	 esi, eax
  000b7	0f 42 f0	 cmovb	 esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4551 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  000ba	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000bd	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000c2	72 0e		 jb	 SHORT $LN27@append

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000ca	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  000cd	83 c4 04	 add	 esp, 4
  000d0	eb 14		 jmp	 SHORT $LN66@append
$LN27@append:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  000d2	85 c0		 test	 eax, eax
  000d4	74 0e		 je	 SHORT $LN28@append

; 85   :         return ::operator new(_Bytes);

  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 244  :         return _Traits::_Allocate(_Bytes);

  000dc	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]

; 85   :         return ::operator new(_Bytes);

  000df	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  000e2	eb 02		 jmp	 SHORT $LN66@append
$LN28@append:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000e4	33 c0		 xor	 eax, eax
$LN66@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4562 :         if (_BUF_SIZE <= _Old_capacity) {

  000e6	83 7d f8 10	 cmp	 DWORD PTR __Old$1$[ebp], 16 ; 00000010H
  000ea	8d 14 19	 lea	 edx, DWORD PTR [ecx+ebx]
  000ed	89 77 14	 mov	 DWORD PTR [edi+20], esi
  000f0	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  000f3	89 57 10	 mov	 DWORD PTR [edi+16], edx
  000f6	8d 14 1e	 lea	 edx, DWORD PTR [esi+ebx]
  000f9	89 45 0c	 mov	 DWORD PTR $T1[ebp], eax
  000fc	89 75 fc	 mov	 DWORD PTR tv534[ebp], esi
  000ff	89 55 f4	 mov	 DWORD PTR tv533[ebp], edx
  00102	51		 push	 ecx
  00103	72 56		 jb	 SHORT $LN13@append

; 4563 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  00105	8b 37		 mov	 esi, DWORD PTR [edi]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00107	56		 push	 esi
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 _memcpy
  0010e	53		 push	 ebx
  0010f	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00112	ff 75 fc	 push	 DWORD PTR tv534[ebp]
  00115	e8 00 00 00 00	 call	 _memcpy

; 3169 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0011a	8b 45 f4	 mov	 eax, DWORD PTR tv533[ebp]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0011d	83 c4 18	 add	 esp, 24			; 00000018H

; 4565 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  00120	8b 4d f8	 mov	 ecx, DWORD PTR __Old$1$[ebp]
  00123	41		 inc	 ecx

; 3169 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00124	c6 00 00	 mov	 BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00127	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0012d	72 12		 jb	 SHORT $LN52@append

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0012f	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  00132	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00135	2b f2		 sub	 esi, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00137	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  0013a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0013d	77 4b		 ja	 SHORT $LN49@append

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0013f	8b f2		 mov	 esi, edx
$LN52@append:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00141	51		 push	 ecx
  00142	56		 push	 esi
  00143	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3163 :         return _Reallocate_grow_by(

  00148	8b 45 0c	 mov	 eax, DWORD PTR $T1[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  0014b	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3163 :         return _Reallocate_grow_by(

  0014e	89 07		 mov	 DWORD PTR [edi], eax

; 3172 :     }

  00150	8b c7		 mov	 eax, edi
  00152	5f		 pop	 edi
  00153	5e		 pop	 esi
  00154	5b		 pop	 ebx
  00155	8b e5		 mov	 esp, ebp
  00157	5d		 pop	 ebp
  00158	c2 08 00	 ret	 8
$LN13@append:

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0015b	57		 push	 edi
  0015c	50		 push	 eax
  0015d	e8 00 00 00 00	 call	 _memcpy
  00162	53		 push	 ebx
  00163	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00166	56		 push	 esi
  00167	e8 00 00 00 00	 call	 _memcpy

; 3169 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0016c	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0016f	83 c4 18	 add	 esp, 24			; 00000018H

; 3169 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00172	c6 00 00	 mov	 BYTE PTR [eax], 0

; 3163 :         return _Reallocate_grow_by(

  00175	8b 45 0c	 mov	 eax, DWORD PTR $T1[ebp]
  00178	89 07		 mov	 DWORD PTR [edi], eax

; 3172 :     }

  0017a	8b c7		 mov	 eax, edi
  0017c	5f		 pop	 edi
  0017d	5e		 pop	 esi
  0017e	5b		 pop	 ebx
  0017f	8b e5		 mov	 esp, ebp
  00181	5d		 pop	 ebp
  00182	c2 08 00	 ret	 8
$LN68@append:

; 4544 :             _Xlen_string(); // result too long

  00185	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN49@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0018a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN64@append:
  0018f	cc		 int	 3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 3002 :     _CONSTEXPR20_CONTAINER ~basic_string() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2319 :         return _BUF_SIZE <= _Myres;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 27		 jb	 SHORT $LN12@basic_stri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0000d	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN22@basic_stri

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN19@basic_stri

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN22@basic_stri:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN12@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi

; 3010 :     }

  00044	c3		 ret	 0
$LN19@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN27@basic_stri:
  0004a	cc		 int	 3
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2374 :     _Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlen_strin:
  0000a	cc		 int	 3
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN12@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 142  :     }

  00003	8b c1		 mov	 eax, ecx

; 65   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 66   :     {
; 67   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 141  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN6@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 96   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 91   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 74   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT __snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__snprintf PROC						; COMDAT

; 1947 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00003	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1948 :         int _Result;
; 1949 :         va_list _ArgList;
; 1950 :         __crt_va_start(_ArgList, _Format);
; 1951 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1952 :         __crt_va_end(_ArgList);
; 1953 :         return _Result;
; 1954 :     }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 837  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __Stream$[ebp]
  0000f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00014	ff 70 04	 push	 DWORD PTR [eax+4]
  00017	ff 30		 push	 DWORD PTR [eax]
  00019	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);
; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 842  :         __crt_va_end(_ArgList);
; 843  :         return _Result;
; 844  :     }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
