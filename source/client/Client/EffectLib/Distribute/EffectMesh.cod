; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30137.0 

	TITLE	C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\Distribute\EffectMesh.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_7?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@6B@ ; CDynamicPool<CEffectMesh::SEffectMeshData>::`vftable'
PUBLIC	??_G?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@UAEPAXI@Z ; CDynamicPool<CEffectMesh::SEffectMeshData>::`scalar deleting destructor'
PUBLIC	??_R4?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@6B@ ; CDynamicPool<CEffectMesh::SEffectMeshData>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@@8 ; CDynamicPool<CEffectMesh::SEffectMeshData> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@8 ; CDynamicPool<CEffectMesh::SEffectMeshData>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@8 ; CDynamicPool<CEffectMesh::SEffectMeshData>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@8 ; CDynamicPool<CEffectMesh::SEffectMeshData>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPool@VCEffectMeshScript@@@@6B@	; CDynamicPool<CEffectMeshScript>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCEffectMeshScript@@@@@8	; CDynamicPool<CEffectMeshScript> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCEffectMeshScript@@@@8	; CDynamicPool<CEffectMeshScript>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCEffectMeshScript@@@@8	; CDynamicPool<CEffectMeshScript>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCEffectMeshScript@@@@8 ; CDynamicPool<CEffectMeshScript>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7?$CDynamicPool@VCEffectMeshScript@@@@6B@	; CDynamicPool<CEffectMeshScript>::`vftable'
PUBLIC	??_G?$CDynamicPool@VCEffectMeshScript@@@@UAEPAXI@Z ; CDynamicPool<CEffectMeshScript>::`scalar deleting destructor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_E?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@UAEPAXI@Z:PROC ; CDynamicPool<CEffectMesh::SEffectMeshData>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPool@VCEffectMeshScript@@@@UAEPAXI@Z:PROC ; CDynamicPool<CEffectMeshScript>::`vector deleting destructor'
;	COMDAT ??_7?$CDynamicPool@VCEffectMeshScript@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCEffectMeshScript@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCEffectMeshScript@@@@6B@ ; CDynamicPool<CEffectMeshScript>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCEffectMeshScript@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCEffectMeshScript@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCEffectMeshScript@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCEffectMeshScript@@@@@8 ; CDynamicPool<CEffectMeshScript>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCEffectMeshScript@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCEffectMeshScript@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCEffectMeshScript@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCEffectMeshScript@@@@8 ; CDynamicPool<CEffectMeshScript>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCEffectMeshScript@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCEffectMeshScript@@@@8 DD 00H	; CDynamicPool<CEffectMeshScript>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCEffectMeshScript@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCEffectMeshScript@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@VCEffectMeshScript@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CEffectMeshScript> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCEffectMeshScript@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCEffectMeshScript@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCEffectMeshScript@@@@6B@ DD 00H	; CDynamicPool<CEffectMeshScript>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCEffectMeshScript@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCEffectMeshScript@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@@8 ; CDynamicPool<CEffectMesh::SEffectMeshData>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@8 ; CDynamicPool<CEffectMesh::SEffectMeshData>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@8 DD 00H ; CDynamicPool<CEffectMesh::SEffectMeshData>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CEffectMesh::SEffectMeshData> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@6B@ DD 00H ; CDynamicPool<CEffectMesh::SEffectMeshData>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@8
rdata$r	ENDS
;	COMDAT ??_7?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@6B@ DD FLAT:??_R4?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@6B@ ; CDynamicPool<CEffectMesh::SEffectMeshData>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@UAEPAXI@Z
CONST	ENDS
CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??1CGotoChild@CTextFileLoader@@QAE@XZ		; CTextFileLoader::CGotoChild::~CGotoChild
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??1?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@QAE@XZ ; std::vector<SPTVertex,std::allocator<SPTVertex> >::~vector<SPTVertex,std::allocator<SPTVertex> >
PUBLIC	?_Xlength@?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@CAXXZ ; std::vector<SPTVertex,std::allocator<SPTVertex> >::_Xlength
PUBLIC	??1?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@QAE@XZ ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::~vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >
PUBLIC	?_Ufill@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@AAEPAUSEffectFrameData@CEffectMesh@@PAU34@IU_Value_init_tag@2@@Z ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::_Ufill
PUBLIC	?_Xlength@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@CAXXZ ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::_Xlength
PUBLIC	?_Xlength@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@CAXXZ ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Xlength
PUBLIC	?New@SEffectMeshData@CEffectMesh@@SAPAU12@XZ	; CEffectMesh::SEffectMeshData::New
PUBLIC	?Delete@SEffectMeshData@CEffectMesh@@SAXPAU12@@Z ; CEffectMesh::SEffectMeshData::Delete
PUBLIC	?DestroySystem@SEffectMeshData@CEffectMesh@@SAXXZ ; CEffectMesh::SEffectMeshData::DestroySystem
PUBLIC	?Type@CEffectMesh@@SAKXZ			; CEffectMesh::Type
PUBLIC	??0CEffectMesh@@QAE@PBD@Z			; CEffectMesh::CEffectMesh
PUBLIC	??1CEffectMesh@@UAE@XZ				; CEffectMesh::~CEffectMesh
PUBLIC	?GetFrameCount@CEffectMesh@@QAEKXZ		; CEffectMesh::GetFrameCount
PUBLIC	?GetMeshCount@CEffectMesh@@QAEKXZ		; CEffectMesh::GetMeshCount
PUBLIC	?GetMeshDataPointer@CEffectMesh@@QAEPAUSEffectMeshData@1@K@Z ; CEffectMesh::GetMeshDataPointer
PUBLIC	?GetTextureVectorPointer@CEffectMesh@@QAEPAV?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@K@Z ; CEffectMesh::GetTextureVectorPointer
PUBLIC	?GetTextureVectorReference@CEffectMesh@@QAEAAV?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@K@Z ; CEffectMesh::GetTextureVectorReference
PUBLIC	?GetMeshElementPointer@CEffectMesh@@QAEHKPAPAUSEffectMeshData@1@@Z ; CEffectMesh::GetMeshElementPointer
PUBLIC	?OnLoad@CEffectMesh@@MAE_NHPBX@Z		; CEffectMesh::OnLoad
PUBLIC	?OnClear@CEffectMesh@@MAEXXZ			; CEffectMesh::OnClear
PUBLIC	?OnIsEmpty@CEffectMesh@@MBE_NXZ			; CEffectMesh::OnIsEmpty
PUBLIC	?OnIsType@CEffectMesh@@MAE_NK@Z			; CEffectMesh::OnIsType
PUBLIC	?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z	; CEffectMesh::__LoadData_Ver001
PUBLIC	?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z	; CEffectMesh::__LoadData_Ver002
PUBLIC	?resize@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@QAEXI@Z ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::resize
PUBLIC	?_Change_array@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@AAEXQAPAUSEffectMeshData@CEffectMesh@@II@Z ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Change_array
PUBLIC	?_Xlength@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@CAXXZ ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Xlength
PUBLIC	??_GCEffectMesh@@UAEPAXI@Z			; CEffectMesh::`scalar deleting destructor'
PUBLIC	??0CEffectMeshScript@@QAE@XZ			; CEffectMeshScript::CEffectMeshScript
PUBLIC	??1CEffectMeshScript@@UAE@XZ			; CEffectMeshScript::~CEffectMeshScript
PUBLIC	?GetMeshFileName@CEffectMeshScript@@QAEPBDXZ	; CEffectMeshScript::GetMeshFileName
PUBLIC	?ReserveMeshData@CEffectMeshScript@@QAEXK@Z	; CEffectMeshScript::ReserveMeshData
PUBLIC	?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z	; CEffectMeshScript::CheckMeshIndex
PUBLIC	?GetMeshDataPointer@CEffectMeshScript@@QAE_NKPAPAUSMeshData@1@@Z ; CEffectMeshScript::GetMeshDataPointer
PUBLIC	?GetMeshDataCount@CEffectMeshScript@@QAEHXZ	; CEffectMeshScript::GetMeshDataCount
PUBLIC	?GetBillboardType@CEffectMeshScript@@QAEHK@Z	; CEffectMeshScript::GetBillboardType
PUBLIC	?isBlendingEnable@CEffectMeshScript@@QAEHK@Z	; CEffectMeshScript::isBlendingEnable
PUBLIC	?GetBlendingSrcType@CEffectMeshScript@@QAEEK@Z	; CEffectMeshScript::GetBlendingSrcType
PUBLIC	?GetBlendingDestType@CEffectMeshScript@@QAEEK@Z	; CEffectMeshScript::GetBlendingDestType
PUBLIC	?isTextureAlphaEnable@CEffectMeshScript@@QAEHK@Z ; CEffectMeshScript::isTextureAlphaEnable
PUBLIC	?GetColorOperationType@CEffectMeshScript@@QAEHKPAE@Z ; CEffectMeshScript::GetColorOperationType
PUBLIC	?GetColorFactor@CEffectMeshScript@@QAEHKPAUD3DXCOLOR@@@Z ; CEffectMeshScript::GetColorFactor
PUBLIC	?GetTimeTableAlphaPointer@CEffectMeshScript@@QAEHKPAPAV?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@Z ; CEffectMeshScript::GetTimeTableAlphaPointer
PUBLIC	?isMeshAnimationLoop@CEffectMeshScript@@QAEHXZ	; CEffectMeshScript::isMeshAnimationLoop
PUBLIC	?GetMeshAnimationLoopCount@CEffectMeshScript@@QAEHXZ ; CEffectMeshScript::GetMeshAnimationLoopCount
PUBLIC	?GetMeshAnimationFrameDelay@CEffectMeshScript@@QAEMXZ ; CEffectMeshScript::GetMeshAnimationFrameDelay
PUBLIC	?isTextureAnimationLoop@CEffectMeshScript@@QAEHK@Z ; CEffectMeshScript::isTextureAnimationLoop
PUBLIC	?GetTextureAnimationFrameDelay@CEffectMeshScript@@QAEMK@Z ; CEffectMeshScript::GetTextureAnimationFrameDelay
PUBLIC	?GetTextureAnimationStartFrame@CEffectMeshScript@@QAEKK@Z ; CEffectMeshScript::GetTextureAnimationStartFrame
PUBLIC	?OnClear@CEffectMeshScript@@MAEXXZ		; CEffectMeshScript::OnClear
PUBLIC	?OnIsData@CEffectMeshScript@@MAE_NXZ		; CEffectMeshScript::OnIsData
PUBLIC	?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z ; CEffectMeshScript::OnLoadScript
PUBLIC	??1?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@QAE@XZ ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::~vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >
PUBLIC	?resize@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@QAEXI@Z ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::resize
PUBLIC	?_Ufill@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@AAEPAUSMeshData@CEffectMeshScript@@PAU34@IU_Value_init_tag@2@@Z ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::_Ufill
PUBLIC	?_Xlength@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@CAXXZ ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::_Xlength
PUBLIC	?DestroySystem@CEffectMeshScript@@SAXXZ		; CEffectMeshScript::DestroySystem
PUBLIC	?New@CEffectMeshScript@@SAPAV1@XZ		; CEffectMeshScript::New
PUBLIC	?Delete@CEffectMeshScript@@SAXPAV1@@Z		; CEffectMeshScript::Delete
PUBLIC	??_GCEffectMeshScript@@UAEPAXI@Z		; CEffectMeshScript::`scalar deleting destructor'
PUBLIC	??1?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@UAE@XZ ; CDynamicPool<CEffectMesh::SEffectMeshData>::~CDynamicPool<CEffectMesh::SEffectMeshData>
PUBLIC	?Delete@?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@KAXPAUSEffectMeshData@CEffectMesh@@@Z ; CDynamicPool<CEffectMesh::SEffectMeshData>::Delete
PUBLIC	??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
PUBLIC	?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlength
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
PUBLIC	??1?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::~vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >
PUBLIC	?_Xlength@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@CAXXZ ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Xlength
PUBLIC	??1?$CDynamicPool@VCEffectMeshScript@@@@UAE@XZ	; CDynamicPool<CEffectMeshScript>::~CDynamicPool<CEffectMeshScript>
PUBLIC	?Delete@?$CDynamicPool@VCEffectMeshScript@@@@KAXPAVCEffectMeshScript@@@Z ; CDynamicPool<CEffectMeshScript>::Delete
PUBLIC	?_Xlength@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@CAXXZ ; std::vector<CEffectMeshScript *,std::allocator<CEffectMeshScript *> >::_Xlength
PUBLIC	??$_Emplace_reallocate@ABQAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEPAPAVCGraphicImage@@QAPAV2@ABQAV2@@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Emplace_reallocate<CGraphicImage * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCEffectMeshScript@@@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@QAEPAPAVCEffectMeshScript@@QAPAV2@ABQAV2@@Z ; std::vector<CEffectMeshScript *,std::allocator<CEffectMeshScript *> >::_Emplace_reallocate<CEffectMeshScript * const &>
PUBLIC	??$_Destroy_range@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAXPAUSMeshData@CEffectMeshScript@@QAU12@AAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshScript::SMeshData> >
PUBLIC	??$_Emplace_reallocate@ABQAUSEffectMeshData@CEffectMesh@@@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@QAEPAPAUSEffectMeshData@CEffectMesh@@QAPAU23@ABQAU23@@Z ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Emplace_reallocate<CEffectMesh::SEffectMeshData * const &>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<SPTVertex,std::allocator<SPTVertex> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Copy_memmove@PAPAVCEffectMeshScript@@PAPAV1@@std@@YAPAPAVCEffectMeshScript@@PAPAV1@00@Z ; std::_Copy_memmove<CEffectMeshScript * *,CEffectMeshScript * *>
PUBLIC	??$_Zero_range@PAH@std@@YAPAHQAH0@Z		; std::_Zero_range<int *>
PUBLIC	??$_Copy_memmove@PAPAUSEffectMeshData@CEffectMesh@@PAPAU12@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@PAPAU12@00@Z ; std::_Copy_memmove<CEffectMesh::SEffectMeshData * *,CEffectMesh::SEffectMeshData * *>
PUBLIC	??$_Zero_range@PAPAUSEffectMeshData@CEffectMesh@@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@QAPAU12@0@Z ; std::_Zero_range<CEffectMesh::SEffectMeshData * *>
PUBLIC	??$_Copy_memmove@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00@Z ; std::_Copy_memmove<CGraphicImage * *,CGraphicImage * *>
PUBLIC	??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z	; std::_Copy_memmove<int *,int *>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
PUBLIC	?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A ; CEffectMesh::SEffectMeshData::ms_kPool
PUBLIC	??_7CEffectMesh@@6B@				; CEffectMesh::`vftable'
PUBLIC	?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A ; CEffectMeshScript::ms_kPool
PUBLIC	??_7CEffectMeshScript@@6B@			; CEffectMeshScript::`vftable'
PUBLIC	??_C@_0M@HCKGHODL@CEffectMesh@			; `string'
PUBLIC	??_C@_0L@HDPGDEFC@EffectData@			; `string'
PUBLIC	??_C@_0L@HDHCIEF@MDEData002@			; `string'
PUBLIC	??_C@_03BNIHALFD@ifl@				; `string'
PUBLIC	??_C@_0N@KFLKANCO@meshfilename@			; `string'
PUBLIC	??_C@_0BI@HOBONKKC@meshanimationloopenable@	; `string'
PUBLIC	??_C@_0BH@CNDNOBIC@meshanimationloopcount@	; `string'
PUBLIC	??_C@_0BI@DLPGELIN@meshanimationframedelay@	; `string'
PUBLIC	??_C@_0BB@IMKDGDDP@meshelementcount@		; `string'
PUBLIC	??_C@_0O@EJACNAIE@billboardtype@		; `string'
PUBLIC	??_C@_0P@LCDJDIBK@blendingenable@		; `string'
PUBLIC	??_C@_0BA@CALCJEKJ@blendingsrctype@		; `string'
PUBLIC	??_C@_0BB@PBNEFHNO@blendingdesttype@		; `string'
PUBLIC	??_C@_0BL@INILLDMC@textureanimationloopenable@	; `string'
PUBLIC	??_C@_0BL@MIGDCCON@textureanimationframedelay@	; `string'
PUBLIC	??_C@_0BL@PMOBBIKD@textureanimationstartframe@	; `string'
PUBLIC	??_C@_0BD@DAMHAFBJ@coloroperationtype@		; `string'
PUBLIC	??_C@_0M@PBDNNBOP@colorfactor@			; `string'
PUBLIC	??_C@_0P@KALIPJCI@timeeventalpha@		; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4CEffectMesh@@6B@				; CEffectMesh::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCEffectMesh@@@8				; CEffectMesh `RTTI Type Descriptor'
PUBLIC	??_R3CEffectMesh@@8				; CEffectMesh::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CEffectMesh@@8				; CEffectMesh::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CEffectMesh@@8			; CEffectMesh::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CResource@@8			; CResource::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCResource@@@8				; CResource `RTTI Type Descriptor'
PUBLIC	??_R3CResource@@8				; CResource::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CResource@@8				; CResource::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CReferenceObject@@8		; CReferenceObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCReferenceObject@@@8			; CReferenceObject `RTTI Type Descriptor'
PUBLIC	??_R3CReferenceObject@@8			; CReferenceObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CReferenceObject@@8			; CReferenceObject::`RTTI Base Class Array'
PUBLIC	??_R4CEffectMeshScript@@6B@			; CEffectMeshScript::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCEffectMeshScript@@@8			; CEffectMeshScript `RTTI Type Descriptor'
PUBLIC	??_R3CEffectMeshScript@@8			; CEffectMeshScript::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CEffectMeshScript@@8			; CEffectMeshScript::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CEffectMeshScript@@8		; CEffectMeshScript::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CEffectElementBase@@8		; CEffectElementBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCEffectElementBase@@@8			; CEffectElementBase `RTTI Type Descriptor'
PUBLIC	??_R3CEffectElementBase@@8			; CEffectElementBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CEffectElementBase@@8			; CEffectElementBase::`RTTI Base Class Array'
PUBLIC	__real@00000000
PUBLIC	__real@bf800000
PUBLIC	__xmm@3f8000003f8000003f8000003f800000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_abort:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	___std_terminate:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?GetFileExtension@@YAXPBDHPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; GetFileExtension
EXTRN	?stl_lowers@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; stl_lowers
EXTRN	?GetOnlyPathName@@YAXPBDAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; GetOnlyPathName
EXTRN	?GetOnlyPathName@@YAPBDPBD@Z:PROC		; GetOnlyPathName
EXTRN	?IsGlobalFileName@@YA_NPBD@Z:PROC		; IsGlobalFileName
EXTRN	??0CMemoryTextFileLoader@@QAE@XZ:PROC		; CMemoryTextFileLoader::CMemoryTextFileLoader
EXTRN	??1CMemoryTextFileLoader@@UAE@XZ:PROC		; CMemoryTextFileLoader::~CMemoryTextFileLoader
EXTRN	?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z:PROC	; CMemoryTextFileLoader::Bind
EXTRN	?GetLineCount@CMemoryTextFileLoader@@QAEKXZ:PROC ; CMemoryTextFileLoader::GetLineCount
EXTRN	?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z:PROC ; CMemoryTextFileLoader::GetLineString
EXTRN	??0CMappedFile@@QAE@XZ:PROC			; CMappedFile::CMappedFile
EXTRN	??1CMappedFile@@UAE@XZ:PROC			; CMappedFile::~CMappedFile
EXTRN	?Size@CMappedFile@@QAEKXZ:PROC			; CMappedFile::Size
EXTRN	?GetFileName@CTextFileLoader@@QAEPBDXZ:PROC	; CTextFileLoader::GetFileName
EXTRN	?SetChildNode@CTextFileLoader@@QAEHK@Z:PROC	; CTextFileLoader::SetChildNode
EXTRN	?SetParentNode@CTextFileLoader@@QAEHXZ:PROC	; CTextFileLoader::SetParentNode
EXTRN	?GetTokenBoolean@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z:PROC ; CTextFileLoader::GetTokenBoolean
EXTRN	?GetTokenByte@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE@Z:PROC ; CTextFileLoader::GetTokenByte
EXTRN	?GetTokenInteger@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z:PROC ; CTextFileLoader::GetTokenInteger
EXTRN	?GetTokenDoubleWord@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAK@Z:PROC ; CTextFileLoader::GetTokenDoubleWord
EXTRN	?GetTokenFloat@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM@Z:PROC ; CTextFileLoader::GetTokenFloat
EXTRN	?GetTokenColor@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUD3DXCOLOR@@@Z:PROC ; CTextFileLoader::GetTokenColor
EXTRN	?GetTokenString@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV23@@Z:PROC ; CTextFileLoader::GetTokenString
EXTRN	?StringToType@CResource@@SAKPBD@Z:PROC		; CResource::StringToType
EXTRN	?CreateDeviceObjects@CResource@@UAE_NXZ:PROC	; CResource::CreateDeviceObjects
EXTRN	?DestroyDeviceObjects@CResource@@UAEXXZ:PROC	; CResource::DestroyDeviceObjects
EXTRN	??0CResource@@QAE@PBD@Z:PROC			; CResource::CResource
EXTRN	??1CResource@@UAE@XZ:PROC			; CResource::~CResource
EXTRN	?OnIsType@CResource@@MAE_NK@Z:PROC		; CResource::OnIsType
EXTRN	?OnConstruct@CResource@@MAEXXZ:PROC		; CResource::OnConstruct
EXTRN	?OnSelfDestruct@CResource@@MAEXXZ:PROC		; CResource::OnSelfDestruct
EXTRN	?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z:PROC ; CResourceManager::GetResourcePointer
EXTRN	?Get@CEterPackManager@@QAE_NAAVCMappedFile@@PBDPAPBX@Z:PROC ; CEterPackManager::Get
EXTRN	?GetTokenTimeEventFloat@@YAHAAVCTextFileLoader@@PBDPAV?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@Z:PROC ; GetTokenTimeEventFloat
EXTRN	??0CEffectElementBase@@QAE@XZ:PROC		; CEffectElementBase::CEffectElementBase
EXTRN	??1CEffectElementBase@@UAE@XZ:PROC		; CEffectElementBase::~CEffectElementBase
EXTRN	?Clear@CEffectElementBase@@QAEXXZ:PROC		; CEffectElementBase::Clear
EXTRN	??_ECEffectMesh@@UAEPAXI@Z:PROC			; CEffectMesh::`vector deleting destructor'
EXTRN	??_ECEffectMeshScript@@UAEPAXI@Z:PROC		; CEffectMeshScript::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A DD 01H DUP (?) ; CSingleton<CResourceManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A DD 01H DUP (?) ; CSingleton<CEterPackManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?s_type@?1??Type@CEffectMesh@@SAKXZ@4KA
_BSS	SEGMENT
?s_type@?1??Type@CEffectMesh@@SAKXZ@4KA DD 01H DUP (?)	; `CEffectMesh::Type'::`2'::s_type
_BSS	ENDS
;	COMDAT ?$TSS0@?1??Type@CEffectMesh@@SAKXZ@4HA
_BSS	SEGMENT
?$TSS0@?1??Type@CEffectMesh@@SAKXZ@4HA DD 01H DUP (?)	; `CEffectMesh::Type'::`2'::$TSS0
_BSS	ENDS
CRT$XCU	SEGMENT
??ms_kPool$initializer$@SEffectMeshData@CEffectMesh@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A@@YAXXZ ; ??ms_kPool$initializer$@SEffectMeshData@CEffectMesh@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT __xmm@3f8000003f8000003f8000003f800000
CONST	SEGMENT
__xmm@3f8000003f8000003f8000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 080H
	DB	'?', 00H, 00H, 080H, '?', 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R2CEffectElementBase@@8
rdata$r	SEGMENT
??_R2CEffectElementBase@@8 DD FLAT:??_R1A@?0A@EA@CEffectElementBase@@8 ; CEffectElementBase::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CEffectElementBase@@8
rdata$r	SEGMENT
??_R3CEffectElementBase@@8 DD 00H			; CEffectElementBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CEffectElementBase@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCEffectElementBase@@@8
data$rs	SEGMENT
??_R0?AVCEffectElementBase@@@8 DD FLAT:??_7type_info@@6B@ ; CEffectElementBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCEffectElementBase@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CEffectElementBase@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CEffectElementBase@@8 DD FLAT:??_R0?AVCEffectElementBase@@@8 ; CEffectElementBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CEffectElementBase@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CEffectMeshScript@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CEffectMeshScript@@8 DD FLAT:??_R0?AVCEffectMeshScript@@@8 ; CEffectMeshScript::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CEffectMeshScript@@8
rdata$r	ENDS
;	COMDAT ??_R2CEffectMeshScript@@8
rdata$r	SEGMENT
??_R2CEffectMeshScript@@8 DD FLAT:??_R1A@?0A@EA@CEffectMeshScript@@8 ; CEffectMeshScript::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CEffectElementBase@@8
rdata$r	ENDS
;	COMDAT ??_R3CEffectMeshScript@@8
rdata$r	SEGMENT
??_R3CEffectMeshScript@@8 DD 00H			; CEffectMeshScript::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CEffectMeshScript@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCEffectMeshScript@@@8
data$rs	SEGMENT
??_R0?AVCEffectMeshScript@@@8 DD FLAT:??_7type_info@@6B@ ; CEffectMeshScript `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCEffectMeshScript@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CEffectMeshScript@@6B@
rdata$r	SEGMENT
??_R4CEffectMeshScript@@6B@ DD 00H			; CEffectMeshScript::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCEffectMeshScript@@@8
	DD	FLAT:??_R3CEffectMeshScript@@8
rdata$r	ENDS
;	COMDAT ??_R2CReferenceObject@@8
rdata$r	SEGMENT
??_R2CReferenceObject@@8 DD FLAT:??_R1A@?0A@EA@CReferenceObject@@8 ; CReferenceObject::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CReferenceObject@@8
rdata$r	SEGMENT
??_R3CReferenceObject@@8 DD 00H				; CReferenceObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CReferenceObject@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCReferenceObject@@@8
data$rs	SEGMENT
??_R0?AVCReferenceObject@@@8 DD FLAT:??_7type_info@@6B@	; CReferenceObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCReferenceObject@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CReferenceObject@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CReferenceObject@@8 DD FLAT:??_R0?AVCReferenceObject@@@8 ; CReferenceObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CReferenceObject@@8
rdata$r	ENDS
;	COMDAT ??_R2CResource@@8
rdata$r	SEGMENT
??_R2CResource@@8 DD FLAT:??_R1A@?0A@EA@CResource@@8	; CResource::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CReferenceObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CResource@@8
rdata$r	SEGMENT
??_R3CResource@@8 DD 00H				; CResource::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CResource@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCResource@@@8
data$rs	SEGMENT
??_R0?AVCResource@@@8 DD FLAT:??_7type_info@@6B@	; CResource `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCResource@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CResource@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CResource@@8 DD FLAT:??_R0?AVCResource@@@8 ; CResource::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CResource@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CEffectMesh@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CEffectMesh@@8 DD FLAT:??_R0?AVCEffectMesh@@@8 ; CEffectMesh::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CEffectMesh@@8
rdata$r	ENDS
;	COMDAT ??_R2CEffectMesh@@8
rdata$r	SEGMENT
??_R2CEffectMesh@@8 DD FLAT:??_R1A@?0A@EA@CEffectMesh@@8 ; CEffectMesh::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CResource@@8
	DD	FLAT:??_R1A@?0A@EA@CReferenceObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CEffectMesh@@8
rdata$r	SEGMENT
??_R3CEffectMesh@@8 DD 00H				; CEffectMesh::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CEffectMesh@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCEffectMesh@@@8
data$rs	SEGMENT
??_R0?AVCEffectMesh@@@8 DD FLAT:??_7type_info@@6B@	; CEffectMesh `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCEffectMesh@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CEffectMesh@@6B@
rdata$r	SEGMENT
??_R4CEffectMesh@@6B@ DD 00H				; CEffectMesh::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCEffectMesh@@@8
	DD	FLAT:??_R3CEffectMesh@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KALIPJCI@timeeventalpha@
CONST	SEGMENT
??_C@_0P@KALIPJCI@timeeventalpha@ DB 'timeeventalpha', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PBDNNBOP@colorfactor@
CONST	SEGMENT
??_C@_0M@PBDNNBOP@colorfactor@ DB 'colorfactor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DAMHAFBJ@coloroperationtype@
CONST	SEGMENT
??_C@_0BD@DAMHAFBJ@coloroperationtype@ DB 'coloroperationtype', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PMOBBIKD@textureanimationstartframe@
CONST	SEGMENT
??_C@_0BL@PMOBBIKD@textureanimationstartframe@ DB 'textureanimationstartf'
	DB	'rame', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MIGDCCON@textureanimationframedelay@
CONST	SEGMENT
??_C@_0BL@MIGDCCON@textureanimationframedelay@ DB 'textureanimationframed'
	DB	'elay', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@INILLDMC@textureanimationloopenable@
CONST	SEGMENT
??_C@_0BL@INILLDMC@textureanimationloopenable@ DB 'textureanimationloopen'
	DB	'able', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PBNEFHNO@blendingdesttype@
CONST	SEGMENT
??_C@_0BB@PBNEFHNO@blendingdesttype@ DB 'blendingdesttype', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CALCJEKJ@blendingsrctype@
CONST	SEGMENT
??_C@_0BA@CALCJEKJ@blendingsrctype@ DB 'blendingsrctype', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LCDJDIBK@blendingenable@
CONST	SEGMENT
??_C@_0P@LCDJDIBK@blendingenable@ DB 'blendingenable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EJACNAIE@billboardtype@
CONST	SEGMENT
??_C@_0O@EJACNAIE@billboardtype@ DB 'billboardtype', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IMKDGDDP@meshelementcount@
CONST	SEGMENT
??_C@_0BB@IMKDGDDP@meshelementcount@ DB 'meshelementcount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DLPGELIN@meshanimationframedelay@
CONST	SEGMENT
??_C@_0BI@DLPGELIN@meshanimationframedelay@ DB 'meshanimationframedelay', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CNDNOBIC@meshanimationloopcount@
CONST	SEGMENT
??_C@_0BH@CNDNOBIC@meshanimationloopcount@ DB 'meshanimationloopcount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HOBONKKC@meshanimationloopenable@
CONST	SEGMENT
??_C@_0BI@HOBONKKC@meshanimationloopenable@ DB 'meshanimationloopenable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KFLKANCO@meshfilename@
CONST	SEGMENT
??_C@_0N@KFLKANCO@meshfilename@ DB 'meshfilename', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03BNIHALFD@ifl@
CONST	SEGMENT
??_C@_03BNIHALFD@ifl@ DB 'ifl', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HDHCIEF@MDEData002@
CONST	SEGMENT
??_C@_0L@HDHCIEF@MDEData002@ DB 'MDEData002', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HDPGDEFC@EffectData@
CONST	SEGMENT
??_C@_0L@HDPGDEFC@EffectData@ DB 'EffectData', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HCKGHODL@CEffectMesh@
CONST	SEGMENT
??_C@_0M@HCKGHODL@CEffectMesh@ DB 'CEffectMesh', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7CEffectMeshScript@@6B@
CONST	SEGMENT
??_7CEffectMeshScript@@6B@ DD FLAT:??_R4CEffectMeshScript@@6B@ ; CEffectMeshScript::`vftable'
	DD	FLAT:??_ECEffectMeshScript@@UAEPAXI@Z
	DD	FLAT:?OnClear@CEffectMeshScript@@MAEXXZ
	DD	FLAT:?OnIsData@CEffectMeshScript@@MAE_NXZ
	DD	FLAT:?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z
CONST	ENDS
;	COMDAT ??_7CEffectMesh@@6B@
CONST	SEGMENT
??_7CEffectMesh@@6B@ DD FLAT:??_R4CEffectMesh@@6B@	; CEffectMesh::`vftable'
	DD	FLAT:??_ECEffectMesh@@UAEPAXI@Z
	DD	FLAT:?OnConstruct@CResource@@MAEXXZ
	DD	FLAT:?OnSelfDestruct@CResource@@MAEXXZ
	DD	FLAT:?CreateDeviceObjects@CResource@@UAE_NXZ
	DD	FLAT:?DestroyDeviceObjects@CResource@@UAEXXZ
	DD	FLAT:?OnLoad@CEffectMesh@@MAE_NHPBX@Z
	DD	FLAT:?OnClear@CEffectMesh@@MAEXXZ
	DD	FLAT:?OnIsEmpty@CEffectMesh@@MBE_NXZ
	DD	FLAT:?OnIsType@CEffectMesh@@MAE_NK@Z
CONST	ENDS
_DATA	SEGMENT
?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A DD FLAT:??_7?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@6B@ ; CEffectMesh::SEffectMeshData::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A DD FLAT:??_7?$CDynamicPool@VCEffectMeshScript@@@@6B@ ; CEffectMeshScript::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Alloc@?$CDynamicPool@VCEffectMeshScript@@@@QAEPAVCEffectMeshScript@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Alloc@?$CDynamicPool@VCEffectMeshScript@@@@QAEPAVCEffectMeshScript@@XZ$0
__ehfuncinfo$?Alloc@?$CDynamicPool@VCEffectMeshScript@@@@QAEPAVCEffectMeshScript@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Alloc@?$CDynamicPool@VCEffectMeshScript@@@@QAEPAVCEffectMeshScript@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?New@CEffectMeshScript@@SAPAV1@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?New@CEffectMeshScript@@SAPAV1@XZ$0
__ehfuncinfo$?New@CEffectMeshScript@@SAPAV1@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?New@CEffectMeshScript@@SAPAV1@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z DD 019930522H
	DD	016H
	DD	FLAT:__unwindtable$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$7
	DD	0ffffffffH
	DD	00H
	DD	05H
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$8
	DD	0ffffffffH
	DD	00H
	DD	05H
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$9
	DD	0ffffffffH
	DD	00H
	DD	05H
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$10
	DD	0ffffffffH
	DD	00H
	DD	05H
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$11
	DD	0ffffffffH
	DD	00H
	DD	05H
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$12
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	05H
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$13
	DD	05H
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$14
	DD	05H
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$15
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$9
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$9
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Type@CEffectMesh@@SAKXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Type@CEffectMesh@@SAKXZ$0
__ehfuncinfo$?Type@CEffectMesh@@SAKXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Type@CEffectMesh@@SAKXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CGotoChild@CTextFileLoader@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
CRT$XCU	SEGMENT
??ms_kPool$initializer$@CEffectMeshScript@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A@@YAXXZ ; ??ms_kPool$initializer$@CEffectMeshScript@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z PROC		; std::_Copy_memmove<int *,int *>, COMDAT

; 4159 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4160 :     auto _FirstPtr              = _To_address(_First);
; 4161 :     auto _LastPtr               = _To_address(_Last);
; 4162 :     auto _DestPtr               = _To_address(_Dest);
; 4163 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4164 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4165 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4168 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4169 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 4170 :     } else {
; 4171 :         return _Dest + (_LastPtr - _FirstPtr);
; 4172 :     }
; 4173 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ENDP		; std::_Copy_memmove<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CGraphicImage * *,CGraphicImage * *>, COMDAT

; 4159 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4160 :     auto _FirstPtr              = _To_address(_First);
; 4161 :     auto _LastPtr               = _To_address(_Last);
; 4162 :     auto _DestPtr               = _To_address(_Dest);
; 4163 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4164 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4165 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4168 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4169 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 4170 :     } else {
; 4171 :         return _Dest + (_LastPtr - _FirstPtr);
; 4172 :     }
; 4173 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CGraphicImage * *,CGraphicImage * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Zero_range@PAPAUSEffectMeshData@CEffectMesh@@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@QAPAU12@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Zero_range@PAPAUSEffectMeshData@CEffectMesh@@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@QAPAU12@0@Z PROC ; std::_Zero_range<CEffectMesh::SEffectMeshData * *>, COMDAT

; 1806 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1807 :     char* const _First_ch = reinterpret_cast<char*>(_To_address(_First));
; 1808 :     char* const _Last_ch  = reinterpret_cast<char*>(_To_address(_Last));
; 1809 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	51		 push	 ecx
  0000c	6a 00		 push	 0
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 _memset

; 1810 :     return _Last;

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1811 : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Zero_range@PAPAUSEffectMeshData@CEffectMesh@@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@QAPAU12@0@Z ENDP ; std::_Zero_range<CEffectMesh::SEffectMeshData * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAUSEffectMeshData@CEffectMesh@@PAPAU12@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@PAPAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAUSEffectMeshData@CEffectMesh@@PAPAU12@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@PAPAU12@00@Z PROC ; std::_Copy_memmove<CEffectMesh::SEffectMeshData * *,CEffectMesh::SEffectMeshData * *>, COMDAT

; 4159 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4160 :     auto _FirstPtr              = _To_address(_First);
; 4161 :     auto _LastPtr               = _To_address(_Last);
; 4162 :     auto _DestPtr               = _To_address(_Dest);
; 4163 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4164 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4165 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4168 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4169 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 4170 :     } else {
; 4171 :         return _Dest + (_LastPtr - _FirstPtr);
; 4172 :     }
; 4173 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PAPAUSEffectMeshData@CEffectMesh@@PAPAU12@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@PAPAU12@00@Z ENDP ; std::_Copy_memmove<CEffectMesh::SEffectMeshData * *,CEffectMesh::SEffectMeshData * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Zero_range@PAH@std@@YAPAHQAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Zero_range@PAH@std@@YAPAHQAH0@Z PROC		; std::_Zero_range<int *>, COMDAT

; 1806 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1807 :     char* const _First_ch = reinterpret_cast<char*>(_To_address(_First));
; 1808 :     char* const _Last_ch  = reinterpret_cast<char*>(_To_address(_Last));
; 1809 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	51		 push	 ecx
  0000c	6a 00		 push	 0
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 _memset

; 1810 :     return _Last;

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1811 : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Zero_range@PAH@std@@YAPAHQAH0@Z ENDP		; std::_Zero_range<int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCEffectMeshScript@@PAPAV1@@std@@YAPAPAVCEffectMeshScript@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCEffectMeshScript@@PAPAV1@@std@@YAPAPAVCEffectMeshScript@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CEffectMeshScript * *,CEffectMeshScript * *>, COMDAT

; 4159 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4160 :     auto _FirstPtr              = _To_address(_First);
; 4161 :     auto _LastPtr               = _To_address(_Last);
; 4162 :     auto _DestPtr               = _To_address(_Dest);
; 4163 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4164 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4165 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4168 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4169 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 4170 :     } else {
; 4171 :         return _Dest + (_LastPtr - _FirstPtr);
; 4172 :     }
; 4173 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PAPAVCEffectMeshScript@@PAPAV1@@std@@YAPAPAVCEffectMeshScript@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CEffectMeshScript * *,CEffectMeshScript * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
_this$1$ = -8						; size = 4
__Oldsize$1$ = -4					; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<SPTVertex,std::allocator<SPTVertex> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1229 :     _CONSTEXPR20_CONTAINER void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 1230 :         if (_Newsize > max_size()) {

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Newsize$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	89 7d f8	 mov	 DWORD PTR _this$1$[ebp], edi
  00011	81 fb cc cc cc
	0c		 cmp	 ebx, 214748364		; 0cccccccH
  00017	0f 87 44 01 00
	00		 ja	 $LN93@Resize_rea

; 1232 :         }
; 1233 : 
; 1234 :         auto& _My_data    = _Mypair._Myval2;
; 1235 :         pointer& _Myfirst = _My_data._Myfirst;
; 1236 :         pointer& _Mylast  = _My_data._Mylast;
; 1237 : 
; 1238 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  0001d	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00020	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00025	2b 0f		 sub	 ecx, DWORD PTR [edi]
  00027	f7 e9		 imul	 ecx

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00029	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0002c	2b 0f		 sub	 ecx, DWORD PTR [edi]

; 1232 :         }
; 1233 : 
; 1234 :         auto& _My_data    = _Mypair._Myval2;
; 1235 :         pointer& _Myfirst = _My_data._Myfirst;
; 1236 :         pointer& _Mylast  = _My_data._Mylast;
; 1237 : 
; 1238 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  0002e	c1 fa 03	 sar	 edx, 3
  00031	8b c2		 mov	 eax, edx
  00033	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00036	03 c2		 add	 eax, edx
  00038	89 45 fc	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0003b	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00040	f7 e9		 imul	 ecx

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00042	b8 cc cc cc 0c	 mov	 eax, 214748364		; 0cccccccH

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00047	c1 fa 03	 sar	 edx, 3
  0004a	8b ca		 mov	 ecx, edx
  0004c	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0004f	03 ca		 add	 ecx, edx

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00051	8b d1		 mov	 edx, ecx
  00053	d1 ea		 shr	 edx, 1
  00055	2b c2		 sub	 eax, edx
  00057	3b c8		 cmp	 ecx, eax
  00059	76 12		 jbe	 SHORT $LN10@Resize_rea

; 1689 :             return _Max; // geometric growth would overflow

  0005b	be f0 ff ff ff	 mov	 esi, -16		; fffffff0H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00060	56		 push	 esi
  00061	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00066	83 c4 04	 add	 esp, 4
  00069	8b d8		 mov	 ebx, eax
  0006b	eb 44		 jmp	 SHORT $LN21@Resize_rea
$LN10@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0006d	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1693 : 
; 1694 :         if (_Geometric < _Newsize) {

  00070	3b c3		 cmp	 eax, ebx
  00072	73 1d		 jae	 SHORT $LN11@Resize_rea

; 1695 :             return _Newsize; // geometric growth would be insufficient

  00074	8b c3		 mov	 eax, ebx
$LN89@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 69   :     return _Count * _Ty_size;

  00076	8d 34 80	 lea	 esi, DWORD PTR [eax+eax*4]
  00079	c1 e6 02	 shl	 esi, 2

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0007c	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  00082	72 1a		 jb	 SHORT $LN22@Resize_rea

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00084	56		 push	 esi
  00085	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0008a	83 c4 04	 add	 esp, 4
  0008d	8b d8		 mov	 ebx, eax
  0008f	eb 20		 jmp	 SHORT $LN21@Resize_rea
$LN11@Resize_rea:

; 64   :         if (_Count > _Max_possible) {

  00091	3d cc cc cc 0c	 cmp	 eax, 214748364		; 0cccccccH
  00096	0f 87 ca 00 00
	00		 ja	 $LN94@Resize_rea
  0009c	eb d8		 jmp	 SHORT $LN89@Resize_rea
$LN22@Resize_rea:

; 243  :     if (_Bytes != 0) {

  0009e	85 f6		 test	 esi, esi
  000a0	74 0d		 je	 SHORT $LN23@Resize_rea

; 85   :         return ::operator new(_Bytes);

  000a2	56		 push	 esi
  000a3	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000a8	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  000ab	8b d8		 mov	 ebx, eax
  000ad	eb 02		 jmp	 SHORT $LN21@Resize_rea
$LN23@Resize_rea:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000af	33 db		 xor	 ebx, ebx
$LN21@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1242 :         const pointer _Appended_first = _Newvec + _Oldsize;

  000b1	8b 4d fc	 mov	 ecx, DWORD PTR __Oldsize$1$[ebp]
  000b4	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  000b7	8d 14 83	 lea	 edx, DWORD PTR [ebx+eax*4]

; 1246 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  000ba	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000bd	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1830 :     for (; 0 < _Count; --_Count) {

  000bf	74 12		 je	 SHORT $LN33@Resize_rea
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1246 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  000c1	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  000c4	c1 e0 02	 shl	 eax, 2
  000c7	50		 push	 eax
  000c8	6a 00		 push	 0
  000ca	52		 push	 edx
  000cb	e8 00 00 00 00	 call	 _memset
  000d0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN33@Resize_rea:

; 1247 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  000d3	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  000d5	8b d3		 mov	 edx, ebx

; 1718 :     const auto _ULast = _Get_unwrapped(_Last);

  000d7	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 1719 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1720 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1721 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1722 :         if (!_STD is_constant_evaluated())
; 1723 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1724 :         {
; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1726 :             return _Dest + (_ULast - _UFirst);
; 1727 :         }
; 1728 :     }
; 1729 : 
; 1730 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  000da	3b c8		 cmp	 ecx, eax
  000dc	74 1e		 je	 SHORT $LN49@Resize_rea
  000de	8b f8		 mov	 edi, eax
$LL50@Resize_rea:

; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

  000e0	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]

; 1632 :         ++_Last;

  000e3	8d 52 14	 lea	 edx, DWORD PTR [edx+20]

; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

  000e6	0f 11 42 ec	 movups	 XMMWORD PTR [edx-20], xmm0
  000ea	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  000ed	83 c1 14	 add	 ecx, 20			; 00000014H

; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

  000f0	89 42 fc	 mov	 DWORD PTR [edx-4], eax

; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  000f3	3b cf		 cmp	 ecx, edi
  000f5	75 e9		 jne	 SHORT $LL50@Resize_rea
  000f7	8b 7d f8	 mov	 edi, DWORD PTR _this$1$[ebp]
  000fa	8b 0f		 mov	 ecx, DWORD PTR [edi]
$LN49@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

  000fc	85 c9		 test	 ecx, ecx
  000fe	74 3f		 je	 SHORT $LN67@Resize_rea

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00100	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00103	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00108	2b d1		 sub	 edx, ecx
  0010a	f7 ea		 imul	 edx
  0010c	c1 fa 03	 sar	 edx, 3
  0010f	8b c2		 mov	 eax, edx
  00111	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00114	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00116	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00119	c1 e0 02	 shl	 eax, 2

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0011c	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00121	72 12		 jb	 SHORT $LN77@Resize_rea

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00123	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  00126	83 c0 23	 add	 eax, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00129	2b ca		 sub	 ecx, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0012b	83 c1 fc	 add	 ecx, -4			; fffffffcH
  0012e	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  00131	77 29		 ja	 SHORT $LN74@Resize_rea

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00133	8b ca		 mov	 ecx, edx
$LN77@Resize_rea:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00135	50		 push	 eax
  00136	51		 push	 ecx
  00137	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0013c	83 c4 08	 add	 esp, 8
$LN67@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1751 :         _Mylast  = _Newvec + _Newsize;

  0013f	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00142	89 1f		 mov	 DWORD PTR [edi], ebx
  00144	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00147	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]
  0014a	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1752 :         _Myend   = _Newvec + _Newcapacity;

  0014d	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
  00150	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00153	5f		 pop	 edi
  00154	5e		 pop	 esi
  00155	5b		 pop	 ebx

; 1255 :     }

  00156	8b e5		 mov	 esp, ebp
  00158	5d		 pop	 ebp
  00159	c2 08 00	 ret	 8
$LN74@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0015c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN93@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1231 :             _Xlength();

  00161	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@CAXXZ ; std::vector<SPTVertex,std::allocator<SPTVertex> >::_Xlength
$LN94@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  00166	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN91@Resize_rea:
  0016b	cc		 int	 3
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<SPTVertex,std::allocator<SPTVertex> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
_this$1$ = -12						; size = 4
__Newcapacity$1$ = -8					; size = 4
$T2 = -4						; size = 4
__Newsize$ = 8						; size = 4
__Last$1$ = 12						; size = 4
__ULast$1$ = 12						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1229 :     _CONSTEXPR20_CONTAINER void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1230 :         if (_Newsize > max_size()) {

  00009	8b 7d 08	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000c	8b d9		 mov	 ebx, ecx
  0000e	89 5d f4	 mov	 DWORD PTR _this$1$[ebp], ebx
  00011	81 ff ff ff ff
	07		 cmp	 edi, 134217727		; 07ffffffH
  00017	0f 87 78 01 00
	00		 ja	 $LN128@Resize_rea

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0001d	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00020	b8 ff ff ff 07	 mov	 eax, 134217727		; 07ffffffH

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00025	2b 0b		 sub	 ecx, DWORD PTR [ebx]

; 1232 :         }
; 1233 : 
; 1234 :         auto& _My_data    = _Mypair._Myval2;
; 1235 :         pointer& _Myfirst = _My_data._Myfirst;
; 1236 :         pointer& _Mylast  = _My_data._Mylast;
; 1237 : 
; 1238 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  00027	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  0002a	2b 33		 sub	 esi, DWORD PTR [ebx]

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002c	c1 f9 05	 sar	 ecx, 5

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0002f	8b d1		 mov	 edx, ecx

; 1232 :         }
; 1233 : 
; 1234 :         auto& _My_data    = _Mypair._Myval2;
; 1235 :         pointer& _Myfirst = _My_data._Myfirst;
; 1236 :         pointer& _Mylast  = _My_data._Mylast;
; 1237 : 
; 1238 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  00031	c1 fe 05	 sar	 esi, 5

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00034	d1 ea		 shr	 edx, 1
  00036	2b c2		 sub	 eax, edx
  00038	3b c8		 cmp	 ecx, eax
  0003a	76 15		 jbe	 SHORT $LN10@Resize_rea

; 1689 :             return _Max; // geometric growth would overflow

  0003c	b8 e0 ff ff ff	 mov	 eax, -32		; ffffffe0H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00041	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1689 :             return _Max; // geometric growth would overflow

  00042	89 45 f8	 mov	 DWORD PTR __Newcapacity$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00045	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0004a	83 c4 04	 add	 esp, 4
  0004d	8b c8		 mov	 ecx, eax
  0004f	eb 46		 jmp	 SHORT $LN126@Resize_rea
$LN10@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00051	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1693 : 
; 1694 :         if (_Geometric < _Newsize) {

  00054	3b c7		 cmp	 eax, edi
  00056	73 1c		 jae	 SHORT $LN11@Resize_rea

; 1695 :             return _Newsize; // geometric growth would be insufficient

  00058	8b c7		 mov	 eax, edi
$LN123@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 69   :     return _Count * _Ty_size;

  0005a	c1 e0 05	 shl	 eax, 5
  0005d	89 45 f8	 mov	 DWORD PTR __Newcapacity$1$[ebp], eax

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00060	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00065	72 1a		 jb	 SHORT $LN22@Resize_rea

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0006d	83 c4 04	 add	 esp, 4
  00070	8b c8		 mov	 ecx, eax
  00072	eb 23		 jmp	 SHORT $LN126@Resize_rea
$LN11@Resize_rea:

; 64   :         if (_Count > _Max_possible) {

  00074	3d ff ff ff 07	 cmp	 eax, 134217727		; 07ffffffH
  00079	0f 87 1b 01 00
	00		 ja	 $LN129@Resize_rea
  0007f	eb d9		 jmp	 SHORT $LN123@Resize_rea
$LN22@Resize_rea:

; 243  :     if (_Bytes != 0) {

  00081	85 c0		 test	 eax, eax
  00083	74 10		 je	 SHORT $LN23@Resize_rea

; 85   :         return ::operator new(_Bytes);

  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0008b	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  0008e	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
  00091	8b c8		 mov	 ecx, eax
  00093	eb 05		 jmp	 SHORT $LN21@Resize_rea
$LN23@Resize_rea:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  00095	33 c9		 xor	 ecx, ecx
$LN126@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1246 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  00097	89 4d fc	 mov	 DWORD PTR $T2[ebp], ecx
$LN21@Resize_rea:
  0009a	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0009d	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  000a0	50		 push	 eax
  000a1	8b c7		 mov	 eax, edi
  000a3	2b c6		 sub	 eax, esi
  000a5	c1 e6 05	 shl	 esi, 5
  000a8	03 f1		 add	 esi, ecx
  000aa	8b cb		 mov	 ecx, ebx
  000ac	50		 push	 eax
  000ad	56		 push	 esi
  000ae	e8 00 00 00 00	 call	 ?_Ufill@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@AAEPAUSEffectFrameData@CEffectMesh@@PAU34@IU_Value_init_tag@2@@Z ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::_Ufill
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1718 :     const auto _ULast = _Get_unwrapped(_Last);

  000b3	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1247 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  000b6	8b 33		 mov	 esi, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1718 :     const auto _ULast = _Get_unwrapped(_Last);

  000b8	89 45 0c	 mov	 DWORD PTR __ULast$1$[ebp], eax

; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  000bb	3b f0		 cmp	 esi, eax
  000bd	74 63		 je	 SHORT $LN34@Resize_rea
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1246 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  000bf	8b 5d fc	 mov	 ebx, DWORD PTR $T2[ebp]
  000c2	8d 7e 18	 lea	 edi, DWORD PTR [esi+24]
  000c5	83 c3 1c	 add	 ebx, 28			; 0000001cH
$LL35@Resize_rea:
  000c8	8a 06		 mov	 al, BYTE PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1632 :         ++_Last;

  000ca	8d 5b 20	 lea	 ebx, DWORD PTR [ebx+32]
  000cd	88 43 c4	 mov	 BYTE PTR [ebx-60], al

; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  000d0	8d 7f 20	 lea	 edi, DWORD PTR [edi+32]
  000d3	8b 47 cc	 mov	 eax, DWORD PTR [edi-52]
  000d6	83 c6 20	 add	 esi, 32			; 00000020H
  000d9	89 43 c8	 mov	 DWORD PTR [ebx-56], eax
  000dc	8b 47 d0	 mov	 eax, DWORD PTR [edi-48]
  000df	89 43 cc	 mov	 DWORD PTR [ebx-52], eax
  000e2	8b 47 d4	 mov	 eax, DWORD PTR [edi-44]
  000e5	89 43 d0	 mov	 DWORD PTR [ebx-48], eax
  000e8	8b 47 d8	 mov	 eax, DWORD PTR [edi-40]
  000eb	89 43 d4	 mov	 DWORD PTR [ebx-44], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 616  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  000ee	8b 57 e4	 mov	 edx, DWORD PTR [edi-28]
  000f1	8b 4f e0	 mov	 ecx, DWORD PTR [edi-32]
  000f4	8b 47 dc	 mov	 eax, DWORD PTR [edi-36]

; 617  :     _Val         = static_cast<_Other&&>(_New_val);

  000f7	c7 47 e4 00 00
	00 00		 mov	 DWORD PTR [edi-28], 0
  000fe	c7 47 e0 00 00
	00 00		 mov	 DWORD PTR [edi-32], 0
  00105	c7 47 dc 00 00
	00 00		 mov	 DWORD PTR [edi-36], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 404  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  0010c	89 43 d8	 mov	 DWORD PTR [ebx-40], eax
  0010f	89 4b dc	 mov	 DWORD PTR [ebx-36], ecx
  00112	89 53 e0	 mov	 DWORD PTR [ebx-32], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  00115	3b 75 0c	 cmp	 esi, DWORD PTR __ULast$1$[ebp]
  00118	75 ae		 jne	 SHORT $LL35@Resize_rea
  0011a	8b 5d f4	 mov	 ebx, DWORD PTR _this$1$[ebp]
  0011d	8b 7d 08	 mov	 edi, DWORD PTR __Newsize$[ebp]
  00120	8b 33		 mov	 esi, DWORD PTR [ebx]
$LN34@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

  00122	85 f6		 test	 esi, esi
  00124	74 4c		 je	 SHORT $LN97@Resize_rea

; 1746 :             _Destroy(_Myfirst, _Mylast);

  00126	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00129	89 45 0c	 mov	 DWORD PTR __Last$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 949  :         for (; _First != _Last; ++_First) {

  0012c	3b f0		 cmp	 esi, eax
  0012e	74 16		 je	 SHORT $LN82@Resize_rea
  00130	8b f8		 mov	 edi, eax
$LL83@Resize_rea:
  00132	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  00135	e8 00 00 00 00	 call	 ??1?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@QAE@XZ ; std::vector<SPTVertex,std::allocator<SPTVertex> >::~vector<SPTVertex,std::allocator<SPTVertex> >
  0013a	83 c6 20	 add	 esi, 32			; 00000020H
  0013d	3b f7		 cmp	 esi, edi
  0013f	75 f1		 jne	 SHORT $LL83@Resize_rea
  00141	8b 33		 mov	 esi, DWORD PTR [ebx]
  00143	8b 7d 08	 mov	 edi, DWORD PTR __Newsize$[ebp]
$LN82@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00146	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00149	2b ce		 sub	 ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0014b	83 e1 e0	 and	 ecx, -32		; ffffffe0H

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0014e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00154	72 12		 jb	 SHORT $LN107@Resize_rea

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00156	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  00159	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0015c	2b f2		 sub	 esi, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0015e	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  00161	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00164	77 2a		 ja	 SHORT $LN104@Resize_rea

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00166	8b f2		 mov	 esi, edx
$LN107@Resize_rea:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00168	51		 push	 ecx
  00169	56		 push	 esi
  0016a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0016f	83 c4 08	 add	 esp, 8
$LN97@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         _Myfirst = _Newvec;

  00172	8b 4d fc	 mov	 ecx, DWORD PTR $T2[ebp]

; 1751 :         _Mylast  = _Newvec + _Newsize;
; 1752 :         _Myend   = _Newvec + _Newcapacity;

  00175	8b 45 f8	 mov	 eax, DWORD PTR __Newcapacity$1$[ebp]
  00178	c1 e7 05	 shl	 edi, 5
  0017b	03 f9		 add	 edi, ecx
  0017d	89 0b		 mov	 DWORD PTR [ebx], ecx
  0017f	89 7b 04	 mov	 DWORD PTR [ebx+4], edi
  00182	03 c1		 add	 eax, ecx
  00184	5f		 pop	 edi
  00185	5e		 pop	 esi
  00186	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00189	5b		 pop	 ebx

; 1255 :     }

  0018a	8b e5		 mov	 esp, ebp
  0018c	5d		 pop	 ebp
  0018d	c2 08 00	 ret	 8
$LN104@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00190	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN128@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1231 :             _Xlength();

  00195	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@CAXXZ ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::_Xlength
$LN129@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  0019a	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN125@Resize_rea:
  0019f	cc		 int	 3
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Oldsize$1$ = 8					; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1229 :     _CONSTEXPR20_CONTAINER void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 1230 :         if (_Newsize > max_size()) {

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000a	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000d	81 ff ff ff ff
	3f		 cmp	 edi, 1073741823		; 3fffffffH
  00013	0f 87 b5 00 00
	00		 ja	 $LN61@Resize_rea

; 1232 :         }
; 1233 : 
; 1234 :         auto& _My_data    = _Mypair._Myval2;
; 1235 :         pointer& _Myfirst = _My_data._Myfirst;
; 1236 :         pointer& _Mylast  = _My_data._Mylast;
; 1237 : 
; 1238 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  00019	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0001e	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 1232 :         }
; 1233 : 
; 1234 :         auto& _My_data    = _Mypair._Myval2;
; 1235 :         pointer& _Myfirst = _My_data._Myfirst;
; 1236 :         pointer& _Mylast  = _My_data._Mylast;
; 1237 : 
; 1238 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  00021	2b d0		 sub	 edx, eax

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00023	2b c8		 sub	 ecx, eax

; 1232 :         }
; 1233 : 
; 1234 :         auto& _My_data    = _Mypair._Myval2;
; 1235 :         pointer& _Myfirst = _My_data._Myfirst;
; 1236 :         pointer& _Mylast  = _My_data._Mylast;
; 1237 : 
; 1238 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  00025	c1 fa 02	 sar	 edx, 2

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00028	c1 f9 02	 sar	 ecx, 2

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0002b	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1232 :         }
; 1233 : 
; 1234 :         auto& _My_data    = _Mypair._Myval2;
; 1235 :         pointer& _Myfirst = _My_data._Myfirst;
; 1236 :         pointer& _Mylast  = _My_data._Mylast;
; 1237 : 
; 1238 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  00030	89 55 08	 mov	 DWORD PTR __Oldsize$1$[ebp], edx

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00033	8b d1		 mov	 edx, ecx
  00035	d1 ea		 shr	 edx, 1
  00037	2b c2		 sub	 eax, edx
  00039	3b c8		 cmp	 ecx, eax
  0003b	76 17		 jbe	 SHORT $LN10@Resize_rea

; 1689 :             return _Max; // geometric growth would overflow

  0003d	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00042	be ff ff ff 3f	 mov	 esi, 1073741823		; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0004d	83 c4 04	 add	 esp, 4
  00050	8b d8		 mov	 ebx, eax
  00052	eb 41		 jmp	 SHORT $LN21@Resize_rea
$LN10@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00054	8d 34 0a	 lea	 esi, DWORD PTR [edx+ecx]

; 1693 : 
; 1694 :         if (_Geometric < _Newsize) {

  00057	3b f7		 cmp	 esi, edi
  00059	73 1d		 jae	 SHORT $LN11@Resize_rea

; 1695 :             return _Newsize; // geometric growth would be insufficient

  0005b	8b f7		 mov	 esi, edi
$LN18@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 69   :     return _Count * _Ty_size;

  0005d	8d 04 b5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*4]

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00064	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00069	72 17		 jb	 SHORT $LN22@Resize_rea

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00071	83 c4 04	 add	 esp, 4
  00074	8b d8		 mov	 ebx, eax
  00076	eb 1d		 jmp	 SHORT $LN21@Resize_rea
$LN11@Resize_rea:

; 64   :         if (_Count > _Max_possible) {

  00078	81 fe ff ff ff
	3f		 cmp	 esi, 1073741823		; 3fffffffH
  0007e	77 53		 ja	 SHORT $LN62@Resize_rea
  00080	eb db		 jmp	 SHORT $LN18@Resize_rea
$LN22@Resize_rea:

; 243  :     if (_Bytes != 0) {

  00082	85 c0		 test	 eax, eax
  00084	74 0d		 je	 SHORT $LN23@Resize_rea

; 85   :         return ::operator new(_Bytes);

  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0008c	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  0008f	8b d8		 mov	 ebx, eax
  00091	eb 02		 jmp	 SHORT $LN21@Resize_rea
$LN23@Resize_rea:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  00093	33 db		 xor	 ebx, ebx
$LN21@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1242 :         const pointer _Appended_first = _Newvec + _Oldsize;

  00095	8b 55 08	 mov	 edx, DWORD PTR __Oldsize$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1824 :             _Zero_range(_PFirst, _PFirst + _Count);

  00098	8b c7		 mov	 eax, edi
  0009a	2b c2		 sub	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1242 :         const pointer _Appended_first = _Newvec + _Oldsize;

  0009c	8d 0c 93	 lea	 ecx, DWORD PTR [ebx+edx*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1824 :             _Zero_range(_PFirst, _PFirst + _Count);

  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	50		 push	 eax
  000a3	51		 push	 ecx
  000a4	e8 00 00 00 00	 call	 ??$_Zero_range@PAPAUSEffectMeshData@CEffectMesh@@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@QAPAU12@0@Z ; std::_Zero_range<CEffectMesh::SEffectMeshData * *>

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000a9	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  000ac	53		 push	 ebx
  000ad	ff 70 04	 push	 DWORD PTR [eax+4]
  000b0	ff 30		 push	 DWORD PTR [eax]
  000b2	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAUSEffectMeshData@CEffectMesh@@PAPAU12@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@PAPAU12@00@Z ; std::_Copy_memmove<CEffectMesh::SEffectMeshData * *,CEffectMesh::SEffectMeshData * *>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1254 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  000b7	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000ba	83 c4 14	 add	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1254 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  000bd	56		 push	 esi
  000be	57		 push	 edi
  000bf	53		 push	 ebx
  000c0	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@AAEXQAPAUSEffectMeshData@CEffectMesh@@II@Z ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Change_array
  000c5	5f		 pop	 edi
  000c6	5e		 pop	 esi
  000c7	5b		 pop	 ebx

; 1255 :     }

  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c2 08 00	 ret	 8
$LN61@Resize_rea:

; 1231 :             _Xlength();

  000ce	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@CAXXZ ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Xlength
$LN62@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  000d3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN59@Resize_rea:
  000d8	cc		 int	 3
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
_this$1$ = -20						; size = 4
__ULast$1$ = -16					; size = 4
__Oldsize$1$ = -12					; size = 4
tv1387 = -8						; size = 4
$T2 = -4						; size = 4
__Newsize$ = 8						; size = 4
__Backout$1$sroa$296$1$ = 12				; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1229 :     _CONSTEXPR20_CONTAINER void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1230 :         if (_Newsize > max_size()) {

  00009	8b 7d 08	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000c	8b d9		 mov	 ebx, ecx
  0000e	89 5d ec	 mov	 DWORD PTR _this$1$[ebp], ebx
  00011	81 ff 44 44 44
	04		 cmp	 edi, 71582788		; 04444444H
  00017	0f 87 f9 01 00
	00		 ja	 $LN95@Resize_rea

; 1232 :         }
; 1233 : 
; 1234 :         auto& _My_data    = _Mypair._Myval2;
; 1235 :         pointer& _Myfirst = _My_data._Myfirst;
; 1236 :         pointer& _Mylast  = _My_data._Mylast;
; 1237 : 
; 1238 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  0001d	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00020	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  00025	2b 0b		 sub	 ecx, DWORD PTR [ebx]
  00027	f7 e9		 imul	 ecx
  00029	03 d1		 add	 edx, ecx

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002b	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0002e	2b 0b		 sub	 ecx, DWORD PTR [ebx]

; 1232 :         }
; 1233 : 
; 1234 :         auto& _My_data    = _Mypair._Myval2;
; 1235 :         pointer& _Myfirst = _My_data._Myfirst;
; 1236 :         pointer& _Mylast  = _My_data._Mylast;
; 1237 : 
; 1238 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  00030	c1 fa 05	 sar	 edx, 5
  00033	8b c2		 mov	 eax, edx
  00035	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00038	03 c2		 add	 eax, edx
  0003a	89 45 f4	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0003d	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  00042	f7 e9		 imul	 ecx

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00044	b8 44 44 44 04	 mov	 eax, 71582788		; 04444444H

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00049	03 d1		 add	 edx, ecx
  0004b	c1 fa 05	 sar	 edx, 5
  0004e	8b ca		 mov	 ecx, edx
  00050	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00053	03 ca		 add	 ecx, edx

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00055	8b d1		 mov	 edx, ecx
  00057	d1 ea		 shr	 edx, 1
  00059	2b c2		 sub	 eax, edx
  0005b	3b c8		 cmp	 ecx, eax
  0005d	76 15		 jbe	 SHORT $LN10@Resize_rea

; 1689 :             return _Max; // geometric growth would overflow

  0005f	bf f0 ff ff ff	 mov	 edi, -16		; fffffff0H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00064	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1689 :             return _Max; // geometric growth would overflow

  00065	89 7d f8	 mov	 DWORD PTR tv1387[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00068	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0006d	83 c4 04	 add	 esp, 4
  00070	8b f0		 mov	 esi, eax
  00072	eb 4e		 jmp	 SHORT $LN93@Resize_rea
$LN10@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00074	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1693 : 
; 1694 :         if (_Geometric < _Newsize) {

  00077	3b c7		 cmp	 eax, edi
  00079	73 24		 jae	 SHORT $LN11@Resize_rea

; 1695 :             return _Newsize; // geometric growth would be insufficient

  0007b	8b c7		 mov	 eax, edi
$LN89@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 69   :     return _Count * _Ty_size;

  0007d	8b f8		 mov	 edi, eax
  0007f	c1 e7 04	 shl	 edi, 4
  00082	2b f8		 sub	 edi, eax
  00084	c1 e7 02	 shl	 edi, 2
  00087	89 7d f8	 mov	 DWORD PTR tv1387[ebp], edi

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0008a	81 ff 00 10 00
	00		 cmp	 edi, 4096		; 00001000H
  00090	72 1a		 jb	 SHORT $LN22@Resize_rea

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00092	57		 push	 edi
  00093	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00098	83 c4 04	 add	 esp, 4
  0009b	8b f0		 mov	 esi, eax
  0009d	eb 23		 jmp	 SHORT $LN93@Resize_rea
$LN11@Resize_rea:

; 64   :         if (_Count > _Max_possible) {

  0009f	3d 44 44 44 04	 cmp	 eax, 71582788		; 04444444H
  000a4	0f 87 71 01 00
	00		 ja	 $LN96@Resize_rea
  000aa	eb d1		 jmp	 SHORT $LN89@Resize_rea
$LN22@Resize_rea:

; 243  :     if (_Bytes != 0) {

  000ac	85 ff		 test	 edi, edi
  000ae	74 10		 je	 SHORT $LN23@Resize_rea

; 85   :         return ::operator new(_Bytes);

  000b0	57		 push	 edi
  000b1	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000b6	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  000b9	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
  000bc	8b f0		 mov	 esi, eax
  000be	eb 05		 jmp	 SHORT $LN21@Resize_rea
$LN23@Resize_rea:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000c0	33 f6		 xor	 esi, esi
$LN93@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1246 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  000c2	89 75 fc	 mov	 DWORD PTR $T2[ebp], esi
$LN21@Resize_rea:
  000c5	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  000c8	8b 4d f4	 mov	 ecx, DWORD PTR __Oldsize$1$[ebp]
  000cb	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  000ce	50		 push	 eax
  000cf	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000d2	2b c1		 sub	 eax, ecx
  000d4	50		 push	 eax
  000d5	8b c1		 mov	 eax, ecx
  000d7	c1 e0 04	 shl	 eax, 4
  000da	2b c1		 sub	 eax, ecx
  000dc	8b cb		 mov	 ecx, ebx
  000de	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 ?_Ufill@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@AAEPAUSMeshData@CEffectMeshScript@@PAU34@IU_Value_init_tag@2@@Z ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::_Ufill
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1718 :     const auto _ULast = _Get_unwrapped(_Last);

  000e7	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  000ea	8b ce		 mov	 ecx, esi

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000ec	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1718 :     const auto _ULast = _Get_unwrapped(_Last);

  000ee	89 55 f0	 mov	 DWORD PTR __ULast$1$[ebp], edx

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  000f1	89 4d 0c	 mov	 DWORD PTR __Backout$1$sroa$296$1$[ebp], ecx

; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  000f4	3b c2		 cmp	 eax, edx
  000f6	0f 84 8f 00 00
	00		 je	 $LN34@Resize_rea
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1246 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  000fc	8b f8		 mov	 edi, eax
  000fe	8d 5e 38	 lea	 ebx, DWORD PTR [esi+56]
  00101	8d 77 34	 lea	 esi, DWORD PTR [edi+52]
$LL35@Resize_rea:
  00104	0f b6 07	 movzx	 eax, BYTE PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1632 :         ++_Last;

  00107	8d 5b 3c	 lea	 ebx, DWORD PTR [ebx+60]
  0010a	88 01		 mov	 BYTE PTR [ecx], al

; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  0010c	8d 76 3c	 lea	 esi, DWORD PTR [esi+60]
  0010f	8b 46 94	 mov	 eax, DWORD PTR [esi-108]
  00112	83 c7 3c	 add	 edi, 60			; 0000003cH
  00115	89 43 90	 mov	 DWORD PTR [ebx-112], eax
  00118	0f b6 46 98	 movzx	 eax, BYTE PTR [esi-104]
  0011c	88 43 94	 mov	 BYTE PTR [ebx-108], al
  0011f	0f b6 46 99	 movzx	 eax, BYTE PTR [esi-103]
  00123	88 43 95	 mov	 BYTE PTR [ebx-107], al
  00126	8b 46 9c	 mov	 eax, DWORD PTR [esi-100]
  00129	89 43 98	 mov	 DWORD PTR [ebx-104], eax
  0012c	0f b6 46 a0	 movzx	 eax, BYTE PTR [esi-96]
  00130	88 43 9c	 mov	 BYTE PTR [ebx-100], al
  00133	0f 10 46 a4	 movups	 xmm0, XMMWORD PTR [esi-92]
  00137	0f 11 43 a0	 movups	 XMMWORD PTR [ebx-96], xmm0
  0013b	8b 46 b4	 mov	 eax, DWORD PTR [esi-76]
  0013e	89 43 b0	 mov	 DWORD PTR [ebx-80], eax
  00141	8b 46 b8	 mov	 eax, DWORD PTR [esi-72]
  00144	89 43 b4	 mov	 DWORD PTR [ebx-76], eax
  00147	8b 46 bc	 mov	 eax, DWORD PTR [esi-68]
  0014a	89 43 b8	 mov	 DWORD PTR [ebx-72], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 616  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0014d	8b 4e c4	 mov	 ecx, DWORD PTR [esi-60]
  00150	8b 56 c8	 mov	 edx, DWORD PTR [esi-56]
  00153	8b 46 c0	 mov	 eax, DWORD PTR [esi-64]

; 617  :     _Val         = static_cast<_Other&&>(_New_val);

  00156	c7 46 c8 00 00
	00 00		 mov	 DWORD PTR [esi-56], 0
  0015d	c7 46 c4 00 00
	00 00		 mov	 DWORD PTR [esi-60], 0
  00164	c7 46 c0 00 00
	00 00		 mov	 DWORD PTR [esi-64], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 404  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  0016b	89 4b c0	 mov	 DWORD PTR [ebx-64], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1632 :         ++_Last;

  0016e	8b 4d 0c	 mov	 ecx, DWORD PTR __Backout$1$sroa$296$1$[ebp]
  00171	83 c1 3c	 add	 ecx, 60			; 0000003cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 404  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  00174	89 43 bc	 mov	 DWORD PTR [ebx-68], eax
  00177	89 53 c4	 mov	 DWORD PTR [ebx-60], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1632 :         ++_Last;

  0017a	89 4d 0c	 mov	 DWORD PTR __Backout$1$sroa$296$1$[ebp], ecx

; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  0017d	3b 7d f0	 cmp	 edi, DWORD PTR __ULast$1$[ebp]
  00180	75 82		 jne	 SHORT $LL35@Resize_rea
  00182	8b 7d f8	 mov	 edi, DWORD PTR tv1387[ebp]
  00185	8b 5d ec	 mov	 ebx, DWORD PTR _this$1$[ebp]
  00188	8b 75 fc	 mov	 esi, DWORD PTR $T2[ebp]
$LN34@Resize_rea:

; 1626 :         _Destroy_range(_First, _Last, _Al);

  0018b	53		 push	 ebx
  0018c	51		 push	 ecx
  0018d	51		 push	 ecx
  0018e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAXPAUSMeshData@CEffectMeshScript@@QAU12@AAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshScript::SMeshData> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

  00193	8b 0b		 mov	 ecx, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1626 :         _Destroy_range(_First, _Last, _Al);

  00195	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

  00198	85 c9		 test	 ecx, ecx
  0019a	74 55		 je	 SHORT $LN71@Resize_rea

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  0019c	53		 push	 ebx
  0019d	ff 73 04	 push	 DWORD PTR [ebx+4]
  001a0	51		 push	 ecx
  001a1	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAXPAUSMeshData@CEffectMeshScript@@QAU12@AAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshScript::SMeshData> >

; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  001a6	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  001a9	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  001ae	2b 0b		 sub	 ecx, DWORD PTR [ebx]

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  001b0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  001b3	f7 e9		 imul	 ecx
  001b5	03 d1		 add	 edx, ecx
  001b7	c1 fa 05	 sar	 edx, 5
  001ba	8b c2		 mov	 eax, edx
  001bc	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001bf	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001c1	8b c8		 mov	 ecx, eax
  001c3	c1 e1 04	 shl	 ecx, 4
  001c6	2b c8		 sub	 ecx, eax

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  001c8	8b 03		 mov	 eax, DWORD PTR [ebx]

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001ca	c1 e1 02	 shl	 ecx, 2

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  001cd	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  001d3	72 12		 jb	 SHORT $LN81@Resize_rea

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001d5	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  001d8	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  001db	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001dd	83 c0 fc	 add	 eax, -4			; fffffffcH
  001e0	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001e3	77 2c		 ja	 SHORT $LN78@Resize_rea

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  001e5	8b c2		 mov	 eax, edx
$LN81@Resize_rea:

; 264  :         ::operator delete(_Ptr, _Bytes);

  001e7	51		 push	 ecx
  001e8	50		 push	 eax
  001e9	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001ee	83 c4 08	 add	 esp, 8
$LN71@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1751 :         _Mylast  = _Newvec + _Newsize;

  001f1	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  001f4	c1 e0 04	 shl	 eax, 4
  001f7	2b 45 08	 sub	 eax, DWORD PTR __Newsize$[ebp]
  001fa	89 33		 mov	 DWORD PTR [ebx], esi
  001fc	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  001ff	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 1752 :         _Myend   = _Newvec + _Newcapacity;

  00202	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  00205	5f		 pop	 edi
  00206	5e		 pop	 esi
  00207	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  0020a	5b		 pop	 ebx

; 1255 :     }

  0020b	8b e5		 mov	 esp, ebp
  0020d	5d		 pop	 ebp
  0020e	c2 08 00	 ret	 8
$LN78@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00211	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN95@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1231 :             _Xlength();

  00216	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@CAXXZ ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::_Xlength
$LN96@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  0021b	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN92@Resize_rea:
  00220	cc		 int	 3
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
$T2 = -4						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1229 :     _CONSTEXPR20_CONTAINER void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 1230 :         if (_Newsize > max_size()) {

  00008	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]
  0000b	8b d9		 mov	 ebx, ecx
  0000d	57		 push	 edi
  0000e	81 fe 55 55 55
	15		 cmp	 esi, 357913941		; 15555555H
  00014	0f 87 1c 01 00
	00		 ja	 $LN92@Resize_rea

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0001a	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0001d	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00022	2b 0b		 sub	 ecx, DWORD PTR [ebx]
  00024	f7 e9		 imul	 ecx

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00026	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002b	d1 fa		 sar	 edx, 1
  0002d	8b ca		 mov	 ecx, edx
  0002f	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00032	03 ca		 add	 ecx, edx

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00034	8b d1		 mov	 edx, ecx
  00036	d1 ea		 shr	 edx, 1
  00038	2b c2		 sub	 eax, edx
  0003a	3b c8		 cmp	 ecx, eax
  0003c	76 12		 jbe	 SHORT $LN10@Resize_rea

; 1689 :             return _Max; // geometric growth would overflow

  0003e	bf fc ff ff ff	 mov	 edi, -4			; fffffffcH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00043	57		 push	 edi
  00044	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00049	83 c4 04	 add	 esp, 4
  0004c	8b d0		 mov	 edx, eax
  0004e	eb 47		 jmp	 SHORT $LN90@Resize_rea
$LN10@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00050	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1693 : 
; 1694 :         if (_Geometric < _Newsize) {

  00053	3b c6		 cmp	 eax, esi
  00055	73 1d		 jae	 SHORT $LN11@Resize_rea

; 1695 :             return _Newsize; // geometric growth would be insufficient

  00057	8b c6		 mov	 eax, esi
$LN87@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 69   :     return _Count * _Ty_size;

  00059	8d 3c 40	 lea	 edi, DWORD PTR [eax+eax*2]
  0005c	c1 e7 02	 shl	 edi, 2

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0005f	81 ff 00 10 00
	00		 cmp	 edi, 4096		; 00001000H
  00065	72 1a		 jb	 SHORT $LN22@Resize_rea

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00067	57		 push	 edi
  00068	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0006d	83 c4 04	 add	 esp, 4
  00070	8b d0		 mov	 edx, eax
  00072	eb 23		 jmp	 SHORT $LN90@Resize_rea
$LN11@Resize_rea:

; 64   :         if (_Count > _Max_possible) {

  00074	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  00079	0f 87 bc 00 00
	00		 ja	 $LN93@Resize_rea
  0007f	eb d8		 jmp	 SHORT $LN87@Resize_rea
$LN22@Resize_rea:

; 243  :     if (_Bytes != 0) {

  00081	85 ff		 test	 edi, edi
  00083	74 10		 je	 SHORT $LN23@Resize_rea

; 85   :         return ::operator new(_Bytes);

  00085	57		 push	 edi
  00086	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0008b	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  0008e	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
  00091	8b d0		 mov	 edx, eax
  00093	eb 05		 jmp	 SHORT $LN21@Resize_rea
$LN23@Resize_rea:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  00095	33 d2		 xor	 edx, edx
$LN90@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1247 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00097	89 55 fc	 mov	 DWORD PTR $T2[ebp], edx
$LN21@Resize_rea:
  0009a	8b 33		 mov	 esi, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  0009c	8b ca		 mov	 ecx, edx

; 1718 :     const auto _ULast = _Get_unwrapped(_Last);

  0009e	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]

; 1719 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1720 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1721 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1722 :         if (!_STD is_constant_evaluated())
; 1723 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1724 :         {
; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1726 :             return _Dest + (_ULast - _UFirst);
; 1727 :         }
; 1728 :     }
; 1729 : 
; 1730 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  000a1	3b f0		 cmp	 esi, eax
  000a3	74 29		 je	 SHORT $LN47@Resize_rea
  000a5	8b d0		 mov	 edx, eax
  000a7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL48@Resize_rea:

; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

  000b0	f3 0f 7e 06	 movq	 xmm0, QWORD PTR [esi]

; 1632 :         ++_Last;

  000b4	8d 49 0c	 lea	 ecx, DWORD PTR [ecx+12]

; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

  000b7	66 0f d6 41 f4	 movq	 QWORD PTR [ecx-12], xmm0
  000bc	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  000bf	83 c6 0c	 add	 esi, 12			; 0000000cH

; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

  000c2	89 41 fc	 mov	 DWORD PTR [ecx-4], eax

; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  000c5	3b f2		 cmp	 esi, edx
  000c7	75 e7		 jne	 SHORT $LL48@Resize_rea
  000c9	8b 33		 mov	 esi, DWORD PTR [ebx]
  000cb	8b 55 fc	 mov	 edx, DWORD PTR $T2[ebp]
$LN47@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

  000ce	85 f6		 test	 esi, esi
  000d0	74 42		 je	 SHORT $LN65@Resize_rea

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000d2	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  000d5	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  000da	2b ce		 sub	 ecx, esi
  000dc	f7 e9		 imul	 ecx
  000de	d1 fa		 sar	 edx, 1
  000e0	8b c2		 mov	 eax, edx
  000e2	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000e5	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e7	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  000ea	c1 e1 02	 shl	 ecx, 2

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000ed	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000f3	72 12		 jb	 SHORT $LN75@Resize_rea

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f5	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  000f8	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000fb	2b f2		 sub	 esi, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000fd	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  00100	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00103	77 2c		 ja	 SHORT $LN72@Resize_rea

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00105	8b f2		 mov	 esi, edx
$LN75@Resize_rea:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00107	51		 push	 ecx
  00108	56		 push	 esi
  00109	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0010e	8b 55 fc	 mov	 edx, DWORD PTR $T2[ebp]
  00111	83 c4 08	 add	 esp, 8
$LN65@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1751 :         _Mylast  = _Newvec + _Newsize;

  00114	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00117	89 13		 mov	 DWORD PTR [ebx], edx
  00119	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0011c	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  0011f	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 1752 :         _Myend   = _Newvec + _Newcapacity;

  00122	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  00125	5f		 pop	 edi
  00126	5e		 pop	 esi
  00127	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  0012a	5b		 pop	 ebx

; 1255 :     }

  0012b	8b e5		 mov	 esp, ebp
  0012d	5d		 pop	 ebp
  0012e	c2 08 00	 ret	 8
$LN72@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00131	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN92@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1231 :             _Xlength();

  00136	e8 00 00 00 00	 call	 ?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlength
$LN93@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  0013b	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN89@Resize_rea:
  00140	cc		 int	 3
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Oldsize$1$ = -4					; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<int,std::allocator<int> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1229 :     _CONSTEXPR20_CONTAINER void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 1230 :         if (_Newsize > max_size()) {

  00005	8b 5d 08	 mov	 ebx, DWORD PTR __Newsize$[ebp]
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	57		 push	 edi
  0000c	81 fb ff ff ff
	3f		 cmp	 ebx, 1073741823		; 3fffffffH
  00012	0f 87 ea 00 00
	00		 ja	 $LN82@Resize_rea

; 1232 :         }
; 1233 : 
; 1234 :         auto& _My_data    = _Mypair._Myval2;
; 1235 :         pointer& _Myfirst = _My_data._Myfirst;
; 1236 :         pointer& _Mylast  = _My_data._Mylast;
; 1237 : 
; 1238 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  00018	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0001b	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1232 :         }
; 1233 : 
; 1234 :         auto& _My_data    = _Mypair._Myval2;
; 1235 :         pointer& _Myfirst = _My_data._Myfirst;
; 1236 :         pointer& _Mylast  = _My_data._Mylast;
; 1237 : 
; 1238 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  00020	2b 0e		 sub	 ecx, DWORD PTR [esi]
  00022	c1 f9 02	 sar	 ecx, 2
  00025	89 4d fc	 mov	 DWORD PTR __Oldsize$1$[ebp], ecx

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00028	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0002b	2b 0e		 sub	 ecx, DWORD PTR [esi]
  0002d	c1 f9 02	 sar	 ecx, 2

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00030	8b d1		 mov	 edx, ecx
  00032	d1 ea		 shr	 edx, 1
  00034	2b c2		 sub	 eax, edx
  00036	3b c8		 cmp	 ecx, eax
  00038	76 12		 jbe	 SHORT $LN10@Resize_rea

; 1689 :             return _Max; // geometric growth would overflow

  0003a	bf fc ff ff ff	 mov	 edi, -4			; fffffffcH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0003f	57		 push	 edi
  00040	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00045	83 c4 04	 add	 esp, 4
  00048	8b d8		 mov	 ebx, eax
  0004a	eb 42		 jmp	 SHORT $LN21@Resize_rea
$LN10@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0004c	8d 3c 0a	 lea	 edi, DWORD PTR [edx+ecx]

; 1693 : 
; 1694 :         if (_Geometric < _Newsize) {

  0004f	3b fb		 cmp	 edi, ebx
  00051	73 1a		 jae	 SHORT $LN11@Resize_rea

; 1695 :             return _Newsize; // geometric growth would be insufficient

  00053	8b fb		 mov	 edi, ebx
$LN18@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 69   :     return _Count * _Ty_size;

  00055	c1 e7 02	 shl	 edi, 2

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00058	81 ff 00 10 00
	00		 cmp	 edi, 4096		; 00001000H
  0005e	72 1b		 jb	 SHORT $LN22@Resize_rea

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00060	57		 push	 edi
  00061	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00066	83 c4 04	 add	 esp, 4
  00069	8b d8		 mov	 ebx, eax
  0006b	eb 21		 jmp	 SHORT $LN21@Resize_rea
$LN11@Resize_rea:

; 64   :         if (_Count > _Max_possible) {

  0006d	81 ff ff ff ff
	3f		 cmp	 edi, 1073741823		; 3fffffffH
  00073	0f 87 8e 00 00
	00		 ja	 $LN83@Resize_rea
  00079	eb da		 jmp	 SHORT $LN18@Resize_rea
$LN22@Resize_rea:

; 243  :     if (_Bytes != 0) {

  0007b	85 ff		 test	 edi, edi
  0007d	74 0d		 je	 SHORT $LN23@Resize_rea

; 85   :         return ::operator new(_Bytes);

  0007f	57		 push	 edi
  00080	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00085	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  00088	8b d8		 mov	 ebx, eax
  0008a	eb 02		 jmp	 SHORT $LN21@Resize_rea
$LN23@Resize_rea:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  0008c	33 db		 xor	 ebx, ebx
$LN21@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1242 :         const pointer _Appended_first = _Newvec + _Oldsize;

  0008e	8b 55 fc	 mov	 edx, DWORD PTR __Oldsize$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1824 :             _Zero_range(_PFirst, _PFirst + _Count);

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	2b c2		 sub	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1242 :         const pointer _Appended_first = _Newvec + _Oldsize;

  00096	8d 0c 93	 lea	 ecx, DWORD PTR [ebx+edx*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1824 :             _Zero_range(_PFirst, _PFirst + _Count);

  00099	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0009c	50		 push	 eax
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ??$_Zero_range@PAH@std@@YAPAHQAH0@Z ; std::_Zero_range<int *>

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000a3	53		 push	 ebx
  000a4	ff 76 04	 push	 DWORD PTR [esi+4]
  000a7	ff 36		 push	 DWORD PTR [esi]
  000a9	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ; std::_Copy_memmove<int *,int *>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

  000ae	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000b0	83 c4 14	 add	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

  000b3	85 c0		 test	 eax, eax
  000b5	74 2c		 je	 SHORT $LN65@Resize_rea

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000b7	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000ba	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000bc	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000bf	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000c5	72 12		 jb	 SHORT $LN75@Resize_rea

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000c7	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000ca	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000cd	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000cf	83 c0 fc	 add	 eax, -4			; fffffffcH
  000d2	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000d5	77 26		 ja	 SHORT $LN72@Resize_rea

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000d7	8b c2		 mov	 eax, edx
$LN75@Resize_rea:

; 264  :         ::operator delete(_Ptr, _Bytes);

  000d9	51		 push	 ecx
  000da	50		 push	 eax
  000db	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000e0	83 c4 08	 add	 esp, 8
$LN65@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1751 :         _Mylast  = _Newvec + _Newsize;

  000e3	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000e6	89 1e		 mov	 DWORD PTR [esi], ebx
  000e8	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]
  000eb	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1752 :         _Myend   = _Newvec + _Newcapacity;

  000ee	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
  000f1	5f		 pop	 edi
  000f2	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000f5	5e		 pop	 esi
  000f6	5b		 pop	 ebx

; 1255 :     }

  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 08 00	 ret	 8
$LN72@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000fd	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN82@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1231 :             _Xlength();

  00102	e8 00 00 00 00	 call	 ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
$LN83@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  00107	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN80@Resize_rea:
  0010c	cc		 int	 3
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<int,std::allocator<int> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
_this$1$ = -12						; size = 4
$T2 = -4						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1229 :     _CONSTEXPR20_CONTAINER void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 1230 :         if (_Newsize > max_size()) {

  00008	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	89 7d f4	 mov	 DWORD PTR _this$1$[ebp], edi
  00011	81 fe ff ff ff
	1f		 cmp	 esi, 536870911		; 1fffffffH
  00017	0f 87 e1 00 00
	00		 ja	 $LN92@Resize_rea

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0001d	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00020	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00025	2b 0f		 sub	 ecx, DWORD PTR [edi]
  00027	c1 f9 03	 sar	 ecx, 3

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0002a	8b d1		 mov	 edx, ecx
  0002c	d1 ea		 shr	 edx, 1
  0002e	2b c2		 sub	 eax, edx
  00030	3b c8		 cmp	 ecx, eax
  00032	76 10		 jbe	 SHORT $LN10@Resize_rea

; 1689 :             return _Max; // geometric growth would overflow

  00034	bb f8 ff ff ff	 mov	 ebx, -8			; fffffff8H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00039	53		 push	 ebx
  0003a	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0003f	83 c4 04	 add	 esp, 4
  00042	eb 3e		 jmp	 SHORT $LN90@Resize_rea
$LN10@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00044	8d 1c 0a	 lea	 ebx, DWORD PTR [edx+ecx]

; 1693 : 
; 1694 :         if (_Geometric < _Newsize) {

  00047	3b de		 cmp	 ebx, esi
  00049	73 18		 jae	 SHORT $LN11@Resize_rea

; 1695 :             return _Newsize; // geometric growth would be insufficient

  0004b	8b de		 mov	 ebx, esi
$LN87@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 69   :     return _Count * _Ty_size;

  0004d	c1 e3 03	 shl	 ebx, 3

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00050	81 fb 00 10 00
	00		 cmp	 ebx, 4096		; 00001000H
  00056	72 19		 jb	 SHORT $LN22@Resize_rea

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00058	53		 push	 ebx
  00059	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0005e	83 c4 04	 add	 esp, 4
  00061	eb 1f		 jmp	 SHORT $LN90@Resize_rea
$LN11@Resize_rea:

; 64   :         if (_Count > _Max_possible) {

  00063	81 fb ff ff ff
	1f		 cmp	 ebx, 536870911		; 1fffffffH
  00069	0f 87 94 00 00
	00		 ja	 $LN93@Resize_rea
  0006f	eb dc		 jmp	 SHORT $LN87@Resize_rea
$LN22@Resize_rea:

; 243  :     if (_Bytes != 0) {

  00071	85 db		 test	 ebx, ebx
  00073	74 0b		 je	 SHORT $LN23@Resize_rea

; 85   :         return ::operator new(_Bytes);

  00075	53		 push	 ebx
  00076	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0007b	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  0007e	eb 02		 jmp	 SHORT $LN90@Resize_rea
$LN23@Resize_rea:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  00080	33 c0		 xor	 eax, eax
$LN90@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1247 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00082	8b 17		 mov	 edx, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00084	8b f0		 mov	 esi, eax

; 1718 :     const auto _ULast = _Get_unwrapped(_Last);

  00086	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1247 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00089	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  0008c	3b d1		 cmp	 edx, ecx
  0008e	74 1c		 je	 SHORT $LN47@Resize_rea
  00090	8b f9		 mov	 edi, ecx
$LL48@Resize_rea:

; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

  00092	8b 02		 mov	 eax, DWORD PTR [edx]

; 1632 :         ++_Last;

  00094	8d 76 08	 lea	 esi, DWORD PTR [esi+8]

; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

  00097	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]

; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  0009a	83 c2 08	 add	 edx, 8

; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

  0009d	89 46 f8	 mov	 DWORD PTR [esi-8], eax
  000a0	89 4e fc	 mov	 DWORD PTR [esi-4], ecx

; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  000a3	3b d7		 cmp	 edx, edi
  000a5	75 eb		 jne	 SHORT $LL48@Resize_rea
  000a7	8b 7d f4	 mov	 edi, DWORD PTR _this$1$[ebp]
  000aa	8b 17		 mov	 edx, DWORD PTR [edi]
$LN47@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

  000ac	85 d2		 test	 edx, edx
  000ae	74 2c		 je	 SHORT $LN65@Resize_rea

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000b0	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000b3	2b ca		 sub	 ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000b5	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000b8	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000be	72 12		 jb	 SHORT $LN75@Resize_rea

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000c0	8b 72 fc	 mov	 esi, DWORD PTR [edx-4]
  000c3	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000c6	2b d6		 sub	 edx, esi

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000c8	8d 42 fc	 lea	 eax, DWORD PTR [edx-4]
  000cb	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000ce	77 29		 ja	 SHORT $LN72@Resize_rea

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000d0	8b d6		 mov	 edx, esi
$LN75@Resize_rea:

; 264  :         ::operator delete(_Ptr, _Bytes);

  000d2	51		 push	 ecx
  000d3	52		 push	 edx
  000d4	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000d9	83 c4 08	 add	 esp, 8
$LN65@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         _Myfirst = _Newvec;

  000dc	8b 4d fc	 mov	 ecx, DWORD PTR $T2[ebp]

; 1751 :         _Mylast  = _Newvec + _Newsize;

  000df	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000e2	89 0f		 mov	 DWORD PTR [edi], ecx
  000e4	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  000e7	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1752 :         _Myend   = _Newvec + _Newcapacity;

  000ea	8d 04 0b	 lea	 eax, DWORD PTR [ebx+ecx]
  000ed	89 47 08	 mov	 DWORD PTR [edi+8], eax
  000f0	5f		 pop	 edi
  000f1	5e		 pop	 esi
  000f2	5b		 pop	 ebx

; 1255 :     }

  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c2 08 00	 ret	 8
$LN72@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000f9	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN92@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1231 :             _Xlength();

  000fe	e8 00 00 00 00	 call	 ?_Xlength@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@CAXXZ ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Xlength
$LN93@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  00103	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN89@Resize_rea:
  00108	cc		 int	 3
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAUSEffectMeshData@CEffectMesh@@@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@QAEPAPAUSEffectMeshData@CEffectMesh@@QAPAU23@ABQAU23@@Z
_TEXT	SEGMENT
__Newsize$1$ = -8					; size = 4
__Whereoff$1$ = -4					; size = 4
tv505 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAUSEffectMeshData@CEffectMesh@@@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@QAEPAPAUSEffectMeshData@CEffectMesh@@QAPAU23@ABQAU23@@Z PROC ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Emplace_reallocate<CEffectMesh::SEffectMeshData * const &>, COMDAT
; _this$ = ecx

; 765  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 766  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 767  :         _Alty& _Al        = _Getal();
; 768  :         auto& _My_data    = _Mypair._Myval2;
; 769  :         pointer& _Myfirst = _My_data._Myfirst;
; 770  :         pointer& _Mylast  = _My_data._Mylast;
; 771  : 
; 772  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 773  : 
; 774  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  00009	53		 push	 ebx
  0000a	8b d9		 mov	 ebx, ecx
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	8b 13		 mov	 edx, DWORD PTR [ebx]
  00010	2b c2		 sub	 eax, edx
  00012	c1 f8 02	 sar	 eax, 2
  00015	89 45 fc	 mov	 DWORD PTR __Whereoff$1$[ebp], eax

; 775  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00018	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0001b	2b c2		 sub	 eax, edx
  0001d	c1 f8 02	 sar	 eax, 2

; 776  : 
; 777  :         if (_Oldsize == max_size()) {

  00020	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00025	0f 84 d2 00 00
	00		 je	 $LN74@Emplace_re

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002b	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

  0002e	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00031	2b ca		 sub	 ecx, edx

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

  00033	89 7d f8	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00036	c1 f9 02	 sar	 ecx, 2

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00039	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0003e	8b d1		 mov	 edx, ecx
  00040	d1 ea		 shr	 edx, 1
  00042	2b c2		 sub	 eax, edx
  00044	3b c8		 cmp	 ecx, eax
  00046	76 17		 jbe	 SHORT $LN12@Emplace_re

; 1689 :             return _Max; // geometric growth would overflow

  00048	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0004d	be ff ff ff 3f	 mov	 esi, 1073741823		; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00058	83 c4 04	 add	 esp, 4
  0005b	8b f8		 mov	 edi, eax
  0005d	eb 44		 jmp	 SHORT $LN23@Emplace_re
$LN12@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0005f	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 64   :         if (_Count > _Max_possible) {

  00062	8b f7		 mov	 esi, edi
  00064	3b c7		 cmp	 eax, edi
  00066	0f 43 f0	 cmovae	 esi, eax
  00069	81 fe ff ff ff
	3f		 cmp	 esi, 1073741823		; 3fffffffH
  0006f	0f 87 8d 00 00
	00		 ja	 $LN75@Emplace_re

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  00075	8d 04 b5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*4]

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0007c	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00081	72 0d		 jb	 SHORT $LN24@Emplace_re

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00089	83 c4 04	 add	 esp, 4
  0008c	8b f8		 mov	 edi, eax
  0008e	eb 13		 jmp	 SHORT $LN23@Emplace_re
$LN24@Emplace_re:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  00090	85 c0		 test	 eax, eax
  00092	74 0d		 je	 SHORT $LN25@Emplace_re

; 85   :         return ::operator new(_Bytes);

  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0009a	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  0009d	8b f8		 mov	 edi, eax
  0009f	eb 02		 jmp	 SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000a1	33 ff		 xor	 edi, edi
$LN23@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 789  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000a3	8b 45 fc	 mov	 eax, DWORD PTR __Whereoff$1$[ebp]
  000a6	8d 0c 87	 lea	 ecx, DWORD PTR [edi+eax*4]
  000a9	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  000ac	89 4d fc	 mov	 DWORD PTR tv505[ebp], ecx
  000af	8b 00		 mov	 eax, DWORD PTR [eax]
  000b1	89 01		 mov	 DWORD PTR [ecx], eax

; 790  :         _Constructed_first = _Newvec + _Whereoff;
; 791  : 
; 792  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000b3	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000b6	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  000b9	8b 13		 mov	 edx, DWORD PTR [ebx]
  000bb	3b c1		 cmp	 eax, ecx
  000bd	75 04		 jne	 SHORT $LN4@Emplace_re
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000bf	8b c7		 mov	 eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 794  :         } else { // provide basic guarantee

  000c1	eb 17		 jmp	 SHORT $LN60@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000c3	57		 push	 edi
  000c4	50		 push	 eax
  000c5	52		 push	 edx
  000c6	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAUSEffectMeshData@CEffectMesh@@PAPAU12@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@PAPAU12@00@Z ; std::_Copy_memmove<CEffectMesh::SEffectMeshData * *,CEffectMesh::SEffectMeshData * *>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000cb	8b 45 fc	 mov	 eax, DWORD PTR tv505[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d1	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000d4	83 c0 04	 add	 eax, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000d7	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
$LN60@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000da	50		 push	 eax
  000db	51		 push	 ecx
  000dc	52		 push	 edx
  000dd	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAUSEffectMeshData@CEffectMesh@@PAPAU12@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@PAPAU12@00@Z ; std::_Copy_memmove<CEffectMesh::SEffectMeshData * *,CEffectMesh::SEffectMeshData * *>
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);
; 801  :         _Al.deallocate(_Newvec, _Newcapacity);
; 802  :         _RERAISE;
; 803  :         _CATCH_END
; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  000e5	8b cb		 mov	 ecx, ebx
  000e7	56		 push	 esi
  000e8	ff 75 f8	 push	 DWORD PTR __Newsize$1$[ebp]
  000eb	57		 push	 edi
  000ec	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@AAEXQAPAUSEffectMeshData@CEffectMesh@@II@Z ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Change_array

; 806  :         return _Newvec + _Whereoff;

  000f1	8b 45 fc	 mov	 eax, DWORD PTR tv505[ebp]
  000f4	5f		 pop	 edi
  000f5	5e		 pop	 esi
  000f6	5b		 pop	 ebx

; 807  :     }

  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 08 00	 ret	 8
$LN74@Emplace_re:

; 778  :             _Xlength();

  000fd	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@CAXXZ ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Xlength
$LN75@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  00102	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN72@Emplace_re:
  00107	cc		 int	 3
??$_Emplace_reallocate@ABQAUSEffectMeshData@CEffectMesh@@@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@QAEPAPAUSEffectMeshData@CEffectMesh@@QAPAU23@ABQAU23@@Z ENDP ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Emplace_reallocate<CEffectMesh::SEffectMeshData * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAXPAUSMeshData@CEffectMeshScript@@QAU12@AAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAXPAUSMeshData@CEffectMeshScript@@QAU12@AAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CEffectMeshScript::SMeshData> >, COMDAT

; 945  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 949  :         for (; _First != _Last; ++_First) {

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 53		 je	 SHORT $LN47@Destroy_ra
  0000f	83 c6 38	 add	 esi, 56			; 00000038H
$LL4@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00012	8b 46 f8	 mov	 eax, DWORD PTR [esi-8]
  00015	85 c0		 test	 eax, eax
  00017	74 3f		 je	 SHORT $LN46@Destroy_ra

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00019	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0001b	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0001d	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00020	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00026	72 12		 jb	 SHORT $LN33@Destroy_ra

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00028	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0002b	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0002e	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00030	83 c0 fc	 add	 eax, -4			; fffffffcH
  00033	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00036	77 2e		 ja	 SHORT $LN30@Destroy_ra

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00038	8b c2		 mov	 eax, edx
$LN33@Destroy_ra:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0003a	51		 push	 ecx
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  00041	c7 46 f8 00 00
	00 00		 mov	 DWORD PTR [esi-8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00048	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  0004b	c7 46 fc 00 00
	00 00		 mov	 DWORD PTR [esi-4], 0

; 1769 :             _Myend   = nullptr;

  00052	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN46@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 949  :         for (; _First != _Last; ++_First) {

  00058	83 c6 3c	 add	 esi, 60			; 0000003cH
  0005b	8d 46 c8	 lea	 eax, DWORD PTR [esi-56]
  0005e	3b c7		 cmp	 eax, edi
  00060	75 b0		 jne	 SHORT $LL4@Destroy_ra
$LN47@Destroy_ra:
  00062	5f		 pop	 edi

; 950  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 951  :         }
; 952  :     }
; 953  : }

  00063	5e		 pop	 esi
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
$LN30@Destroy_ra:

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00066	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN48@Destroy_ra:
  0006b	cc		 int	 3
??$_Destroy_range@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAXPAUSMeshData@CEffectMeshScript@@QAU12@AAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CEffectMeshScript::SMeshData> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCEffectMeshScript@@@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@QAEPAPAVCEffectMeshScript@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Newsize$1$ = -8					; size = 4
tv641 = -4						; size = 4
__Whereoff$1$ = -4					; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAVCEffectMeshScript@@@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@QAEPAPAVCEffectMeshScript@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CEffectMeshScript *,std::allocator<CEffectMeshScript *> >::_Emplace_reallocate<CEffectMeshScript * const &>, COMDAT
; _this$ = ecx

; 765  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 766  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 767  :         _Alty& _Al        = _Getal();
; 768  :         auto& _My_data    = _Mypair._Myval2;
; 769  :         pointer& _Myfirst = _My_data._Myfirst;
; 770  :         pointer& _Mylast  = _My_data._Mylast;
; 771  : 
; 772  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 773  : 
; 774  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00010	2b c1		 sub	 eax, ecx
  00012	c1 f8 02	 sar	 eax, 2
  00015	89 45 fc	 mov	 DWORD PTR __Whereoff$1$[ebp], eax

; 775  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00018	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001b	2b c1		 sub	 eax, ecx
  0001d	c1 f8 02	 sar	 eax, 2

; 776  : 
; 777  :         if (_Oldsize == max_size()) {

  00020	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00025	0f 84 06 01 00
	00		 je	 $LN96@Emplace_re

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

  0002e	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00031	2b d1		 sub	 edx, ecx

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

  00033	89 7d f8	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00036	c1 fa 02	 sar	 edx, 2

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00039	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0003e	8b ca		 mov	 ecx, edx
  00040	d1 e9		 shr	 ecx, 1
  00042	2b c1		 sub	 eax, ecx
  00044	3b d0		 cmp	 edx, eax
  00046	76 12		 jbe	 SHORT $LN12@Emplace_re

; 1689 :             return _Max; // geometric growth would overflow

  00048	bb fc ff ff ff	 mov	 ebx, -4			; fffffffcH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0004d	53		 push	 ebx
  0004e	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00053	83 c4 04	 add	 esp, 4
  00056	8b f8		 mov	 edi, eax
  00058	eb 41		 jmp	 SHORT $LN23@Emplace_re
$LN12@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0005a	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 64   :         if (_Count > _Max_possible) {

  0005d	8b df		 mov	 ebx, edi
  0005f	3b c7		 cmp	 eax, edi
  00061	0f 43 d8	 cmovae	 ebx, eax
  00064	81 fb ff ff ff
	3f		 cmp	 ebx, 1073741823		; 3fffffffH
  0006a	0f 87 c6 00 00
	00		 ja	 $LN97@Emplace_re

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  00070	c1 e3 02	 shl	 ebx, 2

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00073	81 fb 00 10 00
	00		 cmp	 ebx, 4096		; 00001000H
  00079	72 0d		 jb	 SHORT $LN24@Emplace_re

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0007b	53		 push	 ebx
  0007c	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00081	83 c4 04	 add	 esp, 4
  00084	8b f8		 mov	 edi, eax
  00086	eb 13		 jmp	 SHORT $LN23@Emplace_re
$LN24@Emplace_re:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  00088	85 db		 test	 ebx, ebx
  0008a	74 0d		 je	 SHORT $LN25@Emplace_re

; 85   :         return ::operator new(_Bytes);

  0008c	53		 push	 ebx
  0008d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00092	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  00095	8b f8		 mov	 edi, eax
  00097	eb 02		 jmp	 SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  00099	33 ff		 xor	 edi, edi
$LN23@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 789  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0009b	8b 45 fc	 mov	 eax, DWORD PTR __Whereoff$1$[ebp]
  0009e	8d 0c 87	 lea	 ecx, DWORD PTR [edi+eax*4]
  000a1	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  000a4	89 4d fc	 mov	 DWORD PTR tv641[ebp], ecx
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	89 01		 mov	 DWORD PTR [ecx], eax

; 790  :         _Constructed_first = _Newvec + _Whereoff;
; 791  : 
; 792  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000ab	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000ae	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  000b1	8b 16		 mov	 edx, DWORD PTR [esi]
  000b3	3b c1		 cmp	 eax, ecx
  000b5	75 04		 jne	 SHORT $LN4@Emplace_re
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000b7	8b c7		 mov	 eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 794  :         } else { // provide basic guarantee

  000b9	eb 17		 jmp	 SHORT $LN60@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000bb	57		 push	 edi
  000bc	50		 push	 eax
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCEffectMeshScript@@PAPAV1@@std@@YAPAPAVCEffectMeshScript@@PAPAV1@00@Z ; std::_Copy_memmove<CEffectMeshScript * *,CEffectMeshScript * *>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000c3	8b 45 fc	 mov	 eax, DWORD PTR tv641[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c9	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000cc	83 c0 04	 add	 eax, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000cf	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
$LN60@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000d2	50		 push	 eax
  000d3	51		 push	 ecx
  000d4	52		 push	 edx
  000d5	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCEffectMeshScript@@PAPAV1@@std@@YAPAPAVCEffectMeshScript@@PAPAV1@00@Z ; std::_Copy_memmove<CEffectMeshScript * *,CEffectMeshScript * *>

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

  000da	8b 06		 mov	 eax, DWORD PTR [esi]

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000dc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

  000df	85 c0		 test	 eax, eax
  000e1	74 2c		 je	 SHORT $LN78@Emplace_re

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000e3	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000e6	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e8	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000eb	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000f1	72 12		 jb	 SHORT $LN88@Emplace_re

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f3	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000f6	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000f9	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000fb	83 c0 fc	 add	 eax, -4			; fffffffcH
  000fe	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00101	77 29		 ja	 SHORT $LN85@Emplace_re

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00103	8b c2		 mov	 eax, edx
$LN88@Emplace_re:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00105	51		 push	 ecx
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0010c	83 c4 08	 add	 esp, 8
$LN78@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1751 :         _Mylast  = _Newvec + _Newsize;

  0010f	8b 45 f8	 mov	 eax, DWORD PTR __Newsize$1$[ebp]
  00112	89 3e		 mov	 DWORD PTR [esi], edi
  00114	8d 0c 87	 lea	 ecx, DWORD PTR [edi+eax*4]

; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);
; 801  :         _Al.deallocate(_Newvec, _Newcapacity);
; 802  :         _RERAISE;
; 803  :         _CATCH_END
; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 806  :         return _Newvec + _Whereoff;

  00117	8b 45 fc	 mov	 eax, DWORD PTR tv641[ebp]

; 1751 :         _Mylast  = _Newvec + _Newsize;

  0011a	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 1752 :         _Myend   = _Newvec + _Newcapacity;

  0011d	8d 0c 3b	 lea	 ecx, DWORD PTR [ebx+edi]

; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);
; 801  :         _Al.deallocate(_Newvec, _Newcapacity);
; 802  :         _RERAISE;
; 803  :         _CATCH_END
; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 806  :         return _Newvec + _Whereoff;

  00120	5f		 pop	 edi

; 1752 :         _Myend   = _Newvec + _Newcapacity;

  00121	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);
; 801  :         _Al.deallocate(_Newvec, _Newcapacity);
; 802  :         _RERAISE;
; 803  :         _CATCH_END
; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 806  :         return _Newvec + _Whereoff;

  00124	5e		 pop	 esi
  00125	5b		 pop	 ebx

; 807  :     }

  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c2 08 00	 ret	 8
$LN85@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0012c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN96@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 778  :             _Xlength();

  00131	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@CAXXZ ; std::vector<CEffectMeshScript *,std::allocator<CEffectMeshScript *> >::_Xlength
$LN97@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  00136	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN94@Emplace_re:
  0013b	cc		 int	 3
??$_Emplace_reallocate@ABQAVCEffectMeshScript@@@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@QAEPAPAVCEffectMeshScript@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CEffectMeshScript *,std::allocator<CEffectMeshScript *> >::_Emplace_reallocate<CEffectMeshScript * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEPAPAVCGraphicImage@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Newsize$1$ = -8					; size = 4
tv641 = -4						; size = 4
__Whereoff$1$ = -4					; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEPAPAVCGraphicImage@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Emplace_reallocate<CGraphicImage * const &>, COMDAT
; _this$ = ecx

; 765  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 766  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 767  :         _Alty& _Al        = _Getal();
; 768  :         auto& _My_data    = _Mypair._Myval2;
; 769  :         pointer& _Myfirst = _My_data._Myfirst;
; 770  :         pointer& _Mylast  = _My_data._Mylast;
; 771  : 
; 772  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 773  : 
; 774  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00010	2b c1		 sub	 eax, ecx
  00012	c1 f8 02	 sar	 eax, 2
  00015	89 45 fc	 mov	 DWORD PTR __Whereoff$1$[ebp], eax

; 775  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00018	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001b	2b c1		 sub	 eax, ecx
  0001d	c1 f8 02	 sar	 eax, 2

; 776  : 
; 777  :         if (_Oldsize == max_size()) {

  00020	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00025	0f 84 06 01 00
	00		 je	 $LN96@Emplace_re

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

  0002e	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00031	2b d1		 sub	 edx, ecx

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

  00033	89 7d f8	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00036	c1 fa 02	 sar	 edx, 2

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00039	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0003e	8b ca		 mov	 ecx, edx
  00040	d1 e9		 shr	 ecx, 1
  00042	2b c1		 sub	 eax, ecx
  00044	3b d0		 cmp	 edx, eax
  00046	76 12		 jbe	 SHORT $LN12@Emplace_re

; 1689 :             return _Max; // geometric growth would overflow

  00048	bb fc ff ff ff	 mov	 ebx, -4			; fffffffcH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0004d	53		 push	 ebx
  0004e	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00053	83 c4 04	 add	 esp, 4
  00056	8b f8		 mov	 edi, eax
  00058	eb 41		 jmp	 SHORT $LN23@Emplace_re
$LN12@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0005a	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 64   :         if (_Count > _Max_possible) {

  0005d	8b df		 mov	 ebx, edi
  0005f	3b c7		 cmp	 eax, edi
  00061	0f 43 d8	 cmovae	 ebx, eax
  00064	81 fb ff ff ff
	3f		 cmp	 ebx, 1073741823		; 3fffffffH
  0006a	0f 87 c6 00 00
	00		 ja	 $LN97@Emplace_re

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  00070	c1 e3 02	 shl	 ebx, 2

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00073	81 fb 00 10 00
	00		 cmp	 ebx, 4096		; 00001000H
  00079	72 0d		 jb	 SHORT $LN24@Emplace_re

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0007b	53		 push	 ebx
  0007c	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00081	83 c4 04	 add	 esp, 4
  00084	8b f8		 mov	 edi, eax
  00086	eb 13		 jmp	 SHORT $LN23@Emplace_re
$LN24@Emplace_re:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  00088	85 db		 test	 ebx, ebx
  0008a	74 0d		 je	 SHORT $LN25@Emplace_re

; 85   :         return ::operator new(_Bytes);

  0008c	53		 push	 ebx
  0008d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00092	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  00095	8b f8		 mov	 edi, eax
  00097	eb 02		 jmp	 SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  00099	33 ff		 xor	 edi, edi
$LN23@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 789  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0009b	8b 45 fc	 mov	 eax, DWORD PTR __Whereoff$1$[ebp]
  0009e	8d 0c 87	 lea	 ecx, DWORD PTR [edi+eax*4]
  000a1	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  000a4	89 4d fc	 mov	 DWORD PTR tv641[ebp], ecx
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	89 01		 mov	 DWORD PTR [ecx], eax

; 790  :         _Constructed_first = _Newvec + _Whereoff;
; 791  : 
; 792  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000ab	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000ae	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  000b1	8b 16		 mov	 edx, DWORD PTR [esi]
  000b3	3b c1		 cmp	 eax, ecx
  000b5	75 04		 jne	 SHORT $LN4@Emplace_re
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000b7	8b c7		 mov	 eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 794  :         } else { // provide basic guarantee

  000b9	eb 17		 jmp	 SHORT $LN60@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000bb	57		 push	 edi
  000bc	50		 push	 eax
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00@Z ; std::_Copy_memmove<CGraphicImage * *,CGraphicImage * *>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000c3	8b 45 fc	 mov	 eax, DWORD PTR tv641[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c9	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000cc	83 c0 04	 add	 eax, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000cf	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
$LN60@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000d2	50		 push	 eax
  000d3	51		 push	 ecx
  000d4	52		 push	 edx
  000d5	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00@Z ; std::_Copy_memmove<CGraphicImage * *,CGraphicImage * *>

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

  000da	8b 06		 mov	 eax, DWORD PTR [esi]

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000dc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

  000df	85 c0		 test	 eax, eax
  000e1	74 2c		 je	 SHORT $LN78@Emplace_re

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000e3	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000e6	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e8	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000eb	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000f1	72 12		 jb	 SHORT $LN88@Emplace_re

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f3	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000f6	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000f9	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000fb	83 c0 fc	 add	 eax, -4			; fffffffcH
  000fe	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00101	77 29		 ja	 SHORT $LN85@Emplace_re

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00103	8b c2		 mov	 eax, edx
$LN88@Emplace_re:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00105	51		 push	 ecx
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0010c	83 c4 08	 add	 esp, 8
$LN78@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1751 :         _Mylast  = _Newvec + _Newsize;

  0010f	8b 45 f8	 mov	 eax, DWORD PTR __Newsize$1$[ebp]
  00112	89 3e		 mov	 DWORD PTR [esi], edi
  00114	8d 0c 87	 lea	 ecx, DWORD PTR [edi+eax*4]

; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);
; 801  :         _Al.deallocate(_Newvec, _Newcapacity);
; 802  :         _RERAISE;
; 803  :         _CATCH_END
; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 806  :         return _Newvec + _Whereoff;

  00117	8b 45 fc	 mov	 eax, DWORD PTR tv641[ebp]

; 1751 :         _Mylast  = _Newvec + _Newsize;

  0011a	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 1752 :         _Myend   = _Newvec + _Newcapacity;

  0011d	8d 0c 3b	 lea	 ecx, DWORD PTR [ebx+edi]

; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);
; 801  :         _Al.deallocate(_Newvec, _Newcapacity);
; 802  :         _RERAISE;
; 803  :         _CATCH_END
; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 806  :         return _Newvec + _Whereoff;

  00120	5f		 pop	 edi

; 1752 :         _Myend   = _Newvec + _Newcapacity;

  00121	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);
; 801  :         _Al.deallocate(_Newvec, _Newcapacity);
; 802  :         _RERAISE;
; 803  :         _CATCH_END
; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 806  :         return _Newvec + _Whereoff;

  00124	5e		 pop	 esi
  00125	5b		 pop	 ebx

; 807  :     }

  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c2 08 00	 ret	 8
$LN85@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0012c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN96@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 778  :             _Xlength();

  00131	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@CAXXZ ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Xlength
$LN97@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  00136	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN94@Emplace_re:
  0013b	cc		 int	 3
??$_Emplace_reallocate@ABQAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEPAPAVCGraphicImage@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Emplace_reallocate<CGraphicImage * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CEffectMeshScript::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A ; CEffectMeshScript::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPool@VCEffectMeshScript@@@@UAE@XZ ; CDynamicPool<CEffectMeshScript>::~CDynamicPool<CEffectMeshScript>
??__F?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CEffectMeshScript::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ??__E?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CEffectMeshScript::ms_kPool'', COMDAT

; 430  : CDynamicPool<CEffectMeshScript> CEffectMeshScript::ms_kPool;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CEffectMeshScript::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CEffectMeshScript::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPool@VCEffectMeshScript@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCEffectMeshScript@@@@UAEPAXI@Z PROC	; CDynamicPool<CEffectMeshScript>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCEffectMeshScript@@@@UAE@XZ ; CDynamicPool<CEffectMeshScript>::~CDynamicPool<CEffectMeshScript>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCEffectMeshScript@@@@UAEPAXI@Z ENDP	; CDynamicPool<CEffectMeshScript>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@CAXXZ PROC ; std::vector<CEffectMeshScript *,std::allocator<CEffectMeshScript *> >::_Xlength, COMDAT

; 1774 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@CAXXZ ENDP ; std::vector<CEffectMeshScript *,std::allocator<CEffectMeshScript *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPool@VCEffectMeshScript@@@@KAXPAVCEffectMeshScript@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@VCEffectMeshScript@@@@KAXPAVCEffectMeshScript@@@Z PROC ; CDynamicPool<CEffectMeshScript>::Delete, COMDAT

; 109  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 110  : 			delete pkData;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pkData$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 06		 je	 SHORT $LN3@Delete
  0000a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000c	6a 01		 push	 1
  0000e	ff 10		 call	 DWORD PTR [eax]
$LN3@Delete:

; 111  : 		}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?Delete@?$CDynamicPool@VCEffectMeshScript@@@@KAXPAVCEffectMeshScript@@@Z ENDP ; CDynamicPool<CEffectMeshScript>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@VCEffectMeshScript@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPool@VCEffectMeshScript@@@@UAE@XZ PROC	; CDynamicPool<CEffectMeshScript>::~CDynamicPool<CEffectMeshScript>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@VCEffectMeshScript@@@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00009	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000c	85 c0		 test	 eax, eax
  0000e	74 41		 je	 SHORT $LN6@CDynamicPo

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00010	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00013	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00015	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00018	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001e	72 12		 jb	 SHORT $LN22@CDynamicPo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00020	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00023	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00026	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00028	83 c0 fc	 add	 eax, -4			; fffffffcH
  0002b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002e	77 6b		 ja	 SHORT $LN44@CDynamicPo

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00030	8b c2		 mov	 eax, edx
$LN22@CDynamicPo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00032	51		 push	 ecx
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  00039	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00040	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  00043	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1769 :             _Myend   = nullptr;

  0004a	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN6@CDynamicPo:

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00051	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00054	85 c0		 test	 eax, eax
  00056	74 41		 je	 SHORT $LN31@CDynamicPo

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00058	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0005b	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0005d	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00060	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00066	72 12		 jb	 SHORT $LN47@CDynamicPo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00068	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0006b	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0006e	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00070	83 c0 fc	 add	 eax, -4			; fffffffcH
  00073	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00076	77 23		 ja	 SHORT $LN44@CDynamicPo

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00078	8b c2		 mov	 eax, edx
$LN47@CDynamicPo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0007a	51		 push	 ecx
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  00081	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00088	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  0008b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1769 :             _Myend   = nullptr;

  00092	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN31@CDynamicPo:
  00099	5e		 pop	 esi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 26   : 		}

  0009a	c3		 ret	 0
$LN44@CDynamicPo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0009b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN52@CDynamicPo:
  000a0	cc		 int	 3
??1?$CDynamicPool@VCEffectMeshScript@@@@UAE@XZ ENDP	; CDynamicPool<CEffectMeshScript>::~CDynamicPool<CEffectMeshScript>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@CAXXZ PROC ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Xlength, COMDAT

; 1774 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@CAXXZ ENDP ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@XZ PROC ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::~vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >, COMDAT
; _this$ = ecx

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 40		 je	 SHORT $LN4@vector

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000c	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00011	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN20@vector

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00019	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001c	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 22		 ja	 SHORT $LN17@vector

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00029	8b c2		 mov	 eax, edx
$LN20@vector:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0002b	51		 push	 ecx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00038	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  0003b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1769 :             _Myend   = nullptr;

  00042	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:
  00049	5e		 pop	 esi

; 717  :     }

  0004a	c3		 ret	 0
$LN17@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@vector:
  00050	cc		 int	 3
??1?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@XZ ENDP ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::~vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ PROC ; std::vector<int,std::allocator<int> >::_Xlength, COMDAT

; 1774 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ENDP ; std::vector<int,std::allocator<int> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 40		 je	 SHORT $LN4@vector

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000c	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00011	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN20@vector

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00019	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001c	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 22		 ja	 SHORT $LN17@vector

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00029	8b c2		 mov	 eax, edx
$LN20@vector:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0002b	51		 push	 ecx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00038	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  0003b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1769 :             _Myend   = nullptr;

  00042	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:
  00049	5e		 pop	 esi

; 717  :     }

  0004a	c3		 ret	 0
$LN17@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@vector:
  00050	cc		 int	 3
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlength, COMDAT

; 1774 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >, COMDAT
; _this$ = ecx

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00004	8b 37		 mov	 esi, DWORD PTR [edi]
  00006	85 f6		 test	 esi, esi
  00008	74 53		 je	 SHORT $LN4@vector

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0000a	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0000d	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00012	2b ce		 sub	 ecx, esi
  00014	f7 e9		 imul	 ecx
  00016	d1 fa		 sar	 edx, 1
  00018	8b c2		 mov	 eax, edx
  0001a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001d	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0001f	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00022	c1 e1 02	 shl	 ecx, 2

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00025	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0002b	72 12		 jb	 SHORT $LN20@vector

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0002d	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  00030	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00033	2b f2		 sub	 esi, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00035	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  00038	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0003b	77 23		 ja	 SHORT $LN17@vector

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0003d	8b f2		 mov	 esi, edx
$LN20@vector:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0003f	51		 push	 ecx
  00040	56		 push	 esi
  00041	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  00046	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  0004c	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  0004f	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1769 :             _Myend   = nullptr;

  00056	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
$LN4@vector:
  0005d	5f		 pop	 edi

; 717  :     }

  0005e	5e		 pop	 esi
  0005f	c3		 ret	 0
$LN17@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00060	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@vector:
  00065	cc		 int	 3
??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CEffectMesh::SEffectMeshData::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A ; CEffectMesh::SEffectMeshData::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@UAE@XZ ; CDynamicPool<CEffectMesh::SEffectMeshData>::~CDynamicPool<CEffectMesh::SEffectMeshData>
??__F?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CEffectMesh::SEffectMeshData::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ??__E?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CEffectMesh::SEffectMeshData::ms_kPool'', COMDAT

; 7    : CDynamicPool<CEffectMesh::SEffectMeshData> CEffectMesh::SEffectMeshData::ms_kPool;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CEffectMesh::SEffectMeshData::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CEffectMesh::SEffectMeshData::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@UAEPAXI@Z PROC ; CDynamicPool<CEffectMesh::SEffectMeshData>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@UAE@XZ ; CDynamicPool<CEffectMesh::SEffectMeshData>::~CDynamicPool<CEffectMesh::SEffectMeshData>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@UAEPAXI@Z ENDP ; CDynamicPool<CEffectMesh::SEffectMeshData>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@KAXPAUSEffectMeshData@CEffectMesh@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@KAXPAUSEffectMeshData@CEffectMesh@@@Z PROC ; CDynamicPool<CEffectMesh::SEffectMeshData>::Delete, COMDAT

; 109  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 110  : 			delete pkData;

  00004	8b 75 08	 mov	 esi, DWORD PTR _pkData$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 70		 je	 SHORT $LN6@Delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  0000b	8b 86 ac 00 00
	00		 mov	 eax, DWORD PTR [esi+172]
  00011	85 c0		 test	 eax, eax
  00013	74 4d		 je	 SHORT $LN14@Delete

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00015	8b 8e b4 00 00
	00		 mov	 ecx, DWORD PTR [esi+180]
  0001b	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0001d	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00020	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00026	72 12		 jb	 SHORT $LN30@Delete

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00028	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0002b	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0002e	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00030	83 c0 fc	 add	 eax, -4			; fffffffcH
  00033	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00036	77 46		 ja	 SHORT $LN27@Delete

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00038	8b c2		 mov	 eax, edx
$LN30@Delete:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0003a	51		 push	 ecx
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  00041	c7 86 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+172], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  0004b	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  0004e	c7 86 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+176], 0

; 1769 :             _Myend   = nullptr;

  00058	c7 86 b4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+180], 0
$LN14@Delete:
  00062	8d 8e a0 00 00
	00		 lea	 ecx, DWORD PTR [esi+160]
  00068	e8 00 00 00 00	 call	 ??1?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@QAE@XZ ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::~vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >
  0006d	68 b8 00 00 00	 push	 184			; 000000b8H
  00072	56		 push	 esi
  00073	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00078	83 c4 08	 add	 esp, 8
$LN6@Delete:
  0007b	5e		 pop	 esi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 111  : 		}

  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
$LN27@Delete:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0007e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN38@Delete:
  00083	cc		 int	 3
?Delete@?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@KAXPAUSEffectMeshData@CEffectMesh@@@Z ENDP ; CDynamicPool<CEffectMesh::SEffectMeshData>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@UAE@XZ PROC ; CDynamicPool<CEffectMesh::SEffectMeshData>::~CDynamicPool<CEffectMesh::SEffectMeshData>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00009	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000c	85 c0		 test	 eax, eax
  0000e	74 41		 je	 SHORT $LN6@CDynamicPo

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00010	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00013	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00015	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00018	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001e	72 12		 jb	 SHORT $LN22@CDynamicPo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00020	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00023	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00026	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00028	83 c0 fc	 add	 eax, -4			; fffffffcH
  0002b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002e	77 6b		 ja	 SHORT $LN44@CDynamicPo

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00030	8b c2		 mov	 eax, edx
$LN22@CDynamicPo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00032	51		 push	 ecx
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  00039	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00040	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  00043	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1769 :             _Myend   = nullptr;

  0004a	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN6@CDynamicPo:

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00051	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00054	85 c0		 test	 eax, eax
  00056	74 41		 je	 SHORT $LN31@CDynamicPo

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00058	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0005b	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0005d	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00060	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00066	72 12		 jb	 SHORT $LN47@CDynamicPo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00068	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0006b	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0006e	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00070	83 c0 fc	 add	 eax, -4			; fffffffcH
  00073	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00076	77 23		 ja	 SHORT $LN44@CDynamicPo

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00078	8b c2		 mov	 eax, edx
$LN47@CDynamicPo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0007a	51		 push	 ecx
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  00081	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00088	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  0008b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1769 :             _Myend   = nullptr;

  00092	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN31@CDynamicPo:
  00099	5e		 pop	 esi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 26   : 		}

  0009a	c3		 ret	 0
$LN44@CDynamicPo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0009b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN52@CDynamicPo:
  000a0	cc		 int	 3
??1?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@UAE@XZ ENDP ; CDynamicPool<CEffectMesh::SEffectMeshData>::~CDynamicPool<CEffectMesh::SEffectMeshData>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCEffectMeshScript@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCEffectMeshScript@@UAEPAXI@Z PROC			; CEffectMeshScript::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CEffectMeshScript@@UAE@XZ ; CEffectMeshScript::~CEffectMeshScript
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 44		 push	 68			; 00000044H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GCEffectMeshScript@@UAEPAXI@Z ENDP			; CEffectMeshScript::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?Delete@CEffectMeshScript@@SAXPAV1@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
_pkData$ = 8						; size = 4
?Delete@CEffectMeshScript@@SAXPAV1@@Z PROC		; CEffectMeshScript::Delete, COMDAT

; 443  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 444  : 	pkData->Clear();

  00004	8b 75 08	 mov	 esi, DWORD PTR _pkData$[ebp]
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ?Clear@CEffectElementBase@@QAEXXZ ; CEffectElementBase::Clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  0000e	a1 14 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+20
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 445  : 	ms_kPool.Free(pkData);

  00013	89 75 08	 mov	 DWORD PTR _pkData$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  00016	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+24
  0001c	74 0c		 je	 SHORT $LN8@Delete

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	89 30		 mov	 DWORD PTR [eax], esi

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

  00020	83 05 14 00 00
	00 04		 add	 DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+20, 4
  00027	5e		 pop	 esi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 446  : }

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
$LN8@Delete:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0002a	8d 4d 08	 lea	 ecx, DWORD PTR _pkData$[ebp]
  0002d	51		 push	 ecx
  0002e	50		 push	 eax
  0002f	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+16
  00034	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCEffectMeshScript@@@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@QAEPAPAVCEffectMeshScript@@QAPAV2@ABQAV2@@Z ; std::vector<CEffectMeshScript *,std::allocator<CEffectMeshScript *> >::_Emplace_reallocate<CEffectMeshScript * const &>
  00039	5e		 pop	 esi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 446  : }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?Delete@CEffectMeshScript@@SAXPAV1@@Z ENDP		; CEffectMeshScript::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?New@CEffectMeshScript@@SAPAV1@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
_pkNewData$3 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?New@CEffectMeshScript@@SAPAV1@XZ PROC			; CEffectMeshScript::New, COMDAT

; 438  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?New@CEffectMeshScript@@SAPAV1@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  00024	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+20
  0002a	39 0d 10 00 00
	00		 cmp	 DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+16, ecx
  00030	0f 85 84 00 00
	00		 jne	 $LN4@New

; 65   : 				T* pkNewData=new T;

  00036	6a 44		 push	 68			; 00000044H
  00038	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003d	83 c4 04	 add	 esp, 4
  00040	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN6@New
  0004e	8b c8		 mov	 ecx, eax
  00050	e8 00 00 00 00	 call	 ??0CEffectMeshScript@@QAE@XZ ; CEffectMeshScript::CEffectMeshScript
  00055	8b f0		 mov	 esi, eax
  00057	eb 02		 jmp	 SHORT $LN7@New
$LN6@New:
  00059	33 f6		 xor	 esi, esi
$LN7@New:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  0005b	a1 08 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+8
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 65   : 				T* pkNewData=new T;

  00060	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00067	89 75 f0	 mov	 DWORD PTR _pkNewData$3[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  0006a	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+12
  00070	74 21		 je	 SHORT $LN14@New

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00072	89 30		 mov	 DWORD PTR [eax], esi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 439  : 	return ms_kPool.Alloc();

  00074	8b c6		 mov	 eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 729  :         ++_Mylast;

  00076	83 05 08 00 00
	00 04		 add	 DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+8, 4
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 67   : 				++m_uUsedCapacity;

  0007d	ff 05 20 00 00
	00		 inc	 DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+32
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 440  : }

  00083	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00086	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008d	59		 pop	 ecx
  0008e	5e		 pop	 esi
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
$LN14@New:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00093	8d 4d f0	 lea	 ecx, DWORD PTR _pkNewData$3[ebp]
  00096	51		 push	 ecx
  00097	50		 push	 eax
  00098	b9 04 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+4
  0009d	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCEffectMeshScript@@@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@QAEPAPAVCEffectMeshScript@@QAPAV2@ABQAV2@@Z ; std::vector<CEffectMeshScript *,std::allocator<CEffectMeshScript *> >::_Emplace_reallocate<CEffectMeshScript * const &>
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 67   : 				++m_uUsedCapacity;

  000a2	ff 05 20 00 00
	00		 inc	 DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+32
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 439  : 	return ms_kPool.Alloc();

  000a8	8b c6		 mov	 eax, esi

; 440  : }

  000aa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ad	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b4	59		 pop	 ecx
  000b5	5e		 pop	 esi
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
$LN4@New:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  000ba	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1624 :         return _My_data._Mylast[-1];

  000bd	83 c1 fc	 add	 ecx, -4			; fffffffcH

; 1403 :         --_Mylast;

  000c0	89 0d 14 00 00
	00		 mov	 DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+20, ecx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 440  : }

  000c6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d0	59		 pop	 ecx
  000d1	5e		 pop	 esi
  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?New@CEffectMeshScript@@SAPAV1@XZ$0:
  00000	6a 44		 push	 68			; 00000044H
  00002	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
__ehhandler$?New@CEffectMeshScript@@SAPAV1@XZ:
  00014	90		 npad	 1
  00015	90		 npad	 1
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?New@CEffectMeshScript@@SAPAV1@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?New@CEffectMeshScript@@SAPAV1@XZ ENDP			; CEffectMeshScript::New
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?DestroySystem@CEffectMeshScript@@SAXXZ
_TEXT	SEGMENT
?DestroySystem@CEffectMeshScript@@SAXXZ PROC		; CEffectMeshScript::DestroySystem, COMDAT

; 433  : {

  00000	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  00001	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+4
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 433  : {

  00007	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 269  :     const auto _ULast = _Get_unwrapped(_Last);

  00008	8b 3d 08 00 00
	00		 mov	 edi, DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+8

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  0000e	3b f7		 cmp	 esi, edi
  00010	74 2a		 je	 SHORT $LN30@DestroySys
$LL20@DestroySys:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 110  : 			delete pkData;

  00012	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00014	85 c9		 test	 ecx, ecx
  00016	74 06		 je	 SHORT $LN18@DestroySys
  00018	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001a	6a 01		 push	 1
  0001c	ff 10		 call	 DWORD PTR [eax]
$LN18@DestroySys:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  0001e	83 c6 04	 add	 esi, 4
  00021	3b f7		 cmp	 esi, edi
  00023	75 ed		 jne	 SHORT $LL20@DestroySys
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 51   : 			m_kVct_pkData.clear();

  00025	a1 04 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+4
  0002a	a3 08 00 00 00	 mov	 DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+8, eax
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 435  : }

  0002f	a1 10 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+16
  00034	5f		 pop	 edi
  00035	a3 14 00 00 00	 mov	 DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+20, eax
  0003a	5e		 pop	 esi
  0003b	c3		 ret	 0
$LN30@DestroySys:
  0003c	a1 10 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+16
  00041	5f		 pop	 edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 51   : 			m_kVct_pkData.clear();

  00042	89 35 08 00 00
	00		 mov	 DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+8, esi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 435  : }

  00048	a3 14 00 00 00	 mov	 DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+20, eax
  0004d	5e		 pop	 esi
  0004e	c3		 ret	 0
?DestroySystem@CEffectMeshScript@@SAXXZ ENDP		; CEffectMeshScript::DestroySystem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@CAXXZ PROC ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::_Xlength, COMDAT

; 1774 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@CAXXZ ENDP ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Ufill@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@AAEPAUSMeshData@CEffectMeshScript@@PAU34@IU_Value_init_tag@2@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 1
?_Ufill@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@AAEPAUSMeshData@CEffectMeshScript@@PAU34@IU_Value_init_tag@2@@Z PROC ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::_Ufill, COMDAT
; _this$ = ecx

; 1646 :     _CONSTEXPR20_CONTAINER pointer _Ufill(pointer _Dest, const size_type _Count, _Value_init_tag) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1648 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Count$[ebp]
  00007	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00008	8b 7d 08	 mov	 edi, DWORD PTR __Dest$[ebp]

; 1830 :     for (; 0 < _Count; --_Count) {

  0000b	85 f6		 test	 esi, esi
  0000d	74 2e		 je	 SHORT $LN5@Ufill

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  0000f	8b c6		 mov	 eax, esi
  00011	8d 57 38	 lea	 edx, DWORD PTR [edi+56]
  00014	c1 e0 04	 shl	 eax, 4
  00017	2b c6		 sub	 eax, esi
  00019	8d 3c 87	 lea	 edi, DWORD PTR [edi+eax*4]
  0001c	0f 1f 40 00	 npad	 4
$LL6@Ufill:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00020	c7 42 f8 00 00
	00 00		 mov	 DWORD PTR [edx-8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1632 :         ++_Last;

  00027	8d 52 3c	 lea	 edx, DWORD PTR [edx+60]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0002a	c7 42 c4 00 00
	00 00		 mov	 DWORD PTR [edx-60], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.h

; 105  : 				TimeEventAlpha.clear();

  00031	c7 42 c0 00 00
	00 00		 mov	 DWORD PTR [edx-64], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1830 :     for (; 0 < _Count; --_Count) {

  00038	83 ee 01	 sub	 esi, 1
  0003b	75 e3		 jne	 SHORT $LL6@Ufill
$LN5@Ufill:

; 1626 :         _Destroy_range(_First, _Last, _Al);

  0003d	51		 push	 ecx
  0003e	57		 push	 edi
  0003f	57		 push	 edi
  00040	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAXPAUSMeshData@CEffectMeshScript@@QAU12@AAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshScript::SMeshData> >
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1648 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00048	8b c7		 mov	 eax, edi
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi

; 1649 :     }

  0004c	5d		 pop	 ebp
  0004d	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@AAEPAUSMeshData@CEffectMeshScript@@PAU34@IU_Value_init_tag@2@@Z ENDP ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?resize@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
__Newsize$ = 8						; size = 4
?resize@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@QAEXI@Z PROC ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::resize, COMDAT
; _this$ = ecx

; 1288 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 1263 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  00008	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  0000d	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00010	8b f1		 mov	 esi, ecx
  00012	2b 37		 sub	 esi, DWORD PTR [edi]
  00014	f7 ee		 imul	 esi
  00016	03 d6		 add	 edx, esi

; 1264 :         if (_Newsize < _Oldsize) { // trim

  00018	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]
  0001b	c1 fa 05	 sar	 edx, 5
  0001e	8b da		 mov	 ebx, edx
  00020	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  00023	03 da		 add	 ebx, edx
  00025	3b f3		 cmp	 esi, ebx
  00027	73 21		 jae	 SHORT $LN4@resize

; 1265 :             const pointer _Newlast = _Myfirst + _Newsize;

  00029	8b 17		 mov	 edx, DWORD PTR [edi]
  0002b	8b c6		 mov	 eax, esi
  0002d	c1 e0 04	 shl	 eax, 4
  00030	2b c6		 sub	 eax, esi

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00032	57		 push	 edi
  00033	51		 push	 ecx

; 1265 :             const pointer _Newlast = _Myfirst + _Newsize;

  00034	8d 34 82	 lea	 esi, DWORD PTR [edx+eax*4]

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00037	56		 push	 esi
  00038	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAXPAUSMeshData@CEffectMeshScript@@QAU12@AAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshScript::SMeshData> >
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1268 :             _Mylast = _Newlast;

  00040	89 77 04	 mov	 DWORD PTR [edi+4], esi
  00043	5f		 pop	 edi

; 1289 :         // trim or append value-initialized elements, provide strong guarantee
; 1290 :         _Resize(_Newsize, _Value_init_tag{});
; 1291 :     }

  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
$LN4@resize:

; 1272 :         if (_Newsize > _Oldsize) { // append

  0004a	76 40		 jbe	 SHORT $LN5@resize

; 1273 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  0004c	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0004f	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  00054	2b 0f		 sub	 ecx, DWORD PTR [edi]
  00056	f7 e9		 imul	 ecx
  00058	03 d1		 add	 edx, ecx

; 1274 :             if (_Newsize > _Oldcapacity) { // reallocate

  0005a	8b cf		 mov	 ecx, edi
  0005c	c1 fa 05	 sar	 edx, 5
  0005f	8b c2		 mov	 eax, edx
  00061	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00064	03 c2		 add	 eax, edx
  00066	3b f0		 cmp	 esi, eax
  00068	76 11		 jbe	 SHORT $LN6@resize

; 1275 :                 _Resize_reallocate(_Newsize, _Val);

  0006a	8d 45 08	 lea	 eax, DWORD PTR $T1[ebp]
  0006d	50		 push	 eax
  0006e	56		 push	 esi
  0006f	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::_Resize_reallocate<std::_Value_init_tag>
  00074	5f		 pop	 edi

; 1289 :         // trim or append value-initialized elements, provide strong guarantee
; 1290 :         _Resize(_Newsize, _Value_init_tag{});
; 1291 :     }

  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx
  00077	5d		 pop	 ebp
  00078	c2 04 00	 ret	 4
$LN6@resize:

; 1280 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  0007b	ff 75 08	 push	 DWORD PTR $T1[ebp]
  0007e	2b f3		 sub	 esi, ebx
  00080	56		 push	 esi
  00081	ff 77 04	 push	 DWORD PTR [edi+4]
  00084	e8 00 00 00 00	 call	 ?_Ufill@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@AAEPAUSMeshData@CEffectMeshScript@@PAU34@IU_Value_init_tag@2@@Z ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::_Ufill
  00089	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN5@resize:
  0008c	5f		 pop	 edi

; 1289 :         // trim or append value-initialized elements, provide strong guarantee
; 1290 :         _Resize(_Newsize, _Value_init_tag{});
; 1291 :     }

  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	5d		 pop	 ebp
  00090	c2 04 00	 ret	 4
?resize@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@QAE@XZ PROC ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::~vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >, COMDAT
; _this$ = ecx

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 6b		 je	 SHORT $LN4@vector

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00009	57		 push	 edi
  0000a	56		 push	 esi
  0000b	ff 76 04	 push	 DWORD PTR [esi+4]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAXPAUSMeshData@CEffectMeshScript@@QAU12@AAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshScript::SMeshData> >

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00014	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00017	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  0001c	8b 3e		 mov	 edi, DWORD PTR [esi]

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00021	2b cf		 sub	 ecx, edi
  00023	f7 e9		 imul	 ecx
  00025	03 d1		 add	 edx, ecx
  00027	c1 fa 05	 sar	 edx, 5
  0002a	8b c2		 mov	 eax, edx
  0002c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002f	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00031	8b c8		 mov	 ecx, eax
  00033	c1 e1 04	 shl	 ecx, 4
  00036	2b c8		 sub	 ecx, eax
  00038	c1 e1 02	 shl	 ecx, 2

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0003b	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00041	72 12		 jb	 SHORT $LN22@vector

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00043	8b 57 fc	 mov	 edx, DWORD PTR [edi-4]
  00046	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00049	2b fa		 sub	 edi, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004b	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  0004e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00051	77 23		 ja	 SHORT $LN19@vector

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00053	8b fa		 mov	 edi, edx
$LN22@vector:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00055	51		 push	 ecx
  00056	57		 push	 edi
  00057	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0005c	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  0005f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1768 :             _Mylast  = nullptr;

  00065	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1769 :             _Myend   = nullptr;

  0006c	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00073	5f		 pop	 edi
$LN4@vector:
  00074	5e		 pop	 esi

; 717  :     }

  00075	c3		 ret	 0
$LN19@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00076	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN27@vector:
  0007b	cc		 int	 3
??1?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@QAE@XZ ENDP ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::~vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\TextFileLoader.h
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\TextFileLoader.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\extern\include\d3dx8math.inl
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\TextFileLoader.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\TextFileLoader.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\TextFileLoader.h
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z
_TEXT	SEGMENT
_dwMeshElementCount$ = -100				; size = 4
__Left$1$ = -96						; size = 4
__Right_size$1$ = -92					; size = 4
_GotoChild$2 = -92					; size = 4
_this$GSCopy$1$ = -88					; size = 4
__Ptr$1$ = -84						; size = 4
__Result$1$ = -80					; size = 4
_i$1$ = -80						; size = 4
$T3 = -80						; size = 4
__New_size$1$ = -76					; size = 4
tv4800 = -76						; size = 4
__My_data$2$ = -72					; size = 4
__New_capacity$1$ = -72					; size = 4
$T4 = -65						; size = 1
$T5 = -65						; size = 1
$T6 = -65						; size = 1
$T7 = -65						; size = 1
$T8 = -65						; size = 1
$T9 = -65						; size = 1
$T10 = -65						; size = 1
$T11 = -65						; size = 1
$T12 = -65						; size = 1
$T13 = -65						; size = 1
$T14 = -65						; size = 1
$T15 = -65						; size = 1
$T16 = -65						; size = 1
$T17 = -64						; size = 24
$T18 = -64						; size = 24
$T19 = -64						; size = 24
$T20 = -64						; size = 24
$T21 = -64						; size = 24
$T22 = -64						; size = 24
$T23 = -40						; size = 24
$T24 = -40						; size = 24
$T25 = -40						; size = 24
$T26 = -40						; size = 24
$T27 = -40						; size = 24
$T28 = -40						; size = 24
$T29 = -40						; size = 24
$T30 = -40						; size = 24
$T31 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_rTextFileLoader$ = 8					; size = 4
?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z PROC ; CEffectMeshScript::OnLoadScript, COMDAT
; _this$ = ecx

; 606  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 58	 sub	 esp, 88			; 00000058H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d a8	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0002d	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0N@KFLKANCO@meshfilename@
  00035	a1 08 00 00 00	 mov	 eax, DWORD PTR ??_C@_0N@KFLKANCO@meshfilename@+8
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 606  : {

  0003a	8b 75 08	 mov	 esi, DWORD PTR _rTextFileLoader$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0003d	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR $T22[ebp+20], 15 ; 0000000fH

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  00044	c7 45 d0 0c 00
	00 00		 mov	 DWORD PTR $T22[ebp+16], 12 ; 0000000cH

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0004b	66 0f d6 45 c0	 movq	 QWORD PTR $T22[ebp], xmm0
  00050	89 45 c8	 mov	 DWORD PTR $T22[ebp+8], eax

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00053	c6 45 cc 00	 mov	 BYTE PTR $T22[ebp+12], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 607  : 	if (rTextFileLoader.GetTokenString("meshfilename", &m_strMeshFileName))

  00057	8d 79 2c	 lea	 edi, DWORD PTR [ecx+44]
  0005a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00061	57		 push	 edi
  00062	8d 45 c0	 lea	 eax, DWORD PTR $T22[ebp]
  00065	8b ce		 mov	 ecx, esi
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 ?GetTokenString@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV23@@Z ; CTextFileLoader::GetTokenString
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0006d	8b 55 d4	 mov	 edx, DWORD PTR $T22[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 607  : 	if (rTextFileLoader.GetTokenString("meshfilename", &m_strMeshFileName))

  00070	89 45 b0	 mov	 DWORD PTR $T3[ebp], eax
  00073	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0007a	83 fa 10	 cmp	 edx, 16			; 00000010H
  0007d	72 2f		 jb	 SHORT $LN129@OnLoadScri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0007f	8b 4d c0	 mov	 ecx, DWORD PTR $T22[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00082	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00085	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0008b	72 14		 jb	 SHORT $LN139@OnLoadScri

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0008d	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00090	83 c2 23	 add	 edx, 35			; 00000023H
  00093	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00095	83 c0 fc	 add	 eax, -4			; fffffffcH
  00098	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0009b	0f 87 ed 09 00
	00		 ja	 $LN540@OnLoadScri
$LN139@OnLoadScri:

; 264  :         ::operator delete(_Ptr, _Bytes);

  000a1	52		 push	 edx
  000a2	51		 push	 ecx
  000a3	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000a8	8b 45 b0	 mov	 eax, DWORD PTR $T3[ebp]
  000ab	83 c4 08	 add	 esp, 8
$LN129@OnLoadScri:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 607  : 	if (rTextFileLoader.GetTokenString("meshfilename", &m_strMeshFileName))

  000ae	85 c0		 test	 eax, eax
  000b0	0f 84 b9 09 00
	00		 je	 $LN5@OnLoadScri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2306 :         if (_Large_string_engaged()) {

  000b6	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  000ba	8b c7		 mov	 eax, edi
  000bc	72 02		 jb	 SHORT $LN1099@OnLoadScri

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  000be	8b 07		 mov	 eax, DWORD PTR [edi]
$LN1099@OnLoadScri:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 609  : 		if (!IsGlobalFileName(m_strMeshFileName.c_str()))

  000c0	50		 push	 eax
  000c1	e8 00 00 00 00	 call	 ?IsGlobalFileName@@YA_NPBD@Z ; IsGlobalFileName
  000c6	83 c4 04	 add	 esp, 4
  000c9	84 c0		 test	 al, al
  000cb	0f 85 96 01 00
	00		 jne	 $LN252@OnLoadScri

; 611  : 			m_strMeshFileName = GetOnlyPathName(rTextFileLoader.GetFileName()) + m_strMeshFileName;

  000d1	8b ce		 mov	 ecx, esi
  000d3	e8 00 00 00 00	 call	 ?GetFileName@CTextFileLoader@@QAEPBDXZ ; CTextFileLoader::GetFileName
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 ?GetOnlyPathName@@YAPBDPBD@Z ; GetOnlyPathName
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  000de	8b f8		 mov	 edi, eax
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 611  : 			m_strMeshFileName = GetOnlyPathName(rTextFileLoader.GetFileName()) + m_strMeshFileName;

  000e0	89 45 a0	 mov	 DWORD PTR __Left$1$[ebp], eax
  000e3	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  000e6	8d 57 01	 lea	 edx, DWORD PTR [edi+1]
  000e9	0f 1f 80 00 00
	00 00		 npad	 7
$LL1103@OnLoadScri:
  000f0	8a 0f		 mov	 cl, BYTE PTR [edi]
  000f2	47		 inc	 edi
  000f3	84 c9		 test	 cl, cl
  000f5	75 f9		 jne	 SHORT $LL1103@OnLoadScri

; 4701 :     const auto _Right_size = _Right.size();

  000f7	8b 4d a8	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  000fa	2b fa		 sub	 edi, edx

; 4701 :     const auto _Right_size = _Right.size();

  000fc	83 c1 2c	 add	 ecx, 44			; 0000002cH

; 4702 :     if (_Right.max_size() - _Right_size < _Left_size) {

  000ff	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00104	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00107	2b c2		 sub	 eax, edx
  00109	89 55 a4	 mov	 DWORD PTR __Right_size$1$[ebp], edx
  0010c	3b c7		 cmp	 eax, edi
  0010e	0f 82 7f 09 00
	00		 jb	 $LN1108@OnLoadScri

; 2306 :         if (_Large_string_engaged()) {

  00114	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00118	89 4d b0	 mov	 DWORD PTR __Result$1$[ebp], ecx
  0011b	72 05		 jb	 SHORT $LN1100@OnLoadScri

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  0011d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0011f	89 45 b0	 mov	 DWORD PTR __Result$1$[ebp], eax
$LN1100@OnLoadScri:

; 2635 :         const auto _New_size    = static_cast<size_type>(_Left_size + _Right_size);

  00122	03 d7		 add	 edx, edi

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00124	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR $T21[ebp], 0

; 2636 :         size_type _New_capacity = _BUF_SIZE - 1;

  0012b	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH
  00130	89 55 b4	 mov	 DWORD PTR __New_size$1$[ebp], edx

; 2637 :         auto& _My_data          = _Mypair._Myval2;
; 2638 :         _Elem* _Ptr             = _My_data._Bx._Buf;

  00133	8d 4d c0	 lea	 ecx, DWORD PTR $T21[ebp]
  00136	89 4d ac	 mov	 DWORD PTR __Ptr$1$[ebp], ecx

; 2639 :         auto&& _Alproxy         = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2640 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws
; 2641 : 
; 2642 : #ifdef __cpp_lib_constexpr_string
; 2643 :         const bool _Activate_large_mode = _New_capacity < _New_size || _STD is_constant_evaluated();
; 2644 : #else // ^^^ __cpp_lib_constexpr_string / !__cpp_lib_constexpr_string vvv
; 2645 :         const bool _Activate_large_mode = _New_capacity < _New_size;
; 2646 : #endif // __cpp_lib_constexpr_string
; 2647 : 
; 2648 :         if (_Activate_large_mode) {

  00139	3b d0		 cmp	 edx, eax
  0013b	76 67		 jbe	 SHORT $LN166@OnLoadScri

; 2649 :             // we should never allocate less than _BUF_SIZE space (_New_size could be small if constant evaluated)
; 2650 :             const size_type _Requested_size = (_STD max)(_New_size, _BUF_SIZE);

  0013d	8b c2		 mov	 eax, edx

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0013f	83 c8 0f	 or	 eax, 15			; 0000000fH
  00142	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH

; 4489 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00147	76 0e		 jbe	 SHORT $LN179@OnLoadScri

; 4490 :             return _Max;

  00149	c7 45 b8 ff ff
	ff 7f		 mov	 DWORD PTR __New_capacity$1$[ebp], 2147483647 ; 7fffffffH
  00150	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  00155	eb 18		 jmp	 SHORT $LN1101@OnLoadScri
$LN179@OnLoadScri:

; 4491 :         }
; 4492 : 
; 4493 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4494 :             return _Max;
; 4495 :         }
; 4496 : 
; 4497 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00157	b9 16 00 00 00	 mov	 ecx, 22			; 00000016H
  0015c	3b c1		 cmp	 eax, ecx
  0015e	0f 42 c1	 cmovb	 eax, ecx
  00161	89 45 b8	 mov	 DWORD PTR __New_capacity$1$[ebp], eax

; 2652 :             const pointer _Fancyptr         = _Getal().allocate(_New_capacity + 1); // throws

  00164	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00167	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0016d	72 13		 jb	 SHORT $LN187@OnLoadScri
$LN1101@OnLoadScri:

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0016f	51		 push	 ecx
  00170	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00175	8b 55 b4	 mov	 edx, DWORD PTR __New_size$1$[ebp]
  00178	8b c8		 mov	 ecx, eax
  0017a	8b 45 b8	 mov	 eax, DWORD PTR __New_capacity$1$[ebp]
  0017d	83 c4 04	 add	 esp, 4
  00180	eb 1c		 jmp	 SHORT $LN1106@OnLoadScri
$LN187@OnLoadScri:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  00182	85 c9		 test	 ecx, ecx
  00184	74 16		 je	 SHORT $LN188@OnLoadScri

; 85   :         return ::operator new(_Bytes);

  00186	51		 push	 ecx
  00187	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 244  :         return _Traits::_Allocate(_Bytes);

  0018c	8b 55 b4	 mov	 edx, DWORD PTR __New_size$1$[ebp]
  0018f	8b c8		 mov	 ecx, eax
  00191	89 45 ac	 mov	 DWORD PTR __Ptr$1$[ebp], eax

; 85   :         return ::operator new(_Bytes);

  00194	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  00197	8b 45 b8	 mov	 eax, DWORD PTR __New_capacity$1$[ebp]
  0019a	eb 05		 jmp	 SHORT $LN186@OnLoadScri
$LN188@OnLoadScri:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  0019c	33 c9		 xor	 ecx, ecx
$LN1106@OnLoadScri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2654 :             _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);

  0019e	89 4d ac	 mov	 DWORD PTR __Ptr$1$[ebp], ecx
$LN186@OnLoadScri:
  001a1	89 4d c0	 mov	 DWORD PTR $T21[ebp], ecx
$LN166@OnLoadScri:

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  001a4	57		 push	 edi
  001a5	ff 75 a0	 push	 DWORD PTR __Left$1$[ebp]

; 2663 :         _My_data._Mysize = _New_size;

  001a8	89 55 d0	 mov	 DWORD PTR $T21[ebp+16], edx

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  001ab	51		 push	 ecx

; 2664 :         _My_data._Myres  = _New_capacity;

  001ac	89 45 d4	 mov	 DWORD PTR $T21[ebp+20], eax

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  001af	e8 00 00 00 00	 call	 _memcpy
  001b4	ff 75 a4	 push	 DWORD PTR __Right_size$1$[ebp]

; 2666 :         _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);

  001b7	8b 45 ac	 mov	 eax, DWORD PTR __Ptr$1$[ebp]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  001ba	ff 75 b0	 push	 DWORD PTR __Result$1$[ebp]

; 2666 :         _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);

  001bd	03 c7		 add	 eax, edi

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  001bf	50		 push	 eax
  001c0	e8 00 00 00 00	 call	 _memcpy

; 2667 :         _Traits::assign(_Ptr[_New_size], _Elem());

  001c5	8b 4d b4	 mov	 ecx, DWORD PTR __New_size$1$[ebp]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  001c8	83 c4 18	 add	 esp, 24			; 00000018H

; 2667 :         _Traits::assign(_Ptr[_New_size], _Elem());

  001cb	8b 45 ac	 mov	 eax, DWORD PTR __Ptr$1$[ebp]

; 2850 :         if (this != _STD addressof(_Right)) {

  001ce	8b 7d a8	 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  001d1	83 c7 2c	 add	 edi, 44			; 0000002cH

; 2667 :         _Traits::assign(_Ptr[_New_size], _Elem());

  001d4	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 2850 :         if (this != _STD addressof(_Right)) {

  001d8	8d 4d c0	 lea	 ecx, DWORD PTR $T21[ebp]
  001db	3b f9		 cmp	 edi, ecx
  001dd	74 54		 je	 SHORT $LN238@OnLoadScri

; 2319 :         return _BUF_SIZE <= _Myres;

  001df	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  001e2	83 f9 10	 cmp	 ecx, 16			; 00000010H
  001e5	72 2b		 jb	 SHORT $LN210@OnLoadScri

; 4619 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  001e7	8b 07		 mov	 eax, DWORD PTR [edi]

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  001e9	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  001ea	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  001f0	72 16		 jb	 SHORT $LN220@OnLoadScri

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001f2	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  001f5	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  001f8	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001fa	83 c0 fc	 add	 eax, -4			; fffffffcH
  001fd	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00200	0f 87 92 08 00
	00		 ja	 $LN259@OnLoadScri

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00206	8b c2		 mov	 eax, edx
$LN220@OnLoadScri:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00208	51		 push	 ecx
  00209	50		 push	 eax
  0020a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0020f	83 c4 08	 add	 esp, 8
$LN210@OnLoadScri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00212	0f 10 45 c0	 movups	 xmm0, XMMWORD PTR $T21[ebp]

; 4633 :             _Mypair._Myval2._Mysize = 0;

  00216	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0021d	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00224	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
  00227	f3 0f 7e 45 d0	 movq	 xmm0, QWORD PTR $T21[ebp+16]
  0022c	66 0f d6 47 10	 movq	 QWORD PTR [edi+16], xmm0

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00231	eb 34		 jmp	 SHORT $LN252@OnLoadScri
$LN238@OnLoadScri:
  00233	8b 55 d4	 mov	 edx, DWORD PTR $T21[ebp+20]
  00236	83 fa 10	 cmp	 edx, 16			; 00000010H
  00239	72 2c		 jb	 SHORT $LN252@OnLoadScri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0023b	8b 4d c0	 mov	 ecx, DWORD PTR $T21[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0023e	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0023f	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00241	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00247	72 14		 jb	 SHORT $LN262@OnLoadScri

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00249	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0024c	83 c2 23	 add	 edx, 35			; 00000023H
  0024f	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00251	83 c0 fc	 add	 eax, -4			; fffffffcH
  00254	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00257	0f 87 3b 08 00
	00		 ja	 $LN259@OnLoadScri
$LN262@OnLoadScri:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0025d	52		 push	 edx
  0025e	51		 push	 ecx
  0025f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00264	83 c4 08	 add	 esp, 8
$LN252@OnLoadScri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00267	6a 17		 push	 23			; 00000017H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00269	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T31[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00270	8d 4d d8	 lea	 ecx, DWORD PTR $T31[ebp]
  00273	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@HOBONKKC@meshanimationloopenable@

; 4596 :         _My_data._Mysize = 0;

  00278	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T31[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0027f	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T31[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00286	c6 45 d8 00	 mov	 BYTE PTR $T31[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0028a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 619  : 	if (!rTextFileLoader.GetTokenInteger("meshanimationloopenable", &m_isMeshAnimationLoop))

  0028f	8b 7d a8	 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  00292	8b ce		 mov	 ecx, esi
  00294	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0029b	8d 47 14	 lea	 eax, DWORD PTR [edi+20]
  0029e	50		 push	 eax
  0029f	8d 45 d8	 lea	 eax, DWORD PTR $T31[ebp]
  002a2	50		 push	 eax
  002a3	e8 00 00 00 00	 call	 ?GetTokenInteger@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z ; CTextFileLoader::GetTokenInteger
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  002a8	8b 55 ec	 mov	 edx, DWORD PTR $T31[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 619  : 	if (!rTextFileLoader.GetTokenInteger("meshanimationloopenable", &m_isMeshAnimationLoop))

  002ab	85 c0		 test	 eax, eax
  002ad	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  002b4	0f 94 c0	 sete	 al
  002b7	88 45 bf	 mov	 BYTE PTR $T16[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  002ba	83 fa 10	 cmp	 edx, 16			; 00000010H
  002bd	72 2f		 jb	 SHORT $LN295@OnLoadScri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002bf	8b 4d d8	 mov	 ecx, DWORD PTR $T31[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  002c2	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002c3	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  002c5	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  002cb	72 14		 jb	 SHORT $LN305@OnLoadScri

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  002cd	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  002d0	83 c2 23	 add	 edx, 35			; 00000023H
  002d3	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  002d5	83 c0 fc	 add	 eax, -4			; fffffffcH
  002d8	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  002db	0f 87 bc 07 00
	00		 ja	 $LN1109@OnLoadScri
$LN305@OnLoadScri:

; 264  :         ::operator delete(_Ptr, _Bytes);

  002e1	52		 push	 edx
  002e2	51		 push	 ecx
  002e3	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  002e8	8a 45 bf	 mov	 al, BYTE PTR $T16[ebp]
  002eb	83 c4 08	 add	 esp, 8
$LN295@OnLoadScri:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 619  : 	if (!rTextFileLoader.GetTokenInteger("meshanimationloopenable", &m_isMeshAnimationLoop))

  002ee	84 c0		 test	 al, al
  002f0	0f 85 79 07 00
	00		 jne	 $LN5@OnLoadScri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  002f6	6a 16		 push	 22			; 00000016H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  002f8	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T30[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  002ff	8d 4d d8	 lea	 ecx, DWORD PTR $T30[ebp]
  00302	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@CNDNOBIC@meshanimationloopcount@

; 4596 :         _My_data._Mysize = 0;

  00307	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T30[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0030e	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T30[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00315	88 45 d8	 mov	 BYTE PTR $T30[ebp], al

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00318	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 621  : 	if (!rTextFileLoader.GetTokenInteger("meshanimationloopcount", &m_iMeshAnimationLoopCount))

  0031d	83 c7 18	 add	 edi, 24			; 00000018H
  00320	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00327	57		 push	 edi
  00328	8d 45 d8	 lea	 eax, DWORD PTR $T30[ebp]
  0032b	8b ce		 mov	 ecx, esi
  0032d	50		 push	 eax
  0032e	e8 00 00 00 00	 call	 ?GetTokenInteger@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z ; CTextFileLoader::GetTokenInteger
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00333	8b 55 ec	 mov	 edx, DWORD PTR $T30[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 621  : 	if (!rTextFileLoader.GetTokenInteger("meshanimationloopcount", &m_iMeshAnimationLoopCount))

  00336	85 c0		 test	 eax, eax
  00338	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0033f	0f 94 c0	 sete	 al
  00342	88 45 bf	 mov	 BYTE PTR $T15[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00345	83 fa 10	 cmp	 edx, 16			; 00000010H
  00348	72 2f		 jb	 SHORT $LN338@OnLoadScri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0034a	8b 4d d8	 mov	 ecx, DWORD PTR $T30[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0034d	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0034e	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00350	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00356	72 14		 jb	 SHORT $LN348@OnLoadScri

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00358	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0035b	83 c2 23	 add	 edx, 35			; 00000023H
  0035e	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00360	83 c0 fc	 add	 eax, -4			; fffffffcH
  00363	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00366	0f 87 36 07 00
	00		 ja	 $LN1110@OnLoadScri
$LN348@OnLoadScri:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0036c	52		 push	 edx
  0036d	51		 push	 ecx
  0036e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00373	8a 45 bf	 mov	 al, BYTE PTR $T15[ebp]
  00376	83 c4 08	 add	 esp, 8
$LN338@OnLoadScri:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 621  : 	if (!rTextFileLoader.GetTokenInteger("meshanimationloopcount", &m_iMeshAnimationLoopCount))

  00379	84 c0		 test	 al, al
  0037b	74 06		 je	 SHORT $LN9@OnLoadScri

; 622  : 	{
; 623  : 		m_iMeshAnimationLoopCount = 0;

  0037d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN9@OnLoadScri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00383	6a 17		 push	 23			; 00000017H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00385	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T29[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0038c	8d 4d d8	 lea	 ecx, DWORD PTR $T29[ebp]
  0038f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@DLPGELIN@meshanimationframedelay@

; 4596 :         _My_data._Mysize = 0;

  00394	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T29[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0039b	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T29[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  003a2	c6 45 d8 00	 mov	 BYTE PTR $T29[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  003a6	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 625  : 	if (!rTextFileLoader.GetTokenFloat("meshanimationframedelay", &m_fMeshAnimationFrameDelay))

  003ab	8b 7d a8	 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  003ae	8b ce		 mov	 ecx, esi
  003b0	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  003b7	8d 47 1c	 lea	 eax, DWORD PTR [edi+28]
  003ba	50		 push	 eax
  003bb	8d 45 d8	 lea	 eax, DWORD PTR $T29[ebp]
  003be	50		 push	 eax
  003bf	e8 00 00 00 00	 call	 ?GetTokenFloat@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM@Z ; CTextFileLoader::GetTokenFloat
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  003c4	8b 55 ec	 mov	 edx, DWORD PTR $T29[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 625  : 	if (!rTextFileLoader.GetTokenFloat("meshanimationframedelay", &m_fMeshAnimationFrameDelay))

  003c7	85 c0		 test	 eax, eax
  003c9	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003d0	0f 94 c0	 sete	 al
  003d3	88 45 bf	 mov	 BYTE PTR $T14[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  003d6	83 fa 10	 cmp	 edx, 16			; 00000010H
  003d9	72 2f		 jb	 SHORT $LN381@OnLoadScri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003db	8b 4d d8	 mov	 ecx, DWORD PTR $T29[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  003de	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003df	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  003e1	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  003e7	72 14		 jb	 SHORT $LN391@OnLoadScri

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  003e9	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  003ec	83 c2 23	 add	 edx, 35			; 00000023H
  003ef	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003f1	83 c0 fc	 add	 eax, -4			; fffffffcH
  003f4	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  003f7	0f 87 aa 06 00
	00		 ja	 $LN1111@OnLoadScri
$LN391@OnLoadScri:

; 264  :         ::operator delete(_Ptr, _Bytes);

  003fd	52		 push	 edx
  003fe	51		 push	 ecx
  003ff	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00404	8a 45 bf	 mov	 al, BYTE PTR $T14[ebp]
  00407	83 c4 08	 add	 esp, 8
$LN381@OnLoadScri:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 625  : 	if (!rTextFileLoader.GetTokenFloat("meshanimationframedelay", &m_fMeshAnimationFrameDelay))

  0040a	84 c0		 test	 al, al
  0040c	0f 85 5d 06 00
	00		 jne	 $LN5@OnLoadScri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00412	6a 10		 push	 16			; 00000010H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00414	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T28[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0041b	8d 4d d8	 lea	 ecx, DWORD PTR $T28[ebp]
  0041e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IMKDGDDP@meshelementcount@

; 4596 :         _My_data._Mysize = 0;

  00423	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T28[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0042a	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T28[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00431	88 45 d8	 mov	 BYTE PTR $T28[ebp], al

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00434	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 629  : 	if (!rTextFileLoader.GetTokenDoubleWord("meshelementcount", &dwMeshElementCount))

  00439	8d 45 9c	 lea	 eax, DWORD PTR _dwMeshElementCount$[ebp]
  0043c	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4
  00443	50		 push	 eax
  00444	8d 45 d8	 lea	 eax, DWORD PTR $T28[ebp]
  00447	8b ce		 mov	 ecx, esi
  00449	50		 push	 eax
  0044a	e8 00 00 00 00	 call	 ?GetTokenDoubleWord@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAK@Z ; CTextFileLoader::GetTokenDoubleWord
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0044f	8b 55 ec	 mov	 edx, DWORD PTR $T28[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 629  : 	if (!rTextFileLoader.GetTokenDoubleWord("meshelementcount", &dwMeshElementCount))

  00452	85 c0		 test	 eax, eax
  00454	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0045b	0f 94 c0	 sete	 al
  0045e	88 45 bf	 mov	 BYTE PTR $T13[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00461	83 fa 10	 cmp	 edx, 16			; 00000010H
  00464	72 2f		 jb	 SHORT $LN424@OnLoadScri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00466	8b 4d d8	 mov	 ecx, DWORD PTR $T28[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00469	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0046a	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0046c	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00472	72 14		 jb	 SHORT $LN434@OnLoadScri

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00474	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00477	83 c2 23	 add	 edx, 35			; 00000023H
  0047a	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0047c	83 c0 fc	 add	 eax, -4			; fffffffcH
  0047f	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00482	0f 87 24 06 00
	00		 ja	 $LN1112@OnLoadScri
$LN434@OnLoadScri:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00488	52		 push	 edx
  00489	51		 push	 ecx
  0048a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0048f	8a 45 bf	 mov	 al, BYTE PTR $T13[ebp]
  00492	83 c4 08	 add	 esp, 8
$LN424@OnLoadScri:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 629  : 	if (!rTextFileLoader.GetTokenDoubleWord("meshelementcount", &dwMeshElementCount))

  00495	84 c0		 test	 al, al
  00497	0f 85 d2 05 00
	00		 jne	 $LN5@OnLoadScri

; 632  : 	m_MeshDataVector.clear();

  0049d	83 c7 20	 add	 edi, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  004a0	57		 push	 edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 632  : 	m_MeshDataVector.clear();

  004a1	89 7d b8	 mov	 DWORD PTR __My_data$2$[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  004a4	ff 77 04	 push	 DWORD PTR [edi+4]
  004a7	ff 37		 push	 DWORD PTR [edi]
  004a9	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAXPAUSMeshData@CEffectMeshScript@@QAU12@AAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshScript::SMeshData> >

; 1456 :         _Mylast = _Myfirst;

  004ae	8b 07		 mov	 eax, DWORD PTR [edi]

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  004b0	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 633  : 	m_MeshDataVector.resize(dwMeshElementCount);

  004b3	8b cf		 mov	 ecx, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1456 :         _Mylast = _Myfirst;

  004b5	89 47 04	 mov	 DWORD PTR [edi+4], eax
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 633  : 	m_MeshDataVector.resize(dwMeshElementCount);

  004b8	ff 75 9c	 push	 DWORD PTR _dwMeshElementCount$[ebp]
  004bb	e8 00 00 00 00	 call	 ?resize@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@QAEXI@Z ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::resize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  004c0	8b 45 b8	 mov	 eax, DWORD PTR __My_data$2$[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 634  : 	for (DWORD i = 0; i < m_MeshDataVector.size(); ++i)

  004c3	33 ff		 xor	 edi, edi
  004c5	89 7d b0	 mov	 DWORD PTR _i$1$[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  004c8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  004cb	2b 08		 sub	 ecx, DWORD PTR [eax]
  004cd	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  004d2	f7 e9		 imul	 ecx
  004d4	03 d1		 add	 edx, ecx
  004d6	c1 fa 05	 sar	 edx, 5
  004d9	8b c2		 mov	 eax, edx
  004db	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  004de	03 c2		 add	 eax, edx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 634  : 	for (DWORD i = 0; i < m_MeshDataVector.size(); ++i)

  004e0	0f 84 74 05 00
	00		 je	 $LN3@OnLoadScri
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\TextFileLoader.h

; 49   : 			CGotoChild(CTextFileLoader * pOwner, DWORD dwIndex) : m_pOwner(pOwner)

  004e6	89 75 a4	 mov	 DWORD PTR _GotoChild$2[ebp], esi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 632  : 	m_MeshDataVector.clear();

  004e9	89 7d b4	 mov	 DWORD PTR tv4800[ebp], edi
  004ec	0f 1f 40 00	 npad	 4
$LL4@OnLoadScri:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\TextFileLoader.h

; 51   : 				m_pOwner->SetChildNode(dwIndex);

  004f0	57		 push	 edi
  004f1	8b ce		 mov	 ecx, esi
  004f3	e8 00 00 00 00	 call	 ?SetChildNode@CTextFileLoader@@QAEHK@Z ; CTextFileLoader::SetChildNode
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  004f8	8b 7d b8	 mov	 edi, DWORD PTR __My_data$2$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  004fb	a1 08 00 00 00	 mov	 eax, DWORD PTR ??_C@_0O@EJACNAIE@billboardtype@+8
  00500	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0O@EJACNAIE@billboardtype@
  00508	89 45 c8	 mov	 DWORD PTR $T20[ebp+8], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  0050b	8b 3f		 mov	 edi, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0050d	a0 0c 00 00 00	 mov	 al, BYTE PTR ??_C@_0O@EJACNAIE@billboardtype@+12
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  00512	03 7d b4	 add	 edi, DWORD PTR tv4800[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 636  : 		CTextFileLoader::CGotoChild GotoChild(&rTextFileLoader, i);

  00515	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0051c	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR $T20[ebp+20], 15 ; 0000000fH

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  00523	c7 45 d0 0d 00
	00 00		 mov	 DWORD PTR $T20[ebp+16], 13 ; 0000000dH

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0052a	66 0f d6 45 c0	 movq	 QWORD PTR $T20[ebp], xmm0
  0052f	88 45 cc	 mov	 BYTE PTR $T20[ebp+12], al

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00532	c6 45 cd 00	 mov	 BYTE PTR $T20[ebp+13], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 640  : 		if (!rTextFileLoader.GetTokenByte("billboardtype", &rMeshData.byBillboardType))

  00536	57		 push	 edi
  00537	8d 45 c0	 lea	 eax, DWORD PTR $T20[ebp]
  0053a	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  0053e	50		 push	 eax
  0053f	8b ce		 mov	 ecx, esi
  00541	e8 00 00 00 00	 call	 ?GetTokenByte@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE@Z ; CTextFileLoader::GetTokenByte
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00546	8b 55 d4	 mov	 edx, DWORD PTR $T20[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 640  : 		if (!rTextFileLoader.GetTokenByte("billboardtype", &rMeshData.byBillboardType))

  00549	85 c0		 test	 eax, eax
  0054b	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0054f	0f 94 c0	 sete	 al
  00552	88 45 bf	 mov	 BYTE PTR $T12[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00555	83 fa 10	 cmp	 edx, 16			; 00000010H
  00558	72 2f		 jb	 SHORT $LN533@OnLoadScri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0055a	8b 4d c0	 mov	 ecx, DWORD PTR $T20[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0055d	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0055e	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00560	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00566	72 14		 jb	 SHORT $LN543@OnLoadScri

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00568	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0056b	83 c2 23	 add	 edx, 35			; 00000023H
  0056e	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00570	83 c0 fc	 add	 eax, -4			; fffffffcH
  00573	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00576	0f 87 12 05 00
	00		 ja	 $LN540@OnLoadScri
$LN543@OnLoadScri:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0057c	52		 push	 edx
  0057d	51		 push	 ecx
  0057e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00583	8a 45 bf	 mov	 al, BYTE PTR $T12[ebp]
  00586	83 c4 08	 add	 esp, 8
$LN533@OnLoadScri:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 640  : 		if (!rTextFileLoader.GetTokenByte("billboardtype", &rMeshData.byBillboardType))

  00589	84 c0		 test	 al, al
  0058b	0f 85 d0 04 00
	00		 jne	 $LN1092@OnLoadScri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00591	a1 08 00 00 00	 mov	 eax, DWORD PTR ??_C@_0P@LCDJDIBK@blendingenable@+8
  00596	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0P@LCDJDIBK@blendingenable@
  0059e	89 45 c8	 mov	 DWORD PTR $T19[ebp+8], eax
  005a1	66 a1 0c 00 00
	00		 mov	 ax, WORD PTR ??_C@_0P@LCDJDIBK@blendingenable@+12

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  005a7	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR $T19[ebp+20], 15 ; 0000000fH

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  005ae	c7 45 d0 0e 00
	00 00		 mov	 DWORD PTR $T19[ebp+16], 14 ; 0000000eH

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  005b5	66 0f d6 45 c0	 movq	 QWORD PTR $T19[ebp], xmm0
  005ba	66 89 45 cc	 mov	 WORD PTR $T19[ebp+12], ax

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  005be	c6 45 ce 00	 mov	 BYTE PTR $T19[ebp+14], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 642  : 		if (!rTextFileLoader.GetTokenBoolean("blendingenable", &rMeshData.bBlendingEnable))

  005c2	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  005c5	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  005c9	50		 push	 eax
  005ca	8d 45 c0	 lea	 eax, DWORD PTR $T19[ebp]
  005cd	8b ce		 mov	 ecx, esi
  005cf	50		 push	 eax
  005d0	e8 00 00 00 00	 call	 ?GetTokenBoolean@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z ; CTextFileLoader::GetTokenBoolean
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  005d5	8b 55 d4	 mov	 edx, DWORD PTR $T19[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 642  : 		if (!rTextFileLoader.GetTokenBoolean("blendingenable", &rMeshData.bBlendingEnable))

  005d8	85 c0		 test	 eax, eax
  005da	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  005de	0f 94 c0	 sete	 al
  005e1	88 45 bf	 mov	 BYTE PTR $T11[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  005e4	83 fa 10	 cmp	 edx, 16			; 00000010H
  005e7	72 2f		 jb	 SHORT $LN635@OnLoadScri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  005e9	8b 4d c0	 mov	 ecx, DWORD PTR $T19[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  005ec	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  005ed	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  005ef	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  005f5	72 14		 jb	 SHORT $LN645@OnLoadScri

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  005f7	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  005fa	83 c2 23	 add	 edx, 35			; 00000023H
  005fd	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  005ff	83 c0 fc	 add	 eax, -4			; fffffffcH
  00602	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00605	0f 87 83 04 00
	00		 ja	 $LN540@OnLoadScri
$LN645@OnLoadScri:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0060b	52		 push	 edx
  0060c	51		 push	 ecx
  0060d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00612	8a 45 bf	 mov	 al, BYTE PTR $T11[ebp]
  00615	83 c4 08	 add	 esp, 8
$LN635@OnLoadScri:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 642  : 		if (!rTextFileLoader.GetTokenBoolean("blendingenable", &rMeshData.bBlendingEnable))

  00618	84 c0		 test	 al, al
  0061a	0f 85 41 04 00
	00		 jne	 $LN1092@OnLoadScri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00620	a1 08 00 00 00	 mov	 eax, DWORD PTR ??_C@_0BA@CALCJEKJ@blendingsrctype@+8
  00625	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0BA@CALCJEKJ@blendingsrctype@
  0062d	89 45 c8	 mov	 DWORD PTR $T18[ebp+8], eax
  00630	66 a1 0c 00 00
	00		 mov	 ax, WORD PTR ??_C@_0BA@CALCJEKJ@blendingsrctype@+12
  00636	66 89 45 cc	 mov	 WORD PTR $T18[ebp+12], ax
  0063a	a0 0e 00 00 00	 mov	 al, BYTE PTR ??_C@_0BA@CALCJEKJ@blendingsrctype@+14

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0063f	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR $T18[ebp+20], 15 ; 0000000fH

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  00646	c7 45 d0 0f 00
	00 00		 mov	 DWORD PTR $T18[ebp+16], 15 ; 0000000fH

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0064d	66 0f d6 45 c0	 movq	 QWORD PTR $T18[ebp], xmm0
  00652	88 45 ce	 mov	 BYTE PTR $T18[ebp+14], al

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00655	c6 45 cf 00	 mov	 BYTE PTR $T18[ebp+15], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 644  : 		if (!rTextFileLoader.GetTokenByte("blendingsrctype", &rMeshData.byBlendingSrcType))

  00659	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  0065c	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  00660	50		 push	 eax
  00661	8d 45 c0	 lea	 eax, DWORD PTR $T18[ebp]
  00664	8b ce		 mov	 ecx, esi
  00666	50		 push	 eax
  00667	e8 00 00 00 00	 call	 ?GetTokenByte@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE@Z ; CTextFileLoader::GetTokenByte
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0066c	8b 55 d4	 mov	 edx, DWORD PTR $T18[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 644  : 		if (!rTextFileLoader.GetTokenByte("blendingsrctype", &rMeshData.byBlendingSrcType))

  0066f	85 c0		 test	 eax, eax
  00671	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00675	0f 94 c0	 sete	 al
  00678	88 45 bf	 mov	 BYTE PTR $T10[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0067b	83 fa 10	 cmp	 edx, 16			; 00000010H
  0067e	72 2f		 jb	 SHORT $LN737@OnLoadScri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00680	8b 4d c0	 mov	 ecx, DWORD PTR $T18[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00683	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00684	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00686	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0068c	72 14		 jb	 SHORT $LN747@OnLoadScri

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0068e	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00691	83 c2 23	 add	 edx, 35			; 00000023H
  00694	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00696	83 c0 fc	 add	 eax, -4			; fffffffcH
  00699	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0069c	0f 87 ec 03 00
	00		 ja	 $LN540@OnLoadScri
$LN747@OnLoadScri:

; 264  :         ::operator delete(_Ptr, _Bytes);

  006a2	52		 push	 edx
  006a3	51		 push	 ecx
  006a4	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  006a9	8a 45 bf	 mov	 al, BYTE PTR $T10[ebp]
  006ac	83 c4 08	 add	 esp, 8
$LN737@OnLoadScri:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 644  : 		if (!rTextFileLoader.GetTokenByte("blendingsrctype", &rMeshData.byBlendingSrcType))

  006af	84 c0		 test	 al, al
  006b1	0f 85 aa 03 00
	00		 jne	 $LN1092@OnLoadScri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  006b7	6a 10		 push	 16			; 00000010H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  006b9	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T27[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  006c0	8d 4d d8	 lea	 ecx, DWORD PTR $T27[ebp]
  006c3	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@PBNEFHNO@blendingdesttype@

; 4596 :         _My_data._Mysize = 0;

  006c8	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T27[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  006cf	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T27[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  006d6	88 45 d8	 mov	 BYTE PTR $T27[ebp], al

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  006d9	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 646  : 		if (!rTextFileLoader.GetTokenByte("blendingdesttype", &rMeshData.byBlendingDestType))

  006de	8d 47 09	 lea	 eax, DWORD PTR [edi+9]
  006e1	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  006e5	50		 push	 eax
  006e6	8d 45 d8	 lea	 eax, DWORD PTR $T27[ebp]
  006e9	8b ce		 mov	 ecx, esi
  006eb	50		 push	 eax
  006ec	e8 00 00 00 00	 call	 ?GetTokenByte@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE@Z ; CTextFileLoader::GetTokenByte
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  006f1	8b 55 ec	 mov	 edx, DWORD PTR $T27[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 646  : 		if (!rTextFileLoader.GetTokenByte("blendingdesttype", &rMeshData.byBlendingDestType))

  006f4	85 c0		 test	 eax, eax
  006f6	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  006fa	0f 94 c0	 sete	 al
  006fd	88 45 bf	 mov	 BYTE PTR $T9[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00700	83 fa 10	 cmp	 edx, 16			; 00000010H
  00703	72 2f		 jb	 SHORT $LN783@OnLoadScri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00705	8b 4d d8	 mov	 ecx, DWORD PTR $T27[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00708	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00709	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0070b	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00711	72 14		 jb	 SHORT $LN793@OnLoadScri

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00713	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00716	83 c2 23	 add	 edx, 35			; 00000023H
  00719	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0071b	83 c0 fc	 add	 eax, -4			; fffffffcH
  0071e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00721	0f 87 67 03 00
	00		 ja	 $LN540@OnLoadScri
$LN793@OnLoadScri:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00727	52		 push	 edx
  00728	51		 push	 ecx
  00729	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0072e	8a 45 bf	 mov	 al, BYTE PTR $T9[ebp]
  00731	83 c4 08	 add	 esp, 8
$LN783@OnLoadScri:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 646  : 		if (!rTextFileLoader.GetTokenByte("blendingdesttype", &rMeshData.byBlendingDestType))

  00734	84 c0		 test	 al, al
  00736	0f 85 25 03 00
	00		 jne	 $LN1092@OnLoadScri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0073c	6a 1a		 push	 26			; 0000001aH

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0073e	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T26[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00745	8d 4d d8	 lea	 ecx, DWORD PTR $T26[ebp]
  00748	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@INILLDMC@textureanimationloopenable@

; 4596 :         _My_data._Mysize = 0;

  0074d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T26[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00754	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T26[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0075b	88 45 d8	 mov	 BYTE PTR $T26[ebp], al

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0075e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 649  : 		if (!rTextFileLoader.GetTokenBoolean("textureanimationloopenable", &rMeshData.bTextureAnimationLoopEnable))

  00763	8d 47 24	 lea	 eax, DWORD PTR [edi+36]
  00766	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  0076a	50		 push	 eax
  0076b	8d 45 d8	 lea	 eax, DWORD PTR $T26[ebp]
  0076e	8b ce		 mov	 ecx, esi
  00770	50		 push	 eax
  00771	e8 00 00 00 00	 call	 ?GetTokenBoolean@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z ; CTextFileLoader::GetTokenBoolean
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00776	8b 55 ec	 mov	 edx, DWORD PTR $T26[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 649  : 		if (!rTextFileLoader.GetTokenBoolean("textureanimationloopenable", &rMeshData.bTextureAnimationLoopEnable))

  00779	85 c0		 test	 eax, eax
  0077b	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0077f	0f 94 c0	 sete	 al
  00782	88 45 bf	 mov	 BYTE PTR $T8[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00785	83 fa 10	 cmp	 edx, 16			; 00000010H
  00788	72 2f		 jb	 SHORT $LN829@OnLoadScri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0078a	8b 4d d8	 mov	 ecx, DWORD PTR $T26[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0078d	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0078e	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00790	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00796	72 14		 jb	 SHORT $LN839@OnLoadScri

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00798	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0079b	83 c2 23	 add	 edx, 35			; 00000023H
  0079e	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  007a0	83 c0 fc	 add	 eax, -4			; fffffffcH
  007a3	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  007a6	0f 87 e2 02 00
	00		 ja	 $LN540@OnLoadScri
$LN839@OnLoadScri:

; 264  :         ::operator delete(_Ptr, _Bytes);

  007ac	52		 push	 edx
  007ad	51		 push	 ecx
  007ae	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  007b3	8a 45 bf	 mov	 al, BYTE PTR $T8[ebp]
  007b6	83 c4 08	 add	 esp, 8
$LN829@OnLoadScri:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 649  : 		if (!rTextFileLoader.GetTokenBoolean("textureanimationloopenable", &rMeshData.bTextureAnimationLoopEnable))

  007b9	84 c0		 test	 al, al
  007bb	0f 85 a0 02 00
	00		 jne	 $LN1092@OnLoadScri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  007c1	6a 1a		 push	 26			; 0000001aH

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  007c3	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T25[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  007ca	8d 4d d8	 lea	 ecx, DWORD PTR $T25[ebp]
  007cd	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@MIGDCCON@textureanimationframedelay@

; 4596 :         _My_data._Mysize = 0;

  007d2	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T25[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  007d9	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T25[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  007e0	88 45 d8	 mov	 BYTE PTR $T25[ebp], al

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  007e3	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 651  : 		if (!rTextFileLoader.GetTokenFloat("textureanimationframedelay", &rMeshData.fTextureAnimationFrameDelay))

  007e8	8d 47 28	 lea	 eax, DWORD PTR [edi+40]
  007eb	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H
  007ef	50		 push	 eax
  007f0	8d 45 d8	 lea	 eax, DWORD PTR $T25[ebp]
  007f3	8b ce		 mov	 ecx, esi
  007f5	50		 push	 eax
  007f6	e8 00 00 00 00	 call	 ?GetTokenFloat@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM@Z ; CTextFileLoader::GetTokenFloat
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  007fb	8b 55 ec	 mov	 edx, DWORD PTR $T25[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 651  : 		if (!rTextFileLoader.GetTokenFloat("textureanimationframedelay", &rMeshData.fTextureAnimationFrameDelay))

  007fe	85 c0		 test	 eax, eax
  00800	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00804	0f 94 c0	 sete	 al
  00807	88 45 bf	 mov	 BYTE PTR $T7[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0080a	83 fa 10	 cmp	 edx, 16			; 00000010H
  0080d	72 2f		 jb	 SHORT $LN875@OnLoadScri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0080f	8b 4d d8	 mov	 ecx, DWORD PTR $T25[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00812	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00813	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00815	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0081b	72 14		 jb	 SHORT $LN885@OnLoadScri

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0081d	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00820	83 c2 23	 add	 edx, 35			; 00000023H
  00823	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00825	83 c0 fc	 add	 eax, -4			; fffffffcH
  00828	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0082b	0f 87 5d 02 00
	00		 ja	 $LN540@OnLoadScri
$LN885@OnLoadScri:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00831	52		 push	 edx
  00832	51		 push	 ecx
  00833	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00838	8a 45 bf	 mov	 al, BYTE PTR $T7[ebp]
  0083b	83 c4 08	 add	 esp, 8
$LN875@OnLoadScri:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 651  : 		if (!rTextFileLoader.GetTokenFloat("textureanimationframedelay", &rMeshData.fTextureAnimationFrameDelay))

  0083e	84 c0		 test	 al, al
  00840	0f 85 1b 02 00
	00		 jne	 $LN1092@OnLoadScri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00846	6a 1a		 push	 26			; 0000001aH

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00848	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T24[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0084f	8d 4d d8	 lea	 ecx, DWORD PTR $T24[ebp]
  00852	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@PMOBBIKD@textureanimationstartframe@

; 4596 :         _My_data._Mysize = 0;

  00857	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T24[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0085e	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T24[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00865	88 45 d8	 mov	 BYTE PTR $T24[ebp], al

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00868	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 653  : 		if (!rTextFileLoader.GetTokenDoubleWord("textureanimationstartframe", &rMeshData.dwTextureAnimationStartFrame))

  0086d	8d 47 2c	 lea	 eax, DWORD PTR [edi+44]
  00870	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+8], 18 ; 00000012H
  00874	50		 push	 eax
  00875	8d 45 d8	 lea	 eax, DWORD PTR $T24[ebp]
  00878	8b ce		 mov	 ecx, esi
  0087a	50		 push	 eax
  0087b	e8 00 00 00 00	 call	 ?GetTokenDoubleWord@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAK@Z ; CTextFileLoader::GetTokenDoubleWord
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00880	8b 55 ec	 mov	 edx, DWORD PTR $T24[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 653  : 		if (!rTextFileLoader.GetTokenDoubleWord("textureanimationstartframe", &rMeshData.dwTextureAnimationStartFrame))

  00883	85 c0		 test	 eax, eax
  00885	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00889	0f 94 c0	 sete	 al
  0088c	88 45 bf	 mov	 BYTE PTR $T6[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0088f	83 fa 10	 cmp	 edx, 16			; 00000010H
  00892	72 2f		 jb	 SHORT $LN921@OnLoadScri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00894	8b 4d d8	 mov	 ecx, DWORD PTR $T24[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00897	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00898	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0089a	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  008a0	72 14		 jb	 SHORT $LN931@OnLoadScri

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  008a2	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  008a5	83 c2 23	 add	 edx, 35			; 00000023H
  008a8	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  008aa	83 c0 fc	 add	 eax, -4			; fffffffcH
  008ad	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  008b0	0f 87 d8 01 00
	00		 ja	 $LN540@OnLoadScri
$LN931@OnLoadScri:

; 264  :         ::operator delete(_Ptr, _Bytes);

  008b6	52		 push	 edx
  008b7	51		 push	 ecx
  008b8	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  008bd	8a 45 bf	 mov	 al, BYTE PTR $T6[ebp]
  008c0	83 c4 08	 add	 esp, 8
$LN921@OnLoadScri:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 653  : 		if (!rTextFileLoader.GetTokenDoubleWord("textureanimationstartframe", &rMeshData.dwTextureAnimationStartFrame))

  008c3	84 c0		 test	 al, al
  008c5	74 07		 je	 SHORT $LN18@OnLoadScri

; 654  : 		{
; 655  : 			rMeshData.dwTextureAnimationStartFrame = 0;

  008c7	c7 47 2c 00 00
	00 00		 mov	 DWORD PTR [edi+44], 0
$LN18@OnLoadScri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  008ce	6a 12		 push	 18			; 00000012H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  008d0	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T23[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  008d7	8d 4d d8	 lea	 ecx, DWORD PTR $T23[ebp]
  008da	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DAMHAFBJ@coloroperationtype@

; 4596 :         _My_data._Mysize = 0;

  008df	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T23[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  008e6	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T23[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  008ed	c6 45 d8 00	 mov	 BYTE PTR $T23[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  008f1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 658  : 		if (!rTextFileLoader.GetTokenByte("coloroperationtype", &rMeshData.byColorOperationType))

  008f6	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
  008f9	c6 45 fc 13	 mov	 BYTE PTR __$EHRec$[ebp+8], 19 ; 00000013H
  008fd	50		 push	 eax
  008fe	8d 45 d8	 lea	 eax, DWORD PTR $T23[ebp]
  00901	8b ce		 mov	 ecx, esi
  00903	50		 push	 eax
  00904	e8 00 00 00 00	 call	 ?GetTokenByte@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE@Z ; CTextFileLoader::GetTokenByte
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00909	8b 55 ec	 mov	 edx, DWORD PTR $T23[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 658  : 		if (!rTextFileLoader.GetTokenByte("coloroperationtype", &rMeshData.byColorOperationType))

  0090c	85 c0		 test	 eax, eax
  0090e	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00912	0f 94 c0	 sete	 al
  00915	88 45 bf	 mov	 BYTE PTR $T5[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00918	83 fa 10	 cmp	 edx, 16			; 00000010H
  0091b	72 2f		 jb	 SHORT $LN964@OnLoadScri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0091d	8b 4d d8	 mov	 ecx, DWORD PTR $T23[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00920	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00921	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00923	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00929	72 14		 jb	 SHORT $LN974@OnLoadScri

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0092b	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0092e	83 c2 23	 add	 edx, 35			; 00000023H
  00931	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00933	83 c0 fc	 add	 eax, -4			; fffffffcH
  00936	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00939	0f 87 4f 01 00
	00		 ja	 $LN540@OnLoadScri
$LN974@OnLoadScri:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0093f	52		 push	 edx
  00940	51		 push	 ecx
  00941	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00946	8a 45 bf	 mov	 al, BYTE PTR $T5[ebp]
  00949	83 c4 08	 add	 esp, 8
$LN964@OnLoadScri:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 658  : 		if (!rTextFileLoader.GetTokenByte("coloroperationtype", &rMeshData.byColorOperationType))

  0094c	84 c0		 test	 al, al
  0094e	74 04		 je	 SHORT $LN19@OnLoadScri

; 659  : 		{
; 660  : 			rMeshData.byColorOperationType = D3DTOP_MODULATE;

  00950	c6 47 10 04	 mov	 BYTE PTR [edi+16], 4
$LN19@OnLoadScri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00954	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ??_C@_0M@PBDNNBOP@colorfactor@+8
  0095a	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0M@PBDNNBOP@colorfactor@
  00962	66 89 45 c8	 mov	 WORD PTR $T17[ebp+8], ax
  00966	a0 0a 00 00 00	 mov	 al, BYTE PTR ??_C@_0M@PBDNNBOP@colorfactor@+10

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0096b	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR $T17[ebp+20], 15 ; 0000000fH

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  00972	c7 45 d0 0b 00
	00 00		 mov	 DWORD PTR $T17[ebp+16], 11 ; 0000000bH

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00979	66 0f d6 45 c0	 movq	 QWORD PTR $T17[ebp], xmm0
  0097e	88 45 ca	 mov	 BYTE PTR $T17[ebp+10], al

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00981	c6 45 cb 00	 mov	 BYTE PTR $T17[ebp+11], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 662  : 		if (!rTextFileLoader.GetTokenColor("colorfactor", &rMeshData.ColorFactor))

  00985	8d 47 14	 lea	 eax, DWORD PTR [edi+20]
  00988	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
  0098c	50		 push	 eax
  0098d	8d 45 c0	 lea	 eax, DWORD PTR $T17[ebp]
  00990	8b ce		 mov	 ecx, esi
  00992	50		 push	 eax
  00993	e8 00 00 00 00	 call	 ?GetTokenColor@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUD3DXCOLOR@@@Z ; CTextFileLoader::GetTokenColor
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00998	8b 55 d4	 mov	 edx, DWORD PTR $T17[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 662  : 		if (!rTextFileLoader.GetTokenColor("colorfactor", &rMeshData.ColorFactor))

  0099b	85 c0		 test	 eax, eax
  0099d	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  009a1	0f 94 c0	 sete	 al
  009a4	88 45 bf	 mov	 BYTE PTR $T4[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  009a7	83 fa 10	 cmp	 edx, 16			; 00000010H
  009aa	72 2f		 jb	 SHORT $LN1063@OnLoadScri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  009ac	8b 4d c0	 mov	 ecx, DWORD PTR $T17[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  009af	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  009b0	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  009b2	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  009b8	72 14		 jb	 SHORT $LN1073@OnLoadScri

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  009ba	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  009bd	83 c2 23	 add	 edx, 35			; 00000023H
  009c0	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  009c2	83 c0 fc	 add	 eax, -4			; fffffffcH
  009c5	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  009c8	0f 87 c0 00 00
	00		 ja	 $LN540@OnLoadScri
$LN1073@OnLoadScri:

; 264  :         ::operator delete(_Ptr, _Bytes);

  009ce	52		 push	 edx
  009cf	51		 push	 ecx
  009d0	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  009d5	8a 45 bf	 mov	 al, BYTE PTR $T4[ebp]
  009d8	83 c4 08	 add	 esp, 8
$LN1063@OnLoadScri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  009db	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T17[ebp+16], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  009e2	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR $T17[ebp+20], 15 ; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  009e9	c6 45 c0 00	 mov	 BYTE PTR $T17[ebp], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 662  : 		if (!rTextFileLoader.GetTokenColor("colorfactor", &rMeshData.ColorFactor))

  009ed	84 c0		 test	 al, al
  009ef	74 0b		 je	 SHORT $LN20@OnLoadScri
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\extern\include\d3dx8math.inl

; 920  :     r = fr;

  009f1	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@3f8000003f8000003f8000003f800000
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 664  : 			rMeshData.ColorFactor = D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f);

  009f8	0f 11 47 14	 movups	 XMMWORD PTR [edi+20], xmm0
$LN20@OnLoadScri:

; 665  : 		}
; 666  : 
; 667  : 		if (!GetTokenTimeEventFloat(rTextFileLoader, "timeeventalpha", &rMeshData.TimeEventAlpha))

  009fc	83 c7 30	 add	 edi, 48			; 00000030H
  009ff	57		 push	 edi
  00a00	68 00 00 00 00	 push	 OFFSET ??_C@_0P@KALIPJCI@timeeventalpha@
  00a05	56		 push	 esi
  00a06	e8 00 00 00 00	 call	 ?GetTokenTimeEventFloat@@YAHAAVCTextFileLoader@@PBDPAV?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@Z ; GetTokenTimeEventFloat
  00a0b	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a0e	85 c0		 test	 eax, eax
  00a10	75 05		 jne	 SHORT $LN21@OnLoadScri

; 668  : 		{
; 669  : 			rMeshData.TimeEventAlpha.clear();

  00a12	8b 07		 mov	 eax, DWORD PTR [edi]
  00a14	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN21@OnLoadScri:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\TextFileLoader.h

; 55   : 				m_pOwner->SetParentNode();

  00a17	8b ce		 mov	 ecx, esi
  00a19	c7 45 fc 15 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 21 ; 00000015H
  00a20	e8 00 00 00 00	 call	 ?SetParentNode@CTextFileLoader@@QAEHXZ ; CTextFileLoader::SetParentNode
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00a25	8b 45 b8	 mov	 eax, DWORD PTR __My_data$2$[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 634  : 	for (DWORD i = 0; i < m_MeshDataVector.size(); ++i)

  00a28	8b 7d b0	 mov	 edi, DWORD PTR _i$1$[ebp]
  00a2b	83 45 b4 3c	 add	 DWORD PTR tv4800[ebp], 60 ; 0000003cH
  00a2f	47		 inc	 edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\TextFileLoader.h

; 56   : 			}

  00a30	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00a37	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00a3a	2b 08		 sub	 ecx, DWORD PTR [eax]
  00a3c	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  00a41	f7 e9		 imul	 ecx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 634  : 	for (DWORD i = 0; i < m_MeshDataVector.size(); ++i)

  00a43	89 7d b0	 mov	 DWORD PTR _i$1$[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00a46	03 d1		 add	 edx, ecx
  00a48	c1 fa 05	 sar	 edx, 5
  00a4b	8b c2		 mov	 eax, edx
  00a4d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00a50	03 c2		 add	 eax, edx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 634  : 	for (DWORD i = 0; i < m_MeshDataVector.size(); ++i)

  00a52	3b f8		 cmp	 edi, eax
  00a54	0f 82 96 fa ff
	ff		 jb	 $LL4@OnLoadScri
$LN3@OnLoadScri:

; 670  : 		}
; 671  : 	}
; 672  : 
; 673  : 	return TRUE;

  00a5a	b8 01 00 00 00	 mov	 eax, 1
  00a5f	eb 10		 jmp	 SHORT $LN1@OnLoadScri
$LN1092@OnLoadScri:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\TextFileLoader.h

; 55   : 				m_pOwner->SetParentNode();

  00a61	8b ce		 mov	 ecx, esi
  00a63	c7 45 fc 11 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 17 ; 00000011H
  00a6a	e8 00 00 00 00	 call	 ?SetParentNode@CTextFileLoader@@QAEHXZ ; CTextFileLoader::SetParentNode
$LN5@OnLoadScri:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 674  : }

  00a6f	33 c0		 xor	 eax, eax
$LN1@OnLoadScri:
  00a71	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00a74	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00a7b	59		 pop	 ecx
  00a7c	5f		 pop	 edi
  00a7d	5e		 pop	 esi
  00a7e	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a81	33 cd		 xor	 ecx, ebp
  00a83	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a88	8b e5		 mov	 esp, ebp
  00a8a	5d		 pop	 ebp
  00a8b	c2 04 00	 ret	 4
$LN540@OnLoadScri:
  00a8e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1108@OnLoadScri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4703 :         _Xlen_string();

  00a93	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN259@OnLoadScri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00a98	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1109@OnLoadScri:
  00a9d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1110@OnLoadScri:
  00aa2	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1111@OnLoadScri:
  00aa7	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1112@OnLoadScri:
  00aac	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1105@OnLoadScri:
  00ab1	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$0:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR $T22[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$2:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR $T31[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$3:
  00010	8d 4d d8	 lea	 ecx, DWORD PTR $T30[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$4:
  00018	8d 4d d8	 lea	 ecx, DWORD PTR $T29[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$5:
  00020	8d 4d d8	 lea	 ecx, DWORD PTR $T28[ebp]
  00023	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$6:
  00028	8d 4d a4	 lea	 ecx, DWORD PTR _GotoChild$2[ebp]
  0002b	e9 00 00 00 00	 jmp	 ??1CGotoChild@CTextFileLoader@@QAE@XZ ; CTextFileLoader::CGotoChild::~CGotoChild
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$7:
  00030	8d 4d c0	 lea	 ecx, DWORD PTR $T20[ebp]
  00033	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$8:
  00038	8d 4d c0	 lea	 ecx, DWORD PTR $T19[ebp]
  0003b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$9:
  00040	8d 4d c0	 lea	 ecx, DWORD PTR $T18[ebp]
  00043	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$10:
  00048	8d 4d d8	 lea	 ecx, DWORD PTR $T27[ebp]
  0004b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$11:
  00050	8d 4d d8	 lea	 ecx, DWORD PTR $T26[ebp]
  00053	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$12:
  00058	8d 4d d8	 lea	 ecx, DWORD PTR $T25[ebp]
  0005b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$13:
  00060	8d 4d d8	 lea	 ecx, DWORD PTR $T24[ebp]
  00063	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$14:
  00068	8d 4d d8	 lea	 ecx, DWORD PTR $T23[ebp]
  0006b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$15:
  00070	8d 4d c0	 lea	 ecx, DWORD PTR $T17[ebp]
  00073	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00078	cc		 int	 3
  00079	cc		 int	 3
  0007a	cc		 int	 3
  0007b	cc		 int	 3
  0007c	cc		 int	 3
__ehhandler$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z:
  0007d	90		 npad	 1
  0007e	90		 npad	 1
  0007f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00083	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00086	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  00089	33 c8		 xor	 ecx, eax
  0008b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00090	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00093	33 c8		 xor	 ecx, eax
  00095	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z
  0009f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z ENDP ; CEffectMeshScript::OnLoadScript
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?OnIsData@CEffectMeshScript@@MAE_NXZ
_TEXT	SEGMENT
?OnIsData@CEffectMeshScript@@MAE_NXZ PROC		; CEffectMeshScript::OnIsData, COMDAT
; _this$ = ecx

; 678  : 	if (0 == m_strMeshFileName.length())

  00000	83 79 3c 00	 cmp	 DWORD PTR [ecx+60], 0
  00004	0f 95 c0	 setne	 al

; 679  : 		return false;
; 680  : 
; 681  : 	return true;
; 682  : }

  00007	c3		 ret	 0
?OnIsData@CEffectMeshScript@@MAE_NXZ ENDP		; CEffectMeshScript::OnIsData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?OnClear@CEffectMeshScript@@MAEXXZ
_TEXT	SEGMENT
?OnClear@CEffectMeshScript@@MAEXXZ PROC			; CEffectMeshScript::OnClear, COMDAT
; _this$ = ecx

; 685  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 689  : 
; 690  : 	m_MeshDataVector.clear();

  00004	8d 77 20	 lea	 esi, DWORD PTR [edi+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00007	56		 push	 esi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 686  : 	m_isMeshAnimationLoop = false;

  00008	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0

; 687  : 	m_iMeshAnimationLoopCount = 0;

  0000f	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0

; 688  : 	m_fMeshAnimationFrameDelay = 0.02f;

  00016	c7 47 1c 0a d7
	a3 3c		 mov	 DWORD PTR [edi+28], 1017370378 ; 3ca3d70aH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  0001d	ff 76 04	 push	 DWORD PTR [esi+4]
  00020	ff 36		 push	 DWORD PTR [esi]
  00022	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAXPAUSMeshData@CEffectMeshScript@@QAU12@AAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshScript::SMeshData> >

; 1456 :         _Mylast = _Myfirst;

  00027	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 691  : 	m_strMeshFileName = "";

  00029	8d 4f 2c	 lea	 ecx, DWORD PTR [edi+44]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1456 :         _Mylast = _Myfirst;

  0002f	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00032	6a 00		 push	 0
  00034	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  00039	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 692  : }

  00040	c3		 ret	 0
?OnClear@CEffectMeshScript@@MAEXXZ ENDP			; CEffectMeshScript::OnClear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetTextureAnimationStartFrame@CEffectMeshScript@@QAEKK@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
?GetTextureAnimationStartFrame@CEffectMeshScript@@QAEKK@Z PROC ; CEffectMeshScript::GetTextureAnimationStartFrame, COMDAT
; _this$ = ecx

; 598  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 599  : 	if (!CheckMeshIndex(dwMeshIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwMeshIndex$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z ; CEffectMeshScript::CheckMeshIndex
  00010	84 c0		 test	 al, al
  00012	75 08		 jne	 SHORT $LN2@GetTexture

; 600  : 		return 0;

  00014	5f		 pop	 edi
  00015	33 c0		 xor	 eax, eax

; 603  : }

  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN2@GetTexture:

; 601  : 
; 602  : 	return m_MeshDataVector[dwMeshIndex].dwTextureAnimationStartFrame;

  0001c	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  0001f	8b ce		 mov	 ecx, esi
  00021	c1 e1 04	 shl	 ecx, 4
  00024	2b ce		 sub	 ecx, esi
  00026	5f		 pop	 edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 603  : }

  00027	5e		 pop	 esi
  00028	8b 44 88 2c	 mov	 eax, DWORD PTR [eax+ecx*4+44]
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?GetTextureAnimationStartFrame@CEffectMeshScript@@QAEKK@Z ENDP ; CEffectMeshScript::GetTextureAnimationStartFrame
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetTextureAnimationFrameDelay@CEffectMeshScript@@QAEMK@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
?GetTextureAnimationFrameDelay@CEffectMeshScript@@QAEMK@Z PROC ; CEffectMeshScript::GetTextureAnimationFrameDelay, COMDAT
; _this$ = ecx

; 590  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 591  : 	if (!CheckMeshIndex(dwMeshIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwMeshIndex$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z ; CEffectMeshScript::CheckMeshIndex
  00010	84 c0		 test	 al, al
  00012	75 08		 jne	 SHORT $LN2@GetTexture

; 592  : 		return 0.0f;

  00014	d9 ee		 fldz
  00016	5f		 pop	 edi

; 595  : }

  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN2@GetTexture:

; 593  : 
; 594  : 	return m_MeshDataVector[dwMeshIndex].fTextureAnimationFrameDelay;

  0001c	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  0001f	8b ce		 mov	 ecx, esi
  00021	c1 e1 04	 shl	 ecx, 4
  00024	2b ce		 sub	 ecx, esi
  00026	5f		 pop	 edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 595  : }

  00027	5e		 pop	 esi
  00028	d9 44 88 28	 fld	 DWORD PTR [eax+ecx*4+40]
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?GetTextureAnimationFrameDelay@CEffectMeshScript@@QAEMK@Z ENDP ; CEffectMeshScript::GetTextureAnimationFrameDelay
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?isTextureAnimationLoop@CEffectMeshScript@@QAEHK@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
?isTextureAnimationLoop@CEffectMeshScript@@QAEHK@Z PROC	; CEffectMeshScript::isTextureAnimationLoop, COMDAT
; _this$ = ecx

; 583  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 584  : 	if (!CheckMeshIndex(dwMeshIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwMeshIndex$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z ; CEffectMeshScript::CheckMeshIndex
  00010	84 c0		 test	 al, al
  00012	75 08		 jne	 SHORT $LN2@isTextureA

; 585  : 		return 0.0f;

  00014	5f		 pop	 edi
  00015	33 c0		 xor	 eax, eax

; 588  : }

  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN2@isTextureA:

; 586  : 
; 587  : 	return m_MeshDataVector[dwMeshIndex].bTextureAnimationLoopEnable;

  0001c	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  0001f	8b ce		 mov	 ecx, esi
  00021	c1 e1 04	 shl	 ecx, 4
  00024	2b ce		 sub	 ecx, esi
  00026	5f		 pop	 edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 588  : }

  00027	5e		 pop	 esi
  00028	8b 44 88 24	 mov	 eax, DWORD PTR [eax+ecx*4+36]
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?isTextureAnimationLoop@CEffectMeshScript@@QAEHK@Z ENDP	; CEffectMeshScript::isTextureAnimationLoop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetMeshAnimationFrameDelay@CEffectMeshScript@@QAEMXZ
_TEXT	SEGMENT
?GetMeshAnimationFrameDelay@CEffectMeshScript@@QAEMXZ PROC ; CEffectMeshScript::GetMeshAnimationFrameDelay, COMDAT
; _this$ = ecx

; 579  : 	return m_fMeshAnimationFrameDelay;

  00000	d9 41 1c	 fld	 DWORD PTR [ecx+28]

; 580  : }

  00003	c3		 ret	 0
?GetMeshAnimationFrameDelay@CEffectMeshScript@@QAEMXZ ENDP ; CEffectMeshScript::GetMeshAnimationFrameDelay
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetMeshAnimationLoopCount@CEffectMeshScript@@QAEHXZ
_TEXT	SEGMENT
?GetMeshAnimationLoopCount@CEffectMeshScript@@QAEHXZ PROC ; CEffectMeshScript::GetMeshAnimationLoopCount, COMDAT
; _this$ = ecx

; 575  : 	return m_iMeshAnimationLoopCount;

  00000	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]

; 576  : }

  00003	c3		 ret	 0
?GetMeshAnimationLoopCount@CEffectMeshScript@@QAEHXZ ENDP ; CEffectMeshScript::GetMeshAnimationLoopCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?isMeshAnimationLoop@CEffectMeshScript@@QAEHXZ
_TEXT	SEGMENT
?isMeshAnimationLoop@CEffectMeshScript@@QAEHXZ PROC	; CEffectMeshScript::isMeshAnimationLoop, COMDAT
; _this$ = ecx

; 571  : 	return m_isMeshAnimationLoop;

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 572  : }

  00003	c3		 ret	 0
?isMeshAnimationLoop@CEffectMeshScript@@QAEHXZ ENDP	; CEffectMeshScript::isMeshAnimationLoop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetTimeTableAlphaPointer@CEffectMeshScript@@QAEHKPAPAV?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
_pTimeEventAlpha$ = 12					; size = 4
?GetTimeTableAlphaPointer@CEffectMeshScript@@QAEHKPAPAV?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@Z PROC ; CEffectMeshScript::GetTimeTableAlphaPointer, COMDAT
; _this$ = ecx

; 559  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 560  : 	if (!CheckMeshIndex(dwMeshIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwMeshIndex$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z ; CEffectMeshScript::CheckMeshIndex
  00010	84 c0		 test	 al, al
  00012	75 08		 jne	 SHORT $LN2@GetTimeTab

; 561  : 		return FALSE;

  00014	5f		 pop	 edi
  00015	33 c0		 xor	 eax, eax

; 564  : 
; 565  : 	return TRUE;
; 566  : }

  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
$LN2@GetTimeTab:

; 563  : 	*pTimeEventAlpha = &m_MeshDataVector[dwMeshIndex].TimeEventAlpha;

  0001c	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  0001f	8b ce		 mov	 ecx, esi
  00021	c1 e1 04	 shl	 ecx, 4
  00024	2b ce		 sub	 ecx, esi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 563  : 	*pTimeEventAlpha = &m_MeshDataVector[dwMeshIndex].TimeEventAlpha;

  00026	83 c0 30	 add	 eax, 48			; 00000030H
  00029	5f		 pop	 edi

; 564  : 
; 565  : 	return TRUE;
; 566  : }

  0002a	5e		 pop	 esi
  0002b	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  0002e	8b 45 0c	 mov	 eax, DWORD PTR _pTimeEventAlpha$[ebp]
  00031	89 08		 mov	 DWORD PTR [eax], ecx
  00033	b8 01 00 00 00	 mov	 eax, 1
  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?GetTimeTableAlphaPointer@CEffectMeshScript@@QAEHKPAPAV?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@Z ENDP ; CEffectMeshScript::GetTimeTableAlphaPointer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetColorFactor@CEffectMeshScript@@QAEHKPAUD3DXCOLOR@@@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
_pColor$ = 12						; size = 4
?GetColorFactor@CEffectMeshScript@@QAEHKPAUD3DXCOLOR@@@Z PROC ; CEffectMeshScript::GetColorFactor, COMDAT
; _this$ = ecx

; 549  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 550  : 	if (!CheckMeshIndex(dwMeshIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwMeshIndex$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z ; CEffectMeshScript::CheckMeshIndex
  00010	84 c0		 test	 al, al
  00012	75 08		 jne	 SHORT $LN2@GetColorFa

; 551  : 		return FALSE;

  00014	5f		 pop	 edi
  00015	33 c0		 xor	 eax, eax

; 556  : }

  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
$LN2@GetColorFa:

; 552  : 
; 553  : 	*pColor = m_MeshDataVector[dwMeshIndex].ColorFactor;

  0001c	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  0001f	8b ce		 mov	 ecx, esi
  00021	c1 e1 04	 shl	 ecx, 4
  00024	2b ce		 sub	 ecx, esi
  00026	5f		 pop	 edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 556  : }

  00027	5e		 pop	 esi
  00028	0f 10 44 88 14	 movups	 xmm0, XMMWORD PTR [eax+ecx*4+20]
  0002d	8b 45 0c	 mov	 eax, DWORD PTR _pColor$[ebp]
  00030	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  00033	b8 01 00 00 00	 mov	 eax, 1
  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?GetColorFactor@CEffectMeshScript@@QAEHKPAUD3DXCOLOR@@@Z ENDP ; CEffectMeshScript::GetColorFactor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetColorOperationType@CEffectMeshScript@@QAEHKPAE@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
_pbyType$ = 12						; size = 4
?GetColorOperationType@CEffectMeshScript@@QAEHKPAE@Z PROC ; CEffectMeshScript::GetColorOperationType, COMDAT
; _this$ = ecx

; 540  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 541  : 	if (!CheckMeshIndex(dwMeshIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwMeshIndex$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z ; CEffectMeshScript::CheckMeshIndex
  00010	84 c0		 test	 al, al
  00012	75 08		 jne	 SHORT $LN2@GetColorOp

; 542  : 		return FALSE;

  00014	5f		 pop	 edi
  00015	33 c0		 xor	 eax, eax

; 547  : }

  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
$LN2@GetColorOp:

; 543  : 
; 544  : 	*pbyType = m_MeshDataVector[dwMeshIndex].byColorOperationType;

  0001c	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  0001f	8b ce		 mov	 ecx, esi
  00021	c1 e1 04	 shl	 ecx, 4
  00024	2b ce		 sub	 ecx, esi
  00026	5f		 pop	 edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 547  : }

  00027	5e		 pop	 esi
  00028	8a 4c 88 10	 mov	 cl, BYTE PTR [eax+ecx*4+16]
  0002c	8b 45 0c	 mov	 eax, DWORD PTR _pbyType$[ebp]
  0002f	88 08		 mov	 BYTE PTR [eax], cl
  00031	b8 01 00 00 00	 mov	 eax, 1
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
?GetColorOperationType@CEffectMeshScript@@QAEHKPAE@Z ENDP ; CEffectMeshScript::GetColorOperationType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?isTextureAlphaEnable@CEffectMeshScript@@QAEHK@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
?isTextureAlphaEnable@CEffectMeshScript@@QAEHK@Z PROC	; CEffectMeshScript::isTextureAlphaEnable, COMDAT
; _this$ = ecx

; 532  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 533  : 	if (!CheckMeshIndex(dwMeshIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwMeshIndex$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z ; CEffectMeshScript::CheckMeshIndex
  00010	84 c0		 test	 al, al
  00012	75 08		 jne	 SHORT $LN2@isTextureA

; 534  : 		return false;

  00014	5f		 pop	 edi
  00015	33 c0		 xor	 eax, eax

; 537  : }

  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN2@isTextureA:

; 535  : 
; 536  : 	return m_MeshDataVector[dwMeshIndex].bTextureAlphaEnable;

  0001c	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  0001f	8b ce		 mov	 ecx, esi
  00021	c1 e1 04	 shl	 ecx, 4
  00024	2b ce		 sub	 ecx, esi
  00026	5f		 pop	 edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 537  : }

  00027	5e		 pop	 esi
  00028	8b 44 88 0c	 mov	 eax, DWORD PTR [eax+ecx*4+12]
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?isTextureAlphaEnable@CEffectMeshScript@@QAEHK@Z ENDP	; CEffectMeshScript::isTextureAlphaEnable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetBlendingDestType@CEffectMeshScript@@QAEEK@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
?GetBlendingDestType@CEffectMeshScript@@QAEEK@Z PROC	; CEffectMeshScript::GetBlendingDestType, COMDAT
; _this$ = ecx

; 525  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 526  : 	if (!CheckMeshIndex(dwMeshIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwMeshIndex$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z ; CEffectMeshScript::CheckMeshIndex
  00010	84 c0		 test	 al, al
  00012	75 06		 jne	 SHORT $LN2@GetBlendin

; 530  : }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN2@GetBlendin:

; 527  : 		return false;
; 528  : 
; 529  : 	return m_MeshDataVector[dwMeshIndex].byBlendingDestType;

  0001a	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  0001d	8b ce		 mov	 ecx, esi
  0001f	c1 e1 04	 shl	 ecx, 4
  00022	2b ce		 sub	 ecx, esi
  00024	5f		 pop	 edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 530  : }

  00025	5e		 pop	 esi
  00026	8a 44 88 09	 mov	 al, BYTE PTR [eax+ecx*4+9]
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?GetBlendingDestType@CEffectMeshScript@@QAEEK@Z ENDP	; CEffectMeshScript::GetBlendingDestType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetBlendingSrcType@CEffectMeshScript@@QAEEK@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
?GetBlendingSrcType@CEffectMeshScript@@QAEEK@Z PROC	; CEffectMeshScript::GetBlendingSrcType, COMDAT
; _this$ = ecx

; 518  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 519  : 	if (!CheckMeshIndex(dwMeshIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwMeshIndex$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z ; CEffectMeshScript::CheckMeshIndex
  00010	84 c0		 test	 al, al
  00012	75 06		 jne	 SHORT $LN2@GetBlendin

; 523  : }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN2@GetBlendin:

; 520  : 		return false;
; 521  : 
; 522  : 	return m_MeshDataVector[dwMeshIndex].byBlendingSrcType;

  0001a	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  0001d	8b ce		 mov	 ecx, esi
  0001f	c1 e1 04	 shl	 ecx, 4
  00022	2b ce		 sub	 ecx, esi
  00024	5f		 pop	 edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 523  : }

  00025	5e		 pop	 esi
  00026	8a 44 88 08	 mov	 al, BYTE PTR [eax+ecx*4+8]
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?GetBlendingSrcType@CEffectMeshScript@@QAEEK@Z ENDP	; CEffectMeshScript::GetBlendingSrcType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?isBlendingEnable@CEffectMeshScript@@QAEHK@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
?isBlendingEnable@CEffectMeshScript@@QAEHK@Z PROC	; CEffectMeshScript::isBlendingEnable, COMDAT
; _this$ = ecx

; 511  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 512  : 	if (!CheckMeshIndex(dwMeshIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwMeshIndex$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z ; CEffectMeshScript::CheckMeshIndex
  00010	84 c0		 test	 al, al
  00012	75 08		 jne	 SHORT $LN2@isBlending

; 513  : 		return FALSE;

  00014	5f		 pop	 edi
  00015	33 c0		 xor	 eax, eax

; 516  : }

  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN2@isBlending:

; 514  : 
; 515  : 	return m_MeshDataVector[dwMeshIndex].bBlendingEnable;

  0001c	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  0001f	8b ce		 mov	 ecx, esi
  00021	c1 e1 04	 shl	 ecx, 4
  00024	2b ce		 sub	 ecx, esi
  00026	5f		 pop	 edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 516  : }

  00027	5e		 pop	 esi
  00028	8b 44 88 04	 mov	 eax, DWORD PTR [eax+ecx*4+4]
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?isBlendingEnable@CEffectMeshScript@@QAEHK@Z ENDP	; CEffectMeshScript::isBlendingEnable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetBillboardType@CEffectMeshScript@@QAEHK@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
?GetBillboardType@CEffectMeshScript@@QAEHK@Z PROC	; CEffectMeshScript::GetBillboardType, COMDAT
; _this$ = ecx

; 504  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 505  : 	if (!CheckMeshIndex(dwMeshIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwMeshIndex$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z ; CEffectMeshScript::CheckMeshIndex
  00010	84 c0		 test	 al, al
  00012	75 08		 jne	 SHORT $LN2@GetBillboa

; 506  : 		return 0;

  00014	5f		 pop	 edi
  00015	33 c0		 xor	 eax, eax

; 509  : }

  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN2@GetBillboa:

; 507  : 
; 508  : 	return m_MeshDataVector[dwMeshIndex].byBillboardType;

  0001c	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  0001f	8b ce		 mov	 ecx, esi
  00021	c1 e1 04	 shl	 ecx, 4
  00024	2b ce		 sub	 ecx, esi
  00026	5f		 pop	 edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 509  : }

  00027	5e		 pop	 esi
  00028	0f b6 04 88	 movzx	 eax, BYTE PTR [eax+ecx*4]
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?GetBillboardType@CEffectMeshScript@@QAEHK@Z ENDP	; CEffectMeshScript::GetBillboardType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetMeshDataCount@CEffectMeshScript@@QAEHXZ
_TEXT	SEGMENT
?GetMeshDataCount@CEffectMeshScript@@QAEHXZ PROC	; CEffectMeshScript::GetMeshDataCount, COMDAT
; _this$ = ecx

; 499  : {

  00000	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00001	8b 71 24	 mov	 esi, DWORD PTR [ecx+36]
  00004	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  00009	2b 71 20	 sub	 esi, DWORD PTR [ecx+32]
  0000c	f7 ee		 imul	 esi
  0000e	03 d6		 add	 edx, esi
  00010	c1 fa 05	 sar	 edx, 5
  00013	8b c2		 mov	 eax, edx
  00015	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00018	03 c2		 add	 eax, edx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 500  : 	return m_MeshDataVector.size();

  0001a	5e		 pop	 esi

; 501  : }

  0001b	c3		 ret	 0
?GetMeshDataCount@CEffectMeshScript@@QAEHXZ ENDP	; CEffectMeshScript::GetMeshDataCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetMeshDataPointer@CEffectMeshScript@@QAE_NKPAPAUSMeshData@1@@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
_ppMeshData$ = 12					; size = 4
?GetMeshDataPointer@CEffectMeshScript@@QAE_NKPAPAUSMeshData@1@@Z PROC ; CEffectMeshScript::GetMeshDataPointer, COMDAT
; _this$ = ecx

; 489  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 490  : 	if (!CheckMeshIndex(dwMeshIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwMeshIndex$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z ; CEffectMeshScript::CheckMeshIndex
  00010	84 c0		 test	 al, al
  00012	75 06		 jne	 SHORT $LN2@GetMeshDat

; 496  : }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
$LN2@GetMeshDat:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  0001a	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  0001d	8b ce		 mov	 ecx, esi
  0001f	c1 e1 04	 shl	 ecx, 4
  00022	2b ce		 sub	 ecx, esi
  00024	5f		 pop	 edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 496  : }

  00025	5e		 pop	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  00026	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 493  : 	*ppMeshData = &m_MeshDataVector[dwMeshIndex];

  00029	8b 45 0c	 mov	 eax, DWORD PTR _ppMeshData$[ebp]
  0002c	89 08		 mov	 DWORD PTR [eax], ecx

; 494  : 
; 495  : 	return true;

  0002e	b0 01		 mov	 al, 1

; 496  : }

  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
?GetMeshDataPointer@CEffectMeshScript@@QAE_NKPAPAUSMeshData@1@@Z ENDP ; CEffectMeshScript::GetMeshDataPointer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z PROC	; CEffectMeshScript::CheckMeshIndex, COMDAT
; _this$ = ecx

; 481  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00004	8b 71 24	 mov	 esi, DWORD PTR [ecx+36]
  00007	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  0000c	2b 71 20	 sub	 esi, DWORD PTR [ecx+32]
  0000f	f7 ee		 imul	 esi
  00011	03 d6		 add	 edx, esi
  00013	c1 fa 05	 sar	 edx, 5
  00016	8b c2		 mov	 eax, edx
  00018	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001b	03 c2		 add	 eax, edx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 482  : 	if (dwMeshIndex >= m_MeshDataVector.size())

  0001d	39 45 08	 cmp	 DWORD PTR _dwMeshIndex$[ebp], eax
  00020	5e		 pop	 esi
  00021	0f 92 c0	 setb	 al

; 483  : 		return false;
; 484  : 
; 485  : 	return true;
; 486  : }

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z ENDP	; CEffectMeshScript::CheckMeshIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\extern\include\d3dx8math.inl
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?ReserveMeshData@CEffectMeshScript@@QAEXK@Z
_TEXT	SEGMENT
_dwMeshCount$ = 8					; size = 4
?ReserveMeshData@CEffectMeshScript@@QAEXK@Z PROC	; CEffectMeshScript::ReserveMeshData, COMDAT
; _this$ = ecx

; 449  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00004	8b 59 20	 mov	 ebx, DWORD PTR [ecx+32]
  00007	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 449  : {

  0000c	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1548 :         auto& _My_data = _Mypair._Myval2;

  0000d	8d 71 20	 lea	 esi, DWORD PTR [ecx+32]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 449  : {

  00010	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00011	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00014	8b cf		 mov	 ecx, edi
  00016	2b cb		 sub	 ecx, ebx
  00018	f7 e9		 imul	 ecx
  0001a	03 d1		 add	 edx, ecx
  0001c	c1 fa 05	 sar	 edx, 5
  0001f	8b c2		 mov	 eax, edx
  00021	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00024	03 c2		 add	 eax, edx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 450  : 	if (m_MeshDataVector.size() == dwMeshCount)

  00026	3b 45 08	 cmp	 eax, DWORD PTR _dwMeshCount$[ebp]
  00029	0f 84 99 00 00
	00		 je	 $LN3@ReserveMes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  0002f	56		 push	 esi
  00030	57		 push	 edi
  00031	53		 push	 ebx
  00032	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAXPAUSMeshData@CEffectMeshScript@@QAU12@AAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshScript::SMeshData> >

; 1456 :         _Mylast = _Myfirst;

  00037	8b 06		 mov	 eax, DWORD PTR [esi]

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 454  : 	m_MeshDataVector.resize(dwMeshCount);

  0003c	8b ce		 mov	 ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1456 :         _Mylast = _Myfirst;

  0003e	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 454  : 	m_MeshDataVector.resize(dwMeshCount);

  00041	ff 75 08	 push	 DWORD PTR _dwMeshCount$[ebp]
  00044	e8 00 00 00 00	 call	 ?resize@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@QAEXI@Z ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::resize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00049	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0004c	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  00051	2b 0e		 sub	 ecx, DWORD PTR [esi]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 456  : 	for (DWORD i = 0; i < m_MeshDataVector.size(); ++i)

  00053	33 db		 xor	 ebx, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 05	 sar	 edx, 5
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00061	03 c2		 add	 eax, edx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 456  : 	for (DWORD i = 0; i < m_MeshDataVector.size(); ++i)

  00063	74 63		 je	 SHORT $LN3@ReserveMes
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\extern\include\d3dx8math.inl

; 920  :     r = fr;

  00065	0f 28 0d 00 00
	00 00		 movaps	 xmm1, XMMWORD PTR __xmm@3f8000003f8000003f8000003f800000
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 453  : 	m_MeshDataVector.clear();

  0006c	33 ff		 xor	 edi, edi
  0006e	66 90		 npad	 2
$LL4@ReserveMes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  00070	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 456  : 	for (DWORD i = 0; i < m_MeshDataVector.size(); ++i)

  00072	43		 inc	 ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  00073	03 c7		 add	 eax, edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 456  : 	for (DWORD i = 0; i < m_MeshDataVector.size(); ++i)

  00075	83 c7 3c	 add	 edi, 60			; 0000003cH

; 457  : 	{
; 458  : 		TMeshData & rMeshData = m_MeshDataVector[i];
; 459  : 
; 460  : 		rMeshData.byBillboardType = MESH_BILLBOARD_TYPE_NONE;

  00078	c6 00 00	 mov	 BYTE PTR [eax], 0

; 461  : 		rMeshData.bBlendingEnable = TRUE;

  0007b	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [eax+4], 1

; 462  : 		rMeshData.byBlendingSrcType = D3DBLEND_SRCCOLOR;

  00082	66 c7 40 08 03
	02		 mov	 WORD PTR [eax+8], 515	; 00000203H

; 463  : 		rMeshData.byBlendingDestType = D3DBLEND_ONE;
; 464  : 		rMeshData.bTextureAlphaEnable = FALSE;

  00088	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 465  : 
; 466  : 		rMeshData.byColorOperationType = D3DTOP_MODULATE;

  0008f	c6 40 10 04	 mov	 BYTE PTR [eax+16], 4

; 467  : 		rMeshData.ColorFactor = D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f);

  00093	0f 11 48 14	 movups	 XMMWORD PTR [eax+20], xmm1

; 468  : 
; 469  : 		rMeshData.bTextureAnimationLoopEnable = true;

  00097	c7 40 24 01 00
	00 00		 mov	 DWORD PTR [eax+36], 1

; 470  : 		rMeshData.fTextureAnimationFrameDelay = 0.02f;

  0009e	c7 40 28 0a d7
	a3 3c		 mov	 DWORD PTR [eax+40], 1017370378 ; 3ca3d70aH

; 471  : 		rMeshData.dwTextureAnimationStartFrame = 0;

  000a5	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  000ac	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  000b1	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000b4	2b 0e		 sub	 ecx, DWORD PTR [esi]
  000b6	f7 e9		 imul	 ecx
  000b8	03 d1		 add	 edx, ecx
  000ba	c1 fa 05	 sar	 edx, 5
  000bd	8b c2		 mov	 eax, edx
  000bf	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000c2	03 c2		 add	 eax, edx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 456  : 	for (DWORD i = 0; i < m_MeshDataVector.size(); ++i)

  000c4	3b d8		 cmp	 ebx, eax
  000c6	72 a8		 jb	 SHORT $LL4@ReserveMes
$LN3@ReserveMes:
  000c8	5f		 pop	 edi

; 472  : 	}
; 473  : }

  000c9	5e		 pop	 esi
  000ca	5b		 pop	 ebx
  000cb	5d		 pop	 ebp
  000cc	c2 04 00	 ret	 4
?ReserveMeshData@CEffectMeshScript@@QAEXK@Z ENDP	; CEffectMeshScript::ReserveMeshData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetMeshFileName@CEffectMeshScript@@QAEPBDXZ
_TEXT	SEGMENT
?GetMeshFileName@CEffectMeshScript@@QAEPBDXZ PROC	; CEffectMeshScript::GetMeshFileName, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00000	83 79 40 10	 cmp	 DWORD PTR [ecx+64], 16	; 00000010H

; 3922 :         return _Mypair._Myval2._Myptr();

  00004	8d 41 2c	 lea	 eax, DWORD PTR [ecx+44]

; 2306 :         if (_Large_string_engaged()) {

  00007	72 02		 jb	 SHORT $LN6@GetMeshFil
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 477  : 	return m_strMeshFileName.c_str();

  00009	8b 00		 mov	 eax, DWORD PTR [eax]
$LN6@GetMeshFil:

; 478  : }

  0000b	c3		 ret	 0
?GetMeshFileName@CEffectMeshScript@@QAEPBDXZ ENDP	; CEffectMeshScript::GetMeshFileName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ??1CEffectMeshScript@@UAE@XZ
_TEXT	SEGMENT
??1CEffectMeshScript@@UAE@XZ PROC			; CEffectMeshScript::~CEffectMeshScript, COMDAT
; _this$ = ecx

; 698  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CEffectMeshScript@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00009	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  0000c	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0000f	72 28		 jb	 SHORT $LN15@CEffectMes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00014	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00015	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001b	72 12		 jb	 SHORT $LN25@CEffectMes

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001d	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00020	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00023	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00025	83 c0 fc	 add	 eax, -4			; fffffffcH
  00028	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002b	77 2e		 ja	 SHORT $LN22@CEffectMes

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002d	8b c2		 mov	 eax, edx
$LN25@CEffectMes:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0002f	51		 push	 ecx
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00036	83 c4 08	 add	 esp, 8
$LN15@CEffectMes:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 699  : }

  00039	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  0003c	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00043	c7 46 40 0f 00
	00 00		 mov	 DWORD PTR [esi+64], 15	; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0004a	c6 46 2c 00	 mov	 BYTE PTR [esi+44], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 699  : }

  0004e	e8 00 00 00 00	 call	 ??1?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@QAE@XZ ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::~vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >
  00053	8b ce		 mov	 ecx, esi
  00055	5e		 pop	 esi
  00056	e9 00 00 00 00	 jmp	 ??1CEffectElementBase@@UAE@XZ ; CEffectElementBase::~CEffectElementBase
$LN22@CEffectMes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0005b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN31@CEffectMes:
  00060	cc		 int	 3
??1CEffectMeshScript@@UAE@XZ ENDP			; CEffectMeshScript::~CEffectMeshScript
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ??0CEffectMeshScript@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CEffectMeshScript@@QAE@XZ PROC			; CEffectMeshScript::CEffectMeshScript, COMDAT
; _this$ = ecx

; 695  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000a	e8 00 00 00 00	 call	 ??0CEffectElementBase@@QAE@XZ ; CEffectElementBase::CEffectElementBase
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CEffectMeshScript@@6B@

; 696  : }

  00015	8b c6		 mov	 eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00017	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
  0001e	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  00025	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0002c	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0

; 4596 :         _My_data._Mysize = 0;

  00033	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0003a	c7 46 40 0f 00
	00 00		 mov	 DWORD PTR [esi+64], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00041	c6 46 2c 00	 mov	 BYTE PTR [esi+44], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 696  : }

  00045	5e		 pop	 esi
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
??0CEffectMeshScript@@QAE@XZ ENDP			; CEffectMeshScript::CEffectMeshScript
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCEffectMesh@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCEffectMesh@@UAEPAXI@Z PROC				; CEffectMesh::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CEffectMesh@@UAE@XZ	; CEffectMesh::~CEffectMesh
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 44		 push	 68			; 00000044H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GCEffectMesh@@UAEPAXI@Z ENDP				; CEffectMesh::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@CAXXZ PROC ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Xlength, COMDAT

; 1774 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@CAXXZ ENDP ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@AAEXQAPAUSEffectMeshData@CEffectMesh@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@AAEXQAPAUSEffectMeshData@CEffectMesh@@II@Z PROC ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Change_array, COMDAT
; _this$ = ecx

; 1736 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1737 :         // orphan all iterators, discard old array, acquire new array
; 1738 :         auto& _My_data    = _Mypair._Myval2;
; 1739 :         pointer& _Myfirst = _My_data._Myfirst;
; 1740 :         pointer& _Mylast  = _My_data._Mylast;
; 1741 :         pointer& _Myend   = _My_data._Myend;
; 1742 : 
; 1743 :         _My_data._Orphan_all();
; 1744 : 
; 1745 :         if (_Myfirst) { // destroy and deallocate old array

  00006	8b 06		 mov	 eax, DWORD PTR [esi]
  00008	85 c0		 test	 eax, eax
  0000a	74 2c		 je	 SHORT $LN8@Change_arr

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0000c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000f	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00014	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001a	72 12		 jb	 SHORT $LN18@Change_arr

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001c	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001f	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00022	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00024	83 c0 fc	 add	 eax, -4			; fffffffcH
  00027	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002a	77 28		 ja	 SHORT $LN15@Change_arr

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002c	8b c2		 mov	 eax, edx
$LN18@Change_arr:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0002e	51		 push	 ecx
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00035	83 c4 08	 add	 esp, 8
$LN8@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         _Myfirst = _Newvec;

  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]

; 1751 :         _Mylast  = _Newvec + _Newsize;

  0003b	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0003e	89 0e		 mov	 DWORD PTR [esi], ecx
  00040	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00043	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1752 :         _Myend   = _Newvec + _Newcapacity;

  00046	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00049	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0004c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004f	5e		 pop	 esi

; 1753 :     }

  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
$LN15@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00054	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@Change_arr:
  00059	cc		 int	 3
?_Change_array@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@AAEXQAPAUSEffectMeshData@CEffectMesh@@II@Z ENDP ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?resize@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
$T1 = 11						; size = 1
?resize@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@QAEXI@Z PROC ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::resize, COMDAT
; _this$ = ecx

; 1288 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 1264 :         if (_Newsize < _Oldsize) { // trim

  00008	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  0000b	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  0000e	8b d3		 mov	 edx, ebx
  00010	8b 37		 mov	 esi, DWORD PTR [edi]
  00012	2b d6		 sub	 edx, esi
  00014	c1 fa 02	 sar	 edx, 2
  00017	3b ca		 cmp	 ecx, edx
  00019	73 0d		 jae	 SHORT $LN4@resize

; 1265 :             const pointer _Newlast = _Myfirst + _Newsize;

  0001b	8d 04 8e	 lea	 eax, DWORD PTR [esi+ecx*4]

; 1266 :             _Orphan_range(_Newlast, _Mylast);
; 1267 :             _Destroy(_Newlast, _Mylast);
; 1268 :             _Mylast = _Newlast;

  0001e	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00021	5f		 pop	 edi

; 1289 :         // trim or append value-initialized elements, provide strong guarantee
; 1290 :         _Resize(_Newsize, _Value_init_tag{});
; 1291 :     }

  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
$LN4@resize:

; 1272 :         if (_Newsize > _Oldsize) { // append

  00028	76 31		 jbe	 SHORT $LN5@resize

; 1273 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  0002a	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0002d	2b c6		 sub	 eax, esi
  0002f	c1 f8 02	 sar	 eax, 2

; 1274 :             if (_Newsize > _Oldcapacity) { // reallocate

  00032	3b c8		 cmp	 ecx, eax
  00034	76 13		 jbe	 SHORT $LN6@resize

; 1275 :                 _Resize_reallocate(_Newsize, _Val);

  00036	8d 45 0b	 lea	 eax, DWORD PTR $T1[ebp]
  00039	50		 push	 eax
  0003a	51		 push	 ecx
  0003b	8b cf		 mov	 ecx, edi
  0003d	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Resize_reallocate<std::_Value_init_tag>
  00042	5f		 pop	 edi

; 1289 :         // trim or append value-initialized elements, provide strong guarantee
; 1290 :         _Resize(_Newsize, _Value_init_tag{});
; 1291 :     }

  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
$LN6@resize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1824 :             _Zero_range(_PFirst, _PFirst + _Count);

  00049	2b ca		 sub	 ecx, edx
  0004b	8d 34 8b	 lea	 esi, DWORD PTR [ebx+ecx*4]
  0004e	56		 push	 esi
  0004f	53		 push	 ebx
  00050	e8 00 00 00 00	 call	 ??$_Zero_range@PAPAUSEffectMeshData@CEffectMesh@@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@QAPAU12@0@Z ; std::_Zero_range<CEffectMesh::SEffectMeshData * *>
  00055	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1280 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  00058	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN5@resize:
  0005b	5f		 pop	 edi

; 1289 :         // trim or append value-initialized elements, provide strong guarantee
; 1290 :         _Resize(_Newsize, _Value_init_tag{});
; 1291 :     }

  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
?resize@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z
_TEXT	SEGMENT
_stTokenVector$5 = -576					; size = 12
_textFileLoader$6 = -564				; size = 16
__My_data$1$ = -548					; size = 4
_pMotionData$7 = -544					; size = 4
_iTextureIndexVector$ = -540				; size = 12
_v3TextureVertexVector$ = -528				; size = 12
_iIndexVector$ = -516					; size = 12
_v3VertexVector$ = -504					; size = 12
_n$1$ = -492						; size = 4
__Old_capacity$1$ = -488				; size = 4
_rFrameData$1$ = -488					; size = 4
_v3VertexVector$2$ = -484				; size = 4
__Bytes$1$ = -480					; size = 4
__Bytes$1$ = -476					; size = 4
__Bytes$1$ = -472					; size = 4
tv3485 = -468						; size = 4
_i$1$ = -468						; size = 4
__Count$1$ = -464					; size = 4
tv3471 = -464						; size = 4
_this$GSCopy$1$ = -460					; size = 4
__Ptr$1$ = -456						; size = 4
_pMeshData$1$ = -452					; size = 4
__Ptr$1$ = -448						; size = 4
__Ptr$1$ = -444						; size = 4
__Ptr$1$ = -440						; size = 4
__Result$2$ = -436					; size = 4
tv3466 = -436						; size = 4
_pImage$8 = -436					; size = 4
_pImage$9 = -436					; size = 4
_c_pbBuf$GSCopy$4$ = -432				; size = 4
__Result$1$ = -428					; size = 4
__Newlast$1$ = -428					; size = 4
tv3464 = -428						; size = 4
$T10 = -428						; size = 1
__Backout$3$sroa$1121$1$ = -424				; size = 4
_i$1$ = -424						; size = 4
_j$1$ = -424						; size = 4
$T11 = -420						; size = 4
__My_data$1$ = -420					; size = 4
$T12 = -413						; size = 1
$T13 = -413						; size = 1
$T14 = -413						; size = 1
$T15 = -413						; size = 1
$T16 = -413						; size = 1
_File$17 = -412						; size = 324
_strExtension$18 = -88					; size = 24
_strPathName$19 = -64					; size = 24
_strTextureFileName$20 = -40				; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_iSize$ = 8						; size = 4
_c_pbBuf$ = 12						; size = 4
?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z PROC		; CEffectMesh::__LoadData_Ver002, COMDAT
; _this$ = ecx

; 102  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 34 02 00
	00		 sub	 esp, 564		; 00000234H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b f9		 mov	 edi, ecx
  0002f	89 bd 34 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], edi
  00035	8b 75 0c	 mov	 esi, DWORD PTR _c_pbBuf$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00038	33 c0		 xor	 eax, eax
  0003a	89 85 40 fe ff
	ff		 mov	 DWORD PTR __Ptr$1$[ebp], eax
  00040	89 85 08 fe ff
	ff		 mov	 DWORD PTR _v3VertexVector$[ebp], eax
  00046	89 85 0c fe ff
	ff		 mov	 DWORD PTR _v3VertexVector$[ebp+4], eax
  0004c	89 85 1c fe ff
	ff		 mov	 DWORD PTR _v3VertexVector$2$[ebp], eax
  00052	89 85 10 fe ff
	ff		 mov	 DWORD PTR _v3VertexVector$[ebp+8], eax
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 103  : 	std::vector<D3DXVECTOR3> v3VertexVector;

  00058	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0005b	89 85 38 fe ff
	ff		 mov	 DWORD PTR __Ptr$1$[ebp], eax
  00061	89 85 fc fd ff
	ff		 mov	 DWORD PTR _iIndexVector$[ebp], eax
  00067	89 85 00 fe ff
	ff		 mov	 DWORD PTR _iIndexVector$[ebp+4], eax
  0006d	89 85 20 fe ff
	ff		 mov	 DWORD PTR __Bytes$1$[ebp], eax
  00073	89 85 04 fe ff
	ff		 mov	 DWORD PTR _iIndexVector$[ebp+8], eax
  00079	89 85 44 fe ff
	ff		 mov	 DWORD PTR __Ptr$1$[ebp], eax
  0007f	89 85 f0 fd ff
	ff		 mov	 DWORD PTR _v3TextureVertexVector$[ebp], eax
  00085	89 85 f4 fd ff
	ff		 mov	 DWORD PTR _v3TextureVertexVector$[ebp+4], eax
  0008b	89 85 24 fe ff
	ff		 mov	 DWORD PTR __Bytes$1$[ebp], eax
  00091	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _v3TextureVertexVector$[ebp+8], eax
  00097	89 85 48 fe ff
	ff		 mov	 DWORD PTR __Ptr$1$[ebp], eax
  0009d	89 85 e4 fd ff
	ff		 mov	 DWORD PTR _iTextureIndexVector$[ebp], eax
  000a3	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _iTextureIndexVector$[ebp+4], eax
  000a9	89 85 28 fe ff
	ff		 mov	 DWORD PTR __Bytes$1$[ebp], eax
  000af	89 85 ec fd ff
	ff		 mov	 DWORD PTR _iTextureIndexVector$[ebp+8], eax
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 108  : 	m_iGeomCount = *(int *)c_pbBuf;

  000b5	8b 06		 mov	 eax, DWORD PTR [esi]

; 109  : 	c_pbBuf += 4;
; 110  : 	m_iFrameCount = *(int *)c_pbBuf;
; 111  : 	c_pbBuf += 4;
; 112  : 
; 113  : 	m_pEffectMeshDataVector.clear();

  000b7	8d 4f 34	 lea	 ecx, DWORD PTR [edi+52]
  000ba	89 47 2c	 mov	 DWORD PTR [edi+44], eax
  000bd	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000c0	83 c6 08	 add	 esi, 8
  000c3	89 47 30	 mov	 DWORD PTR [edi+48], eax
  000c6	8b 01		 mov	 eax, DWORD PTR [ecx]
  000c8	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 114  : 	m_pEffectMeshDataVector.resize(m_iGeomCount);

  000cb	ff 77 2c	 push	 DWORD PTR [edi+44]
  000ce	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000d2	89 8d dc fd ff
	ff		 mov	 DWORD PTR __My_data$1$[ebp], ecx
  000d8	e8 00 00 00 00	 call	 ?resize@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@QAEXI@Z ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::resize

; 116  : 	for (short n = 0; n < m_iGeomCount; ++n)

  000dd	83 7f 2c 00	 cmp	 DWORD PTR [edi+44], 0
  000e1	c7 85 14 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$1$[ebp], 0
  000eb	0f 8e ac 0a 00
	00		 jle	 $LN605@LoadData_V
$LL4@LoadData_V:

; 118  : 		SEffectMeshData * pMeshData = SEffectMeshData::New();

  000f1	e8 00 00 00 00	 call	 ?New@SEffectMeshData@CEffectMesh@@SAPAU12@XZ ; CEffectMesh::SEffectMeshData::New

; 120  : 		memcpy(pMeshData->szObjectName, c_pbBuf, 32);

  000f6	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  000f9	8b d0		 mov	 edx, eax

; 121  : 		c_pbBuf += 32;
; 122  : 		memcpy(pMeshData->szDiffuseMapFileName, c_pbBuf, 128);

  000fb	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1450 :         auto& _My_data    = _Mypair._Myval2;

  00100	8d 82 a0 00 00
	00		 lea	 eax, DWORD PTR [edx+160]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 118  : 		SEffectMeshData * pMeshData = SEffectMeshData::New();

  00106	89 95 3c fe ff
	ff		 mov	 DWORD PTR _pMeshData$1$[ebp], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1450 :         auto& _My_data    = _Mypair._Myval2;

  0010c	89 85 5c fe ff
	ff		 mov	 DWORD PTR __My_data$1$[ebp], eax
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 120  : 		memcpy(pMeshData->szObjectName, c_pbBuf, 32);

  00112	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 121  : 		c_pbBuf += 32;
; 122  : 		memcpy(pMeshData->szDiffuseMapFileName, c_pbBuf, 128);

  00115	8d 7a 20	 lea	 edi, DWORD PTR [edx+32]
  00118	0f 10 46 10	 movups	 xmm0, XMMWORD PTR [esi+16]
  0011c	83 c6 20	 add	 esi, 32			; 00000020H
  0011f	89 b5 50 fe ff
	ff		 mov	 DWORD PTR _c_pbBuf$GSCopy$4$[ebp], esi

; 123  : 		c_pbBuf += 128;

  00125	83 ad 50 fe ff
	ff 80		 sub	 DWORD PTR _c_pbBuf$GSCopy$4$[ebp], -128 ; ffffff80H
  0012c	0f 11 42 10	 movups	 XMMWORD PTR [edx+16], xmm0
  00130	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1455 :         _Destroy(_Myfirst, _Mylast);

  00132	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  00135	8b 30		 mov	 esi, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 949  :         for (; _First != _Last; ++_First) {

  00137	3b f7		 cmp	 esi, edi
  00139	74 1c		 je	 SHORT $LN59@LoadData_V
  0013b	0f 1f 44 00 00	 npad	 5
$LL60@LoadData_V:
  00140	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  00143	e8 00 00 00 00	 call	 ??1?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@QAE@XZ ; std::vector<SPTVertex,std::allocator<SPTVertex> >::~vector<SPTVertex,std::allocator<SPTVertex> >
  00148	83 c6 20	 add	 esi, 32			; 00000020H
  0014b	3b f7		 cmp	 esi, edi
  0014d	75 f1		 jne	 SHORT $LL60@LoadData_V
  0014f	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR __My_data$1$[ebp]
  00155	8b 30		 mov	 esi, DWORD PTR [eax]
$LN59@LoadData_V:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 126  : 		pMeshData->EffectFrameDataVector.resize(m_iFrameCount);

  00157	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1263 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  0015d	8b d6		 mov	 edx, esi

; 1456 :         _Mylast = _Myfirst;

  0015f	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1263 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  00162	8b 38		 mov	 edi, DWORD PTR [eax]
  00164	2b d7		 sub	 edx, edi
  00166	c1 fa 05	 sar	 edx, 5
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 126  : 		pMeshData->EffectFrameDataVector.resize(m_iFrameCount);

  00169	8b 49 30	 mov	 ecx, DWORD PTR [ecx+48]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1264 :         if (_Newsize < _Oldsize) { // trim

  0016c	3b ca		 cmp	 ecx, edx
  0016e	73 31		 jae	 SHORT $LN73@LoadData_V

; 1265 :             const pointer _Newlast = _Myfirst + _Newsize;

  00170	c1 e1 05	 shl	 ecx, 5
  00173	03 cf		 add	 ecx, edi
  00175	89 8d 54 fe ff
	ff		 mov	 DWORD PTR __Newlast$1$[ebp], ecx

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  0017b	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 949  :         for (; _First != _Last; ++_First) {

  0017d	3b ce		 cmp	 ecx, esi
  0017f	74 1b		 je	 SHORT $LN81@LoadData_V
$LL82@LoadData_V:
  00181	8d 4f 14	 lea	 ecx, DWORD PTR [edi+20]
  00184	e8 00 00 00 00	 call	 ??1?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@QAE@XZ ; std::vector<SPTVertex,std::allocator<SPTVertex> >::~vector<SPTVertex,std::allocator<SPTVertex> >
  00189	83 c7 20	 add	 edi, 32			; 00000020H
  0018c	3b fe		 cmp	 edi, esi
  0018e	75 f1		 jne	 SHORT $LL82@LoadData_V
  00190	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR __Newlast$1$[ebp]
  00196	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR __My_data$1$[ebp]
$LN81@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1268 :             _Mylast = _Newlast;

  0019c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1269 :             return;

  0019f	eb 43		 jmp	 SHORT $LN74@LoadData_V
$LN73@LoadData_V:

; 1272 :         if (_Newsize > _Oldsize) { // append

  001a1	76 41		 jbe	 SHORT $LN74@LoadData_V

; 1273 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  001a3	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  001a6	2b c7		 sub	 eax, edi
  001a8	c1 f8 05	 sar	 eax, 5

; 1274 :             if (_Newsize > _Oldcapacity) { // reallocate

  001ab	3b c8		 cmp	 ecx, eax
  001ad	76 15		 jbe	 SHORT $LN75@LoadData_V

; 1275 :                 _Resize_reallocate(_Newsize, _Val);

  001af	8d 85 54 fe ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  001b5	50		 push	 eax
  001b6	51		 push	 ecx
  001b7	8b 8d 5c fe ff
	ff		 mov	 ecx, DWORD PTR __My_data$1$[ebp]
  001bd	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::_Resize_reallocate<std::_Value_init_tag>

; 1276 :                 return;

  001c2	eb 1a		 jmp	 SHORT $LN678@LoadData_V
$LN75@LoadData_V:

; 1280 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  001c4	ff b5 54 fe ff
	ff		 push	 DWORD PTR $T10[ebp]
  001ca	2b ca		 sub	 ecx, edx
  001cc	51		 push	 ecx
  001cd	56		 push	 esi
  001ce	8b b5 5c fe ff
	ff		 mov	 esi, DWORD PTR __My_data$1$[ebp]
  001d4	8b ce		 mov	 ecx, esi
  001d6	e8 00 00 00 00	 call	 ?_Ufill@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@AAEPAUSEffectFrameData@CEffectMesh@@PAU34@IU_Value_init_tag@2@@Z ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::_Ufill
  001db	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN678@LoadData_V:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 128  : 		for(int i = 0; i < m_iFrameCount; ++i)

  001de	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR __My_data$1$[ebp]
$LN74@LoadData_V:
  001e4	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  001ea	c7 85 2c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$1$[ebp], 0
  001f4	83 79 30 00	 cmp	 DWORD PTR [ecx+48], 0
  001f8	0f 8e 98 03 00
	00		 jle	 $LN6@LoadData_V
  001fe	33 c9		 xor	 ecx, ecx
  00200	89 8d 54 fe ff
	ff		 mov	 DWORD PTR tv3464[ebp], ecx
$LL7@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  00206	8b 38		 mov	 edi, DWORD PTR [eax]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 132  : 			memcpy(&rFrameData.byChangedFrame, c_pbBuf, sizeof(BYTE));

  00208	8b 95 50 fe ff
	ff		 mov	 edx, DWORD PTR _c_pbBuf$GSCopy$4$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  0020e	03 f9		 add	 edi, ecx
  00210	89 bd 18 fe ff
	ff		 mov	 DWORD PTR _rFrameData$1$[ebp], edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 132  : 			memcpy(&rFrameData.byChangedFrame, c_pbBuf, sizeof(BYTE));

  00216	8a 02		 mov	 al, BYTE PTR [edx]
  00218	88 07		 mov	 BYTE PTR [edi], al

; 133  : 			c_pbBuf += sizeof(BYTE);
; 134  : 
; 135  : 			memcpy(&rFrameData.fVisibility, c_pbBuf, sizeof(float));

  0021a	8b 42 01	 mov	 eax, DWORD PTR [edx+1]
  0021d	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 136  : 			c_pbBuf += sizeof(float);
; 137  : 
; 138  : 			memcpy(&rFrameData.dwVertexCount, c_pbBuf, sizeof(DWORD));

  00220	8b 4a 05	 mov	 ecx, DWORD PTR [edx+5]
  00223	89 4f 08	 mov	 DWORD PTR [edi+8], ecx

; 139  : 			c_pbBuf += sizeof(DWORD);
; 140  : 
; 141  : 			memcpy(&rFrameData.dwIndexCount, c_pbBuf, sizeof(DWORD));

  00226	8b 72 09	 mov	 esi, DWORD PTR [edx+9]
  00229	89 77 10	 mov	 DWORD PTR [edi+16], esi

; 142  : 			c_pbBuf += sizeof(DWORD);
; 143  : 
; 144  : 			memcpy(&rFrameData.dwTextureVertexCount, c_pbBuf, sizeof(DWORD));

  0022c	8b 42 0d	 mov	 eax, DWORD PTR [edx+13]

; 145  : 			c_pbBuf += sizeof(DWORD);

  0022f	83 c2 11	 add	 edx, 17			; 00000011H
  00232	89 47 0c	 mov	 DWORD PTR [edi+12], eax

; 146  : 
; 147  : 			v3VertexVector.clear();

  00235	8b 85 40 fe ff
	ff		 mov	 eax, DWORD PTR __Ptr$1$[ebp]
  0023b	89 8d 30 fe ff
	ff		 mov	 DWORD PTR __Count$1$[ebp], ecx
  00241	89 95 50 fe ff
	ff		 mov	 DWORD PTR _c_pbBuf$GSCopy$4$[ebp], edx
  00247	89 85 0c fe ff
	ff		 mov	 DWORD PTR _v3VertexVector$[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1272 :         if (_Newsize > _Oldsize) { // append

  0024d	85 c9		 test	 ecx, ecx
  0024f	74 64		 je	 SHORT $LN98@LoadData_V

; 1273 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  00251	8b 8d 1c fe ff
	ff		 mov	 ecx, DWORD PTR _v3VertexVector$2$[ebp]
  00257	2b c8		 sub	 ecx, eax
  00259	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0025e	f7 e9		 imul	 ecx

; 1274 :             if (_Newsize > _Oldcapacity) { // reallocate

  00260	8b 8d 30 fe ff
	ff		 mov	 ecx, DWORD PTR __Count$1$[ebp]
  00266	d1 fa		 sar	 edx, 1
  00268	8b c2		 mov	 eax, edx
  0026a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0026d	03 c2		 add	 eax, edx
  0026f	3b c8		 cmp	 ecx, eax
  00271	76 30		 jbe	 SHORT $LN99@LoadData_V

; 1275 :                 _Resize_reallocate(_Newsize, _Val);

  00273	8d 85 63 fe ff
	ff		 lea	 eax, DWORD PTR $T16[ebp]
  00279	50		 push	 eax
  0027a	51		 push	 ecx
  0027b	8d 8d 08 fe ff
	ff		 lea	 ecx, DWORD PTR _v3VertexVector$[ebp]
  00281	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Resize_reallocate<std::_Value_init_tag>

; 1276 :                 return;

  00286	8b 85 10 fe ff
	ff		 mov	 eax, DWORD PTR _v3VertexVector$[ebp+8]
  0028c	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  0028f	89 85 1c fe ff
	ff		 mov	 DWORD PTR _v3VertexVector$2$[ebp], eax
  00295	8b 85 08 fe ff
	ff		 mov	 eax, DWORD PTR _v3VertexVector$[ebp]
  0029b	89 85 40 fe ff
	ff		 mov	 DWORD PTR __Ptr$1$[ebp], eax
  002a1	eb 12		 jmp	 SHORT $LN98@LoadData_V
$LN99@LoadData_V:

; 1280 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  002a3	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  002a6	8b 8d 40 fe ff
	ff		 mov	 ecx, DWORD PTR __Ptr$1$[ebp]
  002ac	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  002af	89 85 0c fe ff
	ff		 mov	 DWORD PTR _v3VertexVector$[ebp+4], eax
$LN98@LoadData_V:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 149  : 			iIndexVector.clear();

  002b5	8b 8d 38 fe ff
	ff		 mov	 ecx, DWORD PTR __Ptr$1$[ebp]
  002bb	89 8d 00 fe ff
	ff		 mov	 DWORD PTR _iIndexVector$[ebp+4], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1272 :         if (_Newsize > _Oldsize) { // append

  002c1	85 f6		 test	 esi, esi
  002c3	74 4f		 je	 SHORT $LN118@LoadData_V

; 1273 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  002c5	8b 85 20 fe ff
	ff		 mov	 eax, DWORD PTR __Bytes$1$[ebp]
  002cb	2b c1		 sub	 eax, ecx
  002cd	c1 f8 02	 sar	 eax, 2

; 1274 :             if (_Newsize > _Oldcapacity) { // reallocate

  002d0	3b f0		 cmp	 esi, eax
  002d2	76 2d		 jbe	 SHORT $LN119@LoadData_V

; 1275 :                 _Resize_reallocate(_Newsize, _Val);

  002d4	8d 85 63 fe ff
	ff		 lea	 eax, DWORD PTR $T15[ebp]
  002da	50		 push	 eax
  002db	56		 push	 esi
  002dc	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _iIndexVector$[ebp]
  002e2	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Resize_reallocate<std::_Value_init_tag>

; 1276 :                 return;

  002e7	8b 85 04 fe ff
	ff		 mov	 eax, DWORD PTR _iIndexVector$[ebp+8]
  002ed	89 85 20 fe ff
	ff		 mov	 DWORD PTR __Bytes$1$[ebp], eax
  002f3	8b 85 fc fd ff
	ff		 mov	 eax, DWORD PTR _iIndexVector$[ebp]
  002f9	89 85 38 fe ff
	ff		 mov	 DWORD PTR __Ptr$1$[ebp], eax
  002ff	eb 13		 jmp	 SHORT $LN118@LoadData_V
$LN119@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1824 :             _Zero_range(_PFirst, _PFirst + _Count);

  00301	8d 34 b1	 lea	 esi, DWORD PTR [ecx+esi*4]
  00304	56		 push	 esi
  00305	51		 push	 ecx
  00306	e8 00 00 00 00	 call	 ??$_Zero_range@PAH@std@@YAPAHQAH0@Z ; std::_Zero_range<int *>
  0030b	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1280 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  0030e	89 b5 00 fe ff
	ff		 mov	 DWORD PTR _iIndexVector$[ebp+4], esi
$LN118@LoadData_V:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 152  : 			v3TextureVertexVector.resize(rFrameData.dwTextureVertexCount);

  00314	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00317	8b 95 44 fe ff
	ff		 mov	 edx, DWORD PTR __Ptr$1$[ebp]
  0031d	89 95 f4 fd ff
	ff		 mov	 DWORD PTR _v3TextureVertexVector$[ebp+4], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1272 :         if (_Newsize > _Oldsize) { // append

  00323	85 c9		 test	 ecx, ecx
  00325	74 45		 je	 SHORT $LN140@LoadData_V

; 1273 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  00327	8b 85 24 fe ff
	ff		 mov	 eax, DWORD PTR __Bytes$1$[ebp]
  0032d	2b c2		 sub	 eax, edx
  0032f	c1 f8 03	 sar	 eax, 3

; 1274 :             if (_Newsize > _Oldcapacity) { // reallocate

  00332	3b c8		 cmp	 ecx, eax
  00334	76 2d		 jbe	 SHORT $LN141@LoadData_V

; 1275 :                 _Resize_reallocate(_Newsize, _Val);

  00336	8d 85 63 fe ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  0033c	50		 push	 eax
  0033d	51		 push	 ecx
  0033e	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _v3TextureVertexVector$[ebp]
  00344	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Resize_reallocate<std::_Value_init_tag>

; 1276 :                 return;

  00349	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR _v3TextureVertexVector$[ebp+8]
  0034f	89 85 24 fe ff
	ff		 mov	 DWORD PTR __Bytes$1$[ebp], eax
  00355	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _v3TextureVertexVector$[ebp]
  0035b	89 85 44 fe ff
	ff		 mov	 DWORD PTR __Ptr$1$[ebp], eax
  00361	eb 09		 jmp	 SHORT $LN140@LoadData_V
$LN141@LoadData_V:

; 1280 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  00363	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  00366	89 85 f4 fd ff
	ff		 mov	 DWORD PTR _v3TextureVertexVector$[ebp+4], eax
$LN140@LoadData_V:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 154  : 			iTextureIndexVector.resize(rFrameData.dwIndexCount);

  0036c	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0036f	8b 95 48 fe ff
	ff		 mov	 edx, DWORD PTR __Ptr$1$[ebp]
  00375	89 95 e8 fd ff
	ff		 mov	 DWORD PTR _iTextureIndexVector$[ebp+4], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1272 :         if (_Newsize > _Oldsize) { // append

  0037b	85 c9		 test	 ecx, ecx
  0037d	74 4f		 je	 SHORT $LN160@LoadData_V

; 1273 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  0037f	8b 85 28 fe ff
	ff		 mov	 eax, DWORD PTR __Bytes$1$[ebp]
  00385	2b c2		 sub	 eax, edx
  00387	c1 f8 02	 sar	 eax, 2

; 1274 :             if (_Newsize > _Oldcapacity) { // reallocate

  0038a	3b c8		 cmp	 ecx, eax
  0038c	76 2d		 jbe	 SHORT $LN161@LoadData_V

; 1275 :                 _Resize_reallocate(_Newsize, _Val);

  0038e	8d 85 63 fe ff
	ff		 lea	 eax, DWORD PTR $T13[ebp]
  00394	50		 push	 eax
  00395	51		 push	 ecx
  00396	8d 8d e4 fd ff
	ff		 lea	 ecx, DWORD PTR _iTextureIndexVector$[ebp]
  0039c	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Resize_reallocate<std::_Value_init_tag>

; 1276 :                 return;

  003a1	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _iTextureIndexVector$[ebp+8]
  003a7	89 85 28 fe ff
	ff		 mov	 DWORD PTR __Bytes$1$[ebp], eax
  003ad	8b 85 e4 fd ff
	ff		 mov	 eax, DWORD PTR _iTextureIndexVector$[ebp]
  003b3	89 85 48 fe ff
	ff		 mov	 DWORD PTR __Ptr$1$[ebp], eax
  003b9	eb 13		 jmp	 SHORT $LN160@LoadData_V
$LN161@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1824 :             _Zero_range(_PFirst, _PFirst + _Count);

  003bb	8d 34 8a	 lea	 esi, DWORD PTR [edx+ecx*4]
  003be	56		 push	 esi
  003bf	52		 push	 edx
  003c0	e8 00 00 00 00	 call	 ??$_Zero_range@PAH@std@@YAPAHQAH0@Z ; std::_Zero_range<int *>
  003c5	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1280 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  003c8	89 b5 e8 fd ff
	ff		 mov	 DWORD PTR _iTextureIndexVector$[ebp+4], esi
$LN160@LoadData_V:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 156  : 			memcpy(&v3VertexVector[0], c_pbBuf, rFrameData.dwVertexCount*sizeof(D3DXVECTOR3));

  003ce	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  003d1	8b b5 50 fe ff
	ff		 mov	 esi, DWORD PTR _c_pbBuf$GSCopy$4$[ebp]
  003d7	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  003da	c1 e0 02	 shl	 eax, 2
  003dd	50		 push	 eax
  003de	56		 push	 esi
  003df	ff b5 40 fe ff
	ff		 push	 DWORD PTR __Ptr$1$[ebp]
  003e5	e8 00 00 00 00	 call	 _memcpy

; 157  : 			c_pbBuf += rFrameData.dwVertexCount*sizeof(D3DXVECTOR3);

  003ea	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  003ed	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  003f0	8d 34 86	 lea	 esi, DWORD PTR [esi+eax*4]

; 158  : 			memcpy(&iIndexVector[0], c_pbBuf, rFrameData.dwIndexCount*sizeof(int));

  003f3	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  003f6	c1 e0 02	 shl	 eax, 2
  003f9	50		 push	 eax
  003fa	56		 push	 esi
  003fb	ff b5 38 fe ff
	ff		 push	 DWORD PTR __Ptr$1$[ebp]
  00401	e8 00 00 00 00	 call	 _memcpy

; 159  : 			c_pbBuf += rFrameData.dwIndexCount*sizeof(int);

  00406	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00409	8d 34 86	 lea	 esi, DWORD PTR [esi+eax*4]

; 160  : 			memcpy(&v3TextureVertexVector[0], c_pbBuf, rFrameData.dwTextureVertexCount*sizeof(D3DXVECTOR2));

  0040c	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0040f	c1 e0 03	 shl	 eax, 3
  00412	50		 push	 eax
  00413	56		 push	 esi
  00414	ff b5 44 fe ff
	ff		 push	 DWORD PTR __Ptr$1$[ebp]
  0041a	e8 00 00 00 00	 call	 _memcpy

; 161  : 			c_pbBuf += rFrameData.dwTextureVertexCount*sizeof(D3DXVECTOR2);

  0041f	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00422	8d 34 c6	 lea	 esi, DWORD PTR [esi+eax*8]

; 162  : 			memcpy(&iTextureIndexVector[0], c_pbBuf, rFrameData.dwIndexCount*sizeof(int));

  00425	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00428	c1 e0 02	 shl	 eax, 2
  0042b	50		 push	 eax
  0042c	56		 push	 esi
  0042d	ff b5 48 fe ff
	ff		 push	 DWORD PTR __Ptr$1$[ebp]
  00433	e8 00 00 00 00	 call	 _memcpy

; 163  : 			c_pbBuf += rFrameData.dwIndexCount*sizeof(int);

  00438	8b 47 10	 mov	 eax, DWORD PTR [edi+16]

; 164  : 
; 165  : 			///////////////////////////////
; 166  : 
; 167  : 			rFrameData.PDTVertexVector.clear();

  0043b	8d 57 14	 lea	 edx, DWORD PTR [edi+20]
  0043e	83 c4 30	 add	 esp, 48			; 00000030H
  00441	8d 34 86	 lea	 esi, DWORD PTR [esi+eax*4]
  00444	8b 02		 mov	 eax, DWORD PTR [edx]
  00446	89 b5 50 fe ff
	ff		 mov	 DWORD PTR _c_pbBuf$GSCopy$4$[ebp], esi
  0044c	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 168  : 			rFrameData.PDTVertexVector.resize(rFrameData.dwIndexCount);

  0044f	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  00452	89 85 58 fe ff
	ff		 mov	 DWORD PTR __Backout$3$sroa$1121$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1272 :         if (_Newsize > _Oldsize) { // append

  00458	85 f6		 test	 esi, esi
  0045a	74 54		 je	 SHORT $LN190@LoadData_V

; 1273 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  0045c	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0045f	2b c8		 sub	 ecx, eax
  00461	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00466	f7 e9		 imul	 ecx
  00468	c1 fa 03	 sar	 edx, 3
  0046b	8b c2		 mov	 eax, edx
  0046d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00470	03 c2		 add	 eax, edx

; 1274 :             if (_Newsize > _Oldcapacity) { // reallocate

  00472	3b f0		 cmp	 esi, eax
  00474	76 15		 jbe	 SHORT $LN191@LoadData_V

; 1275 :                 _Resize_reallocate(_Newsize, _Val);

  00476	8d 85 63 fe ff
	ff		 lea	 eax, DWORD PTR $T12[ebp]
  0047c	50		 push	 eax
  0047d	56		 push	 esi
  0047e	8d 4f 14	 lea	 ecx, DWORD PTR [edi+20]
  00481	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<SPTVertex,std::allocator<SPTVertex> >::_Resize_reallocate<std::_Value_init_tag>

; 1276 :                 return;

  00486	8d 57 14	 lea	 edx, DWORD PTR [edi+20]
  00489	eb 25		 jmp	 SHORT $LN190@LoadData_V
$LN191@LoadData_V:

; 1277 :             }
; 1278 : 
; 1279 :             const pointer _Oldlast = _Mylast;

  0048b	8d 34 b6	 lea	 esi, DWORD PTR [esi+esi*4]
  0048e	c1 e6 02	 shl	 esi, 2
  00491	56		 push	 esi
  00492	6a 00		 push	 0
  00494	ff b5 58 fe ff
	ff		 push	 DWORD PTR __Backout$3$sroa$1121$1$[ebp]
  0049a	e8 00 00 00 00	 call	 _memset
  0049f	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR __Backout$3$sroa$1121$1$[ebp]

; 1280 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  004a5	8d 57 14	 lea	 edx, DWORD PTR [edi+20]
  004a8	83 c4 0c	 add	 esp, 12			; 0000000cH
  004ab	03 c6		 add	 eax, esi
  004ad	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN190@LoadData_V:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 169  : 			for (DWORD j = 0; j < rFrameData.dwIndexCount; ++j)

  004b0	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  004b4	c7 85 58 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$1$[ebp], 0
  004be	0f 86 a1 00 00
	00		 jbe	 $LN5@LoadData_V
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1563 :         auto& _My_data = _Mypair._Myval2;

  004c4	8b 85 38 fe ff
	ff		 mov	 eax, DWORD PTR __Ptr$1$[ebp]
  004ca	33 c9		 xor	 ecx, ecx
  004cc	8b b5 48 fe ff
	ff		 mov	 esi, DWORD PTR __Ptr$1$[ebp]
  004d2	2b c6		 sub	 eax, esi
  004d4	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@bf800000
  004dc	89 8d 30 fe ff
	ff		 mov	 DWORD PTR tv3471[ebp], ecx
  004e2	89 85 4c fe ff
	ff		 mov	 DWORD PTR tv3466[ebp], eax
$LL10@LoadData_V:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 173  : 				DWORD dwIndex = iIndexVector[j];

  004e8	8b 04 30	 mov	 eax, DWORD PTR [eax+esi]
  004eb	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  004ee	8b 12		 mov	 edx, DWORD PTR [edx]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 179  : 				rVertex.position = v3VertexVector[dwIndex];

  004f0	8b bd 40 fe ff
	ff		 mov	 edi, DWORD PTR __Ptr$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  004f6	03 d1		 add	 edx, ecx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 174  : 				DWORD dwTextureIndex = iTextureIndexVector[j];

  004f8	8b 4e fc	 mov	 ecx, DWORD PTR [esi-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  004fb	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 179  : 				rVertex.position = v3VertexVector[dwIndex];

  004fe	f3 0f 7e 04 87	 movq	 xmm0, QWORD PTR [edi+eax*4]
  00503	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  00507	8b 44 87 08	 mov	 eax, DWORD PTR [edi+eax*4+8]

; 180  : 				rVertex.texCoord = v3TextureVertexVector[dwTextureIndex];

  0050b	8b bd 44 fe ff
	ff		 mov	 edi, DWORD PTR __Ptr$1$[ebp]
  00511	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00514	8b 85 44 fe ff
	ff		 mov	 eax, DWORD PTR __Ptr$1$[ebp]
  0051a	8b 04 c8	 mov	 eax, DWORD PTR [eax+ecx*8]
  0051d	8b 4c cf 04	 mov	 ecx, DWORD PTR [edi+ecx*8+4]
  00521	8b bd 18 fe ff
	ff		 mov	 edi, DWORD PTR _rFrameData$1$[ebp]
  00527	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 181  : 				rVertex.texCoord.y *= -1;

  0052a	f3 0f 10 42 10	 movss	 xmm0, DWORD PTR [edx+16]
  0052f	8b 8d 30 fe ff
	ff		 mov	 ecx, DWORD PTR tv3471[ebp]
  00535	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  00538	83 c1 14	 add	 ecx, 20			; 00000014H
  0053b	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR _j$1$[ebp]
  00541	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00545	40		 inc	 eax
  00546	89 85 58 fe ff
	ff		 mov	 DWORD PTR _j$1$[ebp], eax
  0054c	89 8d 30 fe ff
	ff		 mov	 DWORD PTR tv3471[ebp], ecx
  00552	f3 0f 11 42 10	 movss	 DWORD PTR [edx+16], xmm0
  00557	8d 57 14	 lea	 edx, DWORD PTR [edi+20]
  0055a	3b 47 10	 cmp	 eax, DWORD PTR [edi+16]
  0055d	8b 85 4c fe ff
	ff		 mov	 eax, DWORD PTR tv3466[ebp]
  00563	72 83		 jb	 SHORT $LL10@LoadData_V
$LN5@LoadData_V:

; 128  : 		for(int i = 0; i < m_iFrameCount; ++i)

  00565	8b 85 2c fe ff
	ff		 mov	 eax, DWORD PTR _i$1$[ebp]
  0056b	8b 95 34 fe ff
	ff		 mov	 edx, DWORD PTR _this$GSCopy$1$[ebp]
  00571	40		 inc	 eax
  00572	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR tv3464[ebp]
  00578	83 c1 20	 add	 ecx, 32			; 00000020H
  0057b	89 85 2c fe ff
	ff		 mov	 DWORD PTR _i$1$[ebp], eax
  00581	89 8d 54 fe ff
	ff		 mov	 DWORD PTR tv3464[ebp], ecx
  00587	3b 42 30	 cmp	 eax, DWORD PTR [edx+48]
  0058a	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR __My_data$1$[ebp]
  00590	0f 8c 70 fc ff
	ff		 jl	 $LL7@LoadData_V
$LN6@LoadData_V:

; 182  : 			}
; 183  : 		}
; 184  : 
; 185  : 		////////////////////////////////////
; 186  : 
; 187  : 		pMeshData->pImageVector.clear();

  00596	8b 8d 3c fe ff
	ff		 mov	 ecx, DWORD PTR _pMeshData$1$[ebp]
  0059c	8b 81 ac 00 00
	00		 mov	 eax, DWORD PTR [ecx+172]
  005a2	8d b9 ac 00 00
	00		 lea	 edi, DWORD PTR [ecx+172]
  005a8	89 47 04	 mov	 DWORD PTR [edi+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  005ab	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _strExtension$18[ebp], 0

; 4596 :         _My_data._Mysize = 0;

  005b2	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _strExtension$18[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  005b9	c7 45 bc 0f 00
	00 00		 mov	 DWORD PTR _strExtension$18[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  005c0	c6 45 a8 00	 mov	 BYTE PTR _strExtension$18[ebp], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 190  : 		GetFileExtension(pMeshData->szDiffuseMapFileName, strlen(pMeshData->szDiffuseMapFileName), &strExtension);

  005c4	8d 71 20	 lea	 esi, DWORD PTR [ecx+32]
  005c7	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  005cb	8b ce		 mov	 ecx, esi
  005cd	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL669@LoadData_V:
  005d0	8a 01		 mov	 al, BYTE PTR [ecx]
  005d2	41		 inc	 ecx
  005d3	84 c0		 test	 al, al
  005d5	75 f9		 jne	 SHORT $LL669@LoadData_V
  005d7	8d 45 a8	 lea	 eax, DWORD PTR _strExtension$18[ebp]
  005da	2b ca		 sub	 ecx, edx
  005dc	50		 push	 eax
  005dd	51		 push	 ecx
  005de	56		 push	 esi
  005df	e8 00 00 00 00	 call	 ?GetFileExtension@@YAXPBDHPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GetFileExtension

; 191  : 		stl_lowers(strExtension);

  005e4	8d 45 a8	 lea	 eax, DWORD PTR _strExtension$18[ebp]
  005e7	50		 push	 eax
  005e8	e8 00 00 00 00	 call	 ?stl_lowers@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; stl_lowers
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 590  :     const int _Ans = _Traits::compare(_Left, _Right, (_STD min)(_Left_size, _Right_size));

  005ed	8b 75 b8	 mov	 esi, DWORD PTR _strExtension$18[ebp+16]

; 2305 :         const value_type* _Result = _Bx._Buf;

  005f0	8d 4d a8	 lea	 ecx, DWORD PTR _strExtension$18[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 191  : 		stl_lowers(strExtension);

  005f3	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 590  :     const int _Ans = _Traits::compare(_Left, _Right, (_STD min)(_Left_size, _Right_size));

  005f6	b8 03 00 00 00	 mov	 eax, 3

; 2306 :         if (_Large_string_engaged()) {

  005fb	83 7d bc 10	 cmp	 DWORD PTR _strExtension$18[ebp+20], 16 ; 00000010H

; 392  :         return _CSTD memcmp(_First1, _First2, _Count);

  005ff	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_03BNIHALFD@ifl@

; 2306 :         if (_Large_string_engaged()) {

  00604	0f 43 4d a8	 cmovae	 ecx, DWORD PTR _strExtension$18[ebp]

; 590  :     const int _Ans = _Traits::compare(_Left, _Right, (_STD min)(_Left_size, _Right_size));

  00608	83 fe 03	 cmp	 esi, 3
  0060b	0f 47 f0	 cmova	 esi, eax

; 392  :         return _CSTD memcmp(_First1, _First2, _Count);

  0060e	83 ee 04	 sub	 esi, 4
  00611	72 11		 jb	 SHORT $LN672@LoadData_V
$LL673@LoadData_V:
  00613	8b 01		 mov	 eax, DWORD PTR [ecx]
  00615	3b 02		 cmp	 eax, DWORD PTR [edx]
  00617	75 10		 jne	 SHORT $LN671@LoadData_V
  00619	83 c1 04	 add	 ecx, 4
  0061c	83 c2 04	 add	 edx, 4
  0061f	83 ee 04	 sub	 esi, 4
  00622	73 ef		 jae	 SHORT $LL673@LoadData_V
$LN672@LoadData_V:
  00624	83 fe fc	 cmp	 esi, -4			; fffffffcH
  00627	74 34		 je	 SHORT $LN670@LoadData_V
$LN671@LoadData_V:
  00629	8a 01		 mov	 al, BYTE PTR [ecx]
  0062b	3a 02		 cmp	 al, BYTE PTR [edx]
  0062d	75 27		 jne	 SHORT $LN674@LoadData_V
  0062f	83 fe fd	 cmp	 esi, -3			; fffffffdH
  00632	74 29		 je	 SHORT $LN670@LoadData_V
  00634	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00637	3a 42 01	 cmp	 al, BYTE PTR [edx+1]
  0063a	75 1a		 jne	 SHORT $LN674@LoadData_V
  0063c	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0063f	74 1c		 je	 SHORT $LN670@LoadData_V
  00641	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  00644	3a 42 02	 cmp	 al, BYTE PTR [edx+2]
  00647	75 0d		 jne	 SHORT $LN674@LoadData_V
  00649	83 fe ff	 cmp	 esi, -1
  0064c	74 0f		 je	 SHORT $LN670@LoadData_V
  0064e	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  00651	3a 42 03	 cmp	 al, BYTE PTR [edx+3]
  00654	74 07		 je	 SHORT $LN670@LoadData_V
$LN674@LoadData_V:
  00656	1b c0		 sbb	 eax, eax
  00658	83 c8 01	 or	 eax, 1
  0065b	eb 02		 jmp	 SHORT $LN675@LoadData_V
$LN670@LoadData_V:
  0065d	33 c0		 xor	 eax, eax
$LN675@LoadData_V:

; 592  :     if (_Ans != 0) {

  0065f	85 c0		 test	 eax, eax
  00661	0f 85 8f 03 00
	00		 jne	 $LN14@LoadData_V

; 593  :         return _Ans;
; 594  :     }
; 595  : 
; 596  :     if (_Left_size < _Right_size) {

  00667	8b 45 b8	 mov	 eax, DWORD PTR _strExtension$18[ebp+16]
  0066a	83 f8 03	 cmp	 eax, 3
  0066d	73 05		 jae	 SHORT $LN242@LoadData_V

; 597  :         return -1;

  0066f	83 c8 ff	 or	 eax, -1
  00672	eb 0b		 jmp	 SHORT $LN243@LoadData_V
$LN242@LoadData_V:

; 598  :     }
; 599  : 
; 600  :     if (_Left_size > _Right_size) {

  00674	b9 03 00 00 00	 mov	 ecx, 3
  00679	3b c8		 cmp	 ecx, eax
  0067b	1b c0		 sbb	 eax, eax
  0067d	f7 d8		 neg	 eax
$LN243@LoadData_V:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 193  : 		if (0 == strExtension.compare("ifl"))

  0067f	85 c0		 test	 eax, eax
  00681	0f 85 6f 03 00
	00		 jne	 $LN14@LoadData_V

; 194  : 		{
; 195  : 			LPCVOID pMotionData;
; 196  : 			CMappedFile File;

  00687	8d 8d 64 fe ff
	ff		 lea	 ecx, DWORD PTR _File$17[ebp]
  0068d	e8 00 00 00 00	 call	 ??0CMappedFile@@QAE@XZ	; CMappedFile::CMappedFile

; 197  : 
; 198  : 			if (CEterPackManager::Instance().Get(File, pMeshData->szDiffuseMapFileName, &pMotionData))

  00692	8b b5 3c fe ff
	ff		 mov	 esi, DWORD PTR _pMeshData$1$[ebp]
  00698	8d 85 e0 fd ff
	ff		 lea	 eax, DWORD PTR _pMotionData$7[ebp]
  0069e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  006a4	83 c6 20	 add	 esi, 32			; 00000020H
  006a7	50		 push	 eax
  006a8	56		 push	 esi
  006a9	8d 85 64 fe ff
	ff		 lea	 eax, DWORD PTR _File$17[ebp]
  006af	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  006b3	50		 push	 eax
  006b4	e8 00 00 00 00	 call	 ?Get@CEterPackManager@@QAE_NAAVCMappedFile@@PBDPAPBX@Z ; CEterPackManager::Get
  006b9	84 c0		 test	 al, al
  006bb	0f 84 22 03 00
	00		 je	 $LN16@LoadData_V

; 199  : 			{
; 200  : 				CMemoryTextFileLoader textFileLoader;

  006c1	8d 8d cc fd ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$6[ebp]
  006c7	e8 00 00 00 00	 call	 ??0CMemoryTextFileLoader@@QAE@XZ ; CMemoryTextFileLoader::CMemoryTextFileLoader
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  006cc	c7 85 c0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _stTokenVector$5[ebp], 0
  006d6	c7 85 c4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _stTokenVector$5[ebp+4], 0
  006e0	c7 85 c8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _stTokenVector$5[ebp+8], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 203  : 				textFileLoader.Bind(File.Size(), pMotionData);

  006ea	ff b5 e0 fd ff
	ff		 push	 DWORD PTR _pMotionData$7[ebp]
  006f0	8d 8d 64 fe ff
	ff		 lea	 ecx, DWORD PTR _File$17[ebp]
  006f6	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  006fa	e8 00 00 00 00	 call	 ?Size@CMappedFile@@QAEKXZ ; CMappedFile::Size
  006ff	50		 push	 eax
  00700	8d 8d cc fd ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$6[ebp]
  00706	e8 00 00 00 00	 call	 ?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z ; CMemoryTextFileLoader::Bind
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0070b	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _strPathName$19[ebp], 0

; 4596 :         _My_data._Mysize = 0;

  00712	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _strPathName$19[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00719	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _strPathName$19[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00720	c6 45 c0 00	 mov	 BYTE PTR _strPathName$19[ebp], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 206  : 				GetOnlyPathName(pMeshData->szDiffuseMapFileName, strPathName);

  00724	8d 45 c0	 lea	 eax, DWORD PTR _strPathName$19[ebp]
  00727	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  0072b	50		 push	 eax
  0072c	56		 push	 esi
  0072d	e8 00 00 00 00	 call	 ?GetOnlyPathName@@YAXPBDAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GetOnlyPathName
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00732	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _strTextureFileName$20[ebp], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 206  : 				GetOnlyPathName(pMeshData->szDiffuseMapFileName, strPathName);

  00739	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4596 :         _My_data._Mysize = 0;

  0073c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _strTextureFileName$20[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00743	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _strTextureFileName$20[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0074a	c6 45 d8 00	 mov	 BYTE PTR _strTextureFileName$20[ebp], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 209  : 				for (DWORD i = 0; i < textFileLoader.GetLineCount(); ++i)

  0074e	33 f6		 xor	 esi, esi
  00750	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00754	8d 8d cc fd ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$6[ebp]
  0075a	89 b5 58 fe ff
	ff		 mov	 DWORD PTR _i$1$[ebp], esi
  00760	e8 00 00 00 00	 call	 ?GetLineCount@CMemoryTextFileLoader@@QAEKXZ ; CMemoryTextFileLoader::GetLineCount
  00765	85 c0		 test	 eax, eax
  00767	0f 84 d7 01 00
	00		 je	 $LN12@LoadData_V
  0076d	0f 1f 00	 npad	 3
$LL13@LoadData_V:

; 210  : 				{
; 211  : 					const std::string & c_rstrFileName = textFileLoader.GetLineString(i);

  00770	56		 push	 esi
  00771	8d 8d cc fd ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$6[ebp]
  00777	e8 00 00 00 00	 call	 ?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; CMemoryTextFileLoader::GetLineString
  0077c	89 85 54 fe ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4019 :         return size() == 0;

  00782	83 c0 10	 add	 eax, 16			; 00000010H
  00785	89 85 2c fe ff
	ff		 mov	 DWORD PTR tv3485[ebp], eax
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 213  : 					if (c_rstrFileName.empty())

  0078b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0078e	0f 84 96 01 00
	00		 je	 $LN11@LoadData_V
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2306 :         if (_Large_string_engaged()) {

  00794	83 7d d4 10	 cmp	 DWORD PTR _strPathName$19[ebp+20], 16 ; 00000010H
  00798	8d 45 c0	 lea	 eax, DWORD PTR _strPathName$19[ebp]

; 3035 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0079b	8b 4d ec	 mov	 ecx, DWORD PTR _strTextureFileName$20[ebp+20]

; 2306 :         if (_Large_string_engaged()) {

  0079e	0f 43 45 c0	 cmovae	 eax, DWORD PTR _strPathName$19[ebp]

; 3035 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  007a2	8b 7d d0	 mov	 edi, DWORD PTR _strPathName$19[ebp+16]

; 2306 :         if (_Large_string_engaged()) {

  007a5	89 85 4c fe ff
	ff		 mov	 DWORD PTR __Result$2$[ebp], eax

; 3035 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  007ab	89 8d 18 fe ff
	ff		 mov	 DWORD PTR __Old_capacity$1$[ebp], ecx
  007b1	3b f9		 cmp	 edi, ecx

; 3246 :         if (_Count <= _Mypair._Myval2._Myres) {

  007b3	77 21		 ja	 SHORT $LN294@LoadData_V

; 2297 :         if (_Large_string_engaged()) {

  007b5	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  007b8	89 7d e8	 mov	 DWORD PTR _strTextureFileName$20[ebp+16], edi
  007bb	57		 push	 edi

; 2296 :         value_type* _Result = _Bx._Buf;

  007bc	8d 75 d8	 lea	 esi, DWORD PTR _strTextureFileName$20[ebp]

; 2297 :         if (_Large_string_engaged()) {

  007bf	0f 43 75 d8	 cmovae	 esi, DWORD PTR _strTextureFileName$20[ebp]

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  007c3	50		 push	 eax
  007c4	56		 push	 esi
  007c5	e8 00 00 00 00	 call	 _memmove
  007ca	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  007cd	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0

; 3251 :             return *this;

  007d1	e9 de 00 00 00	 jmp	 $LN306@LoadData_V
$LN294@LoadData_V:

; 4508 :         if (_New_size > max_size()) {

  007d6	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH
  007dc	0f 87 dd 03 00
	00		 ja	 $LN636@LoadData_V

; 4510 :         }
; 4511 : 
; 4512 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  007e2	8b f7		 mov	 esi, edi
  007e4	83 ce 0f	 or	 esi, 15			; 0000000fH

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  007e7	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 4489 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  007ed	76 15		 jbe	 SHORT $LN311@LoadData_V

; 4490 :             return _Max;

  007ef	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  007f4	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  007f9	50		 push	 eax
  007fa	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  007ff	83 c4 04	 add	 esp, 4
  00802	eb 52		 jmp	 SHORT $LN680@LoadData_V
$LN311@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4493 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00804	8b d1		 mov	 edx, ecx
  00806	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0080b	d1 ea		 shr	 edx, 1
  0080d	2b c2		 sub	 eax, edx
  0080f	3b c8		 cmp	 ecx, eax
  00811	76 15		 jbe	 SHORT $LN312@LoadData_V

; 4494 :             return _Max;

  00813	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00818	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0081d	50		 push	 eax
  0081e	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00823	83 c4 04	 add	 esp, 4
  00826	eb 2e		 jmp	 SHORT $LN680@LoadData_V
$LN312@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4497 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00828	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  0082b	3b f0		 cmp	 esi, eax
  0082d	0f 42 f0	 cmovb	 esi, eax

; 4515 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00830	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00833	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00838	72 0b		 jb	 SHORT $LN319@LoadData_V

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0083a	50		 push	 eax
  0083b	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00840	83 c4 04	 add	 esp, 4
  00843	eb 11		 jmp	 SHORT $LN680@LoadData_V
$LN319@LoadData_V:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  00845	85 c0		 test	 eax, eax
  00847	74 0b		 je	 SHORT $LN320@LoadData_V

; 85   :         return ::operator new(_Bytes);

  00849	50		 push	 eax
  0084a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0084f	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  00852	eb 02		 jmp	 SHORT $LN680@LoadData_V
$LN320@LoadData_V:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  00854	33 c0		 xor	 eax, eax
$LN680@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00856	57		 push	 edi
  00857	ff b5 4c fe ff
	ff		 push	 DWORD PTR __Result$2$[ebp]

; 4524 :         _Mypair._Myval2._Myres  = _New_capacity;

  0085d	89 75 ec	 mov	 DWORD PTR _strTextureFileName$20[ebp+20], esi

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00860	8b f0		 mov	 esi, eax
  00862	56		 push	 esi

; 4523 :         _Mypair._Myval2._Mysize = _New_size;

  00863	89 85 5c fe ff
	ff		 mov	 DWORD PTR $T11[ebp], eax
  00869	89 7d e8	 mov	 DWORD PTR _strTextureFileName$20[ebp+16], edi

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0086c	e8 00 00 00 00	 call	 _memcpy

; 4526 :         if (_BUF_SIZE <= _Old_capacity) {

  00871	8b 85 18 fe ff
	ff		 mov	 eax, DWORD PTR __Old_capacity$1$[ebp]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00877	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3258 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0087a	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0

; 4526 :         if (_BUF_SIZE <= _Old_capacity) {

  0087e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00881	72 2e		 jb	 SHORT $LN305@LoadData_V
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00883	8b 4d d8	 mov	 ecx, DWORD PTR _strTextureFileName$20[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4527 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00886	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00889	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0088b	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00891	72 14		 jb	 SHORT $LN342@LoadData_V

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00893	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00896	83 c2 23	 add	 edx, 35			; 00000023H
  00899	2b c1		 sub	 eax, ecx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0089b	83 c0 fc	 add	 eax, -4			; fffffffcH
  0089e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  008a1	0f 87 1d 03 00
	00		 ja	 $LN618@LoadData_V
$LN342@LoadData_V:

; 264  :         ::operator delete(_Ptr, _Bytes);

  008a7	52		 push	 edx
  008a8	51		 push	 ecx
  008a9	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  008ae	83 c4 08	 add	 esp, 8
$LN305@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2306 :         if (_Large_string_engaged()) {

  008b1	89 75 d8	 mov	 DWORD PTR _strTextureFileName$20[ebp], esi
$LN306@LoadData_V:
  008b4	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR __Result$1$[ebp]
  008ba	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  008be	72 02		 jb	 SHORT $LN355@LoadData_V

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  008c0	8b 00		 mov	 eax, DWORD PTR [eax]
$LN355@LoadData_V:

; 3124 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  008c2	8b 8d 2c fe ff
	ff		 mov	 ecx, DWORD PTR tv3485[ebp]
  008c8	ff 31		 push	 DWORD PTR [ecx]
  008ca	8d 4d d8	 lea	 ecx, DWORD PTR _strTextureFileName$20[ebp]
  008cd	50		 push	 eax
  008ce	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2306 :         if (_Large_string_engaged()) {

  008d3	83 7d ec 10	 cmp	 DWORD PTR _strTextureFileName$20[ebp+20], 16 ; 00000010H
  008d7	8d 45 d8	 lea	 eax, DWORD PTR _strTextureFileName$20[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 219  : 					CGraphicImage * pImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer(strTextureFileName.c_str());

  008da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2306 :         if (_Large_string_engaged()) {

  008e0	0f 43 45 d8	 cmovae	 eax, DWORD PTR _strTextureFileName$20[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 219  : 					CGraphicImage * pImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer(strTextureFileName.c_str());

  008e4	50		 push	 eax
  008e5	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  008ea	8b bd 3c fe ff
	ff		 mov	 edi, DWORD PTR _pMeshData$1$[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 219  : 					CGraphicImage * pImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer(strTextureFileName.c_str());

  008f0	8b c8		 mov	 ecx, eax
  008f2	89 8d 4c fe ff
	ff		 mov	 DWORD PTR _pImage$9[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  008f8	8b 87 b0 00 00
	00		 mov	 eax, DWORD PTR [edi+176]
  008fe	3b 87 b4 00 00
	00		 cmp	 eax, DWORD PTR [edi+180]
  00904	74 0b		 je	 SHORT $LN369@LoadData_V

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00906	89 08		 mov	 DWORD PTR [eax], ecx

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

  00908	83 87 b0 00 00
	00 04		 add	 DWORD PTR [edi+176], 4

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0090f	eb 13		 jmp	 SHORT $LN681@LoadData_V
$LN369@LoadData_V:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00911	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR _pImage$9[ebp]
  00917	51		 push	 ecx
  00918	50		 push	 eax
  00919	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  0091f	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEPAPAVCGraphicImage@@QAPAV2@ABQAV2@@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Emplace_reallocate<CGraphicImage * const &>
$LN681@LoadData_V:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 209  : 				for (DWORD i = 0; i < textFileLoader.GetLineCount(); ++i)

  00924	8b b5 58 fe ff
	ff		 mov	 esi, DWORD PTR _i$1$[ebp]
$LN11@LoadData_V:
  0092a	46		 inc	 esi
  0092b	8d 8d cc fd ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$6[ebp]
  00931	89 b5 58 fe ff
	ff		 mov	 DWORD PTR _i$1$[ebp], esi
  00937	e8 00 00 00 00	 call	 ?GetLineCount@CMemoryTextFileLoader@@QAEKXZ ; CMemoryTextFileLoader::GetLineCount
  0093c	3b f0		 cmp	 esi, eax
  0093e	0f 82 2c fe ff
	ff		 jb	 $LL13@LoadData_V
$LN12@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00944	8b 55 ec	 mov	 edx, DWORD PTR _strTextureFileName$20[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 223  : 			}

  00947	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0094b	83 fa 10	 cmp	 edx, 16			; 00000010H
  0094e	72 2c		 jb	 SHORT $LN385@LoadData_V
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00950	8b 4d d8	 mov	 ecx, DWORD PTR _strTextureFileName$20[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00953	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00954	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00956	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0095c	72 14		 jb	 SHORT $LN395@LoadData_V

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0095e	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00961	83 c2 23	 add	 edx, 35			; 00000023H
  00964	2b c1		 sub	 eax, ecx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00966	83 c0 fc	 add	 eax, -4			; fffffffcH
  00969	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0096c	0f 87 52 02 00
	00		 ja	 $LN618@LoadData_V
$LN395@LoadData_V:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00972	52		 push	 edx
  00973	51		 push	 ecx
  00974	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00979	83 c4 08	 add	 esp, 8
$LN385@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0097c	8b 55 d4	 mov	 edx, DWORD PTR _strPathName$19[ebp+20]

; 4633 :             _Mypair._Myval2._Mysize = 0;

  0097f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _strTextureFileName$20[ebp+16], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00986	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _strTextureFileName$20[ebp+20], 15 ; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0098d	c6 45 d8 00	 mov	 BYTE PTR _strTextureFileName$20[ebp], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 223  : 			}

  00991	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00995	83 fa 10	 cmp	 edx, 16			; 00000010H
  00998	72 2c		 jb	 SHORT $LN412@LoadData_V
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0099a	8b 4d c0	 mov	 ecx, DWORD PTR _strPathName$19[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0099d	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0099e	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  009a0	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  009a6	72 14		 jb	 SHORT $LN422@LoadData_V

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  009a8	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  009ab	83 c2 23	 add	 edx, 35			; 00000023H
  009ae	2b c1		 sub	 eax, ecx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  009b0	83 c0 fc	 add	 eax, -4			; fffffffcH
  009b3	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  009b6	0f 87 08 02 00
	00		 ja	 $LN618@LoadData_V
$LN422@LoadData_V:

; 264  :         ::operator delete(_Ptr, _Bytes);

  009bc	52		 push	 edx
  009bd	51		 push	 ecx
  009be	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  009c3	83 c4 08	 add	 esp, 8
$LN412@LoadData_V:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 223  : 			}

  009c6	8d 8d cc fd ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$6[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  009cc	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _strPathName$19[ebp+16], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  009d3	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _strPathName$19[ebp+20], 15 ; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  009da	c6 45 c0 00	 mov	 BYTE PTR _strPathName$19[ebp], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 223  : 			}

  009de	e8 00 00 00 00	 call	 ??1CMemoryTextFileLoader@@UAE@XZ ; CMemoryTextFileLoader::~CMemoryTextFileLoader
$LN16@LoadData_V:

; 224  : 		}

  009e3	8d 8d 64 fe ff
	ff		 lea	 ecx, DWORD PTR _File$17[ebp]
  009e9	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  009ee	8b b5 3c fe ff
	ff		 mov	 esi, DWORD PTR _pMeshData$1$[ebp]
  009f4	eb 3c		 jmp	 SHORT $LN496@LoadData_V
$LN14@LoadData_V:

; 227  : 			CGraphicImage * pImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer(pMeshData->szDiffuseMapFileName);

  009f6	8b b5 3c fe ff
	ff		 mov	 esi, DWORD PTR _pMeshData$1$[ebp]
  009fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  00a02	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  00a05	50		 push	 eax
  00a06	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  00a0b	8b c8		 mov	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  00a0d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 227  : 			CGraphicImage * pImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer(pMeshData->szDiffuseMapFileName);

  00a10	89 8d 4c fe ff
	ff		 mov	 DWORD PTR _pImage$8[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  00a16	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  00a19	74 08		 je	 SHORT $LN497@LoadData_V

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00a1b	89 08		 mov	 DWORD PTR [eax], ecx

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

  00a1d	83 47 04 04	 add	 DWORD PTR [edi+4], 4

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00a21	eb 0f		 jmp	 SHORT $LN496@LoadData_V
$LN497@LoadData_V:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00a23	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR _pImage$8[ebp]
  00a29	51		 push	 ecx
  00a2a	50		 push	 eax
  00a2b	8b cf		 mov	 ecx, edi
  00a2d	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEPAPAVCGraphicImage@@QAPAV2@ABQAV2@@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Emplace_reallocate<CGraphicImage * const &>
$LN496@LoadData_V:

; 1569 :         return _My_data._Myfirst[_Pos];

  00a32	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR __My_data$1$[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 234  : 		m_pEffectMeshDataVector[n] = pMeshData;

  00a38	8b bd 14 fe ff
	ff		 mov	 edi, DWORD PTR _n$1$[ebp]
  00a3e	0f bf cf	 movsx	 ecx, di

; 235  : 	}

  00a41	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  00a45	8b 00		 mov	 eax, DWORD PTR [eax]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 234  : 		m_pEffectMeshDataVector[n] = pMeshData;

  00a47	89 34 88	 mov	 DWORD PTR [eax+ecx*4], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00a4a	8b 55 bc	 mov	 edx, DWORD PTR _strExtension$18[ebp+20]
  00a4d	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00a50	72 2c		 jb	 SHORT $LN515@LoadData_V
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00a52	8b 4d a8	 mov	 ecx, DWORD PTR _strExtension$18[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00a55	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00a56	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00a58	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00a5e	72 14		 jb	 SHORT $LN525@LoadData_V

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00a60	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00a63	83 c2 23	 add	 edx, 35			; 00000023H
  00a66	2b c1		 sub	 eax, ecx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00a68	83 c0 fc	 add	 eax, -4			; fffffffcH
  00a6b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00a6e	0f 87 50 01 00
	00		 ja	 $LN618@LoadData_V
$LN525@LoadData_V:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00a74	52		 push	 edx
  00a75	51		 push	 ecx
  00a76	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00a7b	83 c4 08	 add	 esp, 8
$LN515@LoadData_V:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 116  : 	for (short n = 0; n < m_iGeomCount; ++n)

  00a7e	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00a84	47		 inc	 edi
  00a85	0f bf c7	 movsx	 eax, di
  00a88	89 bd 14 fe ff
	ff		 mov	 DWORD PTR _n$1$[ebp], edi
  00a8e	3b 41 2c	 cmp	 eax, DWORD PTR [ecx+44]
  00a91	7d 0b		 jge	 SHORT $LN668@LoadData_V
  00a93	8b b5 50 fe ff
	ff		 mov	 esi, DWORD PTR _c_pbBuf$GSCopy$4$[ebp]
  00a99	e9 53 f6 ff ff	 jmp	 $LL4@LoadData_V
$LN668@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00a9e	8b 8d 48 fe ff
	ff		 mov	 ecx, DWORD PTR __Ptr$1$[ebp]
  00aa4	85 c9		 test	 ecx, ecx
  00aa6	74 33		 je	 SHORT $LN533@LoadData_V

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00aa8	8b 95 28 fe ff
	ff		 mov	 edx, DWORD PTR __Bytes$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00aae	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00ab0	2b d1		 sub	 edx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00ab2	83 e2 fc	 and	 edx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00ab5	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00abb	72 14		 jb	 SHORT $LN549@LoadData_V

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00abd	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00ac0	83 c2 23	 add	 edx, 35			; 00000023H
  00ac3	2b c1		 sub	 eax, ecx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00ac5	83 c0 fc	 add	 eax, -4			; fffffffcH
  00ac8	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00acb	0f 87 f3 00 00
	00		 ja	 $LN618@LoadData_V
$LN549@LoadData_V:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00ad1	52		 push	 edx
  00ad2	51		 push	 ecx
  00ad3	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00ad8	83 c4 08	 add	 esp, 8
$LN533@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00adb	8b 8d 44 fe ff
	ff		 mov	 ecx, DWORD PTR __Ptr$1$[ebp]
  00ae1	85 c9		 test	 ecx, ecx
  00ae3	74 33		 je	 SHORT $LN557@LoadData_V

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00ae5	8b 95 24 fe ff
	ff		 mov	 edx, DWORD PTR __Bytes$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00aeb	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00aed	2b d1		 sub	 edx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00aef	83 e2 f8	 and	 edx, -8			; fffffff8H

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00af2	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00af8	72 14		 jb	 SHORT $LN573@LoadData_V

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00afa	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00afd	83 c2 23	 add	 edx, 35			; 00000023H
  00b00	2b c1		 sub	 eax, ecx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00b02	83 c0 fc	 add	 eax, -4			; fffffffcH
  00b05	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00b08	0f 87 b6 00 00
	00		 ja	 $LN618@LoadData_V
$LN573@LoadData_V:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00b0e	52		 push	 edx
  00b0f	51		 push	 ecx
  00b10	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00b15	83 c4 08	 add	 esp, 8
$LN557@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00b18	8b 8d 38 fe ff
	ff		 mov	 ecx, DWORD PTR __Ptr$1$[ebp]
  00b1e	85 c9		 test	 ecx, ecx
  00b20	74 2f		 je	 SHORT $LN581@LoadData_V

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00b22	8b 95 20 fe ff
	ff		 mov	 edx, DWORD PTR __Bytes$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00b28	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00b2a	2b d1		 sub	 edx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00b2c	83 e2 fc	 and	 edx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00b2f	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00b35	72 10		 jb	 SHORT $LN597@LoadData_V

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00b37	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00b3a	83 c2 23	 add	 edx, 35			; 00000023H
  00b3d	2b c1		 sub	 eax, ecx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00b3f	83 c0 fc	 add	 eax, -4			; fffffffcH
  00b42	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00b45	77 7d		 ja	 SHORT $LN618@LoadData_V
$LN597@LoadData_V:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00b47	52		 push	 edx
  00b48	51		 push	 ecx
  00b49	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00b4e	83 c4 08	 add	 esp, 8
$LN581@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00b51	8b b5 40 fe ff
	ff		 mov	 esi, DWORD PTR __Ptr$1$[ebp]
  00b57	85 f6		 test	 esi, esi
  00b59	74 42		 je	 SHORT $LN605@LoadData_V

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00b5b	8b 8d 1c fe ff
	ff		 mov	 ecx, DWORD PTR _v3VertexVector$2$[ebp]
  00b61	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00b66	2b ce		 sub	 ecx, esi
  00b68	f7 e9		 imul	 ecx
  00b6a	d1 fa		 sar	 edx, 1
  00b6c	8b c2		 mov	 eax, edx
  00b6e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00b71	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00b73	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00b76	8b c6		 mov	 eax, esi
  00b78	c1 e1 02	 shl	 ecx, 2

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00b7b	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00b81	72 10		 jb	 SHORT $LN621@LoadData_V

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00b83	8b 76 fc	 mov	 esi, DWORD PTR [esi-4]
  00b86	83 c1 23	 add	 ecx, 35			; 00000023H
  00b89	2b c6		 sub	 eax, esi

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00b8b	83 c0 fc	 add	 eax, -4			; fffffffcH
  00b8e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00b91	77 31		 ja	 SHORT $LN618@LoadData_V
$LN621@LoadData_V:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00b93	51		 push	 ecx
  00b94	56		 push	 esi
  00b95	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00b9a	83 c4 08	 add	 esp, 8
$LN605@LoadData_V:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 237  : 	return TRUE;

  00b9d	b8 01 00 00 00	 mov	 eax, 1

; 238  : }

  00ba2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00ba5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00bac	59		 pop	 ecx
  00bad	5f		 pop	 edi
  00bae	5e		 pop	 esi
  00baf	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00bb2	33 cd		 xor	 ecx, ebp
  00bb4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00bb9	8b e5		 mov	 esp, ebp
  00bbb	5d		 pop	 ebp
  00bbc	c2 08 00	 ret	 8
$LN636@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4509 :             _Xlen_string(); // result too long

  00bbf	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN618@LoadData_V:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 238  : }

  00bc4	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN677@LoadData_V:
  00bc9	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$0:
  00000	8d 8d 08 fe ff
	ff		 lea	 ecx, DWORD PTR _v3VertexVector$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$1:
  0000b	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _iIndexVector$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$2:
  00016	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _v3TextureVertexVector$[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::~vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >
__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$3:
  00021	8d 8d e4 fd ff
	ff		 lea	 ecx, DWORD PTR _iTextureIndexVector$[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$4:
  0002c	8d 4d a8	 lea	 ecx, DWORD PTR _strExtension$18[ebp]
  0002f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$5:
  00034	8d 8d 64 fe ff
	ff		 lea	 ecx, DWORD PTR _File$17[ebp]
  0003a	e9 00 00 00 00	 jmp	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$6:
  0003f	8d 8d cc fd ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$6[ebp]
  00045	e9 00 00 00 00	 jmp	 ??1CMemoryTextFileLoader@@UAE@XZ ; CMemoryTextFileLoader::~CMemoryTextFileLoader
__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$7:
  0004a	8d 8d c0 fd ff
	ff		 lea	 ecx, DWORD PTR _stTokenVector$5[ebp]
  00050	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$8:
  00055	8d 4d c0	 lea	 ecx, DWORD PTR _strPathName$19[ebp]
  00058	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$9:
  0005d	8d 4d d8	 lea	 ecx, DWORD PTR _strTextureFileName$20[ebp]
  00060	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00065	cc		 int	 3
  00066	cc		 int	 3
  00067	cc		 int	 3
  00068	cc		 int	 3
  00069	cc		 int	 3
__ehhandler$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z:
  0006a	90		 npad	 1
  0006b	90		 npad	 1
  0006c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00070	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00073	8b 8a c0 fd ff
	ff		 mov	 ecx, DWORD PTR [edx-576]
  00079	33 c8		 xor	 ecx, eax
  0007b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00080	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00083	33 c8		 xor	 ecx, eax
  00085	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z
  0008f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z ENDP		; CEffectMesh::__LoadData_Ver002
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z
_TEXT	SEGMENT
_stTokenVector$5 = -588					; size = 12
_textFileLoader$6 = -576				; size = 16
__My_data$1$ = -560					; size = 4
_pMotionData$7 = -556					; size = 4
_iTextureIndexVector$ = -552				; size = 12
_v3TextureVertexVector$ = -540				; size = 12
_iIndexVector$ = -528					; size = 12
_v3VertexVector$ = -516					; size = 12
tv3483 = -504						; size = 4
_i$1$ = -500						; size = 4
_n$1$ = -496						; size = 4
__Old_capacity$1$ = -492				; size = 4
_rFrameData$1$ = -492					; size = 4
__Result$1$ = -488					; size = 4
_dwTextureVertexCount$1$ = -488				; size = 4
__Count$1$ = -484					; size = 4
tv3494 = -484						; size = 4
_v3VertexVector$2$ = -480				; size = 4
__Bytes$1$ = -476					; size = 4
__Bytes$1$ = -472					; size = 4
__Bytes$1$ = -468					; size = 4
_this$GSCopy$1$ = -464					; size = 4
_c_pbBuf$GSCopy$4$ = -460				; size = 4
__Backout$3$sroa$1119$1$ = -456				; size = 4
_j$1$ = -456						; size = 4
__Ptr$1$ = -452						; size = 4
__Newlast$1$ = -448					; size = 4
tv3474 = -448						; size = 4
$T8 = -448						; size = 1
_i$1$ = -444						; size = 4
_dwIndexCount$1$ = -444					; size = 4
__Ptr$1$ = -440						; size = 4
__Ptr$1$ = -436						; size = 4
__Ptr$1$ = -432						; size = 4
_pMeshData$1$ = -428					; size = 4
__Result$2$ = -424					; size = 4
tv3476 = -424						; size = 4
_pImage$9 = -424					; size = 4
_pImage$10 = -424					; size = 4
$T11 = -420						; size = 4
__My_data$1$ = -420					; size = 4
$T12 = -413						; size = 1
$T13 = -413						; size = 1
$T14 = -413						; size = 1
$T15 = -413						; size = 1
$T16 = -413						; size = 1
_File$17 = -412						; size = 324
_strExtension$18 = -88					; size = 24
_strPathName$19 = -64					; size = 24
_strTextureFileName$20 = -40				; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_iSize$ = 8						; size = 4
_c_pbBuf$ = 12						; size = 4
?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z PROC		; CEffectMesh::__LoadData_Ver001, COMDAT
; _this$ = ecx

; 241  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 40 02 00
	00		 sub	 esp, 576		; 00000240H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b f1		 mov	 esi, ecx
  0002f	89 b5 30 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], esi
  00035	8b 55 0c	 mov	 edx, DWORD PTR _c_pbBuf$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00038	33 c0		 xor	 eax, eax
  0003a	89 85 48 fe ff
	ff		 mov	 DWORD PTR __Ptr$1$[ebp], eax
  00040	89 85 fc fd ff
	ff		 mov	 DWORD PTR _v3VertexVector$[ebp], eax
  00046	89 85 00 fe ff
	ff		 mov	 DWORD PTR _v3VertexVector$[ebp+4], eax
  0004c	89 85 20 fe ff
	ff		 mov	 DWORD PTR _v3VertexVector$2$[ebp], eax
  00052	89 85 04 fe ff
	ff		 mov	 DWORD PTR _v3VertexVector$[ebp+8], eax
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 242  : 	std::vector<D3DXVECTOR3> v3VertexVector;

  00058	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0005b	89 85 3c fe ff
	ff		 mov	 DWORD PTR __Ptr$1$[ebp], eax
  00061	89 85 f0 fd ff
	ff		 mov	 DWORD PTR _iIndexVector$[ebp], eax
  00067	89 85 f4 fd ff
	ff		 mov	 DWORD PTR _iIndexVector$[ebp+4], eax
  0006d	89 85 24 fe ff
	ff		 mov	 DWORD PTR __Bytes$1$[ebp], eax
  00073	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _iIndexVector$[ebp+8], eax
  00079	89 85 4c fe ff
	ff		 mov	 DWORD PTR __Ptr$1$[ebp], eax
  0007f	89 85 e4 fd ff
	ff		 mov	 DWORD PTR _v3TextureVertexVector$[ebp], eax
  00085	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _v3TextureVertexVector$[ebp+4], eax
  0008b	89 85 28 fe ff
	ff		 mov	 DWORD PTR __Bytes$1$[ebp], eax
  00091	89 85 ec fd ff
	ff		 mov	 DWORD PTR _v3TextureVertexVector$[ebp+8], eax
  00097	89 85 50 fe ff
	ff		 mov	 DWORD PTR __Ptr$1$[ebp], eax
  0009d	89 85 d8 fd ff
	ff		 mov	 DWORD PTR _iTextureIndexVector$[ebp], eax
  000a3	89 85 dc fd ff
	ff		 mov	 DWORD PTR _iTextureIndexVector$[ebp+4], eax
  000a9	89 85 2c fe ff
	ff		 mov	 DWORD PTR __Bytes$1$[ebp], eax
  000af	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _iTextureIndexVector$[ebp+8], eax
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 247  : 	m_iGeomCount = *(int *)c_pbBuf;

  000b5	8b 02		 mov	 eax, DWORD PTR [edx]

; 248  : 	c_pbBuf += 4;
; 249  : 	m_iFrameCount = *(int *)c_pbBuf;
; 250  : 	c_pbBuf += 4;
; 251  : 
; 252  : 	m_pEffectMeshDataVector.clear();

  000b7	8d 4e 34	 lea	 ecx, DWORD PTR [esi+52]
  000ba	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  000bd	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000c0	83 c2 08	 add	 edx, 8
  000c3	89 46 30	 mov	 DWORD PTR [esi+48], eax
  000c6	8b 01		 mov	 eax, DWORD PTR [ecx]
  000c8	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 253  : 	m_pEffectMeshDataVector.resize(m_iGeomCount);

  000cb	ff 76 2c	 push	 DWORD PTR [esi+44]
  000ce	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000d2	89 95 34 fe ff
	ff		 mov	 DWORD PTR _c_pbBuf$GSCopy$4$[ebp], edx
  000d8	89 8d d0 fd ff
	ff		 mov	 DWORD PTR __My_data$1$[ebp], ecx
  000de	e8 00 00 00 00	 call	 ?resize@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@QAEXI@Z ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::resize

; 255  : 	for (short n = 0; n < m_iGeomCount; ++n)

  000e3	83 7e 2c 00	 cmp	 DWORD PTR [esi+44], 0
  000e7	c7 85 10 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$1$[ebp], 0
  000f1	0f 8e cf 0a 00
	00		 jle	 $LN605@LoadData_V
$LL4@LoadData_V:

; 256  : 	{
; 257  : 		SEffectMeshData * pMeshData = SEffectMeshData::New();

  000f7	e8 00 00 00 00	 call	 ?New@SEffectMeshData@CEffectMesh@@SAPAU12@XZ ; CEffectMesh::SEffectMeshData::New

; 258  : 
; 259  : 		memcpy(pMeshData->szObjectName, c_pbBuf, 32);

  000fc	8b 95 34 fe ff
	ff		 mov	 edx, DWORD PTR _c_pbBuf$GSCopy$4$[ebp]

; 260  : 		c_pbBuf += 32;
; 261  : 		memcpy(pMeshData->szDiffuseMapFileName, c_pbBuf, 128);

  00102	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00107	89 85 54 fe ff
	ff		 mov	 DWORD PTR _pMeshData$1$[ebp], eax
  0010d	8d 78 20	 lea	 edi, DWORD PTR [eax+32]
  00110	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00113	8d 72 20	 lea	 esi, DWORD PTR [edx+32]
  00116	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  00119	0f 10 42 10	 movups	 xmm0, XMMWORD PTR [edx+16]
  0011d	0f 11 40 10	 movups	 XMMWORD PTR [eax+16], xmm0
  00121	f3 a5		 rep movsd

; 262  : 		c_pbBuf += 128;
; 263  : 
; 264  : 		//
; 265  : 
; 266  : 		DWORD dwVertexCount;
; 267  : 		DWORD dwIndexCount;
; 268  : 		DWORD dwTextureVertexCount;
; 269  : 
; 270  : 		memcpy(&dwVertexCount, c_pbBuf, sizeof(DWORD));

  00123	8b 82 a0 00 00
	00		 mov	 eax, DWORD PTR [edx+160]

; 273  : 		memcpy(&dwIndexCount, c_pbBuf, sizeof(DWORD));

  00129	8b 8a a4 00 00
	00		 mov	 ecx, DWORD PTR [edx+164]
  0012f	89 85 1c fe ff
	ff		 mov	 DWORD PTR __Count$1$[ebp], eax

; 274  : 		c_pbBuf += sizeof(DWORD);
; 275  : 
; 276  : 		memcpy(&dwTextureVertexCount, c_pbBuf, sizeof(DWORD));

  00135	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]

; 277  : 		c_pbBuf += sizeof(DWORD);

  0013b	81 c2 ac 00 00
	00		 add	 edx, 172		; 000000acH
  00141	89 85 18 fe ff
	ff		 mov	 DWORD PTR _dwTextureVertexCount$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1450 :         auto& _My_data    = _Mypair._Myval2;

  00147	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _pMeshData$1$[ebp]
  0014d	05 a0 00 00 00	 add	 eax, 160		; 000000a0H
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 273  : 		memcpy(&dwIndexCount, c_pbBuf, sizeof(DWORD));

  00152	89 8d 44 fe ff
	ff		 mov	 DWORD PTR _dwIndexCount$1$[ebp], ecx

; 277  : 		c_pbBuf += sizeof(DWORD);

  00158	89 95 34 fe ff
	ff		 mov	 DWORD PTR _c_pbBuf$GSCopy$4$[ebp], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1450 :         auto& _My_data    = _Mypair._Myval2;

  0015e	89 85 5c fe ff
	ff		 mov	 DWORD PTR __My_data$1$[ebp], eax

; 1451 :         pointer& _Myfirst = _My_data._Myfirst;
; 1452 :         pointer& _Mylast  = _My_data._Mylast;
; 1453 : 
; 1454 :         _My_data._Orphan_all();
; 1455 :         _Destroy(_Myfirst, _Mylast);

  00164	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  00167	8b 30		 mov	 esi, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 949  :         for (; _First != _Last; ++_First) {

  00169	3b f7		 cmp	 esi, edi
  0016b	74 1a		 je	 SHORT $LN59@LoadData_V
  0016d	0f 1f 00	 npad	 3
$LL60@LoadData_V:
  00170	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  00173	e8 00 00 00 00	 call	 ??1?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@QAE@XZ ; std::vector<SPTVertex,std::allocator<SPTVertex> >::~vector<SPTVertex,std::allocator<SPTVertex> >
  00178	83 c6 20	 add	 esi, 32			; 00000020H
  0017b	3b f7		 cmp	 esi, edi
  0017d	75 f1		 jne	 SHORT $LL60@LoadData_V
  0017f	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR __My_data$1$[ebp]
  00185	8b 30		 mov	 esi, DWORD PTR [eax]
$LN59@LoadData_V:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 280  : 		pMeshData->EffectFrameDataVector.resize(m_iFrameCount);

  00187	8b 8d 30 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1263 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  0018d	8b d6		 mov	 edx, esi

; 1456 :         _Mylast = _Myfirst;

  0018f	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1263 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  00192	8b 38		 mov	 edi, DWORD PTR [eax]
  00194	2b d7		 sub	 edx, edi
  00196	c1 fa 05	 sar	 edx, 5
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 280  : 		pMeshData->EffectFrameDataVector.resize(m_iFrameCount);

  00199	8b 49 30	 mov	 ecx, DWORD PTR [ecx+48]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1264 :         if (_Newsize < _Oldsize) { // trim

  0019c	3b ca		 cmp	 ecx, edx
  0019e	73 31		 jae	 SHORT $LN73@LoadData_V

; 1265 :             const pointer _Newlast = _Myfirst + _Newsize;

  001a0	c1 e1 05	 shl	 ecx, 5
  001a3	03 cf		 add	 ecx, edi
  001a5	89 8d 40 fe ff
	ff		 mov	 DWORD PTR __Newlast$1$[ebp], ecx

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  001ab	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 949  :         for (; _First != _Last; ++_First) {

  001ad	3b ce		 cmp	 ecx, esi
  001af	74 1b		 je	 SHORT $LN81@LoadData_V
$LL82@LoadData_V:
  001b1	8d 4f 14	 lea	 ecx, DWORD PTR [edi+20]
  001b4	e8 00 00 00 00	 call	 ??1?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@QAE@XZ ; std::vector<SPTVertex,std::allocator<SPTVertex> >::~vector<SPTVertex,std::allocator<SPTVertex> >
  001b9	83 c7 20	 add	 edi, 32			; 00000020H
  001bc	3b fe		 cmp	 edi, esi
  001be	75 f1		 jne	 SHORT $LL82@LoadData_V
  001c0	8b 8d 40 fe ff
	ff		 mov	 ecx, DWORD PTR __Newlast$1$[ebp]
  001c6	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR __My_data$1$[ebp]
$LN81@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1268 :             _Mylast = _Newlast;

  001cc	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1269 :             return;

  001cf	eb 43		 jmp	 SHORT $LN74@LoadData_V
$LN73@LoadData_V:

; 1272 :         if (_Newsize > _Oldsize) { // append

  001d1	76 41		 jbe	 SHORT $LN74@LoadData_V

; 1273 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  001d3	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  001d6	2b c7		 sub	 eax, edi
  001d8	c1 f8 05	 sar	 eax, 5

; 1274 :             if (_Newsize > _Oldcapacity) { // reallocate

  001db	3b c8		 cmp	 ecx, eax
  001dd	76 15		 jbe	 SHORT $LN75@LoadData_V

; 1275 :                 _Resize_reallocate(_Newsize, _Val);

  001df	8d 85 40 fe ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  001e5	50		 push	 eax
  001e6	51		 push	 ecx
  001e7	8b 8d 5c fe ff
	ff		 mov	 ecx, DWORD PTR __My_data$1$[ebp]
  001ed	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::_Resize_reallocate<std::_Value_init_tag>

; 1276 :                 return;

  001f2	eb 1a		 jmp	 SHORT $LN678@LoadData_V
$LN75@LoadData_V:

; 1280 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  001f4	ff b5 40 fe ff
	ff		 push	 DWORD PTR $T8[ebp]
  001fa	2b ca		 sub	 ecx, edx
  001fc	51		 push	 ecx
  001fd	56		 push	 esi
  001fe	8b b5 5c fe ff
	ff		 mov	 esi, DWORD PTR __My_data$1$[ebp]
  00204	8b ce		 mov	 ecx, esi
  00206	e8 00 00 00 00	 call	 ?_Ufill@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@AAEPAUSEffectFrameData@CEffectMesh@@PAU34@IU_Value_init_tag@2@@Z ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::_Ufill
  0020b	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN678@LoadData_V:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 282  : 		for(int i = 0; i < m_iFrameCount; ++i)

  0020e	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR __My_data$1$[ebp]
$LN74@LoadData_V:
  00214	8b 8d 30 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0021a	c7 85 0c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$1$[ebp], 0
  00224	83 79 30 00	 cmp	 DWORD PTR [ecx+48], 0
  00228	0f 8e 91 03 00
	00		 jle	 $LN6@LoadData_V
  0022e	33 c9		 xor	 ecx, ecx
  00230	89 8d 40 fe ff
	ff		 mov	 DWORD PTR tv3474[ebp], ecx
$LL7@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  00236	8b 38		 mov	 edi, DWORD PTR [eax]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 288  : 			rFrameData.dwTextureVertexCount = dwTextureVertexCount;

  00238	8b 85 18 fe ff
	ff		 mov	 eax, DWORD PTR _dwTextureVertexCount$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  0023e	03 f9		 add	 edi, ecx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 286  : 			rFrameData.dwVertexCount = dwVertexCount;

  00240	8b b5 1c fe ff
	ff		 mov	 esi, DWORD PTR __Count$1$[ebp]

; 287  : 			rFrameData.dwIndexCount = dwIndexCount;

  00246	8b 8d 44 fe ff
	ff		 mov	 ecx, DWORD PTR _dwIndexCount$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  0024c	89 bd 14 fe ff
	ff		 mov	 DWORD PTR _rFrameData$1$[ebp], edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 288  : 			rFrameData.dwTextureVertexCount = dwTextureVertexCount;

  00252	89 47 0c	 mov	 DWORD PTR [edi+12], eax

; 289  : 
; 290  : 			v3VertexVector.clear();

  00255	8b 85 48 fe ff
	ff		 mov	 eax, DWORD PTR __Ptr$1$[ebp]
  0025b	89 77 08	 mov	 DWORD PTR [edi+8], esi
  0025e	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  00261	89 85 00 fe ff
	ff		 mov	 DWORD PTR _v3VertexVector$[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1272 :         if (_Newsize > _Oldsize) { // append

  00267	85 f6		 test	 esi, esi
  00269	74 64		 je	 SHORT $LN98@LoadData_V

; 1273 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  0026b	8b 8d 20 fe ff
	ff		 mov	 ecx, DWORD PTR _v3VertexVector$2$[ebp]
  00271	2b c8		 sub	 ecx, eax
  00273	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00278	f7 e9		 imul	 ecx
  0027a	d1 fa		 sar	 edx, 1
  0027c	8b c2		 mov	 eax, edx
  0027e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00281	03 c2		 add	 eax, edx

; 1274 :             if (_Newsize > _Oldcapacity) { // reallocate

  00283	3b f0		 cmp	 esi, eax
  00285	76 30		 jbe	 SHORT $LN99@LoadData_V

; 1275 :                 _Resize_reallocate(_Newsize, _Val);

  00287	8d 85 63 fe ff
	ff		 lea	 eax, DWORD PTR $T16[ebp]
  0028d	50		 push	 eax
  0028e	56		 push	 esi
  0028f	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _v3VertexVector$[ebp]
  00295	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Resize_reallocate<std::_Value_init_tag>

; 1276 :                 return;

  0029a	8b 85 04 fe ff
	ff		 mov	 eax, DWORD PTR _v3VertexVector$[ebp+8]
  002a0	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  002a3	89 85 20 fe ff
	ff		 mov	 DWORD PTR _v3VertexVector$2$[ebp], eax
  002a9	8b 85 fc fd ff
	ff		 mov	 eax, DWORD PTR _v3VertexVector$[ebp]
  002af	89 85 48 fe ff
	ff		 mov	 DWORD PTR __Ptr$1$[ebp], eax
  002b5	eb 18		 jmp	 SHORT $LN98@LoadData_V
$LN99@LoadData_V:

; 1280 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  002b7	8b 8d 48 fe ff
	ff		 mov	 ecx, DWORD PTR __Ptr$1$[ebp]
  002bd	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  002c0	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  002c3	8b 8d 44 fe ff
	ff		 mov	 ecx, DWORD PTR _dwIndexCount$1$[ebp]
  002c9	89 85 00 fe ff
	ff		 mov	 DWORD PTR _v3VertexVector$[ebp+4], eax
$LN98@LoadData_V:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 292  : 			iIndexVector.clear();

  002cf	8b 95 3c fe ff
	ff		 mov	 edx, DWORD PTR __Ptr$1$[ebp]
  002d5	89 95 f4 fd ff
	ff		 mov	 DWORD PTR _iIndexVector$[ebp+4], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1272 :         if (_Newsize > _Oldsize) { // append

  002db	85 c9		 test	 ecx, ecx
  002dd	74 4f		 je	 SHORT $LN118@LoadData_V

; 1273 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  002df	8b 85 24 fe ff
	ff		 mov	 eax, DWORD PTR __Bytes$1$[ebp]
  002e5	2b c2		 sub	 eax, edx
  002e7	c1 f8 02	 sar	 eax, 2

; 1274 :             if (_Newsize > _Oldcapacity) { // reallocate

  002ea	3b c8		 cmp	 ecx, eax
  002ec	76 2d		 jbe	 SHORT $LN119@LoadData_V

; 1275 :                 _Resize_reallocate(_Newsize, _Val);

  002ee	8d 85 63 fe ff
	ff		 lea	 eax, DWORD PTR $T15[ebp]
  002f4	50		 push	 eax
  002f5	51		 push	 ecx
  002f6	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _iIndexVector$[ebp]
  002fc	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Resize_reallocate<std::_Value_init_tag>

; 1276 :                 return;

  00301	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR _iIndexVector$[ebp+8]
  00307	89 85 24 fe ff
	ff		 mov	 DWORD PTR __Bytes$1$[ebp], eax
  0030d	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _iIndexVector$[ebp]
  00313	89 85 3c fe ff
	ff		 mov	 DWORD PTR __Ptr$1$[ebp], eax
  00319	eb 13		 jmp	 SHORT $LN118@LoadData_V
$LN119@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1824 :             _Zero_range(_PFirst, _PFirst + _Count);

  0031b	8d 34 8a	 lea	 esi, DWORD PTR [edx+ecx*4]
  0031e	56		 push	 esi
  0031f	52		 push	 edx
  00320	e8 00 00 00 00	 call	 ??$_Zero_range@PAH@std@@YAPAHQAH0@Z ; std::_Zero_range<int *>
  00325	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1280 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  00328	89 b5 f4 fd ff
	ff		 mov	 DWORD PTR _iIndexVector$[ebp+4], esi
$LN118@LoadData_V:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 295  : 			v3TextureVertexVector.resize(rFrameData.dwTextureVertexCount);

  0032e	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00331	8b 95 4c fe ff
	ff		 mov	 edx, DWORD PTR __Ptr$1$[ebp]
  00337	89 95 e8 fd ff
	ff		 mov	 DWORD PTR _v3TextureVertexVector$[ebp+4], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1272 :         if (_Newsize > _Oldsize) { // append

  0033d	85 c9		 test	 ecx, ecx
  0033f	74 45		 je	 SHORT $LN140@LoadData_V

; 1273 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  00341	8b 85 28 fe ff
	ff		 mov	 eax, DWORD PTR __Bytes$1$[ebp]
  00347	2b c2		 sub	 eax, edx
  00349	c1 f8 03	 sar	 eax, 3

; 1274 :             if (_Newsize > _Oldcapacity) { // reallocate

  0034c	3b c8		 cmp	 ecx, eax
  0034e	76 2d		 jbe	 SHORT $LN141@LoadData_V

; 1275 :                 _Resize_reallocate(_Newsize, _Val);

  00350	8d 85 63 fe ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  00356	50		 push	 eax
  00357	51		 push	 ecx
  00358	8d 8d e4 fd ff
	ff		 lea	 ecx, DWORD PTR _v3TextureVertexVector$[ebp]
  0035e	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Resize_reallocate<std::_Value_init_tag>

; 1276 :                 return;

  00363	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _v3TextureVertexVector$[ebp+8]
  00369	89 85 28 fe ff
	ff		 mov	 DWORD PTR __Bytes$1$[ebp], eax
  0036f	8b 85 e4 fd ff
	ff		 mov	 eax, DWORD PTR _v3TextureVertexVector$[ebp]
  00375	89 85 4c fe ff
	ff		 mov	 DWORD PTR __Ptr$1$[ebp], eax
  0037b	eb 09		 jmp	 SHORT $LN140@LoadData_V
$LN141@LoadData_V:

; 1280 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  0037d	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  00380	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _v3TextureVertexVector$[ebp+4], eax
$LN140@LoadData_V:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 297  : 			iTextureIndexVector.resize(rFrameData.dwIndexCount);

  00386	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00389	8b 95 50 fe ff
	ff		 mov	 edx, DWORD PTR __Ptr$1$[ebp]
  0038f	89 95 dc fd ff
	ff		 mov	 DWORD PTR _iTextureIndexVector$[ebp+4], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1272 :         if (_Newsize > _Oldsize) { // append

  00395	85 c9		 test	 ecx, ecx
  00397	74 4f		 je	 SHORT $LN160@LoadData_V

; 1273 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  00399	8b 85 2c fe ff
	ff		 mov	 eax, DWORD PTR __Bytes$1$[ebp]
  0039f	2b c2		 sub	 eax, edx
  003a1	c1 f8 02	 sar	 eax, 2

; 1274 :             if (_Newsize > _Oldcapacity) { // reallocate

  003a4	3b c8		 cmp	 ecx, eax
  003a6	76 2d		 jbe	 SHORT $LN161@LoadData_V

; 1275 :                 _Resize_reallocate(_Newsize, _Val);

  003a8	8d 85 63 fe ff
	ff		 lea	 eax, DWORD PTR $T13[ebp]
  003ae	50		 push	 eax
  003af	51		 push	 ecx
  003b0	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR _iTextureIndexVector$[ebp]
  003b6	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Resize_reallocate<std::_Value_init_tag>

; 1276 :                 return;

  003bb	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR _iTextureIndexVector$[ebp+8]
  003c1	89 85 2c fe ff
	ff		 mov	 DWORD PTR __Bytes$1$[ebp], eax
  003c7	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _iTextureIndexVector$[ebp]
  003cd	89 85 50 fe ff
	ff		 mov	 DWORD PTR __Ptr$1$[ebp], eax
  003d3	eb 13		 jmp	 SHORT $LN160@LoadData_V
$LN161@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1824 :             _Zero_range(_PFirst, _PFirst + _Count);

  003d5	8d 34 8a	 lea	 esi, DWORD PTR [edx+ecx*4]
  003d8	56		 push	 esi
  003d9	52		 push	 edx
  003da	e8 00 00 00 00	 call	 ??$_Zero_range@PAH@std@@YAPAHQAH0@Z ; std::_Zero_range<int *>
  003df	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1280 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  003e2	89 b5 dc fd ff
	ff		 mov	 DWORD PTR _iTextureIndexVector$[ebp+4], esi
$LN160@LoadData_V:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 299  : 			memcpy(&rFrameData.fVisibility, c_pbBuf, sizeof(float));

  003e8	8b b5 34 fe ff
	ff		 mov	 esi, DWORD PTR _c_pbBuf$GSCopy$4$[ebp]
  003ee	8b 06		 mov	 eax, DWORD PTR [esi]

; 300  : 			c_pbBuf += sizeof(float);

  003f0	83 c6 04	 add	 esi, 4
  003f3	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 301  : 			memcpy(&v3VertexVector[0], c_pbBuf, rFrameData.dwVertexCount*sizeof(D3DXVECTOR3));

  003f6	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  003f9	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  003fc	c1 e0 02	 shl	 eax, 2
  003ff	50		 push	 eax
  00400	56		 push	 esi
  00401	ff b5 48 fe ff
	ff		 push	 DWORD PTR __Ptr$1$[ebp]
  00407	e8 00 00 00 00	 call	 _memcpy

; 302  : 			c_pbBuf += rFrameData.dwVertexCount*sizeof(D3DXVECTOR3);

  0040c	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0040f	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00412	8d 34 86	 lea	 esi, DWORD PTR [esi+eax*4]

; 303  : 			memcpy(&iIndexVector[0], c_pbBuf, rFrameData.dwIndexCount*sizeof(int));

  00415	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00418	c1 e0 02	 shl	 eax, 2
  0041b	50		 push	 eax
  0041c	56		 push	 esi
  0041d	ff b5 3c fe ff
	ff		 push	 DWORD PTR __Ptr$1$[ebp]
  00423	e8 00 00 00 00	 call	 _memcpy

; 304  : 			c_pbBuf += rFrameData.dwIndexCount*sizeof(int);

  00428	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0042b	8d 34 86	 lea	 esi, DWORD PTR [esi+eax*4]

; 305  : 			memcpy(&v3TextureVertexVector[0], c_pbBuf, rFrameData.dwTextureVertexCount*sizeof(D3DXVECTOR2));

  0042e	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00431	c1 e0 03	 shl	 eax, 3
  00434	50		 push	 eax
  00435	56		 push	 esi
  00436	ff b5 4c fe ff
	ff		 push	 DWORD PTR __Ptr$1$[ebp]
  0043c	e8 00 00 00 00	 call	 _memcpy

; 306  : 			c_pbBuf += rFrameData.dwTextureVertexCount*sizeof(D3DXVECTOR2);

  00441	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00444	8d 34 c6	 lea	 esi, DWORD PTR [esi+eax*8]

; 307  : 			memcpy(&iTextureIndexVector[0], c_pbBuf, rFrameData.dwIndexCount*sizeof(int));

  00447	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0044a	c1 e0 02	 shl	 eax, 2
  0044d	50		 push	 eax
  0044e	56		 push	 esi
  0044f	ff b5 50 fe ff
	ff		 push	 DWORD PTR __Ptr$1$[ebp]
  00455	e8 00 00 00 00	 call	 _memcpy

; 308  : 			c_pbBuf += rFrameData.dwIndexCount*sizeof(int);

  0045a	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0045d	83 c4 30	 add	 esp, 48			; 00000030H
  00460	8d 14 86	 lea	 edx, DWORD PTR [esi+eax*4]

; 309  : 
; 310  : 			///////////////////////////////
; 311  : 
; 312  : 			rFrameData.PDTVertexVector.clear();

  00463	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00466	89 95 34 fe ff
	ff		 mov	 DWORD PTR _c_pbBuf$GSCopy$4$[ebp], edx
  0046c	8d 57 14	 lea	 edx, DWORD PTR [edi+20]
  0046f	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 313  : 			rFrameData.PDTVertexVector.resize(rFrameData.dwIndexCount);

  00472	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  00475	89 85 38 fe ff
	ff		 mov	 DWORD PTR __Backout$3$sroa$1119$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1272 :         if (_Newsize > _Oldsize) { // append

  0047b	85 f6		 test	 esi, esi
  0047d	74 54		 je	 SHORT $LN190@LoadData_V

; 1273 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  0047f	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00482	2b c8		 sub	 ecx, eax
  00484	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00489	f7 e9		 imul	 ecx
  0048b	c1 fa 03	 sar	 edx, 3
  0048e	8b c2		 mov	 eax, edx
  00490	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00493	03 c2		 add	 eax, edx

; 1274 :             if (_Newsize > _Oldcapacity) { // reallocate

  00495	3b f0		 cmp	 esi, eax
  00497	76 15		 jbe	 SHORT $LN191@LoadData_V

; 1275 :                 _Resize_reallocate(_Newsize, _Val);

  00499	8d 85 63 fe ff
	ff		 lea	 eax, DWORD PTR $T12[ebp]
  0049f	50		 push	 eax
  004a0	56		 push	 esi
  004a1	8d 4f 14	 lea	 ecx, DWORD PTR [edi+20]
  004a4	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<SPTVertex,std::allocator<SPTVertex> >::_Resize_reallocate<std::_Value_init_tag>

; 1276 :                 return;

  004a9	8d 57 14	 lea	 edx, DWORD PTR [edi+20]
  004ac	eb 25		 jmp	 SHORT $LN190@LoadData_V
$LN191@LoadData_V:

; 1277 :             }
; 1278 : 
; 1279 :             const pointer _Oldlast = _Mylast;

  004ae	8d 34 b6	 lea	 esi, DWORD PTR [esi+esi*4]
  004b1	c1 e6 02	 shl	 esi, 2
  004b4	56		 push	 esi
  004b5	6a 00		 push	 0
  004b7	ff b5 38 fe ff
	ff		 push	 DWORD PTR __Backout$3$sroa$1119$1$[ebp]
  004bd	e8 00 00 00 00	 call	 _memset
  004c2	8b 85 38 fe ff
	ff		 mov	 eax, DWORD PTR __Backout$3$sroa$1119$1$[ebp]

; 1280 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  004c8	8d 57 14	 lea	 edx, DWORD PTR [edi+20]
  004cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  004ce	03 c6		 add	 eax, esi
  004d0	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN190@LoadData_V:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 314  : 			for (DWORD j = 0; j < rFrameData.dwIndexCount; ++j)

  004d3	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  004d7	c7 85 38 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$1$[ebp], 0
  004e1	0f 86 a7 00 00
	00		 jbe	 $LN5@LoadData_V
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1563 :         auto& _My_data = _Mypair._Myval2;

  004e7	8b 8d 3c fe ff
	ff		 mov	 ecx, DWORD PTR __Ptr$1$[ebp]
  004ed	33 c0		 xor	 eax, eax
  004ef	8b b5 50 fe ff
	ff		 mov	 esi, DWORD PTR __Ptr$1$[ebp]
  004f5	2b ce		 sub	 ecx, esi
  004f7	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@bf800000
  004ff	89 85 08 fe ff
	ff		 mov	 DWORD PTR tv3483[ebp], eax
  00505	89 8d 58 fe ff
	ff		 mov	 DWORD PTR tv3476[ebp], ecx
  0050b	0f 1f 44 00 00	 npad	 5
$LL10@LoadData_V:

; 1569 :         return _My_data._Myfirst[_Pos];

  00510	8b 12		 mov	 edx, DWORD PTR [edx]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 314  : 			for (DWORD j = 0; j < rFrameData.dwIndexCount; ++j)

  00512	8d 76 04	 lea	 esi, DWORD PTR [esi+4]

; 324  : 				rVertex.position = v3VertexVector[dwIndex];

  00515	8b bd 48 fe ff
	ff		 mov	 edi, DWORD PTR __Ptr$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  0051b	03 d0		 add	 edx, eax
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 318  : 				DWORD dwIndex = iIndexVector[j];

  0051d	8b 44 31 fc	 mov	 eax, DWORD PTR [ecx+esi-4]

; 319  : 				DWORD dwTextureIndex = iTextureIndexVector[j];

  00521	8b 4e fc	 mov	 ecx, DWORD PTR [esi-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  00524	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 324  : 				rVertex.position = v3VertexVector[dwIndex];

  00527	f3 0f 7e 04 87	 movq	 xmm0, QWORD PTR [edi+eax*4]
  0052c	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  00530	8b 44 87 08	 mov	 eax, DWORD PTR [edi+eax*4+8]

; 325  : 				rVertex.texCoord = v3TextureVertexVector[dwTextureIndex];

  00534	8b bd 4c fe ff
	ff		 mov	 edi, DWORD PTR __Ptr$1$[ebp]
  0053a	89 42 08	 mov	 DWORD PTR [edx+8], eax
  0053d	8b 85 4c fe ff
	ff		 mov	 eax, DWORD PTR __Ptr$1$[ebp]
  00543	8b 04 c8	 mov	 eax, DWORD PTR [eax+ecx*8]
  00546	8b 4c cf 04	 mov	 ecx, DWORD PTR [edi+ecx*8+4]
  0054a	8b bd 14 fe ff
	ff		 mov	 edi, DWORD PTR _rFrameData$1$[ebp]
  00550	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 326  : 				rVertex.texCoord.y *= -1;

  00553	f3 0f 10 42 10	 movss	 xmm0, DWORD PTR [edx+16]
  00558	8b 8d 38 fe ff
	ff		 mov	 ecx, DWORD PTR _j$1$[ebp]
  0055e	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  00561	41		 inc	 ecx
  00562	8b 85 08 fe ff
	ff		 mov	 eax, DWORD PTR tv3483[ebp]
  00568	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0056c	83 c0 14	 add	 eax, 20			; 00000014H
  0056f	89 8d 38 fe ff
	ff		 mov	 DWORD PTR _j$1$[ebp], ecx
  00575	89 85 08 fe ff
	ff		 mov	 DWORD PTR tv3483[ebp], eax
  0057b	f3 0f 11 42 10	 movss	 DWORD PTR [edx+16], xmm0
  00580	8d 57 14	 lea	 edx, DWORD PTR [edi+20]
  00583	3b 4f 10	 cmp	 ecx, DWORD PTR [edi+16]
  00586	8b 8d 58 fe ff
	ff		 mov	 ecx, DWORD PTR tv3476[ebp]
  0058c	72 82		 jb	 SHORT $LL10@LoadData_V
$LN5@LoadData_V:

; 282  : 		for(int i = 0; i < m_iFrameCount; ++i)

  0058e	8b 85 0c fe ff
	ff		 mov	 eax, DWORD PTR _i$1$[ebp]
  00594	8b 95 30 fe ff
	ff		 mov	 edx, DWORD PTR _this$GSCopy$1$[ebp]
  0059a	40		 inc	 eax
  0059b	8b 8d 40 fe ff
	ff		 mov	 ecx, DWORD PTR tv3474[ebp]
  005a1	83 c1 20	 add	 ecx, 32			; 00000020H
  005a4	89 85 0c fe ff
	ff		 mov	 DWORD PTR _i$1$[ebp], eax
  005aa	89 8d 40 fe ff
	ff		 mov	 DWORD PTR tv3474[ebp], ecx
  005b0	3b 42 30	 cmp	 eax, DWORD PTR [edx+48]
  005b3	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR __My_data$1$[ebp]
  005b9	0f 8c 77 fc ff
	ff		 jl	 $LL7@LoadData_V
$LN6@LoadData_V:

; 327  : 			}
; 328  : 		}
; 329  : 
; 330  : 		////////////////////////////////////
; 331  : 
; 332  : 		pMeshData->pImageVector.clear();

  005bf	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR _pMeshData$1$[ebp]
  005c5	8b 81 ac 00 00
	00		 mov	 eax, DWORD PTR [ecx+172]
  005cb	8d b9 ac 00 00
	00		 lea	 edi, DWORD PTR [ecx+172]
  005d1	89 47 04	 mov	 DWORD PTR [edi+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  005d4	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _strExtension$18[ebp], 0

; 4596 :         _My_data._Mysize = 0;

  005db	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _strExtension$18[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  005e2	c7 45 bc 0f 00
	00 00		 mov	 DWORD PTR _strExtension$18[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  005e9	c6 45 a8 00	 mov	 BYTE PTR _strExtension$18[ebp], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 335  : 		GetFileExtension(pMeshData->szDiffuseMapFileName, strlen(pMeshData->szDiffuseMapFileName), &strExtension);

  005ed	8d 71 20	 lea	 esi, DWORD PTR [ecx+32]
  005f0	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  005f4	8b ce		 mov	 ecx, esi
  005f6	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  005f9	0f 1f 80 00 00
	00 00		 npad	 7
$LL669@LoadData_V:
  00600	8a 01		 mov	 al, BYTE PTR [ecx]
  00602	41		 inc	 ecx
  00603	84 c0		 test	 al, al
  00605	75 f9		 jne	 SHORT $LL669@LoadData_V
  00607	8d 45 a8	 lea	 eax, DWORD PTR _strExtension$18[ebp]
  0060a	2b ca		 sub	 ecx, edx
  0060c	50		 push	 eax
  0060d	51		 push	 ecx
  0060e	56		 push	 esi
  0060f	e8 00 00 00 00	 call	 ?GetFileExtension@@YAXPBDHPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GetFileExtension

; 336  : 		stl_lowers(strExtension);

  00614	8d 45 a8	 lea	 eax, DWORD PTR _strExtension$18[ebp]
  00617	50		 push	 eax
  00618	e8 00 00 00 00	 call	 ?stl_lowers@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; stl_lowers
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 590  :     const int _Ans = _Traits::compare(_Left, _Right, (_STD min)(_Left_size, _Right_size));

  0061d	8b 75 b8	 mov	 esi, DWORD PTR _strExtension$18[ebp+16]

; 2305 :         const value_type* _Result = _Bx._Buf;

  00620	8d 4d a8	 lea	 ecx, DWORD PTR _strExtension$18[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 336  : 		stl_lowers(strExtension);

  00623	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 590  :     const int _Ans = _Traits::compare(_Left, _Right, (_STD min)(_Left_size, _Right_size));

  00626	b8 03 00 00 00	 mov	 eax, 3

; 2306 :         if (_Large_string_engaged()) {

  0062b	83 7d bc 10	 cmp	 DWORD PTR _strExtension$18[ebp+20], 16 ; 00000010H

; 392  :         return _CSTD memcmp(_First1, _First2, _Count);

  0062f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_03BNIHALFD@ifl@

; 2306 :         if (_Large_string_engaged()) {

  00634	0f 43 4d a8	 cmovae	 ecx, DWORD PTR _strExtension$18[ebp]

; 590  :     const int _Ans = _Traits::compare(_Left, _Right, (_STD min)(_Left_size, _Right_size));

  00638	83 fe 03	 cmp	 esi, 3
  0063b	0f 47 f0	 cmova	 esi, eax

; 392  :         return _CSTD memcmp(_First1, _First2, _Count);

  0063e	83 ee 04	 sub	 esi, 4
  00641	72 11		 jb	 SHORT $LN672@LoadData_V
$LL673@LoadData_V:
  00643	8b 01		 mov	 eax, DWORD PTR [ecx]
  00645	3b 02		 cmp	 eax, DWORD PTR [edx]
  00647	75 10		 jne	 SHORT $LN671@LoadData_V
  00649	83 c1 04	 add	 ecx, 4
  0064c	83 c2 04	 add	 edx, 4
  0064f	83 ee 04	 sub	 esi, 4
  00652	73 ef		 jae	 SHORT $LL673@LoadData_V
$LN672@LoadData_V:
  00654	83 fe fc	 cmp	 esi, -4			; fffffffcH
  00657	74 34		 je	 SHORT $LN670@LoadData_V
$LN671@LoadData_V:
  00659	8a 01		 mov	 al, BYTE PTR [ecx]
  0065b	3a 02		 cmp	 al, BYTE PTR [edx]
  0065d	75 27		 jne	 SHORT $LN674@LoadData_V
  0065f	83 fe fd	 cmp	 esi, -3			; fffffffdH
  00662	74 29		 je	 SHORT $LN670@LoadData_V
  00664	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00667	3a 42 01	 cmp	 al, BYTE PTR [edx+1]
  0066a	75 1a		 jne	 SHORT $LN674@LoadData_V
  0066c	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0066f	74 1c		 je	 SHORT $LN670@LoadData_V
  00671	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  00674	3a 42 02	 cmp	 al, BYTE PTR [edx+2]
  00677	75 0d		 jne	 SHORT $LN674@LoadData_V
  00679	83 fe ff	 cmp	 esi, -1
  0067c	74 0f		 je	 SHORT $LN670@LoadData_V
  0067e	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  00681	3a 42 03	 cmp	 al, BYTE PTR [edx+3]
  00684	74 07		 je	 SHORT $LN670@LoadData_V
$LN674@LoadData_V:
  00686	1b c0		 sbb	 eax, eax
  00688	83 c8 01	 or	 eax, 1
  0068b	eb 02		 jmp	 SHORT $LN675@LoadData_V
$LN670@LoadData_V:
  0068d	33 c0		 xor	 eax, eax
$LN675@LoadData_V:

; 592  :     if (_Ans != 0) {

  0068f	85 c0		 test	 eax, eax
  00691	0f 85 8f 03 00
	00		 jne	 $LN14@LoadData_V

; 593  :         return _Ans;
; 594  :     }
; 595  : 
; 596  :     if (_Left_size < _Right_size) {

  00697	8b 45 b8	 mov	 eax, DWORD PTR _strExtension$18[ebp+16]
  0069a	83 f8 03	 cmp	 eax, 3
  0069d	73 05		 jae	 SHORT $LN242@LoadData_V

; 597  :         return -1;

  0069f	83 c8 ff	 or	 eax, -1
  006a2	eb 0b		 jmp	 SHORT $LN243@LoadData_V
$LN242@LoadData_V:

; 598  :     }
; 599  : 
; 600  :     if (_Left_size > _Right_size) {

  006a4	b9 03 00 00 00	 mov	 ecx, 3
  006a9	3b c8		 cmp	 ecx, eax
  006ab	1b c0		 sbb	 eax, eax
  006ad	f7 d8		 neg	 eax
$LN243@LoadData_V:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 338  : 		if (0 == strExtension.compare("ifl"))

  006af	85 c0		 test	 eax, eax
  006b1	0f 85 6f 03 00
	00		 jne	 $LN14@LoadData_V

; 339  : 		{
; 340  : 			LPCVOID pMotionData;
; 341  : 			CMappedFile File;

  006b7	8d 8d 64 fe ff
	ff		 lea	 ecx, DWORD PTR _File$17[ebp]
  006bd	e8 00 00 00 00	 call	 ??0CMappedFile@@QAE@XZ	; CMappedFile::CMappedFile

; 342  : 
; 343  : 			if (CEterPackManager::Instance().Get(File, pMeshData->szDiffuseMapFileName, &pMotionData))

  006c2	8b b5 54 fe ff
	ff		 mov	 esi, DWORD PTR _pMeshData$1$[ebp]
  006c8	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _pMotionData$7[ebp]
  006ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  006d4	83 c6 20	 add	 esi, 32			; 00000020H
  006d7	50		 push	 eax
  006d8	56		 push	 esi
  006d9	8d 85 64 fe ff
	ff		 lea	 eax, DWORD PTR _File$17[ebp]
  006df	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  006e3	50		 push	 eax
  006e4	e8 00 00 00 00	 call	 ?Get@CEterPackManager@@QAE_NAAVCMappedFile@@PBDPAPBX@Z ; CEterPackManager::Get
  006e9	84 c0		 test	 al, al
  006eb	0f 84 22 03 00
	00		 je	 $LN16@LoadData_V

; 344  : 			{
; 345  : 				CMemoryTextFileLoader textFileLoader;

  006f1	8d 8d c0 fd ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$6[ebp]
  006f7	e8 00 00 00 00	 call	 ??0CMemoryTextFileLoader@@QAE@XZ ; CMemoryTextFileLoader::CMemoryTextFileLoader
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  006fc	c7 85 b4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _stTokenVector$5[ebp], 0
  00706	c7 85 b8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _stTokenVector$5[ebp+4], 0
  00710	c7 85 bc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _stTokenVector$5[ebp+8], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 348  : 				textFileLoader.Bind(File.Size(), pMotionData);

  0071a	ff b5 d4 fd ff
	ff		 push	 DWORD PTR _pMotionData$7[ebp]
  00720	8d 8d 64 fe ff
	ff		 lea	 ecx, DWORD PTR _File$17[ebp]
  00726	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  0072a	e8 00 00 00 00	 call	 ?Size@CMappedFile@@QAEKXZ ; CMappedFile::Size
  0072f	50		 push	 eax
  00730	8d 8d c0 fd ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$6[ebp]
  00736	e8 00 00 00 00	 call	 ?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z ; CMemoryTextFileLoader::Bind
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0073b	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _strPathName$19[ebp], 0

; 4596 :         _My_data._Mysize = 0;

  00742	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _strPathName$19[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00749	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _strPathName$19[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00750	c6 45 c0 00	 mov	 BYTE PTR _strPathName$19[ebp], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 351  : 				GetOnlyPathName(pMeshData->szDiffuseMapFileName, strPathName);

  00754	8d 45 c0	 lea	 eax, DWORD PTR _strPathName$19[ebp]
  00757	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  0075b	50		 push	 eax
  0075c	56		 push	 esi
  0075d	e8 00 00 00 00	 call	 ?GetOnlyPathName@@YAXPBDAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GetOnlyPathName
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00762	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _strTextureFileName$20[ebp], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 351  : 				GetOnlyPathName(pMeshData->szDiffuseMapFileName, strPathName);

  00769	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4596 :         _My_data._Mysize = 0;

  0076c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _strTextureFileName$20[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00773	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _strTextureFileName$20[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0077a	c6 45 d8 00	 mov	 BYTE PTR _strTextureFileName$20[ebp], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 354  : 				for (DWORD i = 0; i < textFileLoader.GetLineCount(); ++i)

  0077e	33 f6		 xor	 esi, esi
  00780	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00784	8d 8d c0 fd ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$6[ebp]
  0078a	89 b5 44 fe ff
	ff		 mov	 DWORD PTR _i$1$[ebp], esi
  00790	e8 00 00 00 00	 call	 ?GetLineCount@CMemoryTextFileLoader@@QAEKXZ ; CMemoryTextFileLoader::GetLineCount
  00795	85 c0		 test	 eax, eax
  00797	0f 84 d7 01 00
	00		 je	 $LN12@LoadData_V
  0079d	0f 1f 00	 npad	 3
$LL13@LoadData_V:

; 355  : 				{
; 356  : 					const std::string & c_rstrFileName = textFileLoader.GetLineString(i);

  007a0	56		 push	 esi
  007a1	8d 8d c0 fd ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$6[ebp]
  007a7	e8 00 00 00 00	 call	 ?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; CMemoryTextFileLoader::GetLineString
  007ac	89 85 18 fe ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4019 :         return size() == 0;

  007b2	83 c0 10	 add	 eax, 16			; 00000010H
  007b5	89 85 1c fe ff
	ff		 mov	 DWORD PTR tv3494[ebp], eax
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 358  : 					if (c_rstrFileName.empty())

  007bb	83 38 00	 cmp	 DWORD PTR [eax], 0
  007be	0f 84 96 01 00
	00		 je	 $LN11@LoadData_V
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2306 :         if (_Large_string_engaged()) {

  007c4	83 7d d4 10	 cmp	 DWORD PTR _strPathName$19[ebp+20], 16 ; 00000010H
  007c8	8d 45 c0	 lea	 eax, DWORD PTR _strPathName$19[ebp]

; 3035 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  007cb	8b 4d ec	 mov	 ecx, DWORD PTR _strTextureFileName$20[ebp+20]

; 2306 :         if (_Large_string_engaged()) {

  007ce	0f 43 45 c0	 cmovae	 eax, DWORD PTR _strPathName$19[ebp]

; 3035 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  007d2	8b 7d d0	 mov	 edi, DWORD PTR _strPathName$19[ebp+16]

; 2306 :         if (_Large_string_engaged()) {

  007d5	89 85 58 fe ff
	ff		 mov	 DWORD PTR __Result$2$[ebp], eax

; 3035 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  007db	89 8d 14 fe ff
	ff		 mov	 DWORD PTR __Old_capacity$1$[ebp], ecx
  007e1	3b f9		 cmp	 edi, ecx

; 3246 :         if (_Count <= _Mypair._Myval2._Myres) {

  007e3	77 21		 ja	 SHORT $LN294@LoadData_V

; 2297 :         if (_Large_string_engaged()) {

  007e5	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  007e8	89 7d e8	 mov	 DWORD PTR _strTextureFileName$20[ebp+16], edi
  007eb	57		 push	 edi

; 2296 :         value_type* _Result = _Bx._Buf;

  007ec	8d 75 d8	 lea	 esi, DWORD PTR _strTextureFileName$20[ebp]

; 2297 :         if (_Large_string_engaged()) {

  007ef	0f 43 75 d8	 cmovae	 esi, DWORD PTR _strTextureFileName$20[ebp]

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  007f3	50		 push	 eax
  007f4	56		 push	 esi
  007f5	e8 00 00 00 00	 call	 _memmove
  007fa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  007fd	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0

; 3251 :             return *this;

  00801	e9 de 00 00 00	 jmp	 $LN306@LoadData_V
$LN294@LoadData_V:

; 4508 :         if (_New_size > max_size()) {

  00806	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH
  0080c	0f 87 db 03 00
	00		 ja	 $LN636@LoadData_V

; 4510 :         }
; 4511 : 
; 4512 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  00812	8b f7		 mov	 esi, edi
  00814	83 ce 0f	 or	 esi, 15			; 0000000fH

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00817	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 4489 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0081d	76 15		 jbe	 SHORT $LN311@LoadData_V

; 4490 :             return _Max;

  0081f	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00824	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00829	50		 push	 eax
  0082a	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0082f	83 c4 04	 add	 esp, 4
  00832	eb 52		 jmp	 SHORT $LN680@LoadData_V
$LN311@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4493 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00834	8b d1		 mov	 edx, ecx
  00836	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0083b	d1 ea		 shr	 edx, 1
  0083d	2b c2		 sub	 eax, edx
  0083f	3b c8		 cmp	 ecx, eax
  00841	76 15		 jbe	 SHORT $LN312@LoadData_V

; 4494 :             return _Max;

  00843	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00848	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0084d	50		 push	 eax
  0084e	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00853	83 c4 04	 add	 esp, 4
  00856	eb 2e		 jmp	 SHORT $LN680@LoadData_V
$LN312@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4497 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00858	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  0085b	3b f0		 cmp	 esi, eax
  0085d	0f 42 f0	 cmovb	 esi, eax

; 4515 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00860	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00863	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00868	72 0b		 jb	 SHORT $LN319@LoadData_V

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0086a	50		 push	 eax
  0086b	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00870	83 c4 04	 add	 esp, 4
  00873	eb 11		 jmp	 SHORT $LN680@LoadData_V
$LN319@LoadData_V:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  00875	85 c0		 test	 eax, eax
  00877	74 0b		 je	 SHORT $LN320@LoadData_V

; 85   :         return ::operator new(_Bytes);

  00879	50		 push	 eax
  0087a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0087f	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  00882	eb 02		 jmp	 SHORT $LN680@LoadData_V
$LN320@LoadData_V:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  00884	33 c0		 xor	 eax, eax
$LN680@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00886	57		 push	 edi
  00887	ff b5 58 fe ff
	ff		 push	 DWORD PTR __Result$2$[ebp]

; 4524 :         _Mypair._Myval2._Myres  = _New_capacity;

  0088d	89 75 ec	 mov	 DWORD PTR _strTextureFileName$20[ebp+20], esi

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00890	8b f0		 mov	 esi, eax
  00892	56		 push	 esi

; 4523 :         _Mypair._Myval2._Mysize = _New_size;

  00893	89 85 5c fe ff
	ff		 mov	 DWORD PTR $T11[ebp], eax
  00899	89 7d e8	 mov	 DWORD PTR _strTextureFileName$20[ebp+16], edi

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0089c	e8 00 00 00 00	 call	 _memcpy

; 4526 :         if (_BUF_SIZE <= _Old_capacity) {

  008a1	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR __Old_capacity$1$[ebp]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  008a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3258 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  008aa	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0

; 4526 :         if (_BUF_SIZE <= _Old_capacity) {

  008ae	83 f8 10	 cmp	 eax, 16			; 00000010H
  008b1	72 2e		 jb	 SHORT $LN305@LoadData_V
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  008b3	8b 4d d8	 mov	 ecx, DWORD PTR _strTextureFileName$20[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4527 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  008b6	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  008b9	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  008bb	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  008c1	72 14		 jb	 SHORT $LN342@LoadData_V

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  008c3	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  008c6	83 c2 23	 add	 edx, 35			; 00000023H
  008c9	2b c1		 sub	 eax, ecx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  008cb	83 c0 fc	 add	 eax, -4			; fffffffcH
  008ce	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  008d1	0f 87 11 03 00
	00		 ja	 $LN618@LoadData_V
$LN342@LoadData_V:

; 264  :         ::operator delete(_Ptr, _Bytes);

  008d7	52		 push	 edx
  008d8	51		 push	 ecx
  008d9	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  008de	83 c4 08	 add	 esp, 8
$LN305@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2306 :         if (_Large_string_engaged()) {

  008e1	89 75 d8	 mov	 DWORD PTR _strTextureFileName$20[ebp], esi
$LN306@LoadData_V:
  008e4	8b 85 18 fe ff
	ff		 mov	 eax, DWORD PTR __Result$1$[ebp]
  008ea	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  008ee	72 02		 jb	 SHORT $LN355@LoadData_V

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  008f0	8b 00		 mov	 eax, DWORD PTR [eax]
$LN355@LoadData_V:

; 3124 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  008f2	8b 8d 1c fe ff
	ff		 mov	 ecx, DWORD PTR tv3494[ebp]
  008f8	ff 31		 push	 DWORD PTR [ecx]
  008fa	8d 4d d8	 lea	 ecx, DWORD PTR _strTextureFileName$20[ebp]
  008fd	50		 push	 eax
  008fe	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2306 :         if (_Large_string_engaged()) {

  00903	83 7d ec 10	 cmp	 DWORD PTR _strTextureFileName$20[ebp+20], 16 ; 00000010H
  00907	8d 45 d8	 lea	 eax, DWORD PTR _strTextureFileName$20[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 364  : 					CGraphicImage * pImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer(strTextureFileName.c_str());

  0090a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2306 :         if (_Large_string_engaged()) {

  00910	0f 43 45 d8	 cmovae	 eax, DWORD PTR _strTextureFileName$20[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 364  : 					CGraphicImage * pImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer(strTextureFileName.c_str());

  00914	50		 push	 eax
  00915	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  0091a	8b bd 54 fe ff
	ff		 mov	 edi, DWORD PTR _pMeshData$1$[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 364  : 					CGraphicImage * pImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer(strTextureFileName.c_str());

  00920	8b c8		 mov	 ecx, eax
  00922	89 8d 58 fe ff
	ff		 mov	 DWORD PTR _pImage$10[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  00928	8b 87 b0 00 00
	00		 mov	 eax, DWORD PTR [edi+176]
  0092e	3b 87 b4 00 00
	00		 cmp	 eax, DWORD PTR [edi+180]
  00934	74 0b		 je	 SHORT $LN369@LoadData_V

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00936	89 08		 mov	 DWORD PTR [eax], ecx

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

  00938	83 87 b0 00 00
	00 04		 add	 DWORD PTR [edi+176], 4

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0093f	eb 13		 jmp	 SHORT $LN681@LoadData_V
$LN369@LoadData_V:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00941	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR _pImage$10[ebp]
  00947	51		 push	 ecx
  00948	50		 push	 eax
  00949	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  0094f	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEPAPAVCGraphicImage@@QAPAV2@ABQAV2@@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Emplace_reallocate<CGraphicImage * const &>
$LN681@LoadData_V:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 354  : 				for (DWORD i = 0; i < textFileLoader.GetLineCount(); ++i)

  00954	8b b5 44 fe ff
	ff		 mov	 esi, DWORD PTR _i$1$[ebp]
$LN11@LoadData_V:
  0095a	46		 inc	 esi
  0095b	8d 8d c0 fd ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$6[ebp]
  00961	89 b5 44 fe ff
	ff		 mov	 DWORD PTR _i$1$[ebp], esi
  00967	e8 00 00 00 00	 call	 ?GetLineCount@CMemoryTextFileLoader@@QAEKXZ ; CMemoryTextFileLoader::GetLineCount
  0096c	3b f0		 cmp	 esi, eax
  0096e	0f 82 2c fe ff
	ff		 jb	 $LL13@LoadData_V
$LN12@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00974	8b 55 ec	 mov	 edx, DWORD PTR _strTextureFileName$20[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 368  : 			}

  00977	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0097b	83 fa 10	 cmp	 edx, 16			; 00000010H
  0097e	72 2c		 jb	 SHORT $LN385@LoadData_V
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00980	8b 4d d8	 mov	 ecx, DWORD PTR _strTextureFileName$20[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00983	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00984	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00986	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0098c	72 14		 jb	 SHORT $LN395@LoadData_V

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0098e	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00991	83 c2 23	 add	 edx, 35			; 00000023H
  00994	2b c1		 sub	 eax, ecx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00996	83 c0 fc	 add	 eax, -4			; fffffffcH
  00999	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0099c	0f 87 46 02 00
	00		 ja	 $LN618@LoadData_V
$LN395@LoadData_V:

; 264  :         ::operator delete(_Ptr, _Bytes);

  009a2	52		 push	 edx
  009a3	51		 push	 ecx
  009a4	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  009a9	83 c4 08	 add	 esp, 8
$LN385@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  009ac	8b 55 d4	 mov	 edx, DWORD PTR _strPathName$19[ebp+20]

; 4633 :             _Mypair._Myval2._Mysize = 0;

  009af	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _strTextureFileName$20[ebp+16], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  009b6	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _strTextureFileName$20[ebp+20], 15 ; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  009bd	c6 45 d8 00	 mov	 BYTE PTR _strTextureFileName$20[ebp], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 368  : 			}

  009c1	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  009c5	83 fa 10	 cmp	 edx, 16			; 00000010H
  009c8	72 2c		 jb	 SHORT $LN412@LoadData_V
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  009ca	8b 4d c0	 mov	 ecx, DWORD PTR _strPathName$19[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  009cd	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  009ce	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  009d0	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  009d6	72 14		 jb	 SHORT $LN422@LoadData_V

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  009d8	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  009db	83 c2 23	 add	 edx, 35			; 00000023H
  009de	2b c1		 sub	 eax, ecx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  009e0	83 c0 fc	 add	 eax, -4			; fffffffcH
  009e3	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  009e6	0f 87 fc 01 00
	00		 ja	 $LN618@LoadData_V
$LN422@LoadData_V:

; 264  :         ::operator delete(_Ptr, _Bytes);

  009ec	52		 push	 edx
  009ed	51		 push	 ecx
  009ee	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  009f3	83 c4 08	 add	 esp, 8
$LN412@LoadData_V:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 368  : 			}

  009f6	8d 8d c0 fd ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$6[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  009fc	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _strPathName$19[ebp+16], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00a03	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _strPathName$19[ebp+20], 15 ; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00a0a	c6 45 c0 00	 mov	 BYTE PTR _strPathName$19[ebp], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 368  : 			}

  00a0e	e8 00 00 00 00	 call	 ??1CMemoryTextFileLoader@@UAE@XZ ; CMemoryTextFileLoader::~CMemoryTextFileLoader
$LN16@LoadData_V:

; 369  : 		}

  00a13	8d 8d 64 fe ff
	ff		 lea	 ecx, DWORD PTR _File$17[ebp]
  00a19	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  00a1e	8b b5 54 fe ff
	ff		 mov	 esi, DWORD PTR _pMeshData$1$[ebp]
  00a24	eb 3c		 jmp	 SHORT $LN496@LoadData_V
$LN14@LoadData_V:

; 372  : 			CGraphicImage * pImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer(pMeshData->szDiffuseMapFileName);

  00a26	8b b5 54 fe ff
	ff		 mov	 esi, DWORD PTR _pMeshData$1$[ebp]
  00a2c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  00a32	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  00a35	50		 push	 eax
  00a36	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  00a3b	8b c8		 mov	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  00a3d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 372  : 			CGraphicImage * pImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer(pMeshData->szDiffuseMapFileName);

  00a40	89 8d 58 fe ff
	ff		 mov	 DWORD PTR _pImage$9[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  00a46	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  00a49	74 08		 je	 SHORT $LN497@LoadData_V

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00a4b	89 08		 mov	 DWORD PTR [eax], ecx

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

  00a4d	83 47 04 04	 add	 DWORD PTR [edi+4], 4

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00a51	eb 0f		 jmp	 SHORT $LN496@LoadData_V
$LN497@LoadData_V:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00a53	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR _pImage$9[ebp]
  00a59	51		 push	 ecx
  00a5a	50		 push	 eax
  00a5b	8b cf		 mov	 ecx, edi
  00a5d	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEPAPAVCGraphicImage@@QAPAV2@ABQAV2@@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Emplace_reallocate<CGraphicImage * const &>
$LN496@LoadData_V:

; 1569 :         return _My_data._Myfirst[_Pos];

  00a62	8b 85 d0 fd ff
	ff		 mov	 eax, DWORD PTR __My_data$1$[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 379  : 		m_pEffectMeshDataVector[n] = pMeshData;

  00a68	8b bd 10 fe ff
	ff		 mov	 edi, DWORD PTR _n$1$[ebp]
  00a6e	0f bf cf	 movsx	 ecx, di

; 380  : 	}

  00a71	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  00a75	8b 00		 mov	 eax, DWORD PTR [eax]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 379  : 		m_pEffectMeshDataVector[n] = pMeshData;

  00a77	89 34 88	 mov	 DWORD PTR [eax+ecx*4], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00a7a	8b 55 bc	 mov	 edx, DWORD PTR _strExtension$18[ebp+20]
  00a7d	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00a80	72 2c		 jb	 SHORT $LN515@LoadData_V
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00a82	8b 4d a8	 mov	 ecx, DWORD PTR _strExtension$18[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00a85	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00a86	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00a88	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00a8e	72 14		 jb	 SHORT $LN525@LoadData_V

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00a90	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00a93	83 c2 23	 add	 edx, 35			; 00000023H
  00a96	2b c1		 sub	 eax, ecx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00a98	83 c0 fc	 add	 eax, -4			; fffffffcH
  00a9b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00a9e	0f 87 44 01 00
	00		 ja	 $LN618@LoadData_V
$LN525@LoadData_V:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00aa4	52		 push	 edx
  00aa5	51		 push	 ecx
  00aa6	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00aab	83 c4 08	 add	 esp, 8
$LN515@LoadData_V:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 255  : 	for (short n = 0; n < m_iGeomCount; ++n)

  00aae	8b 8d 30 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00ab4	47		 inc	 edi
  00ab5	0f bf c7	 movsx	 eax, di
  00ab8	89 bd 10 fe ff
	ff		 mov	 DWORD PTR _n$1$[ebp], edi
  00abe	3b 41 2c	 cmp	 eax, DWORD PTR [ecx+44]
  00ac1	0f 8c 30 f6 ff
	ff		 jl	 $LL4@LoadData_V
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00ac7	8b 8d 50 fe ff
	ff		 mov	 ecx, DWORD PTR __Ptr$1$[ebp]
  00acd	85 c9		 test	 ecx, ecx
  00acf	74 33		 je	 SHORT $LN533@LoadData_V

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00ad1	8b 95 2c fe ff
	ff		 mov	 edx, DWORD PTR __Bytes$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00ad7	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00ad9	2b d1		 sub	 edx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00adb	83 e2 fc	 and	 edx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00ade	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00ae4	72 14		 jb	 SHORT $LN549@LoadData_V

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00ae6	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00ae9	83 c2 23	 add	 edx, 35			; 00000023H
  00aec	2b c1		 sub	 eax, ecx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00aee	83 c0 fc	 add	 eax, -4			; fffffffcH
  00af1	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00af4	0f 87 ee 00 00
	00		 ja	 $LN618@LoadData_V
$LN549@LoadData_V:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00afa	52		 push	 edx
  00afb	51		 push	 ecx
  00afc	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00b01	83 c4 08	 add	 esp, 8
$LN533@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00b04	8b 8d 4c fe ff
	ff		 mov	 ecx, DWORD PTR __Ptr$1$[ebp]
  00b0a	85 c9		 test	 ecx, ecx
  00b0c	74 33		 je	 SHORT $LN557@LoadData_V

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00b0e	8b 95 28 fe ff
	ff		 mov	 edx, DWORD PTR __Bytes$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00b14	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00b16	2b d1		 sub	 edx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00b18	83 e2 f8	 and	 edx, -8			; fffffff8H

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00b1b	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00b21	72 14		 jb	 SHORT $LN573@LoadData_V

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00b23	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00b26	83 c2 23	 add	 edx, 35			; 00000023H
  00b29	2b c1		 sub	 eax, ecx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00b2b	83 c0 fc	 add	 eax, -4			; fffffffcH
  00b2e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00b31	0f 87 b1 00 00
	00		 ja	 $LN618@LoadData_V
$LN573@LoadData_V:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00b37	52		 push	 edx
  00b38	51		 push	 ecx
  00b39	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00b3e	83 c4 08	 add	 esp, 8
$LN557@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00b41	8b 8d 3c fe ff
	ff		 mov	 ecx, DWORD PTR __Ptr$1$[ebp]
  00b47	85 c9		 test	 ecx, ecx
  00b49	74 2f		 je	 SHORT $LN581@LoadData_V

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00b4b	8b 95 24 fe ff
	ff		 mov	 edx, DWORD PTR __Bytes$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00b51	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00b53	2b d1		 sub	 edx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00b55	83 e2 fc	 and	 edx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00b58	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00b5e	72 10		 jb	 SHORT $LN597@LoadData_V

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00b60	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00b63	83 c2 23	 add	 edx, 35			; 00000023H
  00b66	2b c1		 sub	 eax, ecx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00b68	83 c0 fc	 add	 eax, -4			; fffffffcH
  00b6b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00b6e	77 78		 ja	 SHORT $LN618@LoadData_V
$LN597@LoadData_V:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00b70	52		 push	 edx
  00b71	51		 push	 ecx
  00b72	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00b77	83 c4 08	 add	 esp, 8
$LN581@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00b7a	8b b5 48 fe ff
	ff		 mov	 esi, DWORD PTR __Ptr$1$[ebp]
  00b80	85 f6		 test	 esi, esi
  00b82	74 42		 je	 SHORT $LN605@LoadData_V

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00b84	8b 8d 20 fe ff
	ff		 mov	 ecx, DWORD PTR _v3VertexVector$2$[ebp]
  00b8a	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00b8f	2b ce		 sub	 ecx, esi
  00b91	f7 e9		 imul	 ecx
  00b93	d1 fa		 sar	 edx, 1
  00b95	8b c2		 mov	 eax, edx
  00b97	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00b9a	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00b9c	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00b9f	8b c6		 mov	 eax, esi
  00ba1	c1 e1 02	 shl	 ecx, 2

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00ba4	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00baa	72 10		 jb	 SHORT $LN621@LoadData_V

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00bac	8b 76 fc	 mov	 esi, DWORD PTR [esi-4]
  00baf	83 c1 23	 add	 ecx, 35			; 00000023H
  00bb2	2b c6		 sub	 eax, esi

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00bb4	83 c0 fc	 add	 eax, -4			; fffffffcH
  00bb7	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00bba	77 2c		 ja	 SHORT $LN618@LoadData_V
$LN621@LoadData_V:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00bbc	51		 push	 ecx
  00bbd	56		 push	 esi
  00bbe	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00bc3	83 c4 08	 add	 esp, 8
$LN605@LoadData_V:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 382  : 	return TRUE;

  00bc6	b8 01 00 00 00	 mov	 eax, 1

; 383  : }

  00bcb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00bce	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00bd5	59		 pop	 ecx
  00bd6	5f		 pop	 edi
  00bd7	5e		 pop	 esi
  00bd8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00bdb	33 cd		 xor	 ecx, ebp
  00bdd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00be2	8b e5		 mov	 esp, ebp
  00be4	5d		 pop	 ebp
  00be5	c2 08 00	 ret	 8
$LN618@LoadData_V:
  00be8	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN636@LoadData_V:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4509 :             _Xlen_string(); // result too long

  00bed	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN677@LoadData_V:
  00bf2	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$0:
  00000	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _v3VertexVector$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$1:
  0000b	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _iIndexVector$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$2:
  00016	8d 8d e4 fd ff
	ff		 lea	 ecx, DWORD PTR _v3TextureVertexVector$[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::~vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >
__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$3:
  00021	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR _iTextureIndexVector$[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$4:
  0002c	8d 4d a8	 lea	 ecx, DWORD PTR _strExtension$18[ebp]
  0002f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$5:
  00034	8d 8d 64 fe ff
	ff		 lea	 ecx, DWORD PTR _File$17[ebp]
  0003a	e9 00 00 00 00	 jmp	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$6:
  0003f	8d 8d c0 fd ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$6[ebp]
  00045	e9 00 00 00 00	 jmp	 ??1CMemoryTextFileLoader@@UAE@XZ ; CMemoryTextFileLoader::~CMemoryTextFileLoader
__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$7:
  0004a	8d 8d b4 fd ff
	ff		 lea	 ecx, DWORD PTR _stTokenVector$5[ebp]
  00050	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$8:
  00055	8d 4d c0	 lea	 ecx, DWORD PTR _strPathName$19[ebp]
  00058	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$9:
  0005d	8d 4d d8	 lea	 ecx, DWORD PTR _strTextureFileName$20[ebp]
  00060	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00065	cc		 int	 3
  00066	cc		 int	 3
  00067	cc		 int	 3
  00068	cc		 int	 3
  00069	cc		 int	 3
__ehhandler$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z:
  0006a	90		 npad	 1
  0006b	90		 npad	 1
  0006c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00070	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00073	8b 8a b4 fd ff
	ff		 mov	 ecx, DWORD PTR [edx-588]
  00079	33 c8		 xor	 ecx, eax
  0007b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00080	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00083	33 c8		 xor	 ecx, eax
  00085	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z
  0008f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z ENDP		; CEffectMesh::__LoadData_Ver001
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?OnIsType@CEffectMesh@@MAE_NK@Z
_TEXT	SEGMENT
_type$ = 8						; size = 4
?OnIsType@CEffectMesh@@MAE_NK@Z PROC			; CEffectMesh::OnIsType, COMDAT
; _this$ = ecx

; 64   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 65   : 	if (CEffectMesh::Type() == type)

  00006	e8 00 00 00 00	 call	 ?Type@CEffectMesh@@SAKXZ ; CEffectMesh::Type
  0000b	8b 55 08	 mov	 edx, DWORD PTR _type$[ebp]
  0000e	3b c2		 cmp	 eax, edx
  00010	75 07		 jne	 SHORT $LN2@OnIsType

; 66   : 		return true;

  00012	b0 01		 mov	 al, 1
  00014	5e		 pop	 esi

; 69   : }

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
$LN2@OnIsType:

; 67   : 
; 68   : 	return CResource::OnIsType(type);

  00019	52		 push	 edx
  0001a	8b ce		 mov	 ecx, esi
  0001c	e8 00 00 00 00	 call	 ?OnIsType@CResource@@MAE_NK@Z ; CResource::OnIsType
  00021	5e		 pop	 esi

; 69   : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?OnIsType@CEffectMesh@@MAE_NK@Z ENDP			; CEffectMesh::OnIsType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?OnIsEmpty@CEffectMesh@@MBE_NXZ
_TEXT	SEGMENT
?OnIsEmpty@CEffectMesh@@MBE_NXZ PROC			; CEffectMesh::OnIsEmpty, COMDAT
; _this$ = ecx

; 414  : 	return !m_isData;

  00000	80 79 40 00	 cmp	 BYTE PTR [ecx+64], 0
  00004	0f 94 c0	 sete	 al

; 415  : }

  00007	c3		 ret	 0
?OnIsEmpty@CEffectMesh@@MBE_NXZ ENDP			; CEffectMesh::OnIsEmpty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?OnClear@CEffectMesh@@MAEXXZ
_TEXT	SEGMENT
tv397 = -12						; size = 4
__My_data$1$ = -8					; size = 4
_i$1$ = -4						; size = 4
?OnClear@CEffectMesh@@MAEXXZ PROC			; CEffectMesh::OnClear, COMDAT
; _this$ = ecx

; 396  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx

; 397  : 	if (!m_isData)

  00009	80 7b 40 00	 cmp	 BYTE PTR [ebx+64], 0
  0000d	0f 84 94 00 00
	00		 je	 $LN1@OnClear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00013	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 400  : 	for (DWORD i = 0; i < m_pEffectMeshDataVector.size(); ++i)

  00016	33 d2		 xor	 edx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00018	8b 4b 34	 mov	 ecx, DWORD PTR [ebx+52]
  0001b	2b c1		 sub	 eax, ecx
  0001d	c1 f8 02	 sar	 eax, 2
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 400  : 	for (DWORD i = 0; i < m_pEffectMeshDataVector.size(); ++i)

  00020	89 55 fc	 mov	 DWORD PTR _i$1$[ebp], edx
  00023	85 c0		 test	 eax, eax
  00025	74 79		 je	 SHORT $LN3@OnClear
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@OnClear:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  00030	c1 e2 02	 shl	 edx, 2
  00033	89 55 f4	 mov	 DWORD PTR tv397[ebp], edx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 402  : 		m_pEffectMeshDataVector[i]->pImageVector.clear();

  00036	8b 0c 0a	 mov	 ecx, DWORD PTR [edx+ecx]
  00039	8b 81 ac 00 00
	00		 mov	 eax, DWORD PTR [ecx+172]
  0003f	89 81 b0 00 00
	00		 mov	 DWORD PTR [ecx+176], eax

; 403  : 		m_pEffectMeshDataVector[i]->EffectFrameDataVector.clear();

  00045	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  00048	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0004b	05 a0 00 00 00	 add	 eax, 160		; 000000a0H
  00050	89 45 f8	 mov	 DWORD PTR __My_data$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1455 :         _Destroy(_Myfirst, _Mylast);

  00053	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  00056	8b 30		 mov	 esi, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 949  :         for (; _First != _Last; ++_First) {

  00058	3b f7		 cmp	 esi, edi
  0005a	74 1b		 je	 SHORT $LN40@OnClear
  0005c	0f 1f 40 00	 npad	 4
$LL20@OnClear:
  00060	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  00063	e8 00 00 00 00	 call	 ??1?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@QAE@XZ ; std::vector<SPTVertex,std::allocator<SPTVertex> >::~vector<SPTVertex,std::allocator<SPTVertex> >
  00068	83 c6 20	 add	 esi, 32			; 00000020H
  0006b	3b f7		 cmp	 esi, edi
  0006d	75 f1		 jne	 SHORT $LL20@OnClear
  0006f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$1$[ebp]
  00072	8b 55 f4	 mov	 edx, DWORD PTR tv397[ebp]
  00075	8b 30		 mov	 esi, DWORD PTR [eax]
$LN40@OnClear:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1456 :         _Mylast = _Myfirst;

  00077	89 70 04	 mov	 DWORD PTR [eax+4], esi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 405  : 		SEffectMeshData::Delete(m_pEffectMeshDataVector[i]);

  0007a	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  0007d	ff 34 02	 push	 DWORD PTR [edx+eax]
  00080	e8 00 00 00 00	 call	 ?Delete@SEffectMeshData@CEffectMesh@@SAXPAU12@@Z ; CEffectMesh::SEffectMeshData::Delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00085	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 405  : 		SEffectMeshData::Delete(m_pEffectMeshDataVector[i]);

  00088	83 c4 04	 add	 esp, 4
  0008b	8b 55 fc	 mov	 edx, DWORD PTR _i$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0008e	8b 4b 34	 mov	 ecx, DWORD PTR [ebx+52]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 400  : 	for (DWORD i = 0; i < m_pEffectMeshDataVector.size(); ++i)

  00091	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00092	2b c1		 sub	 eax, ecx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 400  : 	for (DWORD i = 0; i < m_pEffectMeshDataVector.size(); ++i)

  00094	89 55 fc	 mov	 DWORD PTR _i$1$[ebp], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00097	c1 f8 02	 sar	 eax, 2
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 400  : 	for (DWORD i = 0; i < m_pEffectMeshDataVector.size(); ++i)

  0009a	3b d0		 cmp	 edx, eax
  0009c	72 92		 jb	 SHORT $LL4@OnClear
  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi
$LN3@OnClear:

; 406  : 	}
; 407  : 	m_pEffectMeshDataVector.clear();

  000a0	89 4b 38	 mov	 DWORD PTR [ebx+56], ecx

; 408  : 
; 409  : 	m_isData = false;

  000a3	c6 43 40 00	 mov	 BYTE PTR [ebx+64], 0
$LN1@OnClear:
  000a7	5b		 pop	 ebx

; 410  : }

  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
?OnClear@CEffectMesh@@MAEXXZ ENDP			; CEffectMesh::OnClear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?OnLoad@CEffectMesh@@MAE_NHPBX@Z
_TEXT	SEGMENT
_szHeader$ = -12					; size = 11
_iSize$ = 8						; size = 4
_c_pvBuf$ = 12						; size = 4
?OnLoad@CEffectMesh@@MAE_NHPBX@Z PROC			; CEffectMesh::OnLoad, COMDAT
; _this$ = ecx

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   : 	if (!c_pvBuf)

  00003	8b 55 0c	 mov	 edx, DWORD PTR _c_pvBuf$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	57		 push	 edi
  0000d	85 d2		 test	 edx, edx
  0000f	74 5a		 je	 SHORT $LN6@OnLoad

; 74   : 		return false;
; 75   : 
; 76   : 	const BYTE * c_pbBuf = static_cast<const BYTE *> (c_pvBuf);
; 77   : 
; 78   : 	char szHeader[10+1];
; 79   : 	memcpy(szHeader, c_pbBuf, 10+1);

  00011	66 8b 42 08	 mov	 ax, WORD PTR [edx+8]

; 80   : 	c_pbBuf += 10+1;

  00015	8d 7a 0b	 lea	 edi, DWORD PTR [edx+11]
  00018	f3 0f 7e 02	 movq	 xmm0, QWORD PTR [edx]

; 81   : 
; 82   : 	if (0 == strcmp("EffectData", szHeader))

  0001c	8d 4d f4	 lea	 ecx, DWORD PTR _szHeader$[ebp]
  0001f	66 89 45 fc	 mov	 WORD PTR _szHeader$[ebp+8], ax
  00023	8a 42 0a	 mov	 al, BYTE PTR [edx+10]
  00026	88 45 fe	 mov	 BYTE PTR _szHeader$[ebp+10], al
  00029	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0L@HDPGDEFC@EffectData@
  0002e	66 0f d6 45 f4	 movq	 QWORD PTR _szHeader$[ebp], xmm0
$LL10@OnLoad:
  00033	8a 10		 mov	 dl, BYTE PTR [eax]
  00035	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00037	75 1a		 jne	 SHORT $LN11@OnLoad
  00039	84 d2		 test	 dl, dl
  0003b	74 12		 je	 SHORT $LN12@OnLoad
  0003d	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00040	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00043	75 0e		 jne	 SHORT $LN11@OnLoad
  00045	83 c0 02	 add	 eax, 2
  00048	83 c1 02	 add	 ecx, 2
  0004b	84 d2		 test	 dl, dl
  0004d	75 e4		 jne	 SHORT $LL10@OnLoad
$LN12@OnLoad:
  0004f	33 c0		 xor	 eax, eax
  00051	eb 05		 jmp	 SHORT $LN13@OnLoad
$LN11@OnLoad:
  00053	1b c0		 sbb	 eax, eax
  00055	83 c8 01	 or	 eax, 1
$LN13@OnLoad:
  00058	85 c0		 test	 eax, eax
  0005a	75 19		 jne	 SHORT $LN3@OnLoad

; 83   : 	{
; 84   : 		if (!__LoadData_Ver001(iSize, c_pbBuf))

  0005c	57		 push	 edi
  0005d	ff 75 08	 push	 DWORD PTR _iSize$[ebp]
  00060	8b ce		 mov	 ecx, esi
  00062	e8 00 00 00 00	 call	 ?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z ; CEffectMesh::__LoadData_Ver001
  00067	85 c0		 test	 eax, eax
  00069	75 4d		 jne	 SHORT $LN8@OnLoad
$LN6@OnLoad:
  0006b	5f		 pop	 edi

; 90   : 			return false;
; 91   : 	}
; 92   : 	else
; 93   : 	{
; 94   : 		return false;

  0006c	32 c0		 xor	 al, al

; 99   : }

  0006e	5e		 pop	 esi
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c2 08 00	 ret	 8
$LN3@OnLoad:

; 85   : 			return false;
; 86   : 	}
; 87   : 	else if (0 == strcmp("MDEData002", szHeader))

  00075	8d 4d f4	 lea	 ecx, DWORD PTR _szHeader$[ebp]
  00078	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0L@HDHCIEF@MDEData002@
  0007d	0f 1f 00	 npad	 3
$LL14@OnLoad:
  00080	8a 10		 mov	 dl, BYTE PTR [eax]
  00082	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00084	75 1a		 jne	 SHORT $LN15@OnLoad
  00086	84 d2		 test	 dl, dl
  00088	74 12		 je	 SHORT $LN16@OnLoad
  0008a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0008d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00090	75 0e		 jne	 SHORT $LN15@OnLoad
  00092	83 c0 02	 add	 eax, 2
  00095	83 c1 02	 add	 ecx, 2
  00098	84 d2		 test	 dl, dl
  0009a	75 e4		 jne	 SHORT $LL14@OnLoad
$LN16@OnLoad:
  0009c	33 c0		 xor	 eax, eax
  0009e	eb 05		 jmp	 SHORT $LN17@OnLoad
$LN15@OnLoad:
  000a0	1b c0		 sbb	 eax, eax
  000a2	83 c8 01	 or	 eax, 1
$LN17@OnLoad:
  000a5	85 c0		 test	 eax, eax
  000a7	75 c2		 jne	 SHORT $LN6@OnLoad

; 88   : 	{
; 89   : 		if (!__LoadData_Ver002(iSize, c_pbBuf))

  000a9	57		 push	 edi
  000aa	ff 75 08	 push	 DWORD PTR _iSize$[ebp]
  000ad	8b ce		 mov	 ecx, esi
  000af	e8 00 00 00 00	 call	 ?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z ; CEffectMesh::__LoadData_Ver002
  000b4	85 c0		 test	 eax, eax
  000b6	74 b3		 je	 SHORT $LN6@OnLoad
$LN8@OnLoad:
  000b8	5f		 pop	 edi

; 95   : 	}
; 96   : 
; 97   : 	m_isData = true;

  000b9	c6 46 40 01	 mov	 BYTE PTR [esi+64], 1

; 98   : 	return true;

  000bd	b0 01		 mov	 al, 1

; 99   : }

  000bf	5e		 pop	 esi
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c2 08 00	 ret	 8
?OnLoad@CEffectMesh@@MAE_NHPBX@Z ENDP			; CEffectMesh::OnLoad
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetMeshElementPointer@CEffectMesh@@QAEHKPAPAUSEffectMeshData@1@@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
_ppMeshData$ = 12					; size = 4
?GetMeshElementPointer@CEffectMesh@@QAEHKPAPAUSEffectMeshData@1@@Z PROC ; CEffectMesh::GetMeshElementPointer, COMDAT
; _this$ = ecx

; 386  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00003	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00006	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00009	2b c2		 sub	 eax, edx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 387  : 	if (dwMeshIndex >= m_pEffectMeshDataVector.size())

  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _dwMeshIndex$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0000e	c1 f8 02	 sar	 eax, 2
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 387  : 	if (dwMeshIndex >= m_pEffectMeshDataVector.size())

  00011	3b c8		 cmp	 ecx, eax
  00013	72 06		 jb	 SHORT $LN2@GetMeshEle

; 388  : 		return FALSE;

  00015	33 c0		 xor	 eax, eax

; 393  : }

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
$LN2@GetMeshEle:

; 389  : 
; 390  : 	*ppMeshData = m_pEffectMeshDataVector[dwMeshIndex];

  0001b	8b 45 0c	 mov	 eax, DWORD PTR _ppMeshData$[ebp]
  0001e	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00021	89 08		 mov	 DWORD PTR [eax], ecx

; 391  : 
; 392  : 	return TRUE;

  00023	b8 01 00 00 00	 mov	 eax, 1

; 393  : }

  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?GetMeshElementPointer@CEffectMesh@@QAEHKPAPAUSEffectMeshData@1@@Z ENDP ; CEffectMesh::GetMeshElementPointer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetTextureVectorReference@CEffectMesh@@QAEAAV?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@K@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
?GetTextureVectorReference@CEffectMesh@@QAEAAV?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@K@Z PROC ; CEffectMesh::GetTextureVectorReference, COMDAT
; _this$ = ecx

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 54   : 	return m_pEffectMeshDataVector[dwMeshIndex]->pImageVector;

  00003	8b 49 34	 mov	 ecx, DWORD PTR [ecx+52]
  00006	8b 45 08	 mov	 eax, DWORD PTR _dwMeshIndex$[ebp]
  00009	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0000c	05 ac 00 00 00	 add	 eax, 172		; 000000acH

; 55   : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?GetTextureVectorReference@CEffectMesh@@QAEAAV?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@K@Z ENDP ; CEffectMesh::GetTextureVectorReference
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetTextureVectorPointer@CEffectMesh@@QAEPAV?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@K@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
?GetTextureVectorPointer@CEffectMesh@@QAEPAV?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@K@Z PROC ; CEffectMesh::GetTextureVectorPointer, COMDAT
; _this$ = ecx

; 45   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00003	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00006	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00009	2b c2		 sub	 eax, edx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 46   : 	if (dwMeshIndex>=m_pEffectMeshDataVector.size())

  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _dwMeshIndex$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0000e	c1 f8 02	 sar	 eax, 2
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 46   : 	if (dwMeshIndex>=m_pEffectMeshDataVector.size())

  00011	3b c8		 cmp	 ecx, eax
  00013	72 06		 jb	 SHORT $LN2@GetTexture

; 47   : 		return NULL;

  00015	33 c0		 xor	 eax, eax

; 50   : }

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
$LN2@GetTexture:

; 48   : 
; 49   : 	return &m_pEffectMeshDataVector[dwMeshIndex]->pImageVector;

  0001b	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  0001e	05 ac 00 00 00	 add	 eax, 172		; 000000acH

; 50   : }

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
?GetTextureVectorPointer@CEffectMesh@@QAEPAV?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@K@Z ENDP ; CEffectMesh::GetTextureVectorPointer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetMeshDataPointer@CEffectMesh@@QAEPAUSEffectMeshData@1@K@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
?GetMeshDataPointer@CEffectMesh@@QAEPAUSEffectMeshData@1@K@Z PROC ; CEffectMesh::GetMeshDataPointer, COMDAT
; _this$ = ecx

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 40   : 	assert(dwMeshIndex < m_pEffectMeshDataVector.size());
; 41   : 	return m_pEffectMeshDataVector[dwMeshIndex];

  00003	8b 49 34	 mov	 ecx, DWORD PTR [ecx+52]
  00006	8b 45 08	 mov	 eax, DWORD PTR _dwMeshIndex$[ebp]
  00009	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 42   : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?GetMeshDataPointer@CEffectMesh@@QAEPAUSEffectMeshData@1@K@Z ENDP ; CEffectMesh::GetMeshDataPointer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetMeshCount@CEffectMesh@@QAEKXZ
_TEXT	SEGMENT
?GetMeshCount@CEffectMesh@@QAEKXZ PROC			; CEffectMesh::GetMeshCount, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00000	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00003	2b 41 34	 sub	 eax, DWORD PTR [ecx+52]
  00006	c1 f8 02	 sar	 eax, 2
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 36   : }

  00009	c3		 ret	 0
?GetMeshCount@CEffectMesh@@QAEKXZ ENDP			; CEffectMesh::GetMeshCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetFrameCount@CEffectMesh@@QAEKXZ
_TEXT	SEGMENT
?GetFrameCount@CEffectMesh@@QAEKXZ PROC			; CEffectMesh::GetFrameCount, COMDAT
; _this$ = ecx

; 30   : 	return m_iFrameCount;

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]

; 31   : }

  00003	c3		 ret	 0
?GetFrameCount@CEffectMesh@@QAEKXZ ENDP			; CEffectMesh::GetFrameCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ??1CEffectMesh@@UAE@XZ
_TEXT	SEGMENT
??1CEffectMesh@@UAE@XZ PROC				; CEffectMesh::~CEffectMesh, COMDAT
; _this$ = ecx

; 425  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CEffectMesh@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00009	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0000c	85 c0		 test	 eax, eax
  0000e	74 41		 je	 SHORT $LN6@CEffectMes

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00010	8b 4e 3c	 mov	 ecx, DWORD PTR [esi+60]
  00013	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00015	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00018	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001e	72 12		 jb	 SHORT $LN22@CEffectMes

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00020	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00023	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00026	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00028	83 c0 fc	 add	 eax, -4			; fffffffcH
  0002b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002e	77 29		 ja	 SHORT $LN19@CEffectMes

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00030	8b c2		 mov	 eax, edx
$LN22@CEffectMes:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00032	51		 push	 ecx
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  00039	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00040	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  00043	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 1769 :             _Myend   = nullptr;

  0004a	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0
$LN6@CEffectMes:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 426  : }

  00051	8b ce		 mov	 ecx, esi
  00053	5e		 pop	 esi
  00054	e9 00 00 00 00	 jmp	 ??1CResource@@UAE@XZ	; CResource::~CResource
$LN19@CEffectMes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00059	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN28@CEffectMes:
  0005e	cc		 int	 3
??1CEffectMesh@@UAE@XZ ENDP				; CEffectMesh::~CEffectMesh
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ??0CEffectMesh@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_c_szFileName$ = 8					; size = 4
??0CEffectMesh@@QAE@PBD@Z PROC				; CEffectMesh::CEffectMesh, COMDAT
; _this$ = ecx

; 418  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	ff 75 08	 push	 DWORD PTR _c_szFileName$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000d	e8 00 00 00 00	 call	 ??0CResource@@QAE@PBD@Z	; CResource::CResource
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CEffectMesh@@6B@

; 422  : }

  00018	8b c6		 mov	 eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0001a	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
  00021	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  00028	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 419  : 	m_iGeomCount = 0;

  0002f	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0

; 420  : 	m_iFrameCount = 0;

  00036	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0

; 421  : 	m_isData = false;

  0003d	c6 46 40 00	 mov	 BYTE PTR [esi+64], 0

; 422  : }

  00041	5e		 pop	 esi
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
??0CEffectMesh@@QAE@PBD@Z ENDP				; CEffectMesh::CEffectMesh
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?Type@CEffectMesh@@SAKXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?Type@CEffectMesh@@SAKXZ PROC				; CEffectMesh::Type, COMDAT

; 58   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Type@CEffectMesh@@SAKXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 59   : 	static TType s_type = StringToType("CEffectMesh");

  00022	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__tls_array
  00028	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __tls_index
  0002e	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$TSS0@?1??Type@CEffectMesh@@SAKXZ@4HA
  00036	3b 81 00 00 00
	00		 cmp	 eax, DWORD PTR __Init_thread_epoch[ecx]
  0003c	7f 14		 jg	 SHORT $LN9@Type
$LN5@Type:

; 60   : 	return s_type;
; 61   : }

  0003e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?s_type@?1??Type@CEffectMesh@@SAKXZ@4KA
  00043	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00046	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004d	59		 pop	 ecx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
$LN9@Type:

; 59   : 	static TType s_type = StringToType("CEffectMesh");

  00052	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Type@CEffectMesh@@SAKXZ@4HA
  00057	e8 00 00 00 00	 call	 __Init_thread_header
  0005c	83 c4 04	 add	 esp, 4
  0005f	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??Type@CEffectMesh@@SAKXZ@4HA, -1
  00066	75 d6		 jne	 SHORT $LN5@Type
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HCKGHODL@CEffectMesh@
  0006d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00074	e8 00 00 00 00	 call	 ?StringToType@CResource@@SAKPBD@Z ; CResource::StringToType
  00079	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Type@CEffectMesh@@SAKXZ@4HA
  0007e	a3 00 00 00 00	 mov	 DWORD PTR ?s_type@?1??Type@CEffectMesh@@SAKXZ@4KA, eax
  00083	e8 00 00 00 00	 call	 __Init_thread_footer
  00088	83 c4 08	 add	 esp, 8
  0008b	eb b1		 jmp	 SHORT $LN5@Type
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Type@CEffectMesh@@SAKXZ$0:
  00000	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Type@CEffectMesh@@SAKXZ@4HA
  00005	e8 00 00 00 00	 call	 __Init_thread_abort
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
__ehhandler$?Type@CEffectMesh@@SAKXZ:
  00011	90		 npad	 1
  00012	90		 npad	 1
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Type@CEffectMesh@@SAKXZ
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Type@CEffectMesh@@SAKXZ ENDP				; CEffectMesh::Type
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?DestroySystem@SEffectMeshData@CEffectMesh@@SAXXZ
_TEXT	SEGMENT
?DestroySystem@SEffectMeshData@CEffectMesh@@SAXXZ PROC	; CEffectMesh::SEffectMeshData::DestroySystem, COMDAT

; 23   : {

  00000	53		 push	 ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 269  :     const auto _ULast = _Get_unwrapped(_Last);

  00001	8b 1d 08 00 00
	00		 mov	 ebx, DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+8
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 23   : {

  00007	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 268  :     auto _UFirst      = _Get_unwrapped(_First);

  00008	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+4

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  0000e	3b fb		 cmp	 edi, ebx
  00010	0f 84 85 00 00
	00		 je	 $LN66@DestroySys
  00016	56		 push	 esi
$LL20@DestroySys:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 110  : 			delete pkData;

  00017	8b 37		 mov	 esi, DWORD PTR [edi]
  00019	85 f6		 test	 esi, esi
  0001b	74 70		 je	 SHORT $LN18@DestroySys
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  0001d	8b 86 ac 00 00
	00		 mov	 eax, DWORD PTR [esi+172]
  00023	85 c0		 test	 eax, eax
  00025	74 4d		 je	 SHORT $LN35@DestroySys

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00027	8b 8e b4 00 00
	00		 mov	 ecx, DWORD PTR [esi+180]
  0002d	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0002f	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00032	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00038	72 12		 jb	 SHORT $LN51@DestroySys

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0003a	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0003d	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00040	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00042	83 c0 fc	 add	 eax, -4			; fffffffcH
  00045	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00048	77 64		 ja	 SHORT $LN48@DestroySys

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0004a	8b c2		 mov	 eax, edx
$LN51@DestroySys:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0004c	51		 push	 ecx
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  00053	c7 86 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+172], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  0005d	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  00060	c7 86 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+176], 0

; 1769 :             _Myend   = nullptr;

  0006a	c7 86 b4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+180], 0
$LN35@DestroySys:
  00074	8d 8e a0 00 00
	00		 lea	 ecx, DWORD PTR [esi+160]
  0007a	e8 00 00 00 00	 call	 ??1?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@QAE@XZ ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::~vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >
  0007f	68 b8 00 00 00	 push	 184			; 000000b8H
  00084	56		 push	 esi
  00085	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0008a	83 c4 08	 add	 esp, 8
$LN18@DestroySys:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  0008d	83 c7 04	 add	 edi, 4
  00090	3b fb		 cmp	 edi, ebx
  00092	75 83		 jne	 SHORT $LL20@DestroySys
  00094	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+4
  0009a	5e		 pop	 esi
$LN66@DestroySys:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 52   : 			m_kVct_pkFree.clear();

  0009b	a1 10 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+16
  000a0	89 3d 08 00 00
	00		 mov	 DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+8, edi
  000a6	5f		 pop	 edi
  000a7	a3 14 00 00 00	 mov	 DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+20, eax
  000ac	5b		 pop	 ebx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 25   : }

  000ad	c3		 ret	 0
$LN48@DestroySys:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000ae	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN68@DestroySys:
  000b3	cc		 int	 3
?DestroySystem@SEffectMeshData@CEffectMesh@@SAXXZ ENDP	; CEffectMesh::SEffectMeshData::DestroySystem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?Delete@SEffectMeshData@CEffectMesh@@SAXPAU12@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
_pkData$ = 8						; size = 4
?Delete@SEffectMeshData@CEffectMesh@@SAXPAU12@@Z PROC	; CEffectMesh::SEffectMeshData::Delete, COMDAT

; 15   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1450 :         auto& _My_data    = _Mypair._Myval2;

  00006	8b 7d 08	 mov	 edi, DWORD PTR _pkData$[ebp]

; 1451 :         pointer& _Myfirst = _My_data._Myfirst;
; 1452 :         pointer& _Mylast  = _My_data._Mylast;
; 1453 : 
; 1454 :         _My_data._Orphan_all();
; 1455 :         _Destroy(_Myfirst, _Mylast);

  00009	8b 9f a4 00 00
	00		 mov	 ebx, DWORD PTR [edi+164]
  0000f	8b b7 a0 00 00
	00		 mov	 esi, DWORD PTR [edi+160]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 949  :         for (; _First != _Last; ++_First) {

  00015	3b f3		 cmp	 esi, ebx
  00017	74 1c		 je	 SHORT $LN9@Delete
  00019	0f 1f 80 00 00
	00 00		 npad	 7
$LL10@Delete:
  00020	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  00023	e8 00 00 00 00	 call	 ??1?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@QAE@XZ ; std::vector<SPTVertex,std::allocator<SPTVertex> >::~vector<SPTVertex,std::allocator<SPTVertex> >
  00028	83 c6 20	 add	 esi, 32			; 00000020H
  0002b	3b f3		 cmp	 esi, ebx
  0002d	75 f1		 jne	 SHORT $LL10@Delete
  0002f	8b b7 a0 00 00
	00		 mov	 esi, DWORD PTR [edi+160]
$LN9@Delete:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1456 :         _Mylast = _Myfirst;

  00035	89 b7 a4 00 00
	00		 mov	 DWORD PTR [edi+164], esi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 17   : 	pkData->pImageVector.clear();

  0003b	8b 87 ac 00 00
	00		 mov	 eax, DWORD PTR [edi+172]
  00041	89 87 b0 00 00
	00		 mov	 DWORD PTR [edi+176], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  00047	a1 14 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+20
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 19   : 	ms_kPool.Free(pkData);

  0004c	89 7d 08	 mov	 DWORD PTR _pkData$[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  0004f	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+24
  00055	74 0e		 je	 SHORT $LN25@Delete

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00057	89 38		 mov	 DWORD PTR [eax], edi

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

  00059	83 05 14 00 00
	00 04		 add	 DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+20, 4
  00060	5f		 pop	 edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 20   : }

  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
$LN25@Delete:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00065	8d 4d 08	 lea	 ecx, DWORD PTR _pkData$[ebp]
  00068	51		 push	 ecx
  00069	50		 push	 eax
  0006a	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+16
  0006f	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAUSEffectMeshData@CEffectMesh@@@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@QAEPAPAUSEffectMeshData@CEffectMesh@@QAPAU23@ABQAU23@@Z ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Emplace_reallocate<CEffectMesh::SEffectMeshData * const &>
  00074	5f		 pop	 edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 20   : }

  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
?Delete@SEffectMeshData@CEffectMesh@@SAXPAU12@@Z ENDP	; CEffectMesh::SEffectMeshData::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?New@SEffectMeshData@CEffectMesh@@SAPAU12@XZ
_TEXT	SEGMENT
_pkNewData$1 = -4					; size = 4
?New@SEffectMeshData@CEffectMesh@@SAPAU12@XZ PROC	; CEffectMesh::SEffectMeshData::New, COMDAT

; 10   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

  00004	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+20
  0000a	39 0d 10 00 00
	00		 cmp	 DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+16, ecx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  00010	0f 85 96 00 00
	00		 jne	 $LN4@New

; 65   : 				T* pkNewData=new T;

  00016	56		 push	 esi
  00017	68 b8 00 00 00	 push	 184			; 000000b8H
  0001c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00021	8b f0		 mov	 esi, eax
  00023	83 c4 04	 add	 esp, 4
  00026	85 f6		 test	 esi, esi
  00028	74 3e		 je	 SHORT $LN6@New
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0002a	c7 86 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+160], 0
  00034	c7 86 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+164], 0
  0003e	c7 86 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+168], 0
  00048	c7 86 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+172], 0
  00052	c7 86 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+176], 0
  0005c	c7 86 b4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+180], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 65   : 				T* pkNewData=new T;

  00066	eb 02		 jmp	 SHORT $LN7@New
$LN6@New:
  00068	33 f6		 xor	 esi, esi
$LN7@New:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  0006a	a1 08 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+8
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  0006f	89 75 fc	 mov	 DWORD PTR _pkNewData$1[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  00072	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+12
  00078	74 16		 je	 SHORT $LN28@New

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0007a	89 30		 mov	 DWORD PTR [eax], esi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 11   : 	return ms_kPool.Alloc();

  0007c	8b c6		 mov	 eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 729  :         ++_Mylast;

  0007e	83 05 08 00 00
	00 04		 add	 DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+8, 4
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 67   : 				++m_uUsedCapacity;

  00085	ff 05 20 00 00
	00		 inc	 DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+32
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 11   : 	return ms_kPool.Alloc();

  0008b	5e		 pop	 esi

; 12   : }

  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
$LN28@New:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00090	8d 4d fc	 lea	 ecx, DWORD PTR _pkNewData$1[ebp]
  00093	51		 push	 ecx
  00094	50		 push	 eax
  00095	b9 04 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+4
  0009a	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAUSEffectMeshData@CEffectMesh@@@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@QAEPAPAUSEffectMeshData@CEffectMesh@@QAPAU23@ABQAU23@@Z ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Emplace_reallocate<CEffectMesh::SEffectMeshData * const &>
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 67   : 				++m_uUsedCapacity;

  0009f	ff 05 20 00 00
	00		 inc	 DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+32
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 11   : 	return ms_kPool.Alloc();

  000a5	8b c6		 mov	 eax, esi
  000a7	5e		 pop	 esi

; 12   : }

  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
$LN4@New:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  000ac	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1624 :         return _My_data._Mylast[-1];

  000af	83 c1 fc	 add	 ecx, -4			; fffffffcH

; 1403 :         --_Mylast;

  000b2	89 0d 14 00 00
	00		 mov	 DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+20, ecx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EffectLib\EffectMesh.cpp

; 12   : }

  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c3		 ret	 0
?New@SEffectMeshData@CEffectMesh@@SAPAU12@XZ ENDP	; CEffectMesh::SEffectMeshData::New
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@CAXXZ PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Xlength, COMDAT

; 1774 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@CAXXZ ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@CAXXZ PROC ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::_Xlength, COMDAT

; 1774 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@CAXXZ ENDP ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Ufill@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@AAEPAUSEffectFrameData@CEffectMesh@@PAU34@IU_Value_init_tag@2@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 1
?_Ufill@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@AAEPAUSEffectFrameData@CEffectMesh@@PAU34@IU_Value_init_tag@2@@Z PROC ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::_Ufill, COMDAT
; _this$ = ecx

; 1646 :     _CONSTEXPR20_CONTAINER pointer _Ufill(pointer _Dest, const size_type _Count, _Value_init_tag) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1647 :         // fill raw _Dest with _Count value-initialized objects, using allocator
; 1648 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00006	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]

; 1830 :     for (; 0 < _Count; --_Count) {

  00009	85 d2		 test	 edx, edx
  0000b	74 2d		 je	 SHORT $LN5@Ufill

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  0000d	8d 48 1c	 lea	 ecx, DWORD PTR [eax+28]
$LL6@Ufill:
  00010	0f 57 c0	 xorps	 xmm0, xmm0

; 1632 :         ++_Last;

  00013	8d 49 20	 lea	 ecx, DWORD PTR [ecx+32]

; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

  00016	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  00019	0f 11 40 10	 movups	 XMMWORD PTR [eax+16], xmm0

; 1632 :         ++_Last;

  0001d	83 c0 20	 add	 eax, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00020	c7 41 d8 00 00
	00 00		 mov	 DWORD PTR [ecx-40], 0
  00027	c7 41 dc 00 00
	00 00		 mov	 DWORD PTR [ecx-36], 0
  0002e	c7 41 e0 00 00
	00 00		 mov	 DWORD PTR [ecx-32], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1830 :     for (; 0 < _Count; --_Count) {

  00035	83 ea 01	 sub	 edx, 1
  00038	75 d6		 jne	 SHORT $LL6@Ufill
$LN5@Ufill:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     }

  0003a	5d		 pop	 ebp
  0003b	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@AAEPAUSEffectFrameData@CEffectMesh@@PAU34@IU_Value_init_tag@2@@Z ENDP ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@QAE@XZ PROC ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::~vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >, COMDAT
; _this$ = ecx

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00004	8b 37		 mov	 esi, DWORD PTR [edi]
  00006	85 f6		 test	 esi, esi
  00008	74 59		 je	 SHORT $LN4@vector

; 1764 :             _Destroy(_Myfirst, _Mylast);

  0000a	53		 push	 ebx
  0000b	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 949  :         for (; _First != _Last; ++_First) {

  0000e	3b f3		 cmp	 esi, ebx
  00010	74 11		 je	 SHORT $LN10@vector
$LL11@vector:
  00012	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  00015	e8 00 00 00 00	 call	 ??1?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@QAE@XZ ; std::vector<SPTVertex,std::allocator<SPTVertex> >::~vector<SPTVertex,std::allocator<SPTVertex> >
  0001a	83 c6 20	 add	 esi, 32			; 00000020H
  0001d	3b f3		 cmp	 esi, ebx
  0001f	75 f1		 jne	 SHORT $LL11@vector
  00021	8b 37		 mov	 esi, DWORD PTR [edi]
$LN10@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00023	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00026	2b c6		 sub	 eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00028	83 e0 e0	 and	 eax, -32		; ffffffe0H
  0002b	5b		 pop	 ebx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0002c	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00031	72 12		 jb	 SHORT $LN35@vector

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00033	8b 4e fc	 mov	 ecx, DWORD PTR [esi-4]
  00036	83 c0 23	 add	 eax, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00039	2b f1		 sub	 esi, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003b	83 c6 fc	 add	 esi, -4			; fffffffcH
  0003e	83 fe 1f	 cmp	 esi, 31			; 0000001fH
  00041	77 23		 ja	 SHORT $LN32@vector

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00043	8b f1		 mov	 esi, ecx
$LN35@vector:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00045	50		 push	 eax
  00046	56		 push	 esi
  00047	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  0004c	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00052	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  00055	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1769 :             _Myend   = nullptr;

  0005c	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
$LN4@vector:
  00063	5f		 pop	 edi

; 717  :     }

  00064	5e		 pop	 esi
  00065	c3		 ret	 0
$LN32@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00066	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN44@vector:
  0006b	cc		 int	 3
??1?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@QAE@XZ ENDP ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::~vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@CAXXZ PROC ; std::vector<SPTVertex,std::allocator<SPTVertex> >::_Xlength, COMDAT

; 1774 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@CAXXZ ENDP ; std::vector<SPTVertex,std::allocator<SPTVertex> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@QAE@XZ PROC ; std::vector<SPTVertex,std::allocator<SPTVertex> >::~vector<SPTVertex,std::allocator<SPTVertex> >, COMDAT
; _this$ = ecx

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00004	8b 37		 mov	 esi, DWORD PTR [edi]
  00006	85 f6		 test	 esi, esi
  00008	74 54		 je	 SHORT $LN4@vector

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0000a	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0000d	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00012	2b ce		 sub	 ecx, esi
  00014	f7 e9		 imul	 ecx
  00016	c1 fa 03	 sar	 edx, 3
  00019	8b c2		 mov	 eax, edx
  0001b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001e	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00020	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00023	c1 e1 02	 shl	 ecx, 2

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00026	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0002c	72 12		 jb	 SHORT $LN20@vector

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0002e	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  00031	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00034	2b f2		 sub	 esi, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00036	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  00039	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0003c	77 23		 ja	 SHORT $LN17@vector

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0003e	8b f2		 mov	 esi, edx
$LN20@vector:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00040	51		 push	 ecx
  00041	56		 push	 esi
  00042	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  00047	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  0004d	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  00050	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1769 :             _Myend   = nullptr;

  00057	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
$LN4@vector:
  0005e	5f		 pop	 edi

; 717  :     }

  0005f	5e		 pop	 esi
  00060	c3		 ret	 0
$LN17@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00061	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@vector:
  00066	cc		 int	 3
??1?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@QAE@XZ ENDP ; std::vector<SPTVertex,std::allocator<SPTVertex> >::~vector<SPTVertex,std::allocator<SPTVertex> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 134  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 135  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 137  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 85   :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 138  :         _Throw_bad_array_new_length(); // add overflow
; 139  :     }
; 140  : 
; 141  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 85   :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 145  : 
; 146  : #ifdef _DEBUG
; 147  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 148  : #endif // _DEBUG
; 149  :     return _Ptr;
; 150  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\TextFileLoader.h
;	COMDAT ??1CGotoChild@CTextFileLoader@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1CGotoChild@CTextFileLoader@@QAE@XZ PROC		; CTextFileLoader::CGotoChild::~CGotoChild, COMDAT
; _this$ = ecx

; 54   : 			{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CGotoChild@CTextFileLoader@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 55   : 				m_pOwner->SetParentNode();

  00022	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00024	e8 00 00 00 00	 call	 ?SetParentNode@CTextFileLoader@@QAEHXZ ; CTextFileLoader::SetParentNode

; 56   : 			}

  00029	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0002c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00033	59		 pop	 ecx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
  00038	cc		 int	 3
  00039	cc		 int	 3
  0003a	cc		 int	 3
  0003b	cc		 int	 3
  0003c	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CGotoChild@CTextFileLoader@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CGotoChild@CTextFileLoader@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CGotoChild@CTextFileLoader@@QAE@XZ ENDP		; CTextFileLoader::CGotoChild::~CGotoChild
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00004	8b 37		 mov	 esi, DWORD PTR [edi]
  00006	85 f6		 test	 esi, esi
  00008	0f 84 a5 00 00
	00		 je	 $LN4@vector

; 1764 :             _Destroy(_Myfirst, _Mylast);

  0000e	53		 push	 ebx
  0000f	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 949  :         for (; _First != _Last; ++_First) {

  00012	3b f3		 cmp	 esi, ebx
  00014	74 49		 je	 SHORT $LN10@vector
$LL11@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00016	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00019	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0001c	72 27		 jb	 SHORT $LN30@vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0001e	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00020	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00021	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00027	72 12		 jb	 SHORT $LN40@vector

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00029	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0002c	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0002f	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00031	83 c0 fc	 add	 eax, -4			; fffffffcH
  00034	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00037	77 7d		 ja	 SHORT $LN61@vector

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00039	8b c2		 mov	 eax, edx
$LN40@vector:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0003b	51		 push	 ecx
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00042	83 c4 08	 add	 esp, 8
$LN30@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  00045	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0004c	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00053	c6 06 00	 mov	 BYTE PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 949  :         for (; _First != _Last; ++_First) {

  00056	83 c6 18	 add	 esi, 24			; 00000018H
  00059	3b f3		 cmp	 esi, ebx
  0005b	75 b9		 jne	 SHORT $LL11@vector

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0005d	8b 37		 mov	 esi, DWORD PTR [edi]
$LN10@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0005f	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00062	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00067	2b ce		 sub	 ecx, esi
  00069	f7 e9		 imul	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0006b	5b		 pop	 ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0006c	c1 fa 02	 sar	 edx, 2
  0006f	8b c2		 mov	 eax, edx
  00071	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00074	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00076	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00079	c1 e0 03	 shl	 eax, 3

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0007c	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00081	72 12		 jb	 SHORT $LN64@vector

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00083	8b 4e fc	 mov	 ecx, DWORD PTR [esi-4]
  00086	83 c0 23	 add	 eax, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00089	2b f1		 sub	 esi, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0008b	83 c6 fc	 add	 esi, -4			; fffffffcH
  0008e	83 fe 1f	 cmp	 esi, 31			; 0000001fH
  00091	77 23		 ja	 SHORT $LN61@vector

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00093	8b f1		 mov	 esi, ecx
$LN64@vector:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00095	50		 push	 eax
  00096	56		 push	 esi
  00097	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  0009c	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  000a2	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  000a5	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1769 :             _Myend   = nullptr;

  000ac	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
$LN4@vector:
  000b3	5f		 pop	 edi

; 717  :     }

  000b4	5e		 pop	 esi
  000b5	c3		 ret	 0
$LN61@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000b6	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN72@vector:
  000bb	cc		 int	 3
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Old$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
$T1 = 12						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3244 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 3245 :         // assign [_Ptr, _Ptr + _Count)
; 3246 :         if (_Count <= _Mypair._Myval2._Myres) {

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	57		 push	 edi
  0000c	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0000f	89 4d fc	 mov	 DWORD PTR __Old$1$[ebp], ecx
  00012	3b d9		 cmp	 ebx, ecx
  00014	77 28		 ja	 SHORT $LN2@assign

; 2296 :         value_type* _Result = _Bx._Buf;

  00016	8b fe		 mov	 edi, esi

; 2319 :         return _BUF_SIZE <= _Myres;

  00018	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 2297 :         if (_Large_string_engaged()) {

  0001b	72 02		 jb	 SHORT $LN5@assign

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  0001d	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN5@assign:

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0001f	53		 push	 ebx
  00020	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 3247 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3248 :             _Mypair._Myval2._Mysize = _Count;

  00023	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00026	57		 push	 edi
  00027	e8 00 00 00 00	 call	 _memmove
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3249 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0002f	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 3259 :             },
; 3260 :             _Ptr);
; 3261 :     }

  00033	8b c6		 mov	 eax, esi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
$LN2@assign:

; 4508 :         if (_New_size > max_size()) {

  0003e	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  00044	0f 87 d4 00 00
	00		 ja	 $LN60@assign

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0004a	8b fb		 mov	 edi, ebx
  0004c	83 cf 0f	 or	 edi, 15			; 0000000fH
  0004f	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH

; 4489 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00055	76 15		 jbe	 SHORT $LN19@assign

; 4490 :             return _Max;

  00057	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0005c	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00067	83 c4 04	 add	 esp, 4
  0006a	eb 52		 jmp	 SHORT $LN58@assign
$LN19@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4493 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0006c	8b d1		 mov	 edx, ecx
  0006e	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00073	d1 ea		 shr	 edx, 1
  00075	2b c2		 sub	 eax, edx
  00077	3b c8		 cmp	 ecx, eax
  00079	76 15		 jbe	 SHORT $LN20@assign

; 4494 :             return _Max;

  0007b	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00080	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0008b	83 c4 04	 add	 esp, 4
  0008e	eb 2e		 jmp	 SHORT $LN58@assign
$LN20@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4497 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00090	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00093	3b f8		 cmp	 edi, eax
  00095	0f 42 f8	 cmovb	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4515 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00098	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0009b	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000a0	72 0b		 jb	 SHORT $LN27@assign

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a8	83 c4 04	 add	 esp, 4
  000ab	eb 11		 jmp	 SHORT $LN58@assign
$LN27@assign:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  000ad	85 c0		 test	 eax, eax
  000af	74 0b		 je	 SHORT $LN28@assign

; 85   :         return ::operator new(_Bytes);

  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000b7	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  000ba	eb 02		 jmp	 SHORT $LN58@assign
$LN28@assign:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000bc	33 c0		 xor	 eax, eax
$LN58@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000be	53		 push	 ebx
  000bf	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 4523 :         _Mypair._Myval2._Mysize = _New_size;

  000c2	89 45 0c	 mov	 DWORD PTR $T1[ebp], eax

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c5	50		 push	 eax

; 4523 :         _Mypair._Myval2._Mysize = _New_size;

  000c6	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 4524 :         _Mypair._Myval2._Myres  = _New_capacity;

  000c9	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000cc	e8 00 00 00 00	 call	 _memcpy

; 3258 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000d1	8b 7d 0c	 mov	 edi, DWORD PTR $T1[ebp]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4526 :         if (_BUF_SIZE <= _Old_capacity) {

  000d7	8b 45 fc	 mov	 eax, DWORD PTR __Old$1$[ebp]

; 3258 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000da	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 4526 :         if (_BUF_SIZE <= _Old_capacity) {

  000de	83 f8 10	 cmp	 eax, 16			; 00000010H
  000e1	72 29		 jb	 SHORT $LN13@assign

; 4527 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  000e3	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e6	8b 06		 mov	 eax, DWORD PTR [esi]

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000e8	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000ee	72 12		 jb	 SHORT $LN50@assign

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f0	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000f3	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000f6	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000f8	83 c0 fc	 add	 eax, -4			; fffffffcH
  000fb	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000fe	77 19		 ja	 SHORT $LN47@assign

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00100	8b c2		 mov	 eax, edx
$LN50@assign:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00102	51		 push	 ecx
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00109	83 c4 08	 add	 esp, 8
$LN13@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3254 :         return _Reallocate_for(

  0010c	89 3e		 mov	 DWORD PTR [esi], edi

; 3259 :             },
; 3260 :             _Ptr);
; 3261 :     }

  0010e	8b c6		 mov	 eax, esi
  00110	5f		 pop	 edi
  00111	5e		 pop	 esi
  00112	5b		 pop	 ebx
  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c2 08 00	 ret	 8
$LN47@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00119	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN60@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4509 :             _Xlen_string(); // result too long

  0011e	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN56@assign:
  00123	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
tv533 = -12						; size = 4
__Old$1$ = -8						; size = 4
tv534 = -4						; size = 4
__Old_size$1$ = -4					; size = 4
__Ptr$ = 8						; size = 4
tv537 = 12						; size = 4
$T1 = 12						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 3152 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 3153 :         // append [_Ptr, _Ptr + _Count)
; 3154 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3155 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  00011	8b c2		 mov	 eax, edx
  00013	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00016	2b c1		 sub	 eax, ecx
  00018	89 4d fc	 mov	 DWORD PTR __Old_size$1$[ebp], ecx
  0001b	89 55 f8	 mov	 DWORD PTR __Old$1$[ebp], edx
  0001e	3b d8		 cmp	 ebx, eax
  00020	77 2e		 ja	 SHORT $LN2@append

; 3156 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00022	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00025	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 2296 :         value_type* _Result = _Bx._Buf;

  00028	8b c7		 mov	 eax, edi

; 2319 :         return _BUF_SIZE <= _Myres;

  0002a	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2297 :         if (_Large_string_engaged()) {

  0002d	72 02		 jb	 SHORT $LN5@append

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  0002f	8b 07		 mov	 eax, DWORD PTR [edi]
$LN5@append:

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00031	53		 push	 ebx
  00032	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 3157 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3158 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00035	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00038	56		 push	 esi
  00039	e8 00 00 00 00	 call	 _memmove
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3159 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00041	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0

; 3172 :     }

  00045	8b c7		 mov	 eax, edi
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8
$LN2@append:

; 4543 :         if (max_size() - _Old_size < _Size_increase) {

  00050	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00055	2b c1		 sub	 eax, ecx
  00057	3b c3		 cmp	 eax, ebx
  00059	0f 82 26 01 00
	00		 jb	 $LN68@append

; 4545 :         }
; 4546 : 
; 4547 :         const size_type _New_size     = _Old_size + _Size_increase;

  0005f	8d 34 19	 lea	 esi, DWORD PTR [ecx+ebx]

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00062	83 ce 0f	 or	 esi, 15			; 0000000fH
  00065	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 4489 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0006b	76 18		 jbe	 SHORT $LN19@append

; 4490 :             return _Max;

  0006d	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00072	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  00080	83 c4 04	 add	 esp, 4
  00083	eb 61		 jmp	 SHORT $LN66@append
$LN19@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4493 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00085	8b c2		 mov	 eax, edx
  00087	d1 e8		 shr	 eax, 1
  00089	89 45 0c	 mov	 DWORD PTR tv537[ebp], eax
  0008c	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00091	2b 45 0c	 sub	 eax, DWORD PTR tv537[ebp]
  00094	3b d0		 cmp	 edx, eax
  00096	76 18		 jbe	 SHORT $LN20@append

; 4494 :             return _Max;

  00098	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0009d	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  000ab	83 c4 04	 add	 esp, 4
  000ae	eb 36		 jmp	 SHORT $LN66@append
$LN20@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4497 :         return (_STD max)(_Masked, _Old + _Old / 2);

  000b0	8b 45 0c	 mov	 eax, DWORD PTR tv537[ebp]
  000b3	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  000b5	3b f0		 cmp	 esi, eax
  000b7	0f 42 f0	 cmovb	 esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4551 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  000ba	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000bd	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000c2	72 0e		 jb	 SHORT $LN27@append

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000ca	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  000cd	83 c4 04	 add	 esp, 4
  000d0	eb 14		 jmp	 SHORT $LN66@append
$LN27@append:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  000d2	85 c0		 test	 eax, eax
  000d4	74 0e		 je	 SHORT $LN28@append

; 85   :         return ::operator new(_Bytes);

  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 244  :         return _Traits::_Allocate(_Bytes);

  000dc	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]

; 85   :         return ::operator new(_Bytes);

  000df	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  000e2	eb 02		 jmp	 SHORT $LN66@append
$LN28@append:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000e4	33 c0		 xor	 eax, eax
$LN66@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4562 :         if (_BUF_SIZE <= _Old_capacity) {

  000e6	83 7d f8 10	 cmp	 DWORD PTR __Old$1$[ebp], 16 ; 00000010H
  000ea	8d 14 19	 lea	 edx, DWORD PTR [ecx+ebx]
  000ed	89 77 14	 mov	 DWORD PTR [edi+20], esi
  000f0	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  000f3	89 57 10	 mov	 DWORD PTR [edi+16], edx
  000f6	8d 14 1e	 lea	 edx, DWORD PTR [esi+ebx]
  000f9	89 45 0c	 mov	 DWORD PTR $T1[ebp], eax
  000fc	89 75 fc	 mov	 DWORD PTR tv534[ebp], esi
  000ff	89 55 f4	 mov	 DWORD PTR tv533[ebp], edx
  00102	51		 push	 ecx
  00103	72 56		 jb	 SHORT $LN13@append

; 4563 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  00105	8b 37		 mov	 esi, DWORD PTR [edi]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00107	56		 push	 esi
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 _memcpy
  0010e	53		 push	 ebx
  0010f	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00112	ff 75 fc	 push	 DWORD PTR tv534[ebp]
  00115	e8 00 00 00 00	 call	 _memcpy

; 3169 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0011a	8b 45 f4	 mov	 eax, DWORD PTR tv533[ebp]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0011d	83 c4 18	 add	 esp, 24			; 00000018H

; 4565 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  00120	8b 4d f8	 mov	 ecx, DWORD PTR __Old$1$[ebp]
  00123	41		 inc	 ecx

; 3169 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00124	c6 00 00	 mov	 BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00127	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0012d	72 12		 jb	 SHORT $LN52@append

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0012f	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  00132	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00135	2b f2		 sub	 esi, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00137	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  0013a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0013d	77 4b		 ja	 SHORT $LN49@append

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0013f	8b f2		 mov	 esi, edx
$LN52@append:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00141	51		 push	 ecx
  00142	56		 push	 esi
  00143	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3163 :         return _Reallocate_grow_by(

  00148	8b 45 0c	 mov	 eax, DWORD PTR $T1[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  0014b	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3163 :         return _Reallocate_grow_by(

  0014e	89 07		 mov	 DWORD PTR [edi], eax

; 3172 :     }

  00150	8b c7		 mov	 eax, edi
  00152	5f		 pop	 edi
  00153	5e		 pop	 esi
  00154	5b		 pop	 ebx
  00155	8b e5		 mov	 esp, ebp
  00157	5d		 pop	 ebp
  00158	c2 08 00	 ret	 8
$LN13@append:

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0015b	57		 push	 edi
  0015c	50		 push	 eax
  0015d	e8 00 00 00 00	 call	 _memcpy
  00162	53		 push	 ebx
  00163	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00166	56		 push	 esi
  00167	e8 00 00 00 00	 call	 _memcpy

; 3169 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0016c	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0016f	83 c4 18	 add	 esp, 24			; 00000018H

; 3169 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00172	c6 00 00	 mov	 BYTE PTR [eax], 0

; 3163 :         return _Reallocate_grow_by(

  00175	8b 45 0c	 mov	 eax, DWORD PTR $T1[ebp]
  00178	89 07		 mov	 DWORD PTR [edi], eax

; 3172 :     }

  0017a	8b c7		 mov	 eax, edi
  0017c	5f		 pop	 edi
  0017d	5e		 pop	 esi
  0017e	5b		 pop	 ebx
  0017f	8b e5		 mov	 esp, ebp
  00181	5d		 pop	 ebp
  00182	c2 08 00	 ret	 8
$LN68@append:

; 4544 :             _Xlen_string(); // result too long

  00185	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN49@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0018a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN64@append:
  0018f	cc		 int	 3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 3002 :     _CONSTEXPR20_CONTAINER ~basic_string() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2319 :         return _BUF_SIZE <= _Myres;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 27		 jb	 SHORT $LN12@basic_stri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0000d	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN22@basic_stri

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN19@basic_stri

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN22@basic_stri:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN12@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi

; 3010 :     }

  00044	c3		 ret	 0
$LN19@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN27@basic_stri:
  0004a	cc		 int	 3
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2374 :     _Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlen_strin:
  0000a	cc		 int	 3
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN12@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 142  :     }

  00003	8b c1		 mov	 eax, ecx

; 65   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 66   :     {
; 67   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 141  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN6@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 96   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 91   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 74   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 16		 je	 SHORT $LN6@vector
  0000b	53		 push	 ebx
  0000c	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000f	57		 push	 edi
  00010	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00013	8b cf		 mov	 ecx, edi
  00015	ff d3		 call	 ebx
  00017	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  0001a	83 ee 01	 sub	 esi, 1
  0001d	75 f4		 jne	 SHORT $LL2@vector
  0001f	5f		 pop	 edi
  00020	5b		 pop	 ebx
$LN6@vector:
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
