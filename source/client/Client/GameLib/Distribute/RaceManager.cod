; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30137.0 

	TITLE	C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\Distribute\RaceManager.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`vftable'
PUBLIC	??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`scalar deleting destructor'
PUBLIC	??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`vftable'
PUBLIC	??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`scalar deleting destructor'
PUBLIC	??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`vftable'
PUBLIC	??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`scalar deleting destructor'
PUBLIC	??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`vftable'
PUBLIC	??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`scalar deleting destructor'
PUBLIC	??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`vftable'
PUBLIC	??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`scalar deleting destructor'
PUBLIC	??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`vftable'
PUBLIC	??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`scalar deleting destructor'
PUBLIC	??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`vftable'
PUBLIC	??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`scalar deleting destructor'
PUBLIC	??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`vftable'
PUBLIC	??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`scalar deleting destructor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_E?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`vector deleting destructor'
;	COMDAT ??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDe'
	DB	'corator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDec'
	DB	'orator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpd'
	DB	'ateDecorator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@N'
	DB	'EffectUpdateDecorator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEff'
	DB	'ectUpdateDecorator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffe'
	DB	'ctUpdateDecorator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecora'
	DB	'tor@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDeco'
	DB	'rator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	___local_stdio_scanf_options
PUBLIC	__snprintf
PUBLIC	_sscanf
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
PUBLIC	?_Throw_tree_length_error@std@@YAXXZ		; std::_Throw_tree_length_error
PUBLIC	?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
PUBLIC	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
PUBLIC	?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
PUBLIC	?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array
PUBLIC	?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Insert_node
PUBLIC	??1?$CSingleton@VCRaceManager@@@@UAE@XZ		; CSingleton<CRaceManager>::~CSingleton<CRaceManager>
PUBLIC	??_G?$CSingleton@VCRaceManager@@@@UAEPAXI@Z	; CSingleton<CRaceManager>::`scalar deleting destructor'
PUBLIC	??1?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CRaceData *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRaceData *> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,CRaceData *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRaceData *> >,0> >
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCRaceData@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CRaceData *> > >::_Insert_node
PUBLIC	??1?$map@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@@std@@QAE@XZ ; std::map<unsigned long,CRaceData *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRaceData *> > >::~map<unsigned long,CRaceData *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRaceData *> > >
PUBLIC	??0CRaceManager@@QAE@XZ				; CRaceManager::CRaceManager
PUBLIC	??1CRaceManager@@UAE@XZ				; CRaceManager::~CRaceManager
PUBLIC	?Create@CRaceManager@@QAEXXZ			; CRaceManager::Create
PUBLIC	?Destroy@CRaceManager@@QAEXXZ			; CRaceManager::Destroy
PUBLIC	?RegisterRaceName@CRaceManager@@QAEXKPBD@Z	; CRaceManager::RegisterRaceName
PUBLIC	?RegisterRaceSrcName@CRaceManager@@QAEXPBD0@Z	; CRaceManager::RegisterRaceSrcName
PUBLIC	?SetPathName@CRaceManager@@QAEXPBD@Z		; CRaceManager::SetPathName
PUBLIC	?GetFullPathFileName@CRaceManager@@QAEPBDPBD@Z	; CRaceManager::GetFullPathFileName
PUBLIC	?CreateRace@CRaceManager@@QAEXK@Z		; CRaceManager::CreateRace
PUBLIC	?SelectRace@CRaceManager@@QAEXK@Z		; CRaceManager::SelectRace
PUBLIC	?GetSelectedRaceDataPointer@CRaceManager@@QAEPAVCRaceData@@XZ ; CRaceManager::GetSelectedRaceDataPointer
PUBLIC	?GetRaceDataPointer@CRaceManager@@QAEHKPAPAVCRaceData@@@Z ; CRaceManager::GetRaceDataPointer
PUBLIC	?__LoadRaceData@CRaceManager@@IAEPAVCRaceData@@K@Z ; CRaceManager::__LoadRaceData
PUBLIC	?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z ; CRaceManager::__LoadRaceMotionList
PUBLIC	?__Initialize@CRaceManager@@IAEXXZ		; CRaceManager::__Initialize
PUBLIC	?__DestroyRaceDataMap@CRaceManager@@IAEXXZ	; CRaceManager::__DestroyRaceDataMap
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Insert_node
PUBLIC	??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??_GCRaceManager@@UAEPAXI@Z			; CRaceManager::`scalar deleting destructor'
PUBLIC	?__IsGuildRace@@YA_NI@Z				; __IsGuildRace
PUBLIC	?__IsNPCRace@@YA_NI@Z				; __IsNPCRace
PUBLIC	?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; __GetRaceResourcePathes
PUBLIC	??$emplace_back@AAY0O@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?A_TAAY0O@$$CBD@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::emplace_back<char const (&)[14]>
PUBLIC	??$_Emplace_reallocate@AAY0O@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0O@$$CBD@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<char const (&)[14]>
PUBLIC	??$emplace_back@AAY0BC@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?A_TAAY0BC@$$CBD@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::emplace_back<char const (&)[18]>
PUBLIC	??$_Emplace_reallocate@AAY0BC@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0BC@$$CBD@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<char const (&)[18]>
PUBLIC	??1?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::find
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> > >::_Insert_node
PUBLIC	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>
PUBLIC	??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
PUBLIC	??$?0AAY0N@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0N@$$CBD$$QAW4EName@CRaceMotionData@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[13],enum CRaceMotionData::EName,0>
PUBLIC	??$?0AAY0O@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0O@$$CBD$$QAW4EName@CRaceMotionData@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[14],enum CRaceMotionData::EName,0>
PUBLIC	??$?0AAY0P@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0P@$$CBD$$QAW4EName@CRaceMotionData@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[15],enum CRaceMotionData::EName,0>
PUBLIC	??$?0AAY0L@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0L@$$CBD$$QAW4EName@CRaceMotionData@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[11],enum CRaceMotionData::EName,0>
PUBLIC	??$?0AAY0M@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0M@$$CBD$$QAW4EName@CRaceMotionData@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[12],enum CRaceMotionData::EName,0>
PUBLIC	??$?0AAY0BA@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0BA@$$CBD$$QAW4EName@CRaceMotionData@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[16],enum CRaceMotionData::EName,0>
PUBLIC	??$?0AAY09$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY09$$CBD$$QAW4EName@CRaceMotionData@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[10],enum CRaceMotionData::EName,0>
PUBLIC	??$?0AAY07$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY07$$CBD$$QAW4EName@CRaceMotionData@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[8],enum CRaceMotionData::EName,0>
PUBLIC	??$?0AAY08$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY08$$CBD$$QAW4EName@CRaceMotionData@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[9],enum CRaceMotionData::EName,0>
PUBLIC	??$?0AAY06$$CBDH$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY06$$CBD$$QAH@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[7],int,0>
PUBLIC	??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCRaceData@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBKPAVCRaceData@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CRaceData *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRaceData *> >,0> >::insert<0,0>
PUBLIC	??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
PUBLIC	?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete
PUBLIC	??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
PUBLIC	?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete
PUBLIC	??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
PUBLIC	?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete
PUBLIC	??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
PUBLIC	?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete
PUBLIC	??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
PUBLIC	?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete
PUBLIC	??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
PUBLIC	?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete
PUBLIC	??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
PUBLIC	?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete
PUBLIC	??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
PUBLIC	?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCRaceData@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CRaceData *> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CRaceData *>,void *> > >
PUBLIC	??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>,void *> > >
PUBLIC	??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
PUBLIC	??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@1@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CRaceData *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRaceData *> >,0> >::_Find_lower_bound<unsigned long>
PUBLIC	??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find_lower_bound<unsigned long>
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
PUBLIC	??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>,void *> > >
PUBLIC	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>,void *> > >
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
PUBLIC	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CRaceData *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CRaceData *>,void *> > >
PUBLIC	??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_0BB@GCADKGJO@map?1set?5too?5long@		; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_singleton@?$CSingleton@VCRaceManager@@@@0PAVCRaceManager@@A ; CSingleton<CRaceManager>::ms_singleton
PUBLIC	??_7?$CSingleton@VCRaceManager@@@@6B@		; CSingleton<CRaceManager>::`vftable'
PUBLIC	??_7CRaceManager@@6B@				; CRaceManager::`vftable'
PUBLIC	?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
PUBLIC	?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
PUBLIC	??_C@_0BE@PJNPAGEJ@d?3?1ymir?5work?1guild?1@	; `string'
PUBLIC	??_C@_0BC@HJMPPIOH@d?3?1ymir?5work?1npc?1@	; `string'
PUBLIC	??_C@_0BD@DIPFLAGN@d?3?1ymir?5work?1npc2?1@	; `string'
PUBLIC	??_C@_0BG@CKCIELCO@d?3?1ymir?5work?1npc_pet?1@	; `string'
PUBLIC	??_C@_0BG@FGIKCKJD@d?3?1ymir?5work?1monster?1@	; `string'
PUBLIC	??_C@_0BH@GPLCEAJK@d?3?1ymir?5work?1monster2?1@	; `string'
PUBLIC	??_C@_0BI@BCLHILHN@d?3?1ymir?5work?1npc_mount?1@ ; `string'
PUBLIC	??_C@_0O@PEPGGFH@?$CDseason1?1npc?1@		; `string'
PUBLIC	??_C@_0O@DOKHHMMK@?$CDseason2?1npc?1@		; `string'
PUBLIC	??_C@_0BC@DOJALNLB@?$CDseason1?1monster?1@	; `string'
PUBLIC	??_C@_0BC@KHHCNLLA@?$CDseason2?1monster?1@	; `string'
PUBLIC	??_C@_0M@PECPBC@?$CFsshape?4msm@		; `string'
PUBLIC	??_C@_0O@FJBDMFMI@?$CFsmotlist?4txt@		; `string'
PUBLIC	??_C@_0DJ@FBAOJDFF@CRaceManager?3?3RegisterRacePath?$CI@ ; `string'
PUBLIC	??_C@_01KMDKNFGN@?1@				; `string'
PUBLIC	??_C@_09HPPJBJBB@shape?4msm@			; `string'
PUBLIC	??_C@_04IIEHFLK@?4msm@				; `string'
PUBLIC	??_C@_0FK@NGFDIHNH@CRaceManager?3?3RegisterRacePath?5@ ; `string'
PUBLIC	??_C@_0EB@IDBEOJF@CRaceManager?3?3RegisterRacePath?5@ ; `string'
PUBLIC	??_C@_0DN@CNIFOKKO@CRaceManager?3?3RegisterRacePath?5@ ; `string'
PUBLIC	??_C@_05NIJFIOCI@SPAWN@				; `string'
PUBLIC	??_C@_05HBNBIBID@WAIT1@				; `string'
PUBLIC	??_C@_05FKPMNCEA@WAIT2@				; `string'
PUBLIC	??_C@_04PKELMGAL@WALK@				; `string'
PUBLIC	??_C@_05FBHFJFPM@WALK1@				; `string'
PUBLIC	??_C@_05HKFIMGDP@WALK2@				; `string'
PUBLIC	??_C@_03LLDCGJBK@RUN@				; `string'
PUBLIC	??_C@_04DLIEMMKB@RUN1@				; `string'
PUBLIC	??_C@_04BAKJJPGC@RUN2@				; `string'
PUBLIC	??_C@_04MDHMLCKF@STOP@				; `string'
PUBLIC	??_C@_04NNCJDDJC@DEAD@				; `string'
PUBLIC	??_C@_0N@ECIMAFHI@COMBO_ATTACK@			; `string'
PUBLIC	??_C@_0O@JIMBHCLJ@COMBO_ATTACK1@		; `string'
PUBLIC	??_C@_0O@LDOMCBHK@COMBO_ATTACK2@		; `string'
PUBLIC	??_C@_0O@MMNGEKGD@NORMAL_ATTACK@		; `string'
PUBLIC	??_C@_0P@BCCKOBBK@NORMAL_ATTACK1@		; `string'
PUBLIC	??_C@_0P@DJAHLCNJ@NORMAL_ATTACK2@		; `string'
PUBLIC	??_C@_0N@FEIIBDLE@FRONT_DAMAGE@			; `string'
PUBLIC	??_C@_0O@KAFPIDE@FRONT_DAMAGE1@			; `string'
PUBLIC	??_C@_0O@CBCIKLPH@FRONT_DAMAGE2@		; `string'
PUBLIC	??_C@_0O@DIDDJKLG@FRONT_DAMAGE3@		; `string'
PUBLIC	??_C@_0L@OEOOJLDF@FRONT_DEAD@			; `string'
PUBLIC	??_C@_0M@JAAKCNAK@FRONT_DEAD1@			; `string'
PUBLIC	??_C@_0M@LLCHHOMJ@FRONT_DEAD2@			; `string'
PUBLIC	??_C@_0BA@DFAPGFAO@FRONT_KNOCKDOWN@		; `string'
PUBLIC	??_C@_0BB@CBNACFNA@FRONT_KNOCKDOWN1@		; `string'
PUBLIC	??_C@_0O@MOHKHCLN@FRONT_STANDUP@		; `string'
PUBLIC	??_C@_0P@HDEDLCPB@FRONT_STANDUP1@		; `string'
PUBLIC	??_C@_0M@OFKIBNMF@BACK_DAMAGE@			; `string'
PUBLIC	??_C@_0N@CNLGJJJA@BACK_DAMAGE1@			; `string'
PUBLIC	??_C@_09LHOBDCIP@BACK_DEAD@			; `string'
PUBLIC	??_C@_0L@LLONHIDB@BACK_DEAD1@			; `string'
PUBLIC	??_C@_0L@JAMACLPC@BACK_DEAD2@			; `string'
PUBLIC	??_C@_0P@MFNBGKJO@BACK_KNOCKDOWN@		; `string'
PUBLIC	??_C@_0BA@NBCPGIJL@BACK_KNOCKDOWN1@		; `string'
PUBLIC	??_C@_0N@OJMJBDBJ@BACK_STANDUP@			; `string'
PUBLIC	??_C@_0O@KCNPGGGB@BACK_STANDUP1@		; `string'
PUBLIC	??_C@_07OJOPHEAL@SPECIAL@			; `string'
PUBLIC	??_C@_08FBGGDBEO@SPECIAL1@			; `string'
PUBLIC	??_C@_08HKELGCIN@SPECIAL2@			; `string'
PUBLIC	??_C@_08GDFAFDMM@SPECIAL3@			; `string'
PUBLIC	??_C@_08CMBBMFAL@SPECIAL4@			; `string'
PUBLIC	??_C@_08DFAKPEEK@SPECIAL5@			; `string'
PUBLIC	??_C@_06COMNIHKP@SKILL1@			; `string'
PUBLIC	??_C@_06FOANEGM@SKILL2@				; `string'
PUBLIC	??_C@_06BMPLOFCN@SKILL3@			; `string'
PUBLIC	??_C@_06FDLKHDOK@SKILL4@			; `string'
PUBLIC	??_C@_06EKKBECKL@SKILL5@			; `string'
PUBLIC	??_C@_0M@HPBHEBFF@?$CFs?5?$CFs?5?$CFs?5?$CFd@	; `string'
PUBLIC	??_C@_0DC@LBGILCOK@RaceManager?3?3CreateRace?5?3?5Race?5@ ; `string'
PUBLIC	??_C@_0CJ@LEJBEJHD@CRaceManager?3?3CreateRace?$CIdwRace@ ; `string'
PUBLIC	??_C@_0EG@LLEJKJIA@CRaceManager?3?3GetRaceDataPointe@ ; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4CRaceManager@@6B@				; CRaceManager::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCRaceManager@@@8			; CRaceManager `RTTI Type Descriptor'
PUBLIC	??_R3CRaceManager@@8				; CRaceManager::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CRaceManager@@8				; CRaceManager::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CRaceManager@@8			; CRaceManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$CSingleton@VCRaceManager@@@@8	; CSingleton<CRaceManager>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$CSingleton@VCRaceManager@@@@@8	; CSingleton<CRaceManager> `RTTI Type Descriptor'
PUBLIC	??_R3?$CSingleton@VCRaceManager@@@@8		; CSingleton<CRaceManager>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CSingleton@VCRaceManager@@@@8		; CSingleton<CRaceManager>::`RTTI Base Class Array'
PUBLIC	??_R4?$CSingleton@VCRaceManager@@@@6B@		; CSingleton<CRaceManager>::`RTTI Complete Object Locator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_abort:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	___stdio_common_vsscanf:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?Tracenf@@YAXPBDZZ:PROC				; Tracenf
EXTRN	?TraceError@@YAXPBDZZ:PROC			; TraceError
EXTRN	??0CMemoryTextFileLoader@@QAE@XZ:PROC		; CMemoryTextFileLoader::CMemoryTextFileLoader
EXTRN	??1CMemoryTextFileLoader@@UAE@XZ:PROC		; CMemoryTextFileLoader::~CMemoryTextFileLoader
EXTRN	?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z:PROC	; CMemoryTextFileLoader::Bind
EXTRN	?GetLineCount@CMemoryTextFileLoader@@QAEKXZ:PROC ; CMemoryTextFileLoader::GetLineCount
EXTRN	?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z:PROC ; CMemoryTextFileLoader::GetLineString
EXTRN	??0CMappedFile@@QAE@XZ:PROC			; CMappedFile::CMappedFile
EXTRN	??1CMappedFile@@UAE@XZ:PROC			; CMappedFile::~CMappedFile
EXTRN	?Size@CMappedFile@@QAEKXZ:PROC			; CMappedFile::Size
EXTRN	?New@CRaceData@@SAPAV1@XZ:PROC			; CRaceData::New
EXTRN	?Delete@CRaceData@@SAXPAV1@@Z:PROC		; CRaceData::Delete
EXTRN	?CreateSystem@CRaceData@@SAXII@Z:PROC		; CRaceData::CreateSystem
EXTRN	?GetMotionListFileName@CRaceData@@QBEPBDXZ:PROC	; CRaceData::GetMotionListFileName
EXTRN	?LoadRaceData@CRaceData@@QAEHPBD@Z:PROC		; CRaceData::LoadRaceData
EXTRN	?RegisterMotionData@CRaceData@@QAEPAVCGraphicThing@@GGPBDE@Z:PROC ; CRaceData::RegisterMotionData
EXTRN	?SetRace@CRaceData@@QAEXK@Z:PROC		; CRaceData::SetRace
EXTRN	?RegisterMotionMode@CRaceData@@QAEXG@Z:PROC	; CRaceData::RegisterMotionMode
EXTRN	?RegisterNormalAttack@CRaceData@@QAEXGG@Z:PROC	; CRaceData::RegisterNormalAttack
EXTRN	??_E?$CSingleton@VCRaceManager@@@@UAEPAXI@Z:PROC ; CSingleton<CRaceManager>::`vector deleting destructor'
EXTRN	??_ECRaceManager@@UAEPAXI@Z:PROC		; CRaceManager::`vector deleting destructor'
EXTRN	?CreateSystem@CRaceMotionData@@SAXI@Z:PROC	; CRaceMotionData::CreateSystem
EXTRN	?Get@CEterPackManager@@QAE_NAAVCMappedFile@@PBDPAPBX@Z:PROC ; CEterPackManager::Get
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCRaceManager@@@@0PAVCRaceManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCRaceManager@@@@0PAVCRaceManager@@A DD 01H DUP (?) ; CSingleton<CRaceManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A DD 01H DUP (?) ; CSingleton<CEterPackManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
_BSS	SEGMENT
?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A DQ 01H DUP (?) ; `CRaceManager::__LoadRaceMotionList'::`2'::s_kMap_stType_dwIndex
_BSS	ENDS
;	COMDAT ?$TSS0@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4HA DD 01H DUP (?) ; `CRaceManager::__LoadRaceMotionList'::`2'::$TSS0
_BSS	ENDS
;	COMDAT ?s_isInit@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4_NA
_BSS	SEGMENT
?s_isInit@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4_NA DB 01H DUP (?) ; `CRaceManager::__LoadRaceMotionList'::`2'::s_isInit
_BSS	ENDS
;	COMDAT ?$TSS1@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4HA
_BSS	SEGMENT
?$TSS1@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4HA DD 01H DUP (?) ; `CRaceManager::__LoadRaceMotionList'::`2'::$TSS1
_BSS	ENDS
;	COMDAT ?$TSS2@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4HA
_BSS	SEGMENT
?$TSS2@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4HA DD 01H DUP (?) ; `CRaceManager::__LoadRaceMotionList'::`2'::$TSS2
_BSS	ENDS
;	COMDAT ?$TSS0@?1??GetFullPathFileName@CRaceManager@@QAEPBDPBD@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??GetFullPathFileName@CRaceManager@@QAEPBDPBD@Z@4HA DD 01H DUP (?) ; `CRaceManager::GetFullPathFileName'::`2'::$TSS0
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT ??_R4?$CSingleton@VCRaceManager@@@@6B@
rdata$r	SEGMENT
??_R4?$CSingleton@VCRaceManager@@@@6B@ DD 00H		; CSingleton<CRaceManager>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CSingleton@VCRaceManager@@@@@8
	DD	FLAT:??_R3?$CSingleton@VCRaceManager@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CSingleton@VCRaceManager@@@@8
rdata$r	SEGMENT
??_R2?$CSingleton@VCRaceManager@@@@8 DD FLAT:??_R1A@?0A@EA@?$CSingleton@VCRaceManager@@@@8 ; CSingleton<CRaceManager>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CSingleton@VCRaceManager@@@@8
rdata$r	SEGMENT
??_R3?$CSingleton@VCRaceManager@@@@8 DD 00H		; CSingleton<CRaceManager>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CSingleton@VCRaceManager@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CSingleton@VCRaceManager@@@@@8
data$rs	SEGMENT
??_R0?AV?$CSingleton@VCRaceManager@@@@@8 DD FLAT:??_7type_info@@6B@ ; CSingleton<CRaceManager> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CSingleton@VCRaceManager@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CSingleton@VCRaceManager@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CSingleton@VCRaceManager@@@@8 DD FLAT:??_R0?AV?$CSingleton@VCRaceManager@@@@@8 ; CSingleton<CRaceManager>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CSingleton@VCRaceManager@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CRaceManager@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CRaceManager@@8 DD FLAT:??_R0?AVCRaceManager@@@8 ; CRaceManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CRaceManager@@8
rdata$r	ENDS
;	COMDAT ??_R2CRaceManager@@8
rdata$r	SEGMENT
??_R2CRaceManager@@8 DD FLAT:??_R1A@?0A@EA@CRaceManager@@8 ; CRaceManager::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$CSingleton@VCRaceManager@@@@8
rdata$r	ENDS
;	COMDAT ??_R3CRaceManager@@8
rdata$r	SEGMENT
??_R3CRaceManager@@8 DD 00H				; CRaceManager::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CRaceManager@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCRaceManager@@@8
data$rs	SEGMENT
??_R0?AVCRaceManager@@@8 DD FLAT:??_7type_info@@6B@	; CRaceManager `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCRaceManager@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CRaceManager@@6B@
rdata$r	SEGMENT
??_R4CRaceManager@@6B@ DD 00H				; CRaceManager::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCRaceManager@@@8
	DD	FLAT:??_R3CRaceManager@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ?s_stFileName@?1??GetFullPathFileName@CRaceManager@@QAEPBDPBD@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
_DATA	SEGMENT
?s_stFileName@?1??GetFullPathFileName@CRaceManager@@QAEPBDPBD@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 014H DUP (?)
	DD	0fH					; `CRaceManager::GetFullPathFileName'::`2'::s_stFileName
_DATA	ENDS
;	COMDAT ??_C@_0EG@LLEJKJIA@CRaceManager?3?3GetRaceDataPointe@
CONST	SEGMENT
??_C@_0EG@LLEJKJIA@CRaceManager?3?3GetRaceDataPointe@ DB 'CRaceManager::G'
	DB	'etRaceDataPointer: cannot load data by dwRaceIndex %lu', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@LEJBEJHD@CRaceManager?3?3CreateRace?$CIdwRace@
CONST	SEGMENT
??_C@_0CJ@LEJBEJHD@CRaceManager?3?3CreateRace?$CIdwRace@ DB 'CRaceManager'
	DB	'::CreateRace(dwRaceIndex=%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LBGILCOK@RaceManager?3?3CreateRace?5?3?5Race?5@
CONST	SEGMENT
??_C@_0DC@LBGILCOK@RaceManager?3?3CreateRace?5?3?5Race?5@ DB 'RaceManager'
	DB	'::CreateRace : Race %u already created', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HPBHEBFF@?$CFs?5?$CFs?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0M@HPBHEBFF@?$CFs?5?$CFs?5?$CFs?5?$CFd@ DB '%s %s %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06EKKBECKL@SKILL5@
CONST	SEGMENT
??_C@_06EKKBECKL@SKILL5@ DB 'SKILL5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FDLKHDOK@SKILL4@
CONST	SEGMENT
??_C@_06FDLKHDOK@SKILL4@ DB 'SKILL4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BMPLOFCN@SKILL3@
CONST	SEGMENT
??_C@_06BMPLOFCN@SKILL3@ DB 'SKILL3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FOANEGM@SKILL2@
CONST	SEGMENT
??_C@_06FOANEGM@SKILL2@ DB 'SKILL2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06COMNIHKP@SKILL1@
CONST	SEGMENT
??_C@_06COMNIHKP@SKILL1@ DB 'SKILL1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DFAKPEEK@SPECIAL5@
CONST	SEGMENT
??_C@_08DFAKPEEK@SPECIAL5@ DB 'SPECIAL5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CMBBMFAL@SPECIAL4@
CONST	SEGMENT
??_C@_08CMBBMFAL@SPECIAL4@ DB 'SPECIAL4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GDFAFDMM@SPECIAL3@
CONST	SEGMENT
??_C@_08GDFAFDMM@SPECIAL3@ DB 'SPECIAL3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HKELGCIN@SPECIAL2@
CONST	SEGMENT
??_C@_08HKELGCIN@SPECIAL2@ DB 'SPECIAL2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FBGGDBEO@SPECIAL1@
CONST	SEGMENT
??_C@_08FBGGDBEO@SPECIAL1@ DB 'SPECIAL1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07OJOPHEAL@SPECIAL@
CONST	SEGMENT
??_C@_07OJOPHEAL@SPECIAL@ DB 'SPECIAL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KCNPGGGB@BACK_STANDUP1@
CONST	SEGMENT
??_C@_0O@KCNPGGGB@BACK_STANDUP1@ DB 'BACK_STANDUP1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OJMJBDBJ@BACK_STANDUP@
CONST	SEGMENT
??_C@_0N@OJMJBDBJ@BACK_STANDUP@ DB 'BACK_STANDUP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NBCPGIJL@BACK_KNOCKDOWN1@
CONST	SEGMENT
??_C@_0BA@NBCPGIJL@BACK_KNOCKDOWN1@ DB 'BACK_KNOCKDOWN1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MFNBGKJO@BACK_KNOCKDOWN@
CONST	SEGMENT
??_C@_0P@MFNBGKJO@BACK_KNOCKDOWN@ DB 'BACK_KNOCKDOWN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JAMACLPC@BACK_DEAD2@
CONST	SEGMENT
??_C@_0L@JAMACLPC@BACK_DEAD2@ DB 'BACK_DEAD2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LLONHIDB@BACK_DEAD1@
CONST	SEGMENT
??_C@_0L@LLONHIDB@BACK_DEAD1@ DB 'BACK_DEAD1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LHOBDCIP@BACK_DEAD@
CONST	SEGMENT
??_C@_09LHOBDCIP@BACK_DEAD@ DB 'BACK_DEAD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CNLGJJJA@BACK_DAMAGE1@
CONST	SEGMENT
??_C@_0N@CNLGJJJA@BACK_DAMAGE1@ DB 'BACK_DAMAGE1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OFKIBNMF@BACK_DAMAGE@
CONST	SEGMENT
??_C@_0M@OFKIBNMF@BACK_DAMAGE@ DB 'BACK_DAMAGE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HDEDLCPB@FRONT_STANDUP1@
CONST	SEGMENT
??_C@_0P@HDEDLCPB@FRONT_STANDUP1@ DB 'FRONT_STANDUP1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MOHKHCLN@FRONT_STANDUP@
CONST	SEGMENT
??_C@_0O@MOHKHCLN@FRONT_STANDUP@ DB 'FRONT_STANDUP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CBNACFNA@FRONT_KNOCKDOWN1@
CONST	SEGMENT
??_C@_0BB@CBNACFNA@FRONT_KNOCKDOWN1@ DB 'FRONT_KNOCKDOWN1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DFAPGFAO@FRONT_KNOCKDOWN@
CONST	SEGMENT
??_C@_0BA@DFAPGFAO@FRONT_KNOCKDOWN@ DB 'FRONT_KNOCKDOWN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LLCHHOMJ@FRONT_DEAD2@
CONST	SEGMENT
??_C@_0M@LLCHHOMJ@FRONT_DEAD2@ DB 'FRONT_DEAD2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JAAKCNAK@FRONT_DEAD1@
CONST	SEGMENT
??_C@_0M@JAAKCNAK@FRONT_DEAD1@ DB 'FRONT_DEAD1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OEOOJLDF@FRONT_DEAD@
CONST	SEGMENT
??_C@_0L@OEOOJLDF@FRONT_DEAD@ DB 'FRONT_DEAD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DIDDJKLG@FRONT_DAMAGE3@
CONST	SEGMENT
??_C@_0O@DIDDJKLG@FRONT_DAMAGE3@ DB 'FRONT_DAMAGE3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CBCIKLPH@FRONT_DAMAGE2@
CONST	SEGMENT
??_C@_0O@CBCIKLPH@FRONT_DAMAGE2@ DB 'FRONT_DAMAGE2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KAFPIDE@FRONT_DAMAGE1@
CONST	SEGMENT
??_C@_0O@KAFPIDE@FRONT_DAMAGE1@ DB 'FRONT_DAMAGE1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FEIIBDLE@FRONT_DAMAGE@
CONST	SEGMENT
??_C@_0N@FEIIBDLE@FRONT_DAMAGE@ DB 'FRONT_DAMAGE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DJAHLCNJ@NORMAL_ATTACK2@
CONST	SEGMENT
??_C@_0P@DJAHLCNJ@NORMAL_ATTACK2@ DB 'NORMAL_ATTACK2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BCCKOBBK@NORMAL_ATTACK1@
CONST	SEGMENT
??_C@_0P@BCCKOBBK@NORMAL_ATTACK1@ DB 'NORMAL_ATTACK1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MMNGEKGD@NORMAL_ATTACK@
CONST	SEGMENT
??_C@_0O@MMNGEKGD@NORMAL_ATTACK@ DB 'NORMAL_ATTACK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LDOMCBHK@COMBO_ATTACK2@
CONST	SEGMENT
??_C@_0O@LDOMCBHK@COMBO_ATTACK2@ DB 'COMBO_ATTACK2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JIMBHCLJ@COMBO_ATTACK1@
CONST	SEGMENT
??_C@_0O@JIMBHCLJ@COMBO_ATTACK1@ DB 'COMBO_ATTACK1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ECIMAFHI@COMBO_ATTACK@
CONST	SEGMENT
??_C@_0N@ECIMAFHI@COMBO_ATTACK@ DB 'COMBO_ATTACK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04NNCJDDJC@DEAD@
CONST	SEGMENT
??_C@_04NNCJDDJC@DEAD@ DB 'DEAD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MDHMLCKF@STOP@
CONST	SEGMENT
??_C@_04MDHMLCKF@STOP@ DB 'STOP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BAKJJPGC@RUN2@
CONST	SEGMENT
??_C@_04BAKJJPGC@RUN2@ DB 'RUN2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DLIEMMKB@RUN1@
CONST	SEGMENT
??_C@_04DLIEMMKB@RUN1@ DB 'RUN1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LLDCGJBK@RUN@
CONST	SEGMENT
??_C@_03LLDCGJBK@RUN@ DB 'RUN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05HKFIMGDP@WALK2@
CONST	SEGMENT
??_C@_05HKFIMGDP@WALK2@ DB 'WALK2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05FBHFJFPM@WALK1@
CONST	SEGMENT
??_C@_05FBHFJFPM@WALK1@ DB 'WALK1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PKELMGAL@WALK@
CONST	SEGMENT
??_C@_04PKELMGAL@WALK@ DB 'WALK', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05FKPMNCEA@WAIT2@
CONST	SEGMENT
??_C@_05FKPMNCEA@WAIT2@ DB 'WAIT2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05HBNBIBID@WAIT1@
CONST	SEGMENT
??_C@_05HBNBIBID@WAIT1@ DB 'WAIT1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05NIJFIOCI@SPAWN@
CONST	SEGMENT
??_C@_05NIJFIOCI@SPAWN@ DB 'SPAWN', 00H			; `string'
CONST	ENDS
;	COMDAT ?stMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
_DATA	SEGMENT
?stMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 014H DUP (?)
	DD	0fH					; `CRaceManager::__LoadRaceMotionList'::`2'::stMotionFileName
_DATA	ENDS
;	COMDAT ?stSpawnMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
_DATA	SEGMENT
?stSpawnMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 014H DUP (?)
	DD	0fH					; `CRaceManager::__LoadRaceMotionList'::`2'::stSpawnMotionFileName
_DATA	ENDS
;	COMDAT ??_C@_0DN@CNIFOKKO@CRaceManager?3?3RegisterRacePath?5@
CONST	SEGMENT
??_C@_0DN@CNIFOKKO@CRaceManager?3?3RegisterRacePath?5@ DB 'CRaceManager::'
	DB	'RegisterRacePath : RACE[%u] HAVE NO PATH ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@IDBEOJF@CRaceManager?3?3RegisterRacePath?5@
CONST	SEGMENT
??_C@_0EB@IDBEOJF@CRaceManager?3?3RegisterRacePath?5@ DB 'CRaceManager::R'
	DB	'egisterRacePath : RACE[%u] LOAD MSMFILE[%s] ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@NGFDIHNH@CRaceManager?3?3RegisterRacePath?5@
CONST	SEGMENT
??_C@_0FK@NGFDIHNH@CRaceManager?3?3RegisterRacePath?5@ DB 'CRaceManager::'
	DB	'RegisterRacePath : RACE[%u] LOAD MSMFILE[%s] ERROR. Will Find'
	DB	' Another Path.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IIEHFLK@?4msm@
CONST	SEGMENT
??_C@_04IIEHFLK@?4msm@ DB '.msm', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09HPPJBJBB@shape?4msm@
CONST	SEGMENT
??_C@_09HPPJBJBB@shape?4msm@ DB 'shape.msm', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@FBAOJDFF@CRaceManager?3?3RegisterRacePath?$CI@
CONST	SEGMENT
??_C@_0DJ@FBAOJDFF@CRaceManager?3?3RegisterRacePath?$CI@ DB 'CRaceManager'
	DB	'::RegisterRacePath(race=%u).LoadRaceData(%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FJBDMFMI@?$CFsmotlist?4txt@
CONST	SEGMENT
??_C@_0O@FJBDMFMI@?$CFsmotlist?4txt@ DB '%smotlist.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PECPBC@?$CFsshape?4msm@
CONST	SEGMENT
??_C@_0M@PECPBC@?$CFsshape?4msm@ DB '%sshape.msm', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KHHCNLLA@?$CDseason2?1monster?1@
CONST	SEGMENT
??_C@_0BC@KHHCNLLA@?$CDseason2?1monster?1@ DB '#season2/monster/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DOJALNLB@?$CDseason1?1monster?1@
CONST	SEGMENT
??_C@_0BC@DOJALNLB@?$CDseason1?1monster?1@ DB '#season1/monster/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DOKHHMMK@?$CDseason2?1npc?1@
CONST	SEGMENT
??_C@_0O@DOKHHMMK@?$CDseason2?1npc?1@ DB '#season2/npc/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PEPGGFH@?$CDseason1?1npc?1@
CONST	SEGMENT
??_C@_0O@PEPGGFH@?$CDseason1?1npc?1@ DB '#season1/npc/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BCLHILHN@d?3?1ymir?5work?1npc_mount?1@
CONST	SEGMENT
??_C@_0BI@BCLHILHN@d?3?1ymir?5work?1npc_mount?1@ DB 'd:/ymir work/npc_mou'
	DB	'nt/', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GPLCEAJK@d?3?1ymir?5work?1monster2?1@
CONST	SEGMENT
??_C@_0BH@GPLCEAJK@d?3?1ymir?5work?1monster2?1@ DB 'd:/ymir work/monster2'
	DB	'/', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FGIKCKJD@d?3?1ymir?5work?1monster?1@
CONST	SEGMENT
??_C@_0BG@FGIKCKJD@d?3?1ymir?5work?1monster?1@ DB 'd:/ymir work/monster/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CKCIELCO@d?3?1ymir?5work?1npc_pet?1@
CONST	SEGMENT
??_C@_0BG@CKCIELCO@d?3?1ymir?5work?1npc_pet?1@ DB 'd:/ymir work/npc_pet/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DIPFLAGN@d?3?1ymir?5work?1npc2?1@
CONST	SEGMENT
??_C@_0BD@DIPFLAGN@d?3?1ymir?5work?1npc2?1@ DB 'd:/ymir work/npc2/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HJMPPIOH@d?3?1ymir?5work?1npc?1@
CONST	SEGMENT
??_C@_0BC@HJMPPIOH@d?3?1ymir?5work?1npc?1@ DB 'd:/ymir work/npc/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PJNPAGEJ@d?3?1ymir?5work?1guild?1@
CONST	SEGMENT
??_C@_0BE@PJNPAGEJ@d?3?1ymir?5work?1guild?1@ DB 'd:/ymir work/guild/', 00H ; `string'
CONST	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_7CRaceManager@@6B@
CONST	SEGMENT
??_7CRaceManager@@6B@ DD FLAT:??_R4CRaceManager@@6B@	; CRaceManager::`vftable'
	DD	FLAT:??_ECRaceManager@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CSingleton@VCRaceManager@@@@6B@
CONST	SEGMENT
??_7?$CSingleton@VCRaceManager@@@@6B@ DD FLAT:??_R4?$CSingleton@VCRaceManager@@@@6B@ ; CSingleton<CRaceManager>::`vftable'
	DD	FLAT:??_E?$CSingleton@VCRaceManager@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GCADKGJO@map?1set?5too?5long@
CONST	SEGMENT
??_C@_0BB@GCADKGJO@map?1set?5too?5long@ DB 'map/set too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0U?$pair@$$CBKPAVCRaceData@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@1@$$QAU?$pair@$$CBKPAVCRaceData@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0U?$pair@$$CBKPAVCRaceData@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@1@$$QAU?$pair@$$CBKPAVCRaceData@@@1@@Z$1
__ehfuncinfo$??$?0U?$pair@$$CBKPAVCRaceData@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@1@$$QAU?$pair@$$CBKPAVCRaceData@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0U?$pair@$$CBKPAVCRaceData@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@1@$$QAU?$pair@$$CBKPAVCRaceData@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@$$QAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@$$QAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z$1
__ehfuncinfo$??$?0U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@$$QAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@$$QAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@@Z$0
__ehfuncinfo$??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z$0
__ehfuncinfo$??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Emplace@U?$pair@$$CBKPAVCRaceData@@@std@@@?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@_N@1@$$QAU?$pair@$$CBKPAVCRaceData@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Emplace@U?$pair@$$CBKPAVCRaceData@@@std@@@?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@_N@1@$$QAU?$pair@$$CBKPAVCRaceData@@@1@@Z$2
__ehfuncinfo$??$_Emplace@U?$pair@$$CBKPAVCRaceData@@@std@@@?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@_N@1@$$QAU?$pair@$$CBKPAVCRaceData@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Emplace@U?$pair@$$CBKPAVCRaceData@@@std@@@?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@_N@1@$$QAU?$pair@$$CBKPAVCRaceData@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Emplace@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@_N@1@$$QAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Emplace@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@_N@1@$$QAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z$2
__ehfuncinfo$??$_Emplace@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@_N@1@$$QAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Emplace@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@_N@1@$$QAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@@Z$1
__ehfuncinfo$??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z$1
__ehfuncinfo$??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCRaceData@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBKPAVCRaceData@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCRaceData@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBKPAVCRaceData@@@1@@Z$2
__ehfuncinfo$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCRaceData@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBKPAVCRaceData@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCRaceData@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBKPAVCRaceData@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z$2
__ehfuncinfo$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@@Z$1
__ehfuncinfo$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0AAPBDAAPBD$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@AAPBD0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0AAPBDAAPBD$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@AAPBD0@Z$0
__ehfuncinfo$??$?0AAPBDAAPBD$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@AAPBD0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0AAPBDAAPBD$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@AAPBD0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z$1
__ehfuncinfo$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@AAY0BC@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0BC@$$CBD@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@AAY0BC@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0BC@$$CBD@Z$0
__unwindtable$??$_Emplace_reallocate@AAY0BC@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0BC@$$CBD@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@AAY0BC@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0BC@$$CBD@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@AAY0BC@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0BC@$$CBD@Z$4
__ehfuncinfo$??$_Emplace_reallocate@AAY0BC@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0BC@$$CBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@AAY0BC@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0BC@$$CBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@AAY0BC@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0BC@$$CBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@AAY0O@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0O@$$CBD@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@AAY0O@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0O@$$CBD@Z$0
__unwindtable$??$_Emplace_reallocate@AAY0O@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0O@$$CBD@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@AAY0O@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0O@$$CBD@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@AAY0O@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0O@$$CBD@Z$4
__ehfuncinfo$??$_Emplace_reallocate@AAY0O@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0O@$$CBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@AAY0O@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0O@$$CBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@AAY0O@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0O@$$CBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z DD 019930522H
	DD	03bH
	DD	FLAT:__unwindtable$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$15
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$16
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$17
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$18
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$19
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$20
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$21
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$22
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$23
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$24
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$25
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$26
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$27
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$28
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$29
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$30
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$31
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$32
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$33
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$34
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$35
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$36
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$37
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$38
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$39
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$40
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$41
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$42
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$43
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$44
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$45
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$46
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$47
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$48
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$49
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$50
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$51
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$52
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$53
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$54
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$55
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$56
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$57
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$58
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z DD 019930522H
	DD	03bH
	DD	FLAT:__unwindtable$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$61
	DD	01H
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$60
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$2
	DD	04H
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$74
	DD	04H
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$73
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$3
	DD	07H
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$87
	DD	07H
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$86
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$15
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$16
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$17
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$18
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$19
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$20
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$21
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$22
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$23
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$24
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$25
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$26
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$27
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$28
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$29
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$30
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$31
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$32
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$33
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$34
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$35
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$36
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$37
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$38
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$39
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$40
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$41
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$42
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$43
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$44
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$45
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$46
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$47
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$48
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$49
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$50
	DD	038H
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$51
	DD	039H
	DD	FLAT:__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$53
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?__LoadRaceData@CRaceManager@@IAEPAVCRaceData@@K@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadRaceData@CRaceManager@@IAEPAVCRaceData@@K@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?__LoadRaceData@CRaceManager@@IAEPAVCRaceData@@K@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?__LoadRaceData@CRaceManager@@IAEPAVCRaceData@@K@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?__LoadRaceData@CRaceManager@@IAEPAVCRaceData@@K@Z$3
__ehfuncinfo$?__LoadRaceData@CRaceManager@@IAEPAVCRaceData@@K@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?__LoadRaceData@CRaceManager@@IAEPAVCRaceData@@K@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?RegisterRaceSrcName@CRaceManager@@QAEXPBD0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RegisterRaceSrcName@CRaceManager@@QAEXPBD0@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RegisterRaceSrcName@CRaceManager@@QAEXPBD0@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?RegisterRaceSrcName@CRaceManager@@QAEXPBD0@Z$9
	DD	01H
	DD	FLAT:__unwindfunclet$?RegisterRaceSrcName@CRaceManager@@QAEXPBD0@Z$8
__ehfuncinfo$?RegisterRaceSrcName@CRaceManager@@QAEXPBD0@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?RegisterRaceSrcName@CRaceManager@@QAEXPBD0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?RegisterRaceName@CRaceManager@@QAEXKPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RegisterRaceName@CRaceManager@@QAEXKPBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?RegisterRaceName@CRaceManager@@QAEXKPBD@Z$6
__ehfuncinfo$?RegisterRaceName@CRaceManager@@QAEXKPBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?RegisterRaceName@CRaceManager@@QAEXKPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CRaceManager@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CRaceManager@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CRaceManager@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CRaceManager@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CRaceManager@@QAE@XZ$2
__ehfuncinfo$??0CRaceManager@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0CRaceManager@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::operator<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4842 :     const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2305 :         const value_type* _Result = _Bx._Buf;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b c8		 mov	 ecx, eax

; 2319 :         return _BUF_SIZE <= _Myres;

  00008	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 2306 :         if (_Large_string_engaged()) {

  0000c	72 02		 jb	 SHORT $LN6@operator

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
$LN6@operator:
  00010	53		 push	 ebx
  00011	56		 push	 esi

; 2305 :         const value_type* _Result = _Bx._Buf;

  00012	8b 75 08	 mov	 esi, DWORD PTR __Left$[ebp]
  00015	8b d6		 mov	 edx, esi
  00017	57		 push	 edi

; 2319 :         return _BUF_SIZE <= _Myres;

  00018	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2306 :         if (_Large_string_engaged()) {

  0001c	72 02		 jb	 SHORT $LN11@operator

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  0001e	8b 16		 mov	 edx, DWORD PTR [esi]
$LN11@operator:

; 4414 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00020	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00023	8b f3		 mov	 esi, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4414 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00025	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00028	3b fb		 cmp	 edi, ebx
  0002a	0f 42 f7	 cmovb	 esi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 392  :         return _CSTD memcmp(_First1, _First2, _Count);

  0002d	83 ee 04	 sub	 esi, 4
  00030	72 11		 jb	 SHORT $LN26@operator
$LL27@operator:
  00032	8b 02		 mov	 eax, DWORD PTR [edx]
  00034	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00036	75 10		 jne	 SHORT $LN25@operator
  00038	83 c2 04	 add	 edx, 4
  0003b	83 c1 04	 add	 ecx, 4
  0003e	83 ee 04	 sub	 esi, 4
  00041	73 ef		 jae	 SHORT $LL27@operator
$LN26@operator:
  00043	83 fe fc	 cmp	 esi, -4			; fffffffcH
  00046	74 34		 je	 SHORT $LN24@operator
$LN25@operator:
  00048	8a 02		 mov	 al, BYTE PTR [edx]
  0004a	3a 01		 cmp	 al, BYTE PTR [ecx]
  0004c	75 27		 jne	 SHORT $LN28@operator
  0004e	83 fe fd	 cmp	 esi, -3			; fffffffdH
  00051	74 29		 je	 SHORT $LN24@operator
  00053	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  00056	3a 41 01	 cmp	 al, BYTE PTR [ecx+1]
  00059	75 1a		 jne	 SHORT $LN28@operator
  0005b	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0005e	74 1c		 je	 SHORT $LN24@operator
  00060	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  00063	3a 41 02	 cmp	 al, BYTE PTR [ecx+2]
  00066	75 0d		 jne	 SHORT $LN28@operator
  00068	83 fe ff	 cmp	 esi, -1
  0006b	74 0f		 je	 SHORT $LN24@operator
  0006d	8a 42 03	 mov	 al, BYTE PTR [edx+3]
  00070	3a 41 03	 cmp	 al, BYTE PTR [ecx+3]
  00073	74 07		 je	 SHORT $LN24@operator
$LN28@operator:
  00075	1b c0		 sbb	 eax, eax
  00077	83 c8 01	 or	 eax, 1
  0007a	eb 02		 jmp	 SHORT $LN29@operator
$LN24@operator:
  0007c	33 c0		 xor	 eax, eax
$LN29@operator:

; 592  :     if (_Ans != 0) {

  0007e	85 c0		 test	 eax, eax
  00080	75 13		 jne	 SHORT $LN18@operator

; 593  :         return _Ans;
; 594  :     }
; 595  : 
; 596  :     if (_Left_size < _Right_size) {

  00082	3b fb		 cmp	 edi, ebx
  00084	76 0b		 jbe	 SHORT $LN30@operator

; 4843 :     return _Left.compare(_Right) < 0;

  00086	5f		 pop	 edi

; 597  :         return -1;

  00087	83 c8 ff	 or	 eax, -1

; 4843 :     return _Left.compare(_Right) < 0;

  0008a	5e		 pop	 esi
  0008b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0008e	5b		 pop	 ebx

; 4844 : }

  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
$LN30@operator:

; 600  :     if (_Left_size > _Right_size) {

  00091	1b c0		 sbb	 eax, eax
  00093	f7 d8		 neg	 eax
$LN18@operator:

; 4843 :     return _Left.compare(_Right) < 0;

  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0009a	5b		 pop	 ebx

; 4844 : }

  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CRaceData *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CRaceData *>,void *> > >, COMDAT
; _this$ = ecx

; 1024 :         if (_Ptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 0b		 je	 SHORT $LN8@Alloc_cons

; 264  :         ::operator delete(_Ptr, _Bytes);

  00007	6a 18		 push	 24			; 00000018H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000f	83 c4 08	 add	 esp, 8
$LN8@Alloc_cons:

; 1025 :             _Al.deallocate(_Ptr, 1);
; 1026 :         }
; 1027 :     }

  00012	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CRaceData *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CRaceData *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >, COMDAT
; _this$ = ecx

; 1024 :         if (_Ptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 0b		 je	 SHORT $LN8@Alloc_cons

; 264  :         ::operator delete(_Ptr, _Bytes);

  00007	6a 2c		 push	 44			; 0000002cH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000f	83 c4 08	 add	 esp, 8
$LN8@Alloc_cons:

; 1025 :             _Al.deallocate(_Ptr, 1);
; 1026 :         }
; 1027 :     }

  00012	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >, COMDAT
; _this$ = ecx

; 1024 :         if (_Ptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 0b		 je	 SHORT $LN10@Tree_temp_

; 264  :         ::operator delete(_Ptr, _Bytes);

  00007	6a 40		 push	 64			; 00000040H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000f	83 c4 08	 add	 esp, 8
$LN10@Tree_temp_:
  00012	c3		 ret	 0
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >, COMDAT
; _this$ = ecx

; 1024 :         if (_Ptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 0b		 je	 SHORT $LN8@Alloc_cons

; 264  :         ::operator delete(_Ptr, _Bytes);

  00007	6a 40		 push	 64			; 00000040H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000f	83 c4 08	 add	 esp, 8
$LN8@Alloc_cons:

; 1025 :             _Al.deallocate(_Ptr, 1);
; 1026 :         }
; 1027 :     }

  00012	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>,void *> > >, COMDAT
; _this$ = ecx

; 1024 :         if (_Ptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 0b		 je	 SHORT $LN10@Tree_temp_

; 264  :         ::operator delete(_Ptr, _Bytes);

  00007	6a 2c		 push	 44			; 0000002cH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000f	83 c4 08	 add	 esp, 8
$LN10@Tree_temp_:
  00012	c3		 ret	 0
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>,void *> > >, COMDAT
; _this$ = ecx

; 1024 :         if (_Ptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 0b		 je	 SHORT $LN8@Alloc_cons

; 264  :         ::operator delete(_Ptr, _Bytes);

  00007	6a 2c		 push	 44			; 0000002cH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000f	83 c4 08	 add	 esp, 8
$LN8@Alloc_cons:

; 1025 :             _Al.deallocate(_Ptr, 1);
; 1026 :         }
; 1027 :     }

  00012	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 1713 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1714 :     // move [_First, _Last) to raw _Dest, using _Al
; 1715 :     // note: only called internally from elsewhere in the STL
; 1716 :     using _Ptrval     = typename _Alloc::value_type*;
; 1717 :     auto _UFirst      = _Get_unwrapped(_First);
; 1718 :     const auto _ULast = _Get_unwrapped(_Last);
; 1719 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1720 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1721 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1722 :         if (!_STD is_constant_evaluated())
; 1723 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1724 :         {
; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1726 :             return _Dest + (_ULast - _UFirst);
; 1727 :         }
; 1728 :     }
; 1729 : 
; 1730 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	56		 push	 esi

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  0000a	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]

; 1714 :     // move [_First, _Last) to raw _Dest, using _Al
; 1715 :     // note: only called internally from elsewhere in the STL
; 1716 :     using _Ptrval     = typename _Alloc::value_type*;
; 1717 :     auto _UFirst      = _Get_unwrapped(_First);
; 1718 :     const auto _ULast = _Get_unwrapped(_Last);
; 1719 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1720 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1721 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1722 :         if (!_STD is_constant_evaluated())
; 1723 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1724 :         {
; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1726 :             return _Dest + (_ULast - _UFirst);
; 1727 :         }
; 1728 :     }
; 1729 : 
; 1730 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  0000d	3b c2		 cmp	 eax, edx
  0000f	74 4f		 je	 SHORT $LN3@Uninitiali

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00011	8b ce		 mov	 ecx, esi
  00013	2b c8		 sub	 ecx, eax
  00015	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@Uninitiali:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00020	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 2355 :     size_type _Mysize = 0; // current length of string

  00026	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 2356 :     size_type _Myres  = 0; // current storage reserved for string

  0002d	c7 44 01 14 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+20], 0

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00035	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00038	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  0003b	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00040	66 0f d6 46 10	 movq	 QWORD PTR [esi+16], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1632 :         ++_Last;

  00045	83 c6 18	 add	 esi, 24			; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4596 :         _My_data._Mysize = 0;

  00048	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0004f	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00056	c6 00 00	 mov	 BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1632 :         ++_Last;

  00059	83 c0 18	 add	 eax, 24			; 00000018H

; 1714 :     // move [_First, _Last) to raw _Dest, using _Al
; 1715 :     // note: only called internally from elsewhere in the STL
; 1716 :     using _Ptrval     = typename _Alloc::value_type*;
; 1717 :     auto _UFirst      = _Get_unwrapped(_First);
; 1718 :     const auto _ULast = _Get_unwrapped(_Last);
; 1719 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1720 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1721 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1722 :         if (!_STD is_constant_evaluated())
; 1723 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1724 :         {
; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1726 :             return _Dest + (_ULast - _UFirst);
; 1727 :         }
; 1728 :     }
; 1729 : 
; 1730 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  0005c	3b c2		 cmp	 eax, edx
  0005e	75 c0		 jne	 SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 1626 :         _Destroy_range(_First, _Last, _Al);

  00060	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00063	56		 push	 esi
  00064	56		 push	 esi
  00065	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1732 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1733 :     }
; 1734 : 
; 1735 :     return _Backout._Release();

  0006d	8b c6		 mov	 eax, esi
  0006f	5e		 pop	 esi

; 1736 : }

  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >, COMDAT
; _this$ = ecx

; 748  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 749  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00005	8b 7d 0c	 mov	 edi, DWORD PTR __Rootnode$[ebp]
  00008	8b c1		 mov	 eax, ecx
  0000a	89 45 fc	 mov	 DWORD PTR _this$1$[ebp], eax
  0000d	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00011	75 6e		 jne	 SHORT $LN73@Erase_tree
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR __Al$[ebp]
  00017	56		 push	 esi
$LL2@Erase_tree:

; 750  :             _Erase_tree(_Al, _Rootnode->_Right);

  00018	ff 77 08	 push	 DWORD PTR [edi+8]
  0001b	8b c8		 mov	 ecx, eax
  0001d	53		 push	 ebx
  0001e	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 616  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00023	8b f7		 mov	 esi, edi

; 617  :     _Val         = static_cast<_Other&&>(_New_val);

  00025	8b 3f		 mov	 edi, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00027	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0002a	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0002d	72 28		 jb	 SHORT $LN29@Erase_tree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0002f	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00032	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00033	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00039	72 12		 jb	 SHORT $LN39@Erase_tree

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0003b	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0003e	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00041	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00043	83 c0 fc	 add	 eax, -4			; fffffffcH
  00046	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00049	77 3d		 ja	 SHORT $LN36@Erase_tree

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0004b	8b c2		 mov	 eax, edx
$LN39@Erase_tree:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0004d	51		 push	 ecx
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00054	83 c4 08	 add	 esp, 8
$LN29@Erase_tree:
  00057	6a 2c		 push	 44			; 0000002cH
  00059	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  0005a	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00061	c7 46 28 0f 00
	00 00		 mov	 DWORD PTR [esi+40], 15	; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00068	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  0006c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00071	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 749  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00074	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00078	75 05		 jne	 SHORT $LN75@Erase_tree
  0007a	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  0007d	eb 99		 jmp	 SHORT $LL2@Erase_tree
$LN75@Erase_tree:
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
$LN73@Erase_tree:
  00081	5f		 pop	 edi

; 753  :     }

  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 08 00	 ret	 8
$LN36@Erase_tree:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00088	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN76@Erase_tree:
  0008d	cc		 int	 3
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@ABK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find_lower_bound<unsigned long>, COMDAT
; _this$ = ecx

; 1603 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1604 :         const auto _Scary = _Get_scary();
; 1605 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00008	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0000b	89 02		 mov	 DWORD PTR [edx], eax
  0000d	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
  00014	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1606 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1607 :         while (!_Trynode->_Isnil) {

  00017	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0001b	75 28		 jne	 SHORT $LN12@Find_lower
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef

; 127  :         return _Left < _Right;

  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00020	56		 push	 esi
  00021	8b 31		 mov	 esi, DWORD PTR [ecx]
$LL2@Find_lower:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1608 :             _Result._Location._Parent = _Trynode;

  00023	89 02		 mov	 DWORD PTR [edx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef

; 127  :         return _Left < _Right;

  00025	39 70 10	 cmp	 DWORD PTR [eax+16], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1609 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  00028	73 07		 jae	 SHORT $LN4@Find_lower

; 1610 :                 _Result._Location._Child = _Tree_child::_Right;
; 1611 :                 _Trynode                 = _Trynode->_Right;

  0002a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002d	33 c9		 xor	 ecx, ecx

; 1612 :             } else {

  0002f	eb 0a		 jmp	 SHORT $LN5@Find_lower
$LN4@Find_lower:

; 1613 :                 _Result._Location._Child = _Tree_child::_Left;
; 1614 :                 _Result._Bound           = _Trynode;

  00031	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1615 :                 _Trynode                 = _Trynode->_Left;

  00034	b9 01 00 00 00	 mov	 ecx, 1
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
$LN5@Find_lower:

; 1606 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1607 :         while (!_Trynode->_Isnil) {

  0003b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0003e	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00042	74 df		 je	 SHORT $LL2@Find_lower

; 1616 :             }
; 1617 :         }
; 1618 : 
; 1619 :         return _Result;

  00044	5e		 pop	 esi
$LN12@Find_lower:

; 1620 :     }

  00045	8b c2		 mov	 eax, edx
  00047	5d		 pop	 ebp
  00048	c2 08 00	 ret	 8
??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find_lower_bound<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@1@ABK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@1@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CRaceData *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRaceData *> >,0> >::_Find_lower_bound<unsigned long>, COMDAT
; _this$ = ecx

; 1603 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1604 :         const auto _Scary = _Get_scary();
; 1605 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00008	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0000b	89 02		 mov	 DWORD PTR [edx], eax
  0000d	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
  00014	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1606 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1607 :         while (!_Trynode->_Isnil) {

  00017	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0001b	75 28		 jne	 SHORT $LN12@Find_lower
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef

; 127  :         return _Left < _Right;

  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00020	56		 push	 esi
  00021	8b 31		 mov	 esi, DWORD PTR [ecx]
$LL2@Find_lower:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1608 :             _Result._Location._Parent = _Trynode;

  00023	89 02		 mov	 DWORD PTR [edx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef

; 127  :         return _Left < _Right;

  00025	39 70 10	 cmp	 DWORD PTR [eax+16], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1609 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  00028	73 07		 jae	 SHORT $LN4@Find_lower

; 1610 :                 _Result._Location._Child = _Tree_child::_Right;
; 1611 :                 _Trynode                 = _Trynode->_Right;

  0002a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002d	33 c9		 xor	 ecx, ecx

; 1612 :             } else {

  0002f	eb 0a		 jmp	 SHORT $LN5@Find_lower
$LN4@Find_lower:

; 1613 :                 _Result._Location._Child = _Tree_child::_Left;
; 1614 :                 _Result._Bound           = _Trynode;

  00031	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1615 :                 _Trynode                 = _Trynode->_Left;

  00034	b9 01 00 00 00	 mov	 ecx, 1
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
$LN5@Find_lower:

; 1606 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1607 :         while (!_Trynode->_Isnil) {

  0003b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0003e	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00042	74 df		 je	 SHORT $LL2@Find_lower

; 1616 :             }
; 1617 :         }
; 1618 : 
; 1619 :         return _Result;

  00044	5e		 pop	 esi
$LN12@Find_lower:

; 1620 :     }

  00045	8b c2		 mov	 eax, edx
  00047	5d		 pop	 ebp
  00048	c2 08 00	 ret	 8
??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@1@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CRaceData *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRaceData *> >,0> >::_Find_lower_bound<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >, COMDAT
; _this$ = ecx

; 748  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 749  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00005	8b 75 0c	 mov	 esi, DWORD PTR __Rootnode$[ebp]
  00008	8b c1		 mov	 eax, ecx
  0000a	89 45 fc	 mov	 DWORD PTR _this$1$[ebp], eax
  0000d	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00011	75 32		 jne	 SHORT $LN3@Erase_tree
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR __Al$[ebp]
  00017	57		 push	 edi
$LL2@Erase_tree:

; 750  :             _Erase_tree(_Al, _Rootnode->_Right);

  00018	ff 76 08	 push	 DWORD PTR [esi+8]
  0001b	8b c8		 mov	 ecx, eax
  0001d	53		 push	 ebx
  0001e	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 616  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00023	8b fe		 mov	 edi, esi

; 617  :     _Val         = static_cast<_Other&&>(_New_val);

  00025	8b 36		 mov	 esi, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 385  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  00027	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  0002a	e8 00 00 00 00	 call	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  0002f	6a 40		 push	 64			; 00000040H
  00031	57		 push	 edi
  00032	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 749  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  0003a	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 749  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  0003d	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00041	74 d5		 je	 SHORT $LL2@Erase_tree
  00043	5f		 pop	 edi
  00044	5b		 pop	 ebx
$LN3@Erase_tree:
  00045	5e		 pop	 esi

; 751  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));
; 752  :         }
; 753  :     }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1603 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1604 :         const auto _Scary = _Get_scary();
; 1605 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0000d	89 37		 mov	 DWORD PTR [edi], esi

; 1606 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1607 :         while (!_Trynode->_Isnil) {

  0000f	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00013	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  0001a	89 47 08	 mov	 DWORD PTR [edi+8], eax
  0001d	75 32		 jne	 SHORT $LN12@Find_lower
  0001f	53		 push	 ebx
  00020	8b 5d 0c	 mov	 ebx, DWORD PTR __Keyval$[ebp]
$LL2@Find_lower:

; 1609 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  00023	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  00026	89 37		 mov	 DWORD PTR [edi], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef

; 127  :         return _Left < _Right;

  00028	53		 push	 ebx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
  0002f	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1609 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  00032	84 c0		 test	 al, al
  00034	74 07		 je	 SHORT $LN4@Find_lower

; 1610 :                 _Result._Location._Child = _Tree_child::_Right;
; 1611 :                 _Trynode                 = _Trynode->_Right;

  00036	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  00039	33 c0		 xor	 eax, eax

; 1612 :             } else {

  0003b	eb 0a		 jmp	 SHORT $LN5@Find_lower
$LN4@Find_lower:

; 1613 :                 _Result._Location._Child = _Tree_child::_Left;
; 1614 :                 _Result._Bound           = _Trynode;

  0003d	89 77 08	 mov	 DWORD PTR [edi+8], esi

; 1615 :                 _Trynode                 = _Trynode->_Left;

  00040	b8 01 00 00 00	 mov	 eax, 1
  00045	8b 36		 mov	 esi, DWORD PTR [esi]
$LN5@Find_lower:

; 1606 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1607 :         while (!_Trynode->_Isnil) {

  00047	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0004a	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0004e	74 d3		 je	 SHORT $LL2@Find_lower

; 1616 :             }
; 1617 :         }
; 1618 : 
; 1619 :         return _Result;

  00050	5b		 pop	 ebx
$LN12@Find_lower:

; 1620 :     }

  00051	8b c7		 mov	 eax, edi
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5d		 pop	 ebp
  00056	c2 08 00	 ret	 8
??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@1@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>,void *> > >, COMDAT
; _this$ = ecx

; 748  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 749  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00005	8b 7d 0c	 mov	 edi, DWORD PTR __Rootnode$[ebp]
  00008	8b c1		 mov	 eax, ecx
  0000a	89 45 fc	 mov	 DWORD PTR _this$1$[ebp], eax
  0000d	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00011	75 6e		 jne	 SHORT $LN73@Erase_tree
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR __Al$[ebp]
  00017	56		 push	 esi
$LL2@Erase_tree:

; 750  :             _Erase_tree(_Al, _Rootnode->_Right);

  00018	ff 77 08	 push	 DWORD PTR [edi+8]
  0001b	8b c8		 mov	 ecx, eax
  0001d	53		 push	 ebx
  0001e	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 616  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00023	8b f7		 mov	 esi, edi

; 617  :     _Val         = static_cast<_Other&&>(_New_val);

  00025	8b 3f		 mov	 edi, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00027	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  0002a	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0002d	72 28		 jb	 SHORT $LN29@Erase_tree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0002f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00032	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00033	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00039	72 12		 jb	 SHORT $LN39@Erase_tree

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0003b	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0003e	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00041	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00043	83 c0 fc	 add	 eax, -4			; fffffffcH
  00046	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00049	77 3d		 ja	 SHORT $LN36@Erase_tree

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0004b	8b c2		 mov	 eax, edx
$LN39@Erase_tree:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0004d	51		 push	 ecx
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00054	83 c4 08	 add	 esp, 8
$LN29@Erase_tree:
  00057	6a 2c		 push	 44			; 0000002cH
  00059	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  0005a	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00061	c7 46 24 0f 00
	00 00		 mov	 DWORD PTR [esi+36], 15	; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00068	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  0006c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00071	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 749  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00074	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00078	75 05		 jne	 SHORT $LN75@Erase_tree
  0007a	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  0007d	eb 99		 jmp	 SHORT $LL2@Erase_tree
$LN75@Erase_tree:
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
$LN73@Erase_tree:
  00081	5f		 pop	 edi

; 753  :     }

  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 08 00	 ret	 8
$LN36@Erase_tree:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00088	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN76@Erase_tree:
  0008d	cc		 int	 3
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1603 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1604 :         const auto _Scary = _Get_scary();
; 1605 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0000d	89 37		 mov	 DWORD PTR [edi], esi

; 1606 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1607 :         while (!_Trynode->_Isnil) {

  0000f	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00013	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  0001a	89 47 08	 mov	 DWORD PTR [edi+8], eax
  0001d	75 32		 jne	 SHORT $LN12@Find_lower
  0001f	53		 push	 ebx
  00020	8b 5d 0c	 mov	 ebx, DWORD PTR __Keyval$[ebp]
$LL2@Find_lower:

; 1609 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  00023	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  00026	89 37		 mov	 DWORD PTR [edi], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef

; 127  :         return _Left < _Right;

  00028	53		 push	 ebx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
  0002f	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1609 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  00032	84 c0		 test	 al, al
  00034	74 07		 je	 SHORT $LN4@Find_lower

; 1610 :                 _Result._Location._Child = _Tree_child::_Right;
; 1611 :                 _Trynode                 = _Trynode->_Right;

  00036	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  00039	33 c0		 xor	 eax, eax

; 1612 :             } else {

  0003b	eb 0a		 jmp	 SHORT $LN5@Find_lower
$LN4@Find_lower:

; 1613 :                 _Result._Location._Child = _Tree_child::_Left;
; 1614 :                 _Result._Bound           = _Trynode;

  0003d	89 77 08	 mov	 DWORD PTR [edi+8], esi

; 1615 :                 _Trynode                 = _Trynode->_Left;

  00040	b8 01 00 00 00	 mov	 eax, 1
  00045	8b 36		 mov	 esi, DWORD PTR [esi]
$LN5@Find_lower:

; 1606 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1607 :         while (!_Trynode->_Isnil) {

  00047	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0004a	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0004e	74 d3		 je	 SHORT $LL2@Find_lower

; 1616 :             }
; 1617 :         }
; 1618 : 
; 1619 :         return _Result;

  00050	5b		 pop	 ebx
$LN12@Find_lower:

; 1620 :     }

  00051	8b c7		 mov	 eax, edi
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5d		 pop	 ebp
  00056	c2 08 00	 ret	 8
??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 945  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 949  :         for (; _First != _Last; ++_First) {

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 48		 je	 SHORT $LN45@Destroy_ra
  0000f	90		 npad	 1
$LL4@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00010	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00013	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00016	72 27		 jb	 SHORT $LN23@Destroy_ra
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00018	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0001a	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0001b	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00021	72 12		 jb	 SHORT $LN33@Destroy_ra

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00023	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00026	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00029	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0002b	83 c0 fc	 add	 eax, -4			; fffffffcH
  0002e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00031	77 28		 ja	 SHORT $LN30@Destroy_ra

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00033	8b c2		 mov	 eax, edx
$LN33@Destroy_ra:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00035	51		 push	 ecx
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003c	83 c4 08	 add	 esp, 8
$LN23@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  0003f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00046	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0004d	c6 06 00	 mov	 BYTE PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 949  :         for (; _First != _Last; ++_First) {

  00050	83 c6 18	 add	 esi, 24			; 00000018H
  00053	3b f7		 cmp	 esi, edi
  00055	75 b9		 jne	 SHORT $LL4@Destroy_ra
$LN45@Destroy_ra:
  00057	5f		 pop	 edi

; 950  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 951  :         }
; 952  :     }
; 953  : }

  00058	5e		 pop	 esi
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
$LN30@Destroy_ra:

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0005b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN46@Destroy_ra:
  00060	cc		 int	 3
??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z
_TEXT	SEGMENT
__Oldsize$1$ = -8					; size = 4
_this$1$ = -4						; size = 4
__Whereoff$1$ = -4					; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 765  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 766  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 767  :         _Alty& _Al        = _Getal();
; 768  :         auto& _My_data    = _Mypair._Myval2;
; 769  :         pointer& _Myfirst = _My_data._Myfirst;
; 770  :         pointer& _Mylast  = _My_data._Mylast;
; 771  : 
; 772  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 773  : 
; 774  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00006	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
  00009	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000e	53		 push	 ebx
  0000f	8b d9		 mov	 ebx, ecx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	8b 33		 mov	 esi, DWORD PTR [ebx]
  00015	2b d6		 sub	 edx, esi

; 775  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00017	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0001a	f7 ea		 imul	 edx
  0001c	2b ce		 sub	 ecx, esi
  0001e	c1 fa 02	 sar	 edx, 2
  00021	8b c2		 mov	 eax, edx
  00023	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00026	03 c2		 add	 eax, edx
  00028	89 45 fc	 mov	 DWORD PTR __Whereoff$1$[ebp], eax
  0002b	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00030	f7 e9		 imul	 ecx
  00032	c1 fa 02	 sar	 edx, 2
  00035	8b c2		 mov	 eax, edx
  00037	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0003a	03 c2		 add	 eax, edx
  0003c	89 45 f8	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 776  : 
; 777  :         if (_Oldsize == max_size()) {

  0003f	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  00044	0f 84 14 01 00
	00		 je	 $LN68@Emplace_re

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0004a	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

  0004d	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00050	2b ce		 sub	 ecx, esi
  00052	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00057	f7 e9		 imul	 ecx

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00059	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0005e	c1 fa 02	 sar	 edx, 2
  00061	8b ca		 mov	 ecx, edx
  00063	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00066	03 ca		 add	 ecx, edx

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00068	8b d1		 mov	 edx, ecx
  0006a	d1 ea		 shr	 edx, 1
  0006c	2b c2		 sub	 eax, edx
  0006e	3b c8		 cmp	 ecx, eax
  00070	76 17		 jbe	 SHORT $LN12@Emplace_re

; 1689 :             return _Max; // geometric growth would overflow

  00072	b8 f0 ff ff ff	 mov	 eax, -16		; fffffff0H
  00077	be aa aa aa 0a	 mov	 esi, 178956970		; 0aaaaaaaH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00082	83 c4 04	 add	 esp, 4
  00085	8b f8		 mov	 edi, eax
  00087	eb 43		 jmp	 SHORT $LN23@Emplace_re
$LN12@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00089	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 64   :         if (_Count > _Max_possible) {

  0008c	8b f7		 mov	 esi, edi
  0008e	3b c7		 cmp	 eax, edi
  00090	0f 43 f0	 cmovae	 esi, eax
  00093	81 fe aa aa aa
	0a		 cmp	 esi, 178956970		; 0aaaaaaaH
  00099	0f 87 c4 00 00
	00		 ja	 $LN69@Emplace_re

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  0009f	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  000a2	c1 e0 03	 shl	 eax, 3

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000a5	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000aa	72 0d		 jb	 SHORT $LN24@Emplace_re

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000b2	83 c4 04	 add	 esp, 4
  000b5	8b f8		 mov	 edi, eax
  000b7	eb 13		 jmp	 SHORT $LN23@Emplace_re
$LN24@Emplace_re:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  000b9	85 c0		 test	 eax, eax
  000bb	74 0d		 je	 SHORT $LN25@Emplace_re

; 85   :         return ::operator new(_Bytes);

  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000c3	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  000c6	8b f8		 mov	 edi, eax
  000c8	eb 02		 jmp	 SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000ca	33 ff		 xor	 edi, edi
$LN23@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 789  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000cc	8b 45 fc	 mov	 eax, DWORD PTR __Whereoff$1$[ebp]
  000cf	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  000d2	8d 0c c7	 lea	 ecx, DWORD PTR [edi+eax*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  000d5	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  000d8	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 2355 :     size_type _Mysize = 0; // current length of string

  000de	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 2356 :     size_type _Myres  = 0; // current storage reserved for string

  000e5	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  000ec	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 789  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000ef	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  000f2	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  000f5	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  000fa	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0

; 4596 :         _My_data._Mysize = 0;

  000ff	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00106	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0010d	c6 00 00	 mov	 BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 792  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00110	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00113	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  00116	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00118	3b c2		 cmp	 eax, edx
  0011a	75 04		 jne	 SHORT $LN4@Emplace_re

; 1664 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0011c	8b c7		 mov	 eax, edi

; 793  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 794  :         } else { // provide basic guarantee

  0011e	eb 18		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 1659 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00120	53		 push	 ebx
  00121	57		 push	 edi
  00122	50		 push	 eax
  00123	51		 push	 ecx
  00124	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 795  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 796  :             _Constructed_first = _Newvec;
; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00129	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]

; 1659 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0012c	83 c4 10	 add	 esp, 16			; 00000010H
  0012f	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]

; 795  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 796  :             _Constructed_first = _Newvec;
; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00132	83 c0 18	 add	 eax, 24			; 00000018H

; 1659 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00135	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
$LN5@Emplace_re:

; 795  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 796  :             _Constructed_first = _Newvec;
; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00138	53		 push	 ebx
  00139	50		 push	 eax
  0013a	52		 push	 edx
  0013b	51		 push	 ecx
  0013c	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);
; 801  :         _Al.deallocate(_Newvec, _Newcapacity);
; 802  :         _RERAISE;
; 803  :         _CATCH_END
; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00141	8b 45 f8	 mov	 eax, DWORD PTR __Oldsize$1$[ebp]
  00144	83 c4 10	 add	 esp, 16			; 00000010H
  00147	40		 inc	 eax
  00148	8b cb		 mov	 ecx, ebx
  0014a	56		 push	 esi
  0014b	50		 push	 eax
  0014c	57		 push	 edi
  0014d	e8 00 00 00 00	 call	 ?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array

; 806  :         return _Newvec + _Whereoff;

  00152	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00155	5f		 pop	 edi
  00156	5e		 pop	 esi
  00157	5b		 pop	 ebx

; 807  :     }

  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c2 08 00	 ret	 8
$LN68@Emplace_re:

; 778  :             _Xlength();

  0015e	e8 00 00 00 00	 call	 ?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
$LN69@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  00163	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN66@Emplace_re:
  00168	cc		 int	 3
??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCRaceData@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCRaceData@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CRaceData *> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CRaceData *>,void *> > >, COMDAT
; _this$ = ecx

; 748  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 749  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00005	8b 75 0c	 mov	 esi, DWORD PTR __Rootnode$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0000e	75 25		 jne	 SHORT $LN3@Erase_tree
  00010	57		 push	 edi
  00011	8b 7d 08	 mov	 edi, DWORD PTR __Al$[ebp]
$LL2@Erase_tree:

; 750  :             _Erase_tree(_Al, _Rootnode->_Right);

  00014	ff 76 08	 push	 DWORD PTR [esi+8]
  00017	8b cb		 mov	 ecx, ebx
  00019	57		 push	 edi
  0001a	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCRaceData@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CRaceData *> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CRaceData *>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 616  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0001f	8b c6		 mov	 eax, esi

; 617  :     _Val         = static_cast<_Other&&>(_New_val);

  00021	8b 36		 mov	 esi, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00023	6a 18		 push	 24			; 00000018H
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002b	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 749  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  0002e	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00032	74 e0		 je	 SHORT $LL2@Erase_tree
  00034	5f		 pop	 edi
$LN3@Erase_tree:
  00035	5e		 pop	 esi

; 751  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));
; 752  :         }
; 753  :     }

  00036	5b		 pop	 ebx
  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCRaceData@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CRaceData *> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CRaceData *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx
  00005	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 42   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0000b	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  0000e	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  00011	3b f3		 cmp	 esi, ebx
  00013	74 14		 je	 SHORT $LN19@CDynamicPo
$LL20@CDynamicPo:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 224  : 			::operator delete(pkData);

  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  0001c	83 c6 04	 add	 esi, 4
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 224  : 			::operator delete(pkData);

  0001f	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  00022	3b f3		 cmp	 esi, ebx
  00024	75 ef		 jne	 SHORT $LL20@CDynamicPo
  00026	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
$LN19@CDynamicPo:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 162  : 			m_kVct_pkFree.clear();

  00029	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0002c	89 77 08	 mov	 DWORD PTR [edi+8], esi
  0002f	89 47 14	 mov	 DWORD PTR [edi+20], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00032	85 c0		 test	 eax, eax
  00034	74 41		 je	 SHORT $LN27@CDynamicPo

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00036	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00039	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0003b	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0003e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00044	72 12		 jb	 SHORT $LN43@CDynamicPo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00046	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00049	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0004c	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00051	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00054	77 6d		 ja	 SHORT $LN65@CDynamicPo

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00056	8b c2		 mov	 eax, edx
$LN43@CDynamicPo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00058	51		 push	 ecx
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  0005f	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00066	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  00069	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0

; 1769 :             _Myend   = nullptr;

  00070	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
$LN27@CDynamicPo:

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00077	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0007a	85 c0		 test	 eax, eax
  0007c	74 41		 je	 SHORT $LN52@CDynamicPo

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0007e	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00081	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00086	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0008c	72 12		 jb	 SHORT $LN68@CDynamicPo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0008e	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00091	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00094	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00096	83 c0 fc	 add	 eax, -4			; fffffffcH
  00099	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0009c	77 25		 ja	 SHORT $LN65@CDynamicPo

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0009e	8b c2		 mov	 eax, edx
$LN68@CDynamicPo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  000a0	51		 push	 ecx
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  000a7	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  000ae	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  000b1	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 1769 :             _Myend   = nullptr;

  000b8	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
$LN52@CDynamicPo:
  000bf	5f		 pop	 edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 142  : 		}

  000c0	5e		 pop	 esi
  000c1	5b		 pop	 ebx
  000c2	c3		 ret	 0
$LN65@CDynamicPo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000c3	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN77@CDynamicPo:
  000c8	cc		 int	 3
??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx
  00005	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 42   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0000b	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  0000e	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  00011	3b f3		 cmp	 esi, ebx
  00013	74 14		 je	 SHORT $LN19@CDynamicPo
$LL20@CDynamicPo:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 224  : 			::operator delete(pkData);

  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  0001c	83 c6 04	 add	 esi, 4
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 224  : 			::operator delete(pkData);

  0001f	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  00022	3b f3		 cmp	 esi, ebx
  00024	75 ef		 jne	 SHORT $LL20@CDynamicPo
  00026	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
$LN19@CDynamicPo:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 162  : 			m_kVct_pkFree.clear();

  00029	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0002c	89 77 08	 mov	 DWORD PTR [edi+8], esi
  0002f	89 47 14	 mov	 DWORD PTR [edi+20], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00032	85 c0		 test	 eax, eax
  00034	74 41		 je	 SHORT $LN27@CDynamicPo

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00036	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00039	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0003b	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0003e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00044	72 12		 jb	 SHORT $LN43@CDynamicPo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00046	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00049	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0004c	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00051	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00054	77 6d		 ja	 SHORT $LN65@CDynamicPo

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00056	8b c2		 mov	 eax, edx
$LN43@CDynamicPo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00058	51		 push	 ecx
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  0005f	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00066	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  00069	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0

; 1769 :             _Myend   = nullptr;

  00070	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
$LN27@CDynamicPo:

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00077	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0007a	85 c0		 test	 eax, eax
  0007c	74 41		 je	 SHORT $LN52@CDynamicPo

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0007e	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00081	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00086	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0008c	72 12		 jb	 SHORT $LN68@CDynamicPo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0008e	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00091	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00094	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00096	83 c0 fc	 add	 eax, -4			; fffffffcH
  00099	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0009c	77 25		 ja	 SHORT $LN65@CDynamicPo

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0009e	8b c2		 mov	 eax, edx
$LN68@CDynamicPo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  000a0	51		 push	 ecx
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  000a7	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  000ae	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  000b1	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 1769 :             _Myend   = nullptr;

  000b8	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
$LN52@CDynamicPo:
  000bf	5f		 pop	 edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 142  : 		}

  000c0	5e		 pop	 esi
  000c1	5b		 pop	 ebx
  000c2	c3		 ret	 0
$LN65@CDynamicPo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000c3	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN77@CDynamicPo:
  000c8	cc		 int	 3
??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx
  00005	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 42   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0000b	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  0000e	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  00011	3b f3		 cmp	 esi, ebx
  00013	74 14		 je	 SHORT $LN19@CDynamicPo
$LL20@CDynamicPo:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 224  : 			::operator delete(pkData);

  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  0001c	83 c6 04	 add	 esi, 4
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 224  : 			::operator delete(pkData);

  0001f	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  00022	3b f3		 cmp	 esi, ebx
  00024	75 ef		 jne	 SHORT $LL20@CDynamicPo
  00026	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
$LN19@CDynamicPo:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 162  : 			m_kVct_pkFree.clear();

  00029	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0002c	89 77 08	 mov	 DWORD PTR [edi+8], esi
  0002f	89 47 14	 mov	 DWORD PTR [edi+20], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00032	85 c0		 test	 eax, eax
  00034	74 41		 je	 SHORT $LN27@CDynamicPo

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00036	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00039	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0003b	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0003e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00044	72 12		 jb	 SHORT $LN43@CDynamicPo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00046	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00049	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0004c	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00051	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00054	77 6d		 ja	 SHORT $LN65@CDynamicPo

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00056	8b c2		 mov	 eax, edx
$LN43@CDynamicPo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00058	51		 push	 ecx
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  0005f	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00066	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  00069	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0

; 1769 :             _Myend   = nullptr;

  00070	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
$LN27@CDynamicPo:

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00077	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0007a	85 c0		 test	 eax, eax
  0007c	74 41		 je	 SHORT $LN52@CDynamicPo

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0007e	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00081	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00086	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0008c	72 12		 jb	 SHORT $LN68@CDynamicPo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0008e	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00091	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00094	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00096	83 c0 fc	 add	 eax, -4			; fffffffcH
  00099	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0009c	77 25		 ja	 SHORT $LN65@CDynamicPo

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0009e	8b c2		 mov	 eax, edx
$LN68@CDynamicPo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  000a0	51		 push	 ecx
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  000a7	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  000ae	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  000b1	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 1769 :             _Myend   = nullptr;

  000b8	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
$LN52@CDynamicPo:
  000bf	5f		 pop	 edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 142  : 		}

  000c0	5e		 pop	 esi
  000c1	5b		 pop	 ebx
  000c2	c3		 ret	 0
$LN65@CDynamicPo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000c3	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN77@CDynamicPo:
  000c8	cc		 int	 3
??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx
  00005	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 42   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0000b	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  0000e	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  00011	3b f3		 cmp	 esi, ebx
  00013	74 14		 je	 SHORT $LN19@CDynamicPo
$LL20@CDynamicPo:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 224  : 			::operator delete(pkData);

  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  0001c	83 c6 04	 add	 esi, 4
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 224  : 			::operator delete(pkData);

  0001f	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  00022	3b f3		 cmp	 esi, ebx
  00024	75 ef		 jne	 SHORT $LL20@CDynamicPo
  00026	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
$LN19@CDynamicPo:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 162  : 			m_kVct_pkFree.clear();

  00029	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0002c	89 77 08	 mov	 DWORD PTR [edi+8], esi
  0002f	89 47 14	 mov	 DWORD PTR [edi+20], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00032	85 c0		 test	 eax, eax
  00034	74 41		 je	 SHORT $LN27@CDynamicPo

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00036	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00039	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0003b	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0003e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00044	72 12		 jb	 SHORT $LN43@CDynamicPo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00046	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00049	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0004c	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00051	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00054	77 6d		 ja	 SHORT $LN65@CDynamicPo

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00056	8b c2		 mov	 eax, edx
$LN43@CDynamicPo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00058	51		 push	 ecx
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  0005f	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00066	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  00069	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0

; 1769 :             _Myend   = nullptr;

  00070	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
$LN27@CDynamicPo:

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00077	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0007a	85 c0		 test	 eax, eax
  0007c	74 41		 je	 SHORT $LN52@CDynamicPo

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0007e	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00081	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00086	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0008c	72 12		 jb	 SHORT $LN68@CDynamicPo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0008e	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00091	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00094	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00096	83 c0 fc	 add	 eax, -4			; fffffffcH
  00099	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0009c	77 25		 ja	 SHORT $LN65@CDynamicPo

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0009e	8b c2		 mov	 eax, edx
$LN68@CDynamicPo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  000a0	51		 push	 ecx
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  000a7	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  000ae	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  000b1	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 1769 :             _Myend   = nullptr;

  000b8	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
$LN52@CDynamicPo:
  000bf	5f		 pop	 edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 142  : 		}

  000c0	5e		 pop	 esi
  000c1	5b		 pop	 ebx
  000c2	c3		 ret	 0
$LN65@CDynamicPo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000c3	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN77@CDynamicPo:
  000c8	cc		 int	 3
??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx
  00005	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 42   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0000b	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  0000e	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  00011	3b f3		 cmp	 esi, ebx
  00013	74 14		 je	 SHORT $LN19@CDynamicPo
$LL20@CDynamicPo:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 224  : 			::operator delete(pkData);

  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  0001c	83 c6 04	 add	 esi, 4
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 224  : 			::operator delete(pkData);

  0001f	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  00022	3b f3		 cmp	 esi, ebx
  00024	75 ef		 jne	 SHORT $LL20@CDynamicPo
  00026	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
$LN19@CDynamicPo:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 162  : 			m_kVct_pkFree.clear();

  00029	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0002c	89 77 08	 mov	 DWORD PTR [edi+8], esi
  0002f	89 47 14	 mov	 DWORD PTR [edi+20], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00032	85 c0		 test	 eax, eax
  00034	74 41		 je	 SHORT $LN27@CDynamicPo

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00036	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00039	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0003b	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0003e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00044	72 12		 jb	 SHORT $LN43@CDynamicPo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00046	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00049	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0004c	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00051	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00054	77 6d		 ja	 SHORT $LN65@CDynamicPo

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00056	8b c2		 mov	 eax, edx
$LN43@CDynamicPo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00058	51		 push	 ecx
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  0005f	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00066	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  00069	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0

; 1769 :             _Myend   = nullptr;

  00070	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
$LN27@CDynamicPo:

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00077	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0007a	85 c0		 test	 eax, eax
  0007c	74 41		 je	 SHORT $LN52@CDynamicPo

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0007e	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00081	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00086	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0008c	72 12		 jb	 SHORT $LN68@CDynamicPo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0008e	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00091	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00094	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00096	83 c0 fc	 add	 eax, -4			; fffffffcH
  00099	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0009c	77 25		 ja	 SHORT $LN65@CDynamicPo

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0009e	8b c2		 mov	 eax, edx
$LN68@CDynamicPo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  000a0	51		 push	 ecx
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  000a7	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  000ae	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  000b1	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 1769 :             _Myend   = nullptr;

  000b8	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
$LN52@CDynamicPo:
  000bf	5f		 pop	 edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 142  : 		}

  000c0	5e		 pop	 esi
  000c1	5b		 pop	 ebx
  000c2	c3		 ret	 0
$LN65@CDynamicPo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000c3	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN77@CDynamicPo:
  000c8	cc		 int	 3
??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx
  00005	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 42   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0000b	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  0000e	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  00011	3b f3		 cmp	 esi, ebx
  00013	74 14		 je	 SHORT $LN19@CDynamicPo
$LL20@CDynamicPo:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 224  : 			::operator delete(pkData);

  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  0001c	83 c6 04	 add	 esi, 4
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 224  : 			::operator delete(pkData);

  0001f	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  00022	3b f3		 cmp	 esi, ebx
  00024	75 ef		 jne	 SHORT $LL20@CDynamicPo
  00026	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
$LN19@CDynamicPo:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 162  : 			m_kVct_pkFree.clear();

  00029	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0002c	89 77 08	 mov	 DWORD PTR [edi+8], esi
  0002f	89 47 14	 mov	 DWORD PTR [edi+20], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00032	85 c0		 test	 eax, eax
  00034	74 41		 je	 SHORT $LN27@CDynamicPo

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00036	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00039	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0003b	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0003e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00044	72 12		 jb	 SHORT $LN43@CDynamicPo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00046	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00049	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0004c	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00051	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00054	77 6d		 ja	 SHORT $LN65@CDynamicPo

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00056	8b c2		 mov	 eax, edx
$LN43@CDynamicPo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00058	51		 push	 ecx
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  0005f	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00066	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  00069	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0

; 1769 :             _Myend   = nullptr;

  00070	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
$LN27@CDynamicPo:

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00077	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0007a	85 c0		 test	 eax, eax
  0007c	74 41		 je	 SHORT $LN52@CDynamicPo

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0007e	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00081	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00086	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0008c	72 12		 jb	 SHORT $LN68@CDynamicPo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0008e	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00091	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00094	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00096	83 c0 fc	 add	 eax, -4			; fffffffcH
  00099	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0009c	77 25		 ja	 SHORT $LN65@CDynamicPo

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0009e	8b c2		 mov	 eax, edx
$LN68@CDynamicPo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  000a0	51		 push	 ecx
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  000a7	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  000ae	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  000b1	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 1769 :             _Myend   = nullptr;

  000b8	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
$LN52@CDynamicPo:
  000bf	5f		 pop	 edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 142  : 		}

  000c0	5e		 pop	 esi
  000c1	5b		 pop	 ebx
  000c2	c3		 ret	 0
$LN65@CDynamicPo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000c3	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN77@CDynamicPo:
  000c8	cc		 int	 3
??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx
  00005	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 42   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0000b	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  0000e	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  00011	3b f3		 cmp	 esi, ebx
  00013	74 14		 je	 SHORT $LN19@CDynamicPo
$LL20@CDynamicPo:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 224  : 			::operator delete(pkData);

  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  0001c	83 c6 04	 add	 esi, 4
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 224  : 			::operator delete(pkData);

  0001f	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  00022	3b f3		 cmp	 esi, ebx
  00024	75 ef		 jne	 SHORT $LL20@CDynamicPo
  00026	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
$LN19@CDynamicPo:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 162  : 			m_kVct_pkFree.clear();

  00029	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0002c	89 77 08	 mov	 DWORD PTR [edi+8], esi
  0002f	89 47 14	 mov	 DWORD PTR [edi+20], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00032	85 c0		 test	 eax, eax
  00034	74 41		 je	 SHORT $LN27@CDynamicPo

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00036	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00039	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0003b	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0003e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00044	72 12		 jb	 SHORT $LN43@CDynamicPo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00046	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00049	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0004c	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00051	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00054	77 6d		 ja	 SHORT $LN65@CDynamicPo

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00056	8b c2		 mov	 eax, edx
$LN43@CDynamicPo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00058	51		 push	 ecx
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  0005f	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00066	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  00069	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0

; 1769 :             _Myend   = nullptr;

  00070	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
$LN27@CDynamicPo:

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00077	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0007a	85 c0		 test	 eax, eax
  0007c	74 41		 je	 SHORT $LN52@CDynamicPo

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0007e	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00081	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00086	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0008c	72 12		 jb	 SHORT $LN68@CDynamicPo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0008e	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00091	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00094	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00096	83 c0 fc	 add	 eax, -4			; fffffffcH
  00099	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0009c	77 25		 ja	 SHORT $LN65@CDynamicPo

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0009e	8b c2		 mov	 eax, edx
$LN68@CDynamicPo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  000a0	51		 push	 ecx
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  000a7	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  000ae	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  000b1	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 1769 :             _Myend   = nullptr;

  000b8	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
$LN52@CDynamicPo:
  000bf	5f		 pop	 edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 142  : 		}

  000c0	5e		 pop	 esi
  000c1	5b		 pop	 ebx
  000c2	c3		 ret	 0
$LN65@CDynamicPo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000c3	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN77@CDynamicPo:
  000c8	cc		 int	 3
??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx
  00005	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 42   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0000b	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  0000e	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  00011	3b f3		 cmp	 esi, ebx
  00013	74 14		 je	 SHORT $LN19@CDynamicPo
$LL20@CDynamicPo:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 224  : 			::operator delete(pkData);

  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  0001c	83 c6 04	 add	 esi, 4
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 224  : 			::operator delete(pkData);

  0001f	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\algorithm

; 270  :     for (; _UFirst != _ULast; ++_UFirst) {

  00022	3b f3		 cmp	 esi, ebx
  00024	75 ef		 jne	 SHORT $LL20@CDynamicPo
  00026	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
$LN19@CDynamicPo:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 162  : 			m_kVct_pkFree.clear();

  00029	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0002c	89 77 08	 mov	 DWORD PTR [edi+8], esi
  0002f	89 47 14	 mov	 DWORD PTR [edi+20], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00032	85 c0		 test	 eax, eax
  00034	74 41		 je	 SHORT $LN27@CDynamicPo

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00036	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00039	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0003b	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0003e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00044	72 12		 jb	 SHORT $LN43@CDynamicPo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00046	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00049	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0004c	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00051	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00054	77 6d		 ja	 SHORT $LN65@CDynamicPo

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00056	8b c2		 mov	 eax, edx
$LN43@CDynamicPo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00058	51		 push	 ecx
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  0005f	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00066	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  00069	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0

; 1769 :             _Myend   = nullptr;

  00070	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
$LN27@CDynamicPo:

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00077	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0007a	85 c0		 test	 eax, eax
  0007c	74 41		 je	 SHORT $LN52@CDynamicPo

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0007e	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00081	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00086	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0008c	72 12		 jb	 SHORT $LN68@CDynamicPo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0008e	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00091	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00094	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00096	83 c0 fc	 add	 eax, -4			; fffffffcH
  00099	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0009c	77 25		 ja	 SHORT $LN65@CDynamicPo

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0009e	8b c2		 mov	 eax, edx
$LN68@CDynamicPo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  000a0	51		 push	 ecx
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  000a7	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  000ae	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  000b1	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 1769 :             _Myend   = nullptr;

  000b8	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
$LN52@CDynamicPo:
  000bf	5f		 pop	 edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterLib\Pool.h

; 142  : 		}

  000c0	5e		 pop	 esi
  000c1	5b		 pop	 ebx
  000c2	c3		 ret	 0
$LN65@CDynamicPo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000c3	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN77@CDynamicPo:
  000c8	cc		 int	 3
??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??__Fs_stFileName@?1??GetFullPathFileName@CRaceManager@@QAEPBDPBD@Z@YAXXZ
text$yd	SEGMENT
??__Fs_stFileName@?1??GetFullPathFileName@CRaceManager@@QAEPBDPBD@Z@YAXXZ PROC ; `CRaceManager::GetFullPathFileName'::`2'::`dynamic atexit destructor for 's_stFileName'', COMDAT

; 2319 :         return _BUF_SIZE <= _Myres;

  00000	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?s_stFileName@?1??GetFullPathFileName@CRaceManager@@QAEPBDPBD@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  00006	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 2f		 jb	 SHORT $LN15@dynamic
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?s_stFileName@?1??GetFullPathFileName@CRaceManager@@QAEPBDPBD@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00011	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00012	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00014	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0001a	72 14		 jb	 SHORT $LN25@dynamic

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001c	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0001f	83 c2 23	 add	 edx, 35			; 00000023H
  00022	2b c1		 sub	 eax, ecx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00024	83 c0 fc	 add	 eax, -4			; fffffffcH
  00027	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002a	0f 87 00 00 00
	00		 ja	 __invalid_parameter_noinfo_noreturn
$LN25@dynamic:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00030	52		 push	 edx
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00037	83 c4 08	 add	 esp, 8
$LN15@dynamic:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  0003a	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_stFileName@?1??GetFullPathFileName@CRaceManager@@QAEPBDPBD@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00044	c7 05 14 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?s_stFileName@?1??GetFullPathFileName@CRaceManager@@QAEPBDPBD@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0004e	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?s_stFileName@?1??GetFullPathFileName@CRaceManager@@QAEPBDPBD@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, 0
  00055	c3		 ret	 0
??__Fs_stFileName@?1??GetFullPathFileName@CRaceManager@@QAEPBDPBD@Z@YAXXZ ENDP ; `CRaceManager::GetFullPathFileName'::`2'::`dynamic atexit destructor for 's_stFileName''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCRaceData@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBKPAVCRaceData@@@1@@Z
_TEXT	SEGMENT
__Loc$2 = -36						; size = 12
$T3 = -24						; size = 12
$T4 = -20						; size = 8
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCRaceData@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBKPAVCRaceData@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CRaceData *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRaceData *> >,0> >::insert<0,0>, COMDAT
; _this$ = ecx

; 1246 :     pair<iterator, bool> insert(value_type&& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCRaceData@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBKPAVCRaceData@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx

; 1014 :             _Loc                = _Find_lower_bound(_Keyval);

  0002a	8b 5d 0c	 mov	 ebx, DWORD PTR __Val$[ebp]
  0002d	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  00030	53		 push	 ebx
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@1@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CRaceData *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRaceData *> >,0> >::_Find_lower_bound<unsigned long>
  00037	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0003a	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  0003e	66 0f d6 45 dc	 movq	 QWORD PTR __Loc$2[ebp], xmm0

; 1599 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00043	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00047	75 0b		 jne	 SHORT $LN4@insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef

; 127  :         return _Left < _Right;

  00049	8b 03		 mov	 eax, DWORD PTR [ebx]
  0004b	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1599 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0004e	72 04		 jb	 SHORT $LN4@insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00050	32 d2		 xor	 dl, dl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1016 :                 return {_Loc._Bound, false};

  00052	eb 51		 jmp	 SHORT $LN79@insert
$LN4@insert:

; 1623 :         if (max_size() == _Get_scary()->_Mysize) {

  00054	81 7f 04 aa aa
	aa 0a		 cmp	 DWORD PTR [edi+4], 178956970 ; 0aaaaaaaH
  0005b	74 64		 je	 SHORT $LN94@insert

; 1020 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  0005d	8b 37		 mov	 esi, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1012 :     _CONSTEXPR20_DYNALLOC explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  0005f	89 7d ec	 mov	 DWORD PTR $T4[ebp], edi

; 85   :         return ::operator new(_Bytes);

  00062	6a 18		 push	 24			; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 790  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00064	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1019 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  0006b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+4], 0

; 85   :         return ::operator new(_Bytes);

  00072	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 812  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  00077	8b 0b		 mov	 ecx, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 85   :         return ::operator new(_Bytes);

  00079	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 812  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0007c	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0007f	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 1039 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00082	8b cf		 mov	 ecx, edi
  00084	50		 push	 eax
  00085	ff 75 e0	 push	 DWORD PTR __Loc$2[ebp+4]

; 812  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  00088	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 1039 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  0008b	ff 75 dc	 push	 DWORD PTR __Loc$2[ebp]

; 813  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  0008e	89 30		 mov	 DWORD PTR [eax], esi

; 814  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  00090	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 815  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  00093	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 816  :         this->_Ptr->_Color = _Red;

  00096	66 c7 40 0c 00
	00		 mov	 WORD PTR [eax+12], 0

; 1039 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  0009c	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCRaceData@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CRaceData *> > >::_Insert_node
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  000a1	8b c8		 mov	 ecx, eax
  000a3	b2 01		 mov	 dl, 1
$LN79@insert:
  000a5	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000a8	89 08		 mov	 DWORD PTR [eax], ecx
  000aa	88 50 04	 mov	 BYTE PTR [eax+4], dl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1249 :     }

  000ad	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b7	59		 pop	 ecx
  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi
  000ba	5b		 pop	 ebx
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c2 08 00	 ret	 8
$LN94@insert:

; 1624 :             _Throw_tree_length_error();

  000c1	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN92@insert:
  000c6	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCRaceData@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBKPAVCRaceData@@@1@@Z$2:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR $T4[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CRaceData *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CRaceData *>,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCRaceData@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBKPAVCRaceData@@@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCRaceData@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBKPAVCRaceData@@@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCRaceData@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBKPAVCRaceData@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CRaceData *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRaceData *> >,0> >::insert<0,0>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z PROC ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4836 : _NODISCARD bool operator!=(const basic_string<_Elem, _Traits, _Alloc>& _Left, _In_z_ const _Elem* const _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Right$[ebp]

; 4836 : _NODISCARD bool operator!=(const basic_string<_Elem, _Traits, _Alloc>& _Left, _In_z_ const _Elem* const _Right) {

  00007	57		 push	 edi

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00008	8b fe		 mov	 edi, esi
  0000a	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0000d	0f 1f 00	 npad	 3
$LL20@operator:
  00010	8a 07		 mov	 al, BYTE PTR [edi]
  00012	47		 inc	 edi
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL20@operator

; 2305 :         const value_type* _Result = _Bx._Buf;

  00017	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0001a	2b f9		 sub	 edi, ecx

; 2305 :         const value_type* _Result = _Bx._Buf;

  0001c	8b ca		 mov	 ecx, edx

; 2319 :         return _BUF_SIZE <= _Myres;

  0001e	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H

; 2306 :         if (_Large_string_engaged()) {

  00022	72 02		 jb	 SHORT $LN10@operator

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  00024	8b 0a		 mov	 ecx, DWORD PTR [edx]
$LN10@operator:

; 4378 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  00026	8b 52 10	 mov	 edx, DWORD PTR [edx+16]

; 583  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  00029	3b d7		 cmp	 edx, edi
  0002b	75 5b		 jne	 SHORT $LN16@operator

; 392  :         return _CSTD memcmp(_First1, _First2, _Count);

  0002d	83 ea 04	 sub	 edx, 4
  00030	72 11		 jb	 SHORT $LN23@operator
$LL24@operator:
  00032	8b 01		 mov	 eax, DWORD PTR [ecx]
  00034	3b 06		 cmp	 eax, DWORD PTR [esi]
  00036	75 10		 jne	 SHORT $LN22@operator
  00038	83 c1 04	 add	 ecx, 4
  0003b	83 c6 04	 add	 esi, 4
  0003e	83 ea 04	 sub	 edx, 4
  00041	73 ef		 jae	 SHORT $LL24@operator
$LN23@operator:
  00043	83 fa fc	 cmp	 edx, -4			; fffffffcH
  00046	74 34		 je	 SHORT $LN21@operator
$LN22@operator:
  00048	8a 01		 mov	 al, BYTE PTR [ecx]
  0004a	3a 06		 cmp	 al, BYTE PTR [esi]
  0004c	75 27		 jne	 SHORT $LN25@operator
  0004e	83 fa fd	 cmp	 edx, -3			; fffffffdH
  00051	74 29		 je	 SHORT $LN21@operator
  00053	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00056	3a 46 01	 cmp	 al, BYTE PTR [esi+1]
  00059	75 1a		 jne	 SHORT $LN25@operator
  0005b	83 fa fe	 cmp	 edx, -2			; fffffffeH
  0005e	74 1c		 je	 SHORT $LN21@operator
  00060	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  00063	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  00066	75 0d		 jne	 SHORT $LN25@operator
  00068	83 fa ff	 cmp	 edx, -1
  0006b	74 0f		 je	 SHORT $LN21@operator
  0006d	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  00070	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  00073	74 07		 je	 SHORT $LN21@operator
$LN25@operator:
  00075	1b c0		 sbb	 eax, eax
  00077	83 c8 01	 or	 eax, 1
  0007a	eb 02		 jmp	 SHORT $LN26@operator
$LN21@operator:
  0007c	33 c0		 xor	 eax, eax
$LN26@operator:

; 583  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  0007e	85 c0		 test	 eax, eax
  00080	75 06		 jne	 SHORT $LN16@operator
  00082	5f		 pop	 edi
  00083	32 c0		 xor	 al, al

; 4837 :     return !(_Left == _Right);
; 4838 : }

  00085	5e		 pop	 esi
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
$LN16@operator:
  00088	5f		 pop	 edi

; 583  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  00089	b0 01		 mov	 al, 1

; 4837 :     return !(_Left == _Right);
; 4838 : }

  0008b	5e		 pop	 esi
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ENDP ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??__FstMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@YAXXZ
text$yd	SEGMENT
??__FstMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@YAXXZ PROC ; `CRaceManager::__LoadRaceMotionList'::`2'::`dynamic atexit destructor for 'stMotionFileName'', COMDAT

; 2319 :         return _BUF_SIZE <= _Myres;

  00000	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?stMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  00006	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 2f		 jb	 SHORT $LN15@dynamic
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?stMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00011	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00012	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00014	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0001a	72 14		 jb	 SHORT $LN25@dynamic

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001c	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0001f	83 c2 23	 add	 edx, 35			; 00000023H
  00022	2b c1		 sub	 eax, ecx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00024	83 c0 fc	 add	 eax, -4			; fffffffcH
  00027	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002a	0f 87 00 00 00
	00		 ja	 __invalid_parameter_noinfo_noreturn
$LN25@dynamic:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00030	52		 push	 edx
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00037	83 c4 08	 add	 esp, 8
$LN15@dynamic:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  0003a	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?stMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00044	c7 05 14 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?stMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0004e	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?stMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, 0
  00055	c3		 ret	 0
??__FstMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@YAXXZ ENDP ; `CRaceManager::__LoadRaceMotionList'::`2'::`dynamic atexit destructor for 'stMotionFileName''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??__FstSpawnMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@YAXXZ
text$yd	SEGMENT
??__FstSpawnMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@YAXXZ PROC ; `CRaceManager::__LoadRaceMotionList'::`2'::`dynamic atexit destructor for 'stSpawnMotionFileName'', COMDAT

; 2319 :         return _BUF_SIZE <= _Myres;

  00000	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?stSpawnMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  00006	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 2f		 jb	 SHORT $LN15@dynamic
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?stSpawnMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00011	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00012	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00014	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0001a	72 14		 jb	 SHORT $LN25@dynamic

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001c	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0001f	83 c2 23	 add	 edx, 35			; 00000023H
  00022	2b c1		 sub	 eax, ecx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00024	83 c0 fc	 add	 eax, -4			; fffffffcH
  00027	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002a	0f 87 00 00 00
	00		 ja	 __invalid_parameter_noinfo_noreturn
$LN25@dynamic:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00030	52		 push	 edx
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00037	83 c4 08	 add	 esp, 8
$LN15@dynamic:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  0003a	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?stSpawnMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00044	c7 05 14 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?stSpawnMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0004e	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?stSpawnMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, 0
  00055	c3		 ret	 0
??__FstSpawnMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@YAXXZ ENDP ; `CRaceManager::__LoadRaceMotionList'::`2'::`dynamic atexit destructor for 'stSpawnMotionFileName''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$?0AAY06$$CBDH$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY06$$CBD$$QAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAY06$$CBDH$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY06$$CBD$$QAH@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[7],int,0>, COMDAT
; _this$ = ecx

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00004	8b 55 08	 mov	 edx, DWORD PTR __Val1$[ebp]
  00007	8b c2		 mov	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	57		 push	 edi
  0000d	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00010	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00013	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 4596 :         _My_data._Mysize = 0;

  00019	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00020	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00027	c6 06 00	 mov	 BYTE PTR [esi], 0
  0002a	66 0f 1f 44 00
	00		 npad	 6
$LL20@allocator:

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00030	8a 08		 mov	 cl, BYTE PTR [eax]
  00032	40		 inc	 eax
  00033	84 c9		 test	 cl, cl
  00035	75 f9		 jne	 SHORT $LL20@allocator
  00037	2b c7		 sub	 eax, edi

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00039	8b ce		 mov	 ecx, esi
  0003b	50		 push	 eax
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00042	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00045	5f		 pop	 edi
  00046	8b 00		 mov	 eax, DWORD PTR [eax]
  00048	89 46 18	 mov	 DWORD PTR [esi+24], eax
  0004b	8b c6		 mov	 eax, esi
  0004d	5e		 pop	 esi
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 08 00	 ret	 8
??$?0AAY06$$CBDH$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY06$$CBD$$QAH@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[7],int,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$?0AAY08$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY08$$CBD$$QAW4EName@CRaceMotionData@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAY08$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY08$$CBD$$QAW4EName@CRaceMotionData@@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[9],enum CRaceMotionData::EName,0>, COMDAT
; _this$ = ecx

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00004	8b 55 08	 mov	 edx, DWORD PTR __Val1$[ebp]
  00007	8b c2		 mov	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	57		 push	 edi
  0000d	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00010	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00013	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 4596 :         _My_data._Mysize = 0;

  00019	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00020	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00027	c6 06 00	 mov	 BYTE PTR [esi], 0
  0002a	66 0f 1f 44 00
	00		 npad	 6
$LL20@allocator:

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00030	8a 08		 mov	 cl, BYTE PTR [eax]
  00032	40		 inc	 eax
  00033	84 c9		 test	 cl, cl
  00035	75 f9		 jne	 SHORT $LL20@allocator
  00037	2b c7		 sub	 eax, edi

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00039	8b ce		 mov	 ecx, esi
  0003b	50		 push	 eax
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00042	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00045	5f		 pop	 edi
  00046	8b 00		 mov	 eax, DWORD PTR [eax]
  00048	89 46 18	 mov	 DWORD PTR [esi+24], eax
  0004b	8b c6		 mov	 eax, esi
  0004d	5e		 pop	 esi
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 08 00	 ret	 8
??$?0AAY08$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY08$$CBD$$QAW4EName@CRaceMotionData@@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[9],enum CRaceMotionData::EName,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$?0AAY07$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY07$$CBD$$QAW4EName@CRaceMotionData@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAY07$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY07$$CBD$$QAW4EName@CRaceMotionData@@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[8],enum CRaceMotionData::EName,0>, COMDAT
; _this$ = ecx

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00004	8b 55 08	 mov	 edx, DWORD PTR __Val1$[ebp]
  00007	8b c2		 mov	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	57		 push	 edi
  0000d	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00010	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00013	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 4596 :         _My_data._Mysize = 0;

  00019	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00020	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00027	c6 06 00	 mov	 BYTE PTR [esi], 0
  0002a	66 0f 1f 44 00
	00		 npad	 6
$LL20@allocator:

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00030	8a 08		 mov	 cl, BYTE PTR [eax]
  00032	40		 inc	 eax
  00033	84 c9		 test	 cl, cl
  00035	75 f9		 jne	 SHORT $LL20@allocator
  00037	2b c7		 sub	 eax, edi

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00039	8b ce		 mov	 ecx, esi
  0003b	50		 push	 eax
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00042	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00045	5f		 pop	 edi
  00046	8b 00		 mov	 eax, DWORD PTR [eax]
  00048	89 46 18	 mov	 DWORD PTR [esi+24], eax
  0004b	8b c6		 mov	 eax, esi
  0004d	5e		 pop	 esi
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 08 00	 ret	 8
??$?0AAY07$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY07$$CBD$$QAW4EName@CRaceMotionData@@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[8],enum CRaceMotionData::EName,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$?0AAY09$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY09$$CBD$$QAW4EName@CRaceMotionData@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAY09$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY09$$CBD$$QAW4EName@CRaceMotionData@@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[10],enum CRaceMotionData::EName,0>, COMDAT
; _this$ = ecx

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00004	8b 55 08	 mov	 edx, DWORD PTR __Val1$[ebp]
  00007	8b c2		 mov	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	57		 push	 edi
  0000d	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00010	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00013	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 4596 :         _My_data._Mysize = 0;

  00019	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00020	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00027	c6 06 00	 mov	 BYTE PTR [esi], 0
  0002a	66 0f 1f 44 00
	00		 npad	 6
$LL20@allocator:

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00030	8a 08		 mov	 cl, BYTE PTR [eax]
  00032	40		 inc	 eax
  00033	84 c9		 test	 cl, cl
  00035	75 f9		 jne	 SHORT $LL20@allocator
  00037	2b c7		 sub	 eax, edi

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00039	8b ce		 mov	 ecx, esi
  0003b	50		 push	 eax
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00042	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00045	5f		 pop	 edi
  00046	8b 00		 mov	 eax, DWORD PTR [eax]
  00048	89 46 18	 mov	 DWORD PTR [esi+24], eax
  0004b	8b c6		 mov	 eax, esi
  0004d	5e		 pop	 esi
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 08 00	 ret	 8
??$?0AAY09$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY09$$CBD$$QAW4EName@CRaceMotionData@@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[10],enum CRaceMotionData::EName,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$?0AAY0BA@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0BA@$$CBD$$QAW4EName@CRaceMotionData@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAY0BA@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0BA@$$CBD$$QAW4EName@CRaceMotionData@@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[16],enum CRaceMotionData::EName,0>, COMDAT
; _this$ = ecx

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00004	8b 55 08	 mov	 edx, DWORD PTR __Val1$[ebp]
  00007	8b c2		 mov	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	57		 push	 edi
  0000d	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00010	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00013	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 4596 :         _My_data._Mysize = 0;

  00019	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00020	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00027	c6 06 00	 mov	 BYTE PTR [esi], 0
  0002a	66 0f 1f 44 00
	00		 npad	 6
$LL20@allocator:

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00030	8a 08		 mov	 cl, BYTE PTR [eax]
  00032	40		 inc	 eax
  00033	84 c9		 test	 cl, cl
  00035	75 f9		 jne	 SHORT $LL20@allocator
  00037	2b c7		 sub	 eax, edi

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00039	8b ce		 mov	 ecx, esi
  0003b	50		 push	 eax
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00042	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00045	5f		 pop	 edi
  00046	8b 00		 mov	 eax, DWORD PTR [eax]
  00048	89 46 18	 mov	 DWORD PTR [esi+24], eax
  0004b	8b c6		 mov	 eax, esi
  0004d	5e		 pop	 esi
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 08 00	 ret	 8
??$?0AAY0BA@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0BA@$$CBD$$QAW4EName@CRaceMotionData@@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[16],enum CRaceMotionData::EName,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$?0AAY0M@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0M@$$CBD$$QAW4EName@CRaceMotionData@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAY0M@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0M@$$CBD$$QAW4EName@CRaceMotionData@@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[12],enum CRaceMotionData::EName,0>, COMDAT
; _this$ = ecx

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00004	8b 55 08	 mov	 edx, DWORD PTR __Val1$[ebp]
  00007	8b c2		 mov	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	57		 push	 edi
  0000d	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00010	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00013	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 4596 :         _My_data._Mysize = 0;

  00019	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00020	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00027	c6 06 00	 mov	 BYTE PTR [esi], 0
  0002a	66 0f 1f 44 00
	00		 npad	 6
$LL20@allocator:

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00030	8a 08		 mov	 cl, BYTE PTR [eax]
  00032	40		 inc	 eax
  00033	84 c9		 test	 cl, cl
  00035	75 f9		 jne	 SHORT $LL20@allocator
  00037	2b c7		 sub	 eax, edi

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00039	8b ce		 mov	 ecx, esi
  0003b	50		 push	 eax
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00042	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00045	5f		 pop	 edi
  00046	8b 00		 mov	 eax, DWORD PTR [eax]
  00048	89 46 18	 mov	 DWORD PTR [esi+24], eax
  0004b	8b c6		 mov	 eax, esi
  0004d	5e		 pop	 esi
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 08 00	 ret	 8
??$?0AAY0M@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0M@$$CBD$$QAW4EName@CRaceMotionData@@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[12],enum CRaceMotionData::EName,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$?0AAY0L@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0L@$$CBD$$QAW4EName@CRaceMotionData@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAY0L@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0L@$$CBD$$QAW4EName@CRaceMotionData@@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[11],enum CRaceMotionData::EName,0>, COMDAT
; _this$ = ecx

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00004	8b 55 08	 mov	 edx, DWORD PTR __Val1$[ebp]
  00007	8b c2		 mov	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	57		 push	 edi
  0000d	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00010	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00013	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 4596 :         _My_data._Mysize = 0;

  00019	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00020	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00027	c6 06 00	 mov	 BYTE PTR [esi], 0
  0002a	66 0f 1f 44 00
	00		 npad	 6
$LL20@allocator:

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00030	8a 08		 mov	 cl, BYTE PTR [eax]
  00032	40		 inc	 eax
  00033	84 c9		 test	 cl, cl
  00035	75 f9		 jne	 SHORT $LL20@allocator
  00037	2b c7		 sub	 eax, edi

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00039	8b ce		 mov	 ecx, esi
  0003b	50		 push	 eax
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00042	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00045	5f		 pop	 edi
  00046	8b 00		 mov	 eax, DWORD PTR [eax]
  00048	89 46 18	 mov	 DWORD PTR [esi+24], eax
  0004b	8b c6		 mov	 eax, esi
  0004d	5e		 pop	 esi
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 08 00	 ret	 8
??$?0AAY0L@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0L@$$CBD$$QAW4EName@CRaceMotionData@@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[11],enum CRaceMotionData::EName,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$?0AAY0P@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0P@$$CBD$$QAW4EName@CRaceMotionData@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAY0P@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0P@$$CBD$$QAW4EName@CRaceMotionData@@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[15],enum CRaceMotionData::EName,0>, COMDAT
; _this$ = ecx

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00004	8b 55 08	 mov	 edx, DWORD PTR __Val1$[ebp]
  00007	8b c2		 mov	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	57		 push	 edi
  0000d	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00010	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00013	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 4596 :         _My_data._Mysize = 0;

  00019	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00020	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00027	c6 06 00	 mov	 BYTE PTR [esi], 0
  0002a	66 0f 1f 44 00
	00		 npad	 6
$LL20@allocator:

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00030	8a 08		 mov	 cl, BYTE PTR [eax]
  00032	40		 inc	 eax
  00033	84 c9		 test	 cl, cl
  00035	75 f9		 jne	 SHORT $LL20@allocator
  00037	2b c7		 sub	 eax, edi

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00039	8b ce		 mov	 ecx, esi
  0003b	50		 push	 eax
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00042	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00045	5f		 pop	 edi
  00046	8b 00		 mov	 eax, DWORD PTR [eax]
  00048	89 46 18	 mov	 DWORD PTR [esi+24], eax
  0004b	8b c6		 mov	 eax, esi
  0004d	5e		 pop	 esi
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 08 00	 ret	 8
??$?0AAY0P@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0P@$$CBD$$QAW4EName@CRaceMotionData@@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[15],enum CRaceMotionData::EName,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$?0AAY0O@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0O@$$CBD$$QAW4EName@CRaceMotionData@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAY0O@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0O@$$CBD$$QAW4EName@CRaceMotionData@@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[14],enum CRaceMotionData::EName,0>, COMDAT
; _this$ = ecx

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00004	8b 55 08	 mov	 edx, DWORD PTR __Val1$[ebp]
  00007	8b c2		 mov	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	57		 push	 edi
  0000d	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00010	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00013	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 4596 :         _My_data._Mysize = 0;

  00019	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00020	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00027	c6 06 00	 mov	 BYTE PTR [esi], 0
  0002a	66 0f 1f 44 00
	00		 npad	 6
$LL20@allocator:

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00030	8a 08		 mov	 cl, BYTE PTR [eax]
  00032	40		 inc	 eax
  00033	84 c9		 test	 cl, cl
  00035	75 f9		 jne	 SHORT $LL20@allocator
  00037	2b c7		 sub	 eax, edi

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00039	8b ce		 mov	 ecx, esi
  0003b	50		 push	 eax
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00042	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00045	5f		 pop	 edi
  00046	8b 00		 mov	 eax, DWORD PTR [eax]
  00048	89 46 18	 mov	 DWORD PTR [esi+24], eax
  0004b	8b c6		 mov	 eax, esi
  0004d	5e		 pop	 esi
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 08 00	 ret	 8
??$?0AAY0O@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0O@$$CBD$$QAW4EName@CRaceMotionData@@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[14],enum CRaceMotionData::EName,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$?0AAY0N@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0N@$$CBD$$QAW4EName@CRaceMotionData@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAY0N@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0N@$$CBD$$QAW4EName@CRaceMotionData@@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[13],enum CRaceMotionData::EName,0>, COMDAT
; _this$ = ecx

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00004	8b 55 08	 mov	 edx, DWORD PTR __Val1$[ebp]
  00007	8b c2		 mov	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	57		 push	 edi
  0000d	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00010	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00013	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 4596 :         _My_data._Mysize = 0;

  00019	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00020	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00027	c6 06 00	 mov	 BYTE PTR [esi], 0
  0002a	66 0f 1f 44 00
	00		 npad	 6
$LL20@allocator:

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00030	8a 08		 mov	 cl, BYTE PTR [eax]
  00032	40		 inc	 eax
  00033	84 c9		 test	 cl, cl
  00035	75 f9		 jne	 SHORT $LL20@allocator
  00037	2b c7		 sub	 eax, edi

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00039	8b ce		 mov	 ecx, esi
  0003b	50		 push	 eax
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00042	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00045	5f		 pop	 edi
  00046	8b 00		 mov	 eax, DWORD PTR [eax]
  00048	89 46 18	 mov	 DWORD PTR [esi+24], eax
  0004b	8b c6		 mov	 eax, esi
  0004d	5e		 pop	 esi
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 08 00	 ret	 8
??$?0AAY0N@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0N@$$CBD$$QAW4EName@CRaceMotionData@@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[13],enum CRaceMotionData::EName,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z
_TEXT	SEGMENT
__Loc$2 = -40						; size = 12
$T3 = -28						; size = 12
$T4 = -24						; size = 8
_this$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>, COMDAT
; _this$ = ecx

; 1246 :     pair<iterator, bool> insert(value_type&& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	89 7d f0	 mov	 DWORD PTR _this$1$[ebp], edi

; 1014 :             _Loc                = _Find_lower_bound(_Keyval);

  0002d	8b 5d 0c	 mov	 ebx, DWORD PTR __Val$[ebp]
  00030	8d 45 e4	 lea	 eax, DWORD PTR $T3[ebp]
  00033	53		 push	 ebx
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  0003a	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0003d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00041	66 0f d6 45 d8	 movq	 QWORD PTR __Loc$2[ebp], xmm0

; 1599 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00046	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0004a	75 15		 jne	 SHORT $LN4@insert
  0004c	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef

; 127  :         return _Left < _Right;

  0004f	50		 push	 eax
  00050	53		 push	 ebx
  00051	e8 00 00 00 00	 call	 ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
  00056	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1599 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00059	84 c0		 test	 al, al
  0005b	75 04		 jne	 SHORT $LN4@insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0005d	32 c9		 xor	 cl, cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1016 :                 return {_Loc._Bound, false};

  0005f	eb 67		 jmp	 SHORT $LN122@insert
$LN4@insert:

; 1623 :         if (max_size() == _Get_scary()->_Mysize) {

  00061	81 7f 04 5d 74
	d1 05		 cmp	 DWORD PTR [edi+4], 97612893 ; 05d1745dH
  00068	74 7a		 je	 SHORT $LN137@insert

; 1020 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  0006a	8b 1f		 mov	 ebx, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1012 :     _CONSTEXPR20_DYNALLOC explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  0006c	89 7d e8	 mov	 DWORD PTR $T4[ebp], edi

; 85   :         return ::operator new(_Bytes);

  0006f	6a 2c		 push	 44			; 0000002cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 790  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00071	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1019 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00078	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+4], 0

; 85   :         return ::operator new(_Bytes);

  0007f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 244  :         return _Traits::_Allocate(_Bytes);

  00084	8b f8		 mov	 edi, eax

; 85   :         return ::operator new(_Bytes);

  00086	83 c4 04	 add	 esp, 4

; 1020 :         _Ptr = _Al.allocate(1);

  00089	89 7d ec	 mov	 DWORD PTR $T4[ebp+4], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 213  :     pair(pair&&)      = default;

  0008c	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  0008f	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 811  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

  00092	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 213  :     pair(pair&&)      = default;

  00099	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0009e	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1039 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000a1	57		 push	 edi
  000a2	ff 75 dc	 push	 DWORD PTR __Loc$2[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 213  :     pair(pair&&)      = default;

  000a5	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1039 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000a8	ff 75 d8	 push	 DWORD PTR __Loc$2[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 213  :     pair(pair&&)      = default;

  000ab	89 4f 28	 mov	 DWORD PTR [edi+40], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1039 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000ae	8b 4d f0	 mov	 ecx, DWORD PTR _this$1$[ebp]

; 813  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  000b1	89 1f		 mov	 DWORD PTR [edi], ebx

; 814  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  000b3	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 815  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  000b6	89 5f 08	 mov	 DWORD PTR [edi+8], ebx

; 816  :         this->_Ptr->_Color = _Red;

  000b9	66 c7 47 0c 00
	00		 mov	 WORD PTR [edi+12], 0

; 1039 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000bf	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> > >::_Insert_node
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  000c4	8b f0		 mov	 esi, eax
  000c6	b1 01		 mov	 cl, 1
$LN122@insert:
  000c8	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000cb	89 30		 mov	 DWORD PTR [eax], esi
  000cd	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1249 :     }

  000d0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000da	59		 pop	 ecx
  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi
  000dd	5b		 pop	 ebx
  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c2 08 00	 ret	 8
$LN137@insert:

; 1624 :             _Throw_tree_length_error();

  000e4	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN135@insert:
  000e9	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z$2:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR $T4[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>,void *> > >
__unwindfunclet$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z$1:
  00008	8d 4d e8	 lea	 ecx, DWORD PTR $T4[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@std@@QAE@XZ
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
_TEXT	SEGMENT
??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 27		 jb	 SHORT $LN15@pair
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0000d	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN25@pair

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN22@pair

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN25@pair:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN15@pair:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi
  00044	c3		 ret	 0
$LN22@pair:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN31@pair:
  0004a	cc		 int	 3
??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??__Fs_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@YAXXZ
text$yd	SEGMENT
??__Fs_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@YAXXZ PROC ; `CRaceManager::__LoadRaceMotionList'::`2'::`dynamic atexit destructor for 's_kMap_stType_dwIndex'', COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 758  :         _Erase_tree(_Al, _Myhead->_Parent);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  00005	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  0000a	ff 70 04	 push	 DWORD PTR [eax+4]
  0000d	68 00 00 00 00	 push	 OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  00012	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00017	6a 2c		 push	 44			; 0000002cH
  00019	ff 35 00 00 00
	00		 push	 DWORD PTR ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	83 c4 08	 add	 esp, 8
  00027	c3		 ret	 0
??__Fs_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@YAXXZ ENDP ; `CRaceManager::__LoadRaceMotionList'::`2'::`dynamic atexit destructor for 's_kMap_stType_dwIndex''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@2@QAU32@@Z
_TEXT	SEGMENT
__Head$1$ = -8						; size = 4
_this$1$ = -4						; size = 4
__Loc$ = 8						; size = 8
__Newnode$ = 16						; size = 4
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@2@QAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> > >::_Insert_node, COMDAT
; _this$ = ecx

; 650  :     _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 651  :         ++_Mysize;
; 652  :         const auto _Head  = _Myhead;
; 653  :         _Newnode->_Parent = _Loc._Parent;

  00006	8b 55 08	 mov	 edx, DWORD PTR __Loc$[ebp]
  00009	8b c1		 mov	 eax, ecx
  0000b	89 45 fc	 mov	 DWORD PTR _this$1$[ebp], eax
  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00010	ff 40 04	 inc	 DWORD PTR [eax+4]
  00013	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00016	89 4d f8	 mov	 DWORD PTR __Head$1$[ebp], ecx
  00019	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 654  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

  0001c	3b d1		 cmp	 edx, ecx
  0001e	75 12		 jne	 SHORT $LN5@Insert_nod

; 655  :             _Head->_Left     = _Newnode;

  00020	89 01		 mov	 DWORD PTR [ecx], eax

; 656  :             _Head->_Parent   = _Newnode;

  00022	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 657  :             _Head->_Right    = _Newnode;

  00025	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 658  :             _Newnode->_Color = _Black; // the root is black

  00028	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 717  :     }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 0c 00	 ret	 12			; 0000000cH
$LN5@Insert_nod:

; 659  :             return _Newnode;
; 660  :         }
; 661  : 
; 662  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 663  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

  00032	83 7d 0c 00	 cmp	 DWORD PTR __Loc$[ebp+4], 0
  00036	75 0d		 jne	 SHORT $LN6@Insert_nod

; 664  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 665  :             _Loc._Parent->_Right = _Newnode;

  00038	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 666  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

  0003b	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003e	75 0d		 jne	 SHORT $LN9@Insert_nod

; 667  :                 _Head->_Right = _Newnode;

  00040	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 668  :             }
; 669  :         } else { // add to left of _Loc._Parent

  00043	eb 08		 jmp	 SHORT $LN9@Insert_nod
$LN6@Insert_nod:

; 670  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 671  :             _Loc._Parent->_Left = _Newnode;

  00045	89 02		 mov	 DWORD PTR [edx], eax

; 672  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

  00047	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00049	75 02		 jne	 SHORT $LN9@Insert_nod

; 673  :                 _Head->_Left = _Newnode;

  0004b	89 01		 mov	 DWORD PTR [ecx], eax
$LN9@Insert_nod:

; 674  :             }
; 675  :         }
; 676  : 
; 677  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  0004d	8b d0		 mov	 edx, eax
  0004f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00052	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  00056	0f 85 99 01 00
	00		 jne	 $LN3@Insert_nod
  0005c	53		 push	 ebx
  0005d	56		 push	 esi
  0005e	57		 push	 edi
  0005f	90		 npad	 1
$LL2@Insert_nod:

; 678  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

  00060	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00063	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
  00066	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00069	8d 59 04	 lea	 ebx, DWORD PTR [ecx+4]
  0006c	8b 06		 mov	 eax, DWORD PTR [esi]
  0006e	3b c8		 cmp	 ecx, eax
  00070	0f 85 ba 00 00
	00		 jne	 $LN10@Insert_nod

; 679  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

  00076	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 680  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00079	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  0007d	0f 84 b3 00 00
	00		 je	 $LN53@Insert_nod

; 681  :                     _Pnode->_Parent->_Color          = _Black;
; 682  :                     _Parent_sibling->_Color          = _Black;
; 683  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 684  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 685  :                 } else { // parent's sibling has red and black children
; 686  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

  00083	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00086	3b d6		 cmp	 edx, esi
  00088	75 47		 jne	 SHORT $LN51@Insert_nod

; 466  :         _Wherenode->_Right = _Pnode->_Left;

  0008a	8b 06		 mov	 eax, DWORD PTR [esi]

; 687  :                         _Pnode = _Pnode->_Parent;

  0008c	8b d1		 mov	 edx, ecx

; 466  :         _Wherenode->_Right = _Pnode->_Left;

  0008e	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 467  : 
; 468  :         if (!_Pnode->_Left->_Isnil) {

  00091	8b 06		 mov	 eax, DWORD PTR [esi]
  00093	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00097	75 03		 jne	 SHORT $LN20@Insert_nod

; 469  :             _Pnode->_Left->_Parent = _Wherenode;

  00099	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN20@Insert_nod:

; 470  :         }
; 471  : 
; 472  :         _Pnode->_Parent = _Wherenode->_Parent;

  0009c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0009e	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 473  : 
; 474  :         if (_Wherenode == _Myhead->_Parent) {

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  000a4	8b 00		 mov	 eax, DWORD PTR [eax]
  000a6	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  000a9	75 0b		 jne	 SHORT $LN21@Insert_nod

; 475  :             _Myhead->_Parent = _Pnode;

  000ab	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 483  :         _Wherenode->_Parent = _Pnode;

  000ae	8b fb		 mov	 edi, ebx
  000b0	89 16		 mov	 DWORD PTR [esi], edx
  000b2	89 33		 mov	 DWORD PTR [ebx], esi
  000b4	eb 1d		 jmp	 SHORT $LN49@Insert_nod
$LN21@Insert_nod:

; 476  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  000b6	8b 03		 mov	 eax, DWORD PTR [ebx]
  000b8	3b 10		 cmp	 edx, DWORD PTR [eax]
  000ba	75 0a		 jne	 SHORT $LN23@Insert_nod

; 477  :             _Wherenode->_Parent->_Left = _Pnode;

  000bc	89 30		 mov	 DWORD PTR [eax], esi

; 483  :         _Wherenode->_Parent = _Pnode;

  000be	8b fb		 mov	 edi, ebx
  000c0	89 16		 mov	 DWORD PTR [esi], edx
  000c2	89 33		 mov	 DWORD PTR [ebx], esi
  000c4	eb 0d		 jmp	 SHORT $LN49@Insert_nod
$LN23@Insert_nod:

; 479  :             _Wherenode->_Parent->_Right = _Pnode;

  000c6	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 483  :         _Wherenode->_Parent = _Pnode;

  000c9	8b fb		 mov	 edi, ebx
  000cb	89 16		 mov	 DWORD PTR [esi], edx
  000cd	89 33		 mov	 DWORD PTR [ebx], esi
  000cf	eb 02		 jmp	 SHORT $LN49@Insert_nod
$LN51@Insert_nod:
  000d1	8b f1		 mov	 esi, ecx
$LN49@Insert_nod:

; 688  :                         _Lrotate(_Pnode);
; 689  :                     }
; 690  : 
; 691  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  000d3	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1

; 692  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  000d7	8b 07		 mov	 eax, DWORD PTR [edi]
  000d9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000dc	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 693  :                     _Rrotate(_Pnode->_Parent->_Parent);

  000e0	8b 07		 mov	 eax, DWORD PTR [edi]
  000e2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 487  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  000e5	8b 31		 mov	 esi, DWORD PTR [ecx]

; 488  :         _Wherenode->_Left = _Pnode->_Right;

  000e7	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ea	89 01		 mov	 DWORD PTR [ecx], eax

; 489  : 
; 490  :         if (!_Pnode->_Right->_Isnil) {

  000ec	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ef	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000f3	75 03		 jne	 SHORT $LN27@Insert_nod

; 491  :             _Pnode->_Right->_Parent = _Wherenode;

  000f5	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN27@Insert_nod:

; 492  :         }
; 493  : 
; 494  :         _Pnode->_Parent = _Wherenode->_Parent;

  000f8	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000fb	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 495  : 
; 496  :         if (_Wherenode == _Myhead->_Parent) {

  000fe	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00101	8b 00		 mov	 eax, DWORD PTR [eax]
  00103	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00106	75 0b		 jne	 SHORT $LN28@Insert_nod

; 497  :             _Myhead->_Parent = _Pnode;

  00108	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 502  :         }
; 503  : 
; 504  :         _Pnode->_Right      = _Wherenode;

  0010b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 694  :                 }
; 695  :             } else { // fixup red-red in right subtree

  0010e	e9 cc 00 00 00	 jmp	 $LN52@Insert_nod
$LN28@Insert_nod:

; 498  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00113	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00116	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00119	75 0b		 jne	 SHORT $LN30@Insert_nod

; 499  :             _Wherenode->_Parent->_Right = _Pnode;

  0011b	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 502  :         }
; 503  : 
; 504  :         _Pnode->_Right      = _Wherenode;

  0011e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 694  :                 }
; 695  :             } else { // fixup red-red in right subtree

  00121	e9 b9 00 00 00	 jmp	 $LN52@Insert_nod
$LN30@Insert_nod:

; 501  :             _Wherenode->_Parent->_Left = _Pnode;

  00126	89 30		 mov	 DWORD PTR [eax], esi

; 502  :         }
; 503  : 
; 504  :         _Pnode->_Right      = _Wherenode;

  00128	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 694  :                 }
; 695  :             } else { // fixup red-red in right subtree

  0012b	e9 af 00 00 00	 jmp	 $LN52@Insert_nod
$LN10@Insert_nod:

; 696  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;
; 697  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00130	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  00134	75 1b		 jne	 SHORT $LN15@Insert_nod
$LN53@Insert_nod:

; 674  :             }
; 675  :         }
; 676  : 
; 677  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  00136	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1
  0013a	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  0013e	8b 07		 mov	 eax, DWORD PTR [edi]
  00140	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00143	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0
  00147	8b 07		 mov	 eax, DWORD PTR [edi]
  00149	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0014c	e9 91 00 00 00	 jmp	 $LN46@Insert_nod
$LN15@Insert_nod:

; 698  :                     _Pnode->_Parent->_Color          = _Black;
; 699  :                     _Parent_sibling->_Color          = _Black;
; 700  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 701  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 702  :                 } else { // parent's sibling has red and black children
; 703  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

  00151	8b 01		 mov	 eax, DWORD PTR [ecx]
  00153	3b d0		 cmp	 edx, eax
  00155	75 3e		 jne	 SHORT $LN39@Insert_nod

; 704  :                         _Pnode = _Pnode->_Parent;

  00157	8b d1		 mov	 edx, ecx

; 487  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  00159	8b c8		 mov	 ecx, eax

; 488  :         _Wherenode->_Left = _Pnode->_Right;

  0015b	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0015e	89 02		 mov	 DWORD PTR [edx], eax

; 489  : 
; 490  :         if (!_Pnode->_Right->_Isnil) {

  00160	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00163	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00167	75 03		 jne	 SHORT $LN34@Insert_nod

; 491  :             _Pnode->_Right->_Parent = _Wherenode;

  00169	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN34@Insert_nod:

; 492  :         }
; 493  : 
; 494  :         _Pnode->_Parent = _Wherenode->_Parent;

  0016c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0016e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 495  : 
; 496  :         if (_Wherenode == _Myhead->_Parent) {

  00171	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00174	8b 00		 mov	 eax, DWORD PTR [eax]
  00176	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00179	75 05		 jne	 SHORT $LN35@Insert_nod

; 497  :             _Myhead->_Parent = _Pnode;

  0017b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0017e	eb 0e		 jmp	 SHORT $LN38@Insert_nod
$LN35@Insert_nod:

; 498  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00180	8b 03		 mov	 eax, DWORD PTR [ebx]
  00182	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  00185	75 05		 jne	 SHORT $LN37@Insert_nod

; 499  :             _Wherenode->_Parent->_Right = _Pnode;

  00187	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 500  :         } else {

  0018a	eb 02		 jmp	 SHORT $LN38@Insert_nod
$LN37@Insert_nod:

; 501  :             _Wherenode->_Parent->_Left = _Pnode;

  0018c	89 08		 mov	 DWORD PTR [eax], ecx
$LN38@Insert_nod:

; 502  :         }
; 503  : 
; 504  :         _Pnode->_Right      = _Wherenode;

  0018e	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 505  :         _Wherenode->_Parent = _Pnode;

  00191	8b fb		 mov	 edi, ebx
  00193	89 0b		 mov	 DWORD PTR [ebx], ecx
$LN39@Insert_nod:

; 705  :                         _Rrotate(_Pnode);
; 706  :                     }
; 707  : 
; 708  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  00195	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 709  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00199	8b 07		 mov	 eax, DWORD PTR [edi]
  0019b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019e	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 710  :                     _Lrotate(_Pnode->_Parent->_Parent);

  001a2	8b 07		 mov	 eax, DWORD PTR [edi]
  001a4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 465  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  001a7	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]

; 466  :         _Wherenode->_Right = _Pnode->_Left;

  001aa	8b 06		 mov	 eax, DWORD PTR [esi]
  001ac	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 467  : 
; 468  :         if (!_Pnode->_Left->_Isnil) {

  001af	8b 06		 mov	 eax, DWORD PTR [esi]
  001b1	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  001b5	75 03		 jne	 SHORT $LN41@Insert_nod

; 469  :             _Pnode->_Left->_Parent = _Wherenode;

  001b7	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN41@Insert_nod:

; 470  :         }
; 471  : 
; 472  :         _Pnode->_Parent = _Wherenode->_Parent;

  001ba	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001bd	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 473  : 
; 474  :         if (_Wherenode == _Myhead->_Parent) {

  001c0	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  001c3	8b 00		 mov	 eax, DWORD PTR [eax]
  001c5	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  001c8	75 05		 jne	 SHORT $LN42@Insert_nod

; 475  :             _Myhead->_Parent = _Pnode;

  001ca	89 70 04	 mov	 DWORD PTR [eax+4], esi
  001cd	eb 0e		 jmp	 SHORT $LN45@Insert_nod
$LN42@Insert_nod:

; 476  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  001cf	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001d2	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001d4	75 04		 jne	 SHORT $LN44@Insert_nod

; 477  :             _Wherenode->_Parent->_Left = _Pnode;

  001d6	89 30		 mov	 DWORD PTR [eax], esi

; 478  :         } else {

  001d8	eb 03		 jmp	 SHORT $LN45@Insert_nod
$LN44@Insert_nod:

; 479  :             _Wherenode->_Parent->_Right = _Pnode;

  001da	89 70 08	 mov	 DWORD PTR [eax+8], esi
$LN45@Insert_nod:

; 480  :         }
; 481  : 
; 482  :         _Pnode->_Left       = _Wherenode;

  001dd	89 0e		 mov	 DWORD PTR [esi], ecx
$LN52@Insert_nod:

; 674  :             }
; 675  :         }
; 676  : 
; 677  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  001df	89 71 04	 mov	 DWORD PTR [ecx+4], esi
$LN46@Insert_nod:
  001e2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001e5	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  001e9	0f 84 71 fe ff
	ff		 je	 $LL2@Insert_nod
  001ef	8b 4d f8	 mov	 ecx, DWORD PTR __Head$1$[ebp]
  001f2	5f		 pop	 edi
  001f3	5e		 pop	 esi
  001f4	5b		 pop	 ebx
$LN3@Insert_nod:

; 711  :                 }
; 712  :             }
; 713  :         }
; 714  : 
; 715  :         _Head->_Parent->_Color = _Black; // root is always black

  001f5	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001f8	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 716  :         return _Newnode;

  001fc	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]

; 717  :     }

  001ff	8b e5		 mov	 esp, ebp
  00201	5d		 pop	 ebp
  00202	c2 0c 00	 ret	 12			; 0000000cH
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@2@QAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> > >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
__Loc$1 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::find, COMDAT
; _this$ = ecx

; 1370 :     _NODISCARD iterator find(const key_type& _Keyval) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi

; 1361 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00008	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  0000b	8d 45 f4	 lea	 eax, DWORD PTR __Loc$1[ebp]

; 1370 :     _NODISCARD iterator find(const key_type& _Keyval) {

  0000e	8b f9		 mov	 edi, ecx

; 1361 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 1599 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00016	8b 75 fc	 mov	 esi, DWORD PTR __Loc$1[ebp+8]
  00019	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0001d	75 20		 jne	 SHORT $LN4@find
  0001f	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef

; 127  :         return _Left < _Right;

  00022	50		 push	 eax
  00023	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  00026	e8 00 00 00 00	 call	 ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
  0002b	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1599 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0002e	84 c0		 test	 al, al
  00030	75 0d		 jne	 SHORT $LN4@find

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00032	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00035	5f		 pop	 edi
  00036	89 30		 mov	 DWORD PTR [eax], esi

; 1371 :         return iterator(_Find(_Keyval), _Get_scary());
; 1372 :     }

  00038	5e		 pop	 esi
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
$LN4@find:

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0003f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1366 :         return _Get_scary()->_Myhead;

  00042	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00044	5f		 pop	 edi

; 1371 :         return iterator(_Find(_Keyval), _Get_scary());
; 1372 :     }

  00045	5e		 pop	 esi

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00046	89 08		 mov	 DWORD PTR [eax], ecx

; 1371 :         return iterator(_Find(_Keyval), _Get_scary());
; 1372 :     }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 28		 jb	 SHORT $LN15@pair
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0000e	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000f	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00015	72 12		 jb	 SHORT $LN25@pair

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00017	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001a	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001d	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001f	83 c0 fc	 add	 eax, -4			; fffffffcH
  00022	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00025	77 60		 ja	 SHORT $LN50@pair

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00027	8b c2		 mov	 eax, edx
$LN25@pair:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00029	51		 push	 ecx
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00030	83 c4 08	 add	 esp, 8
$LN15@pair:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  00033	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0003a	c7 46 2c 0f 00
	00 00		 mov	 DWORD PTR [esi+44], 15	; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00041	c6 46 18 00	 mov	 BYTE PTR [esi+24], 0

; 2319 :         return _BUF_SIZE <= _Myres;

  00045	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00048	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0004b	72 27		 jb	 SHORT $LN43@pair
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0004d	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0004f	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00050	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00056	72 12		 jb	 SHORT $LN53@pair

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00058	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0005b	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0005e	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00060	83 c0 fc	 add	 eax, -4			; fffffffcH
  00063	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00066	77 1f		 ja	 SHORT $LN50@pair

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00068	8b c2		 mov	 eax, edx
$LN53@pair:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0006a	51		 push	 ecx
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00071	83 c4 08	 add	 esp, 8
$LN43@pair:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  00074	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0007b	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00082	c6 06 00	 mov	 BYTE PTR [esi], 0
  00085	5e		 pop	 esi
  00086	c3		 ret	 0
$LN50@pair:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00087	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN58@pair:
  0008c	cc		 int	 3
??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC ; std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 28		 jb	 SHORT $LN15@pair
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0000e	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000f	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00015	72 12		 jb	 SHORT $LN25@pair

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00017	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001a	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001d	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001f	83 c0 fc	 add	 eax, -4			; fffffffcH
  00022	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00025	77 20		 ja	 SHORT $LN22@pair

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00027	8b c2		 mov	 eax, edx
$LN25@pair:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00029	51		 push	 ecx
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00030	83 c4 08	 add	 esp, 8
$LN15@pair:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  00033	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0003a	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00041	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
  00045	5e		 pop	 esi
  00046	c3		 ret	 0
$LN22@pair:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00047	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN31@pair:
  0004c	cc		 int	 3
??1?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@AAY0BC@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0BC@$$CBD@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
__My_data$1$ = -40					; size = 4
__Newsize$1$ = -36					; size = 4
tv428 = -32						; size = 4
__Whereoff$1$ = -28					; size = 4
__Constructed_last$ = -28				; size = 4
$T2 = -24						; size = 4
__Newcapacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@AAY0BC@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0BC@$$CBD@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<char const (&)[18]>, COMDAT
; _this$ = ecx

; 765  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@AAY0BC@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0BC@$$CBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b d9		 mov	 ebx, ecx
  0002d	89 5d d4	 mov	 DWORD PTR _this$[ebp], ebx

; 766  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 767  :         _Alty& _Al        = _Getal();
; 768  :         auto& _My_data    = _Mypair._Myval2;
; 769  :         pointer& _Myfirst = _My_data._Myfirst;
; 770  :         pointer& _Mylast  = _My_data._Mylast;
; 771  : 
; 772  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 773  : 
; 774  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00030	8b 33		 mov	 esi, DWORD PTR [ebx]
  00032	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00037	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]

; 775  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  0003a	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0003d	2b d6		 sub	 edx, esi
  0003f	f7 ea		 imul	 edx
  00041	2b ce		 sub	 ecx, esi
  00043	c1 fa 02	 sar	 edx, 2
  00046	8b c2		 mov	 eax, edx
  00048	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0004b	03 c2		 add	 eax, edx
  0004d	89 45 e4	 mov	 DWORD PTR __Whereoff$1$[ebp], eax
  00050	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00055	f7 e9		 imul	 ecx
  00057	c1 fa 02	 sar	 edx, 2
  0005a	8b c2		 mov	 eax, edx
  0005c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0005f	03 c2		 add	 eax, edx

; 776  : 
; 777  :         if (_Oldsize == max_size()) {

  00061	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  00066	0f 84 54 01 00
	00		 je	 $LN64@Emplace_re

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0006c	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

  0006f	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00072	2b ce		 sub	 ecx, esi

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

  00074	89 7d dc	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00077	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0007c	f7 e9		 imul	 ecx

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0007e	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00083	c1 fa 02	 sar	 edx, 2
  00086	8b ca		 mov	 ecx, edx
  00088	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0008b	03 ca		 add	 ecx, edx

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0008d	8b d1		 mov	 edx, ecx
  0008f	d1 ea		 shr	 edx, 1
  00091	2b c2		 sub	 eax, edx
  00093	3b c8		 cmp	 ecx, eax
  00095	76 1a		 jbe	 SHORT $LN12@Emplace_re

; 1689 :             return _Max; // geometric growth would overflow

  00097	b8 f0 ff ff ff	 mov	 eax, -16		; fffffff0H
  0009c	be aa aa aa 0a	 mov	 esi, 178956970		; 0aaaaaaaH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a1	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1689 :             return _Max; // geometric growth would overflow

  000a2	89 75 ec	 mov	 DWORD PTR __Newcapacity$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a5	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000aa	83 c4 04	 add	 esp, 4
  000ad	8b f8		 mov	 edi, eax
  000af	eb 49		 jmp	 SHORT $LN61@Emplace_re
$LN12@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  000b1	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 64   :         if (_Count > _Max_possible) {

  000b4	8b f7		 mov	 esi, edi
  000b6	3b c7		 cmp	 eax, edi
  000b8	0f 43 f0	 cmovae	 esi, eax
  000bb	81 fe aa aa aa
	0a		 cmp	 esi, 178956970		; 0aaaaaaaH
  000c1	0f 87 fe 00 00
	00		 ja	 $LN65@Emplace_re

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  000c7	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  000ca	89 75 ec	 mov	 DWORD PTR __Newcapacity$[ebp], esi
  000cd	c1 e0 03	 shl	 eax, 3

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000d0	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000d5	72 0d		 jb	 SHORT $LN24@Emplace_re

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000dd	83 c4 04	 add	 esp, 4
  000e0	8b f8		 mov	 edi, eax
  000e2	eb 16		 jmp	 SHORT $LN61@Emplace_re
$LN24@Emplace_re:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  000e4	85 c0		 test	 eax, eax
  000e6	74 0d		 je	 SHORT $LN25@Emplace_re

; 85   :         return ::operator new(_Bytes);

  000e8	50		 push	 eax
  000e9	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000ee	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  000f1	8b f8		 mov	 edi, eax
  000f3	eb 02		 jmp	 SHORT $LN62@Emplace_re
$LN25@Emplace_re:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000f5	33 ff		 xor	 edi, edi
$LN62@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 785  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  000f7	89 75 ec	 mov	 DWORD PTR __Newcapacity$[ebp], esi
$LN61@Emplace_re:
  000fa	8b 45 e4	 mov	 eax, DWORD PTR __Whereoff$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  000fd	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Val_0>$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 785  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  00100	89 7d e8	 mov	 DWORD PTR $T2[ebp], edi

; 786  :         pointer _Constructed_first      = _Constructed_last;
; 787  : 
; 788  :         _TRY_BEGIN

  00103	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0010a	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0010d	8d 14 c7	 lea	 edx, DWORD PTR [edi+eax*8]
  00110	8d 42 18	 lea	 eax, DWORD PTR [edx+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00113	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 785  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  00119	89 45 e4	 mov	 DWORD PTR __Constructed_last$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0011c	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 785  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0011f	89 55 d8	 mov	 DWORD PTR __My_data$1$[ebp], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4596 :         _My_data._Mysize = 0;

  00122	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00129	c7 42 14 0f 00
	00 00		 mov	 DWORD PTR [edx+20], 15	; 0000000fH

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00130	89 45 e0	 mov	 DWORD PTR tv428[ebp], eax
$LL58@Emplace_re:
  00133	8a 01		 mov	 al, BYTE PTR [ecx]
  00135	41		 inc	 ecx
  00136	84 c0		 test	 al, al
  00138	75 f9		 jne	 SHORT $LL58@Emplace_re
  0013a	2b 4d e0	 sub	 ecx, DWORD PTR tv428[ebp]

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0013d	51		 push	 ecx
  0013e	ff 75 0c	 push	 DWORD PTR _<_Val_0>$[ebp]
  00141	8b ca		 mov	 ecx, edx
  00143	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 792  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00148	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0014b	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
  0014e	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00150	3b d0		 cmp	 edx, eax
  00152	75 04		 jne	 SHORT $LN4@Emplace_re

; 1664 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00154	8b d7		 mov	 edx, edi

; 793  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 794  :         } else { // provide basic guarantee

  00156	eb 15		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 1659 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00158	53		 push	 ebx
  00159	57		 push	 edi
  0015a	52		 push	 edx
  0015b	51		 push	 ecx
  0015c	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00161	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00164	83 c4 10	 add	 esp, 16			; 00000010H
  00167	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0016a	8b 55 e4	 mov	 edx, DWORD PTR __Constructed_last$[ebp]
$LN5@Emplace_re:

; 795  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 796  :             _Constructed_first = _Newvec;
; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  0016d	53		 push	 ebx
  0016e	52		 push	 edx
  0016f	50		 push	 eax
  00170	51		 push	 ecx
  00171	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00176	83 c4 10	 add	 esp, 16			; 00000010H

; 803  :         _CATCH_END
; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00179	8b cb		 mov	 ecx, ebx
  0017b	56		 push	 esi
  0017c	ff 75 dc	 push	 DWORD PTR __Newsize$1$[ebp]
  0017f	57		 push	 edi
  00180	e8 00 00 00 00	 call	 ?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array

; 806  :         return _Newvec + _Whereoff;

  00185	8b 45 d8	 mov	 eax, DWORD PTR __My_data$1$[ebp]

; 807  :     }

  00188	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0018b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00192	59		 pop	 ecx
  00193	5f		 pop	 edi
  00194	5e		 pop	 esi
  00195	5b		 pop	 ebx
  00196	8b e5		 mov	 esp, ebp
  00198	5d		 pop	 ebp
  00199	c2 08 00	 ret	 8
__catch$??$_Emplace_reallocate@AAY0BC@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0BC@$$CBD@Z$0:

; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);

  0019c	8b 45 e4	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0019f	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  001a2	50		 push	 eax
  001a3	50		 push	 eax
  001a4	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy

; 801  :         _Al.deallocate(_Newvec, _Newcapacity);

  001a9	ff 75 ec	 push	 DWORD PTR __Newcapacity$[ebp]
  001ac	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  001af	ff 75 e8	 push	 DWORD PTR $T2[ebp]
  001b2	e8 00 00 00 00	 call	 ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate

; 802  :         _RERAISE;

  001b7	6a 00		 push	 0
  001b9	6a 00		 push	 0
  001bb	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN64@Emplace_re:

; 778  :             _Xlength();

  001c0	e8 00 00 00 00	 call	 ?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
$LN65@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  001c5	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN60@Emplace_re:
  001ca	cc		 int	 3
  001cb	cc		 int	 3
  001cc	cc		 int	 3
  001cd	cc		 int	 3
  001ce	cc		 int	 3
  001cf	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@AAY0BC@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0BC@$$CBD@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@AAY0BC@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0BC@$$CBD@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@AAY0BC@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0BC@$$CBD@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<char const (&)[18]>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@AAY0BC@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?A_TAAY0BC@$$CBD@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@AAY0BC@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?A_TAAY0BC@$$CBD@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::emplace_back<char const (&)[18]>, COMDAT
; _this$ = ecx

; 739  :     _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 740  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 741  :         auto& _My_data   = _Mypair._Myval2;
; 742  :         pointer& _Mylast = _My_data._Mylast;
; 743  :         if (_Mylast != _My_data._Myend) {

  00006	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00009	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0000c	74 3e		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0000e	8b 55 08	 mov	 edx, DWORD PTR _<_Val_0>$[ebp]

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00011	53		 push	 ebx
  00012	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 4596 :         _My_data._Mysize = 0;

  00018	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0001f	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00026	8d 5a 01	 lea	 ebx, DWORD PTR [edx+1]
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL24@emplace_ba:
  00030	8a 02		 mov	 al, BYTE PTR [edx]
  00032	42		 inc	 edx
  00033	84 c0		 test	 al, al
  00035	75 f9		 jne	 SHORT $LL24@emplace_ba
  00037	2b d3		 sub	 edx, ebx

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00039	52		 push	 edx
  0003a	ff 75 08	 push	 DWORD PTR _<_Val_0>$[ebp]
  0003d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 729  :         ++_Mylast;

  00042	83 46 04 18	 add	 DWORD PTR [esi+4], 24	; 00000018H
  00046	5b		 pop	 ebx
  00047	5e		 pop	 esi

; 748  : #if _HAS_CXX17
; 749  :         return _Result;
; 750  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 751  :         (void) _Result;
; 752  : #endif // _HAS_CXX17
; 753  :     }

  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
$LN2@emplace_ba:

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0004c	ff 75 08	 push	 DWORD PTR _<_Val_0>$[ebp]
  0004f	51		 push	 ecx
  00050	8b ce		 mov	 ecx, esi
  00052	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@AAY0BC@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0BC@$$CBD@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<char const (&)[18]>
  00057	5e		 pop	 esi

; 748  : #if _HAS_CXX17
; 749  :         return _Result;
; 750  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 751  :         (void) _Result;
; 752  : #endif // _HAS_CXX17
; 753  :     }

  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
??$emplace_back@AAY0BC@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?A_TAAY0BC@$$CBD@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::emplace_back<char const (&)[18]>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@AAY0O@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0O@$$CBD@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
__My_data$1$ = -40					; size = 4
__Newsize$1$ = -36					; size = 4
tv428 = -32						; size = 4
__Whereoff$1$ = -28					; size = 4
__Constructed_last$ = -28				; size = 4
$T2 = -24						; size = 4
__Newcapacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@AAY0O@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0O@$$CBD@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<char const (&)[14]>, COMDAT
; _this$ = ecx

; 765  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@AAY0O@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0O@$$CBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b d9		 mov	 ebx, ecx
  0002d	89 5d d4	 mov	 DWORD PTR _this$[ebp], ebx

; 766  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 767  :         _Alty& _Al        = _Getal();
; 768  :         auto& _My_data    = _Mypair._Myval2;
; 769  :         pointer& _Myfirst = _My_data._Myfirst;
; 770  :         pointer& _Mylast  = _My_data._Mylast;
; 771  : 
; 772  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 773  : 
; 774  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00030	8b 33		 mov	 esi, DWORD PTR [ebx]
  00032	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00037	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]

; 775  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  0003a	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0003d	2b d6		 sub	 edx, esi
  0003f	f7 ea		 imul	 edx
  00041	2b ce		 sub	 ecx, esi
  00043	c1 fa 02	 sar	 edx, 2
  00046	8b c2		 mov	 eax, edx
  00048	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0004b	03 c2		 add	 eax, edx
  0004d	89 45 e4	 mov	 DWORD PTR __Whereoff$1$[ebp], eax
  00050	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00055	f7 e9		 imul	 ecx
  00057	c1 fa 02	 sar	 edx, 2
  0005a	8b c2		 mov	 eax, edx
  0005c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0005f	03 c2		 add	 eax, edx

; 776  : 
; 777  :         if (_Oldsize == max_size()) {

  00061	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  00066	0f 84 54 01 00
	00		 je	 $LN64@Emplace_re

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0006c	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

  0006f	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00072	2b ce		 sub	 ecx, esi

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

  00074	89 7d dc	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00077	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0007c	f7 e9		 imul	 ecx

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0007e	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00083	c1 fa 02	 sar	 edx, 2
  00086	8b ca		 mov	 ecx, edx
  00088	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0008b	03 ca		 add	 ecx, edx

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0008d	8b d1		 mov	 edx, ecx
  0008f	d1 ea		 shr	 edx, 1
  00091	2b c2		 sub	 eax, edx
  00093	3b c8		 cmp	 ecx, eax
  00095	76 1a		 jbe	 SHORT $LN12@Emplace_re

; 1689 :             return _Max; // geometric growth would overflow

  00097	b8 f0 ff ff ff	 mov	 eax, -16		; fffffff0H
  0009c	be aa aa aa 0a	 mov	 esi, 178956970		; 0aaaaaaaH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a1	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1689 :             return _Max; // geometric growth would overflow

  000a2	89 75 ec	 mov	 DWORD PTR __Newcapacity$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a5	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000aa	83 c4 04	 add	 esp, 4
  000ad	8b f8		 mov	 edi, eax
  000af	eb 49		 jmp	 SHORT $LN61@Emplace_re
$LN12@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  000b1	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 64   :         if (_Count > _Max_possible) {

  000b4	8b f7		 mov	 esi, edi
  000b6	3b c7		 cmp	 eax, edi
  000b8	0f 43 f0	 cmovae	 esi, eax
  000bb	81 fe aa aa aa
	0a		 cmp	 esi, 178956970		; 0aaaaaaaH
  000c1	0f 87 fe 00 00
	00		 ja	 $LN65@Emplace_re

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  000c7	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  000ca	89 75 ec	 mov	 DWORD PTR __Newcapacity$[ebp], esi
  000cd	c1 e0 03	 shl	 eax, 3

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000d0	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000d5	72 0d		 jb	 SHORT $LN24@Emplace_re

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000dd	83 c4 04	 add	 esp, 4
  000e0	8b f8		 mov	 edi, eax
  000e2	eb 16		 jmp	 SHORT $LN61@Emplace_re
$LN24@Emplace_re:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  000e4	85 c0		 test	 eax, eax
  000e6	74 0d		 je	 SHORT $LN25@Emplace_re

; 85   :         return ::operator new(_Bytes);

  000e8	50		 push	 eax
  000e9	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000ee	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  000f1	8b f8		 mov	 edi, eax
  000f3	eb 02		 jmp	 SHORT $LN62@Emplace_re
$LN25@Emplace_re:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000f5	33 ff		 xor	 edi, edi
$LN62@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 785  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  000f7	89 75 ec	 mov	 DWORD PTR __Newcapacity$[ebp], esi
$LN61@Emplace_re:
  000fa	8b 45 e4	 mov	 eax, DWORD PTR __Whereoff$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  000fd	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Val_0>$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 785  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  00100	89 7d e8	 mov	 DWORD PTR $T2[ebp], edi

; 786  :         pointer _Constructed_first      = _Constructed_last;
; 787  : 
; 788  :         _TRY_BEGIN

  00103	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0010a	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0010d	8d 14 c7	 lea	 edx, DWORD PTR [edi+eax*8]
  00110	8d 42 18	 lea	 eax, DWORD PTR [edx+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00113	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 785  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  00119	89 45 e4	 mov	 DWORD PTR __Constructed_last$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0011c	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 785  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0011f	89 55 d8	 mov	 DWORD PTR __My_data$1$[ebp], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4596 :         _My_data._Mysize = 0;

  00122	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00129	c7 42 14 0f 00
	00 00		 mov	 DWORD PTR [edx+20], 15	; 0000000fH

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00130	89 45 e0	 mov	 DWORD PTR tv428[ebp], eax
$LL58@Emplace_re:
  00133	8a 01		 mov	 al, BYTE PTR [ecx]
  00135	41		 inc	 ecx
  00136	84 c0		 test	 al, al
  00138	75 f9		 jne	 SHORT $LL58@Emplace_re
  0013a	2b 4d e0	 sub	 ecx, DWORD PTR tv428[ebp]

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0013d	51		 push	 ecx
  0013e	ff 75 0c	 push	 DWORD PTR _<_Val_0>$[ebp]
  00141	8b ca		 mov	 ecx, edx
  00143	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 792  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00148	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0014b	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
  0014e	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00150	3b d0		 cmp	 edx, eax
  00152	75 04		 jne	 SHORT $LN4@Emplace_re

; 1664 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00154	8b d7		 mov	 edx, edi

; 793  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 794  :         } else { // provide basic guarantee

  00156	eb 15		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 1659 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00158	53		 push	 ebx
  00159	57		 push	 edi
  0015a	52		 push	 edx
  0015b	51		 push	 ecx
  0015c	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00161	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00164	83 c4 10	 add	 esp, 16			; 00000010H
  00167	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0016a	8b 55 e4	 mov	 edx, DWORD PTR __Constructed_last$[ebp]
$LN5@Emplace_re:

; 795  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 796  :             _Constructed_first = _Newvec;
; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  0016d	53		 push	 ebx
  0016e	52		 push	 edx
  0016f	50		 push	 eax
  00170	51		 push	 ecx
  00171	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00176	83 c4 10	 add	 esp, 16			; 00000010H

; 803  :         _CATCH_END
; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00179	8b cb		 mov	 ecx, ebx
  0017b	56		 push	 esi
  0017c	ff 75 dc	 push	 DWORD PTR __Newsize$1$[ebp]
  0017f	57		 push	 edi
  00180	e8 00 00 00 00	 call	 ?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array

; 806  :         return _Newvec + _Whereoff;

  00185	8b 45 d8	 mov	 eax, DWORD PTR __My_data$1$[ebp]

; 807  :     }

  00188	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0018b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00192	59		 pop	 ecx
  00193	5f		 pop	 edi
  00194	5e		 pop	 esi
  00195	5b		 pop	 ebx
  00196	8b e5		 mov	 esp, ebp
  00198	5d		 pop	 ebp
  00199	c2 08 00	 ret	 8
__catch$??$_Emplace_reallocate@AAY0O@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0O@$$CBD@Z$0:

; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);

  0019c	8b 45 e4	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0019f	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  001a2	50		 push	 eax
  001a3	50		 push	 eax
  001a4	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy

; 801  :         _Al.deallocate(_Newvec, _Newcapacity);

  001a9	ff 75 ec	 push	 DWORD PTR __Newcapacity$[ebp]
  001ac	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  001af	ff 75 e8	 push	 DWORD PTR $T2[ebp]
  001b2	e8 00 00 00 00	 call	 ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate

; 802  :         _RERAISE;

  001b7	6a 00		 push	 0
  001b9	6a 00		 push	 0
  001bb	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN64@Emplace_re:

; 778  :             _Xlength();

  001c0	e8 00 00 00 00	 call	 ?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
$LN65@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  001c5	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN60@Emplace_re:
  001ca	cc		 int	 3
  001cb	cc		 int	 3
  001cc	cc		 int	 3
  001cd	cc		 int	 3
  001ce	cc		 int	 3
  001cf	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@AAY0O@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0O@$$CBD@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@AAY0O@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0O@$$CBD@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@AAY0O@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0O@$$CBD@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<char const (&)[14]>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@AAY0O@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?A_TAAY0O@$$CBD@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@AAY0O@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?A_TAAY0O@$$CBD@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::emplace_back<char const (&)[14]>, COMDAT
; _this$ = ecx

; 739  :     _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 740  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 741  :         auto& _My_data   = _Mypair._Myval2;
; 742  :         pointer& _Mylast = _My_data._Mylast;
; 743  :         if (_Mylast != _My_data._Myend) {

  00006	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00009	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0000c	74 3e		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0000e	8b 55 08	 mov	 edx, DWORD PTR _<_Val_0>$[ebp]

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00011	53		 push	 ebx
  00012	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 4596 :         _My_data._Mysize = 0;

  00018	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0001f	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00026	8d 5a 01	 lea	 ebx, DWORD PTR [edx+1]
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL24@emplace_ba:
  00030	8a 02		 mov	 al, BYTE PTR [edx]
  00032	42		 inc	 edx
  00033	84 c0		 test	 al, al
  00035	75 f9		 jne	 SHORT $LL24@emplace_ba
  00037	2b d3		 sub	 edx, ebx

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00039	52		 push	 edx
  0003a	ff 75 08	 push	 DWORD PTR _<_Val_0>$[ebp]
  0003d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 729  :         ++_Mylast;

  00042	83 46 04 18	 add	 DWORD PTR [esi+4], 24	; 00000018H
  00046	5b		 pop	 ebx
  00047	5e		 pop	 esi

; 748  : #if _HAS_CXX17
; 749  :         return _Result;
; 750  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 751  :         (void) _Result;
; 752  : #endif // _HAS_CXX17
; 753  :     }

  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
$LN2@emplace_ba:

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0004c	ff 75 08	 push	 DWORD PTR _<_Val_0>$[ebp]
  0004f	51		 push	 ecx
  00050	8b ce		 mov	 ecx, esi
  00052	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@AAY0O@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0O@$$CBD@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<char const (&)[14]>
  00057	5e		 pop	 esi

; 748  : #if _HAS_CXX17
; 749  :         return _Result;
; 750  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 751  :         (void) _Result;
; 752  : #endif // _HAS_CXX17
; 753  :     }

  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
??$emplace_back@AAY0O@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?A_TAAY0O@$$CBD@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::emplace_back<char const (&)[14]>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
;	COMDAT ?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
$T2 = -40						; size = 24
$T3 = -40						; size = 24
$T4 = -40						; size = 24
$T5 = -40						; size = 24
$T6 = -40						; size = 24
$T7 = -40						; size = 24
$T8 = -40						; size = 24
$T9 = -40						; size = 24
$T10 = -40						; size = 24
$T11 = -40						; size = 24
$T12 = -40						; size = 24
$T13 = -40						; size = 24
$T14 = -40						; size = 24
$T15 = -40						; size = 24
$T16 = -40						; size = 24
$T17 = -40						; size = 24
$T18 = -40						; size = 24
$T19 = -40						; size = 24
$T20 = -40						; size = 24
$T21 = -40						; size = 24
$T22 = -40						; size = 24
$T23 = -40						; size = 24
$T24 = -40						; size = 24
$T25 = -40						; size = 24
$T26 = -40						; size = 24
$T27 = -40						; size = 24
$T28 = -40						; size = 24
$T29 = -40						; size = 24
$T30 = -40						; size = 24
$T31 = -40						; size = 24
$T32 = -40						; size = 24
$T33 = -40						; size = 24
$T34 = -40						; size = 24
$T35 = -40						; size = 24
$T36 = -40						; size = 24
$T37 = -40						; size = 24
$T38 = -40						; size = 24
$T39 = -40						; size = 24
$T40 = -40						; size = 24
$T41 = -40						; size = 24
$T42 = -40						; size = 24
$T43 = -40						; size = 24
$T44 = -40						; size = 24
$T45 = -40						; size = 24
$T46 = -40						; size = 24
$T47 = -40						; size = 24
$T48 = -40						; size = 24
$T49 = -40						; size = 24
$T50 = -40						; size = 24
$T51 = -40						; size = 24
$T52 = -40						; size = 24
$T53 = -40						; size = 24
$T54 = -40						; size = 24
$T55 = -40						; size = 24
$T56 = -40						; size = 24
$T57 = -40						; size = 24
$T58 = -40						; size = 24
$T59 = -40						; size = 24
$T60 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_race$ = 8						; size = 4
_vec_stPathes$ = 12					; size = 4
?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z PROC ; __GetRaceResourcePathes, COMDAT

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 27   : 	if (__IsGuildRace(race))

  0002a	8b 7d 08	 mov	 edi, DWORD PTR _race$[ebp]
  0002d	8b 75 0c	 mov	 esi, DWORD PTR _vec_stPathes$[ebp]
  00030	57		 push	 edi
  00031	e8 00 00 00 00	 call	 ?__IsGuildRace@@YA_NI@Z	; __IsGuildRace
  00036	83 c4 04	 add	 esp, 4
  00039	84 c0		 test	 al, al
  0003b	0f 84 f5 02 00
	00		 je	 $LN2@GetRaceRes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00041	6a 13		 push	 19			; 00000013H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00043	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T60[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0004a	8d 4d d8	 lea	 ecx, DWORD PTR $T60[ebp]
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@PJNPAGEJ@d?3?1ymir?5work?1guild?1@

; 4596 :         _My_data._Mysize = 0;

  00052	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T60[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00059	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T60[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00060	c6 45 d8 00	 mov	 BYTE PTR $T60[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00064	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 29   : 		vec_stPathes.push_back ("d:/ymir work/guild/");

  00069	8d 45 d8	 lea	 eax, DWORD PTR $T60[ebp]
  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00073	50		 push	 eax
  00074	8b ce		 mov	 ecx, esi
  00076	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0007b	8b 55 ec	 mov	 edx, DWORD PTR $T60[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 29   : 		vec_stPathes.push_back ("d:/ymir work/guild/");

  0007e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00085	83 fa 10	 cmp	 edx, 16			; 00000010H
  00088	72 2c		 jb	 SHORT $LN109@GetRaceRes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0008a	8b 4d d8	 mov	 ecx, DWORD PTR $T60[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0008d	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0008e	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00090	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00096	72 14		 jb	 SHORT $LN119@GetRaceRes

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00098	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0009b	83 c2 23	 add	 edx, 35			; 00000023H
  0009e	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000a0	83 c0 fc	 add	 eax, -4			; fffffffcH
  000a3	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000a6	0f 87 2b 12 00
	00		 ja	 $LN1407@GetRaceRes
$LN119@GetRaceRes:

; 264  :         ::operator delete(_Ptr, _Bytes);

  000ac	52		 push	 edx
  000ad	51		 push	 ecx
  000ae	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000b3	83 c4 08	 add	 esp, 8
$LN109@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000b6	6a 11		 push	 17			; 00000011H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  000b8	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T59[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000bf	8d 4d d8	 lea	 ecx, DWORD PTR $T59[ebp]
  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@HJMPPIOH@d?3?1ymir?5work?1npc?1@

; 4596 :         _My_data._Mysize = 0;

  000c7	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T59[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  000ce	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T59[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  000d5	c6 45 d8 00	 mov	 BYTE PTR $T59[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000d9	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 30   : 		vec_stPathes.push_back ("d:/ymir work/npc/");

  000de	8d 45 d8	 lea	 eax, DWORD PTR $T59[ebp]
  000e1	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000e8	50		 push	 eax
  000e9	8b ce		 mov	 ecx, esi
  000eb	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  000f0	8b 55 ec	 mov	 edx, DWORD PTR $T59[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 30   : 		vec_stPathes.push_back ("d:/ymir work/npc/");

  000f3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  000fa	83 fa 10	 cmp	 edx, 16			; 00000010H
  000fd	72 2c		 jb	 SHORT $LN153@GetRaceRes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000ff	8b 4d d8	 mov	 ecx, DWORD PTR $T59[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00102	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00103	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00105	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0010b	72 14		 jb	 SHORT $LN163@GetRaceRes

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0010d	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00110	83 c2 23	 add	 edx, 35			; 00000023H
  00113	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00115	83 c0 fc	 add	 eax, -4			; fffffffcH
  00118	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0011b	0f 87 b6 11 00
	00		 ja	 $LN1407@GetRaceRes
$LN163@GetRaceRes:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00121	52		 push	 edx
  00122	51		 push	 ecx
  00123	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00128	83 c4 08	 add	 esp, 8
$LN153@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0012b	6a 12		 push	 18			; 00000012H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0012d	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T58[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00134	8d 4d d8	 lea	 ecx, DWORD PTR $T58[ebp]
  00137	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DIPFLAGN@d?3?1ymir?5work?1npc2?1@

; 4596 :         _My_data._Mysize = 0;

  0013c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T58[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00143	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T58[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0014a	c6 45 d8 00	 mov	 BYTE PTR $T58[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0014e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 31   : 		vec_stPathes.push_back ("d:/ymir work/npc2/");

  00153	8d 45 d8	 lea	 eax, DWORD PTR $T58[ebp]
  00156	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  0015d	50		 push	 eax
  0015e	8b ce		 mov	 ecx, esi
  00160	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00165	8b 55 ec	 mov	 edx, DWORD PTR $T58[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 31   : 		vec_stPathes.push_back ("d:/ymir work/npc2/");

  00168	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0016f	83 fa 10	 cmp	 edx, 16			; 00000010H
  00172	72 2c		 jb	 SHORT $LN196@GetRaceRes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00174	8b 4d d8	 mov	 ecx, DWORD PTR $T58[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00177	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00178	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0017a	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00180	72 14		 jb	 SHORT $LN206@GetRaceRes

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00182	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00185	83 c2 23	 add	 edx, 35			; 00000023H
  00188	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0018a	83 c0 fc	 add	 eax, -4			; fffffffcH
  0018d	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00190	0f 87 41 11 00
	00		 ja	 $LN1407@GetRaceRes
$LN206@GetRaceRes:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00196	52		 push	 edx
  00197	51		 push	 ecx
  00198	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0019d	83 c4 08	 add	 esp, 8
$LN196@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  001a0	6a 15		 push	 21			; 00000015H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  001a2	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T57[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  001a9	8d 4d d8	 lea	 ecx, DWORD PTR $T57[ebp]
  001ac	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@CKCIELCO@d?3?1ymir?5work?1npc_pet?1@

; 4596 :         _My_data._Mysize = 0;

  001b1	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T57[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  001b8	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T57[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  001bf	c6 45 d8 00	 mov	 BYTE PTR $T57[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  001c3	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 32   : 		vec_stPathes.push_back ("d:/ymir work/npc_pet/");

  001c8	8d 45 d8	 lea	 eax, DWORD PTR $T57[ebp]
  001cb	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  001d2	50		 push	 eax
  001d3	8b ce		 mov	 ecx, esi
  001d5	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  001da	8b 55 ec	 mov	 edx, DWORD PTR $T57[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 32   : 		vec_stPathes.push_back ("d:/ymir work/npc_pet/");

  001dd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  001e4	83 fa 10	 cmp	 edx, 16			; 00000010H
  001e7	72 2c		 jb	 SHORT $LN239@GetRaceRes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001e9	8b 4d d8	 mov	 ecx, DWORD PTR $T57[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  001ec	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001ed	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  001ef	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001f5	72 14		 jb	 SHORT $LN249@GetRaceRes

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001f7	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  001fa	83 c2 23	 add	 edx, 35			; 00000023H
  001fd	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001ff	83 c0 fc	 add	 eax, -4			; fffffffcH
  00202	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00205	0f 87 cc 10 00
	00		 ja	 $LN1407@GetRaceRes
$LN249@GetRaceRes:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0020b	52		 push	 edx
  0020c	51		 push	 ecx
  0020d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00212	83 c4 08	 add	 esp, 8
$LN239@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00215	6a 15		 push	 21			; 00000015H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00217	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T56[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0021e	8d 4d d8	 lea	 ecx, DWORD PTR $T56[ebp]
  00221	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FGIKCKJD@d?3?1ymir?5work?1monster?1@

; 4596 :         _My_data._Mysize = 0;

  00226	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T56[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0022d	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T56[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00234	c6 45 d8 00	 mov	 BYTE PTR $T56[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00238	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 33   : 		vec_stPathes.push_back ("d:/ymir work/monster/");

  0023d	8d 45 d8	 lea	 eax, DWORD PTR $T56[ebp]
  00240	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4
  00247	50		 push	 eax
  00248	8b ce		 mov	 ecx, esi
  0024a	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0024f	8b 55 ec	 mov	 edx, DWORD PTR $T56[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 33   : 		vec_stPathes.push_back ("d:/ymir work/monster/");

  00252	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00259	83 fa 10	 cmp	 edx, 16			; 00000010H
  0025c	72 2c		 jb	 SHORT $LN282@GetRaceRes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0025e	8b 4d d8	 mov	 ecx, DWORD PTR $T56[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00261	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00262	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00264	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0026a	72 14		 jb	 SHORT $LN292@GetRaceRes

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0026c	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0026f	83 c2 23	 add	 edx, 35			; 00000023H
  00272	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00274	83 c0 fc	 add	 eax, -4			; fffffffcH
  00277	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0027a	0f 87 57 10 00
	00		 ja	 $LN1407@GetRaceRes
$LN292@GetRaceRes:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00280	52		 push	 edx
  00281	51		 push	 ecx
  00282	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00287	83 c4 08	 add	 esp, 8
$LN282@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0028a	6a 16		 push	 22			; 00000016H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0028c	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T55[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00293	8d 4d d8	 lea	 ecx, DWORD PTR $T55[ebp]
  00296	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@GPLCEAJK@d?3?1ymir?5work?1monster2?1@

; 4596 :         _My_data._Mysize = 0;

  0029b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T55[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  002a2	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T55[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  002a9	c6 45 d8 00	 mov	 BYTE PTR $T55[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  002ad	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 34   : 		vec_stPathes.push_back ("d:/ymir work/monster2/");

  002b2	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5
$LN1448@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  002b9	8d 45 d8	 lea	 eax, DWORD PTR $T55[ebp]
  002bc	8b ce		 mov	 ecx, esi
  002be	50		 push	 eax
  002bf	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  002c4	8b 55 ec	 mov	 edx, DWORD PTR $T55[ebp+20]
  002c7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  002ce	83 fa 10	 cmp	 edx, 16			; 00000010H
  002d1	72 2c		 jb	 SHORT $LN1400@GetRaceRes
  002d3	8b 4d d8	 mov	 ecx, DWORD PTR $T55[ebp]
  002d6	42		 inc	 edx
  002d7	8b c1		 mov	 eax, ecx
  002d9	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  002df	72 14		 jb	 SHORT $LN1410@GetRaceRes
  002e1	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  002e4	83 c2 23	 add	 edx, 35			; 00000023H
  002e7	2b c1		 sub	 eax, ecx
  002e9	83 c0 fc	 add	 eax, -4			; fffffffcH
  002ec	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  002ef	0f 87 e2 0f 00
	00		 ja	 $LN1407@GetRaceRes
$LN1410@GetRaceRes:
  002f5	52		 push	 edx
  002f6	51		 push	 ecx
  002f7	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  002fc	83 c4 08	 add	 esp, 8
$LN1400@GetRaceRes:
  002ff	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00302	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00305	0f 84 80 0f 00
	00		 je	 $LN1416@GetRaceRes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0030b	6a 0d		 push	 13			; 0000000dH
  0030d	68 00 00 00 00	 push	 OFFSET ??_C@_0O@PEPGGFH@?$CDseason1?1npc?1@
  00312	8b c8		 mov	 ecx, eax

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00314	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 4596 :         _My_data._Mysize = 0;

  0031a	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00321	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00328	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 729  :         ++_Mylast;

  0032d	83 46 04 18	 add	 DWORD PTR [esi+4], 24	; 00000018H

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00331	e9 62 0f 00 00	 jmp	 $LN1415@GetRaceRes
$LN2@GetRaceRes:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 36   : 	else if (__IsNPCRace(race))

  00336	57		 push	 edi
  00337	e8 00 00 00 00	 call	 ?__IsNPCRace@@YA_NI@Z	; __IsNPCRace
  0033c	83 c4 04	 add	 esp, 4
  0033f	84 c0		 test	 al, al
  00341	0f 84 0c 07 00
	00		 je	 $LN4@GetRaceRes

; 37   : 	{
; 38   : 		if (race >= 30000)

  00347	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T54[ebp], 0
  0034e	8d 4d d8	 lea	 ecx, DWORD PTR $T54[ebp]
  00351	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T54[ebp+16], 0
  00358	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T54[ebp+20], 15 ; 0000000fH
  0035f	c6 45 d8 00	 mov	 BYTE PTR $T54[ebp], 0
  00363	81 ff 30 75 00
	00		 cmp	 edi, 30000		; 00007530H
  00369	0f 82 72 03 00
	00		 jb	 $LN6@GetRaceRes

; 39   : 		{
; 40   : 			if (race>=34028 && race<=34099) // last known 34072

  0036f	8d 87 14 7b ff
	ff		 lea	 eax, DWORD PTR [edi-34028]
  00375	83 f8 47	 cmp	 eax, 71			; 00000047H
  00378	0f 87 8d 00 00
	00		 ja	 $LN8@GetRaceRes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0037e	6a 15		 push	 21			; 00000015H
  00380	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@CKCIELCO@d?3?1ymir?5work?1npc_pet?1@
  00385	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 42   : 				vec_stPathes.push_back ("d:/ymir work/npc_pet/");

  0038a	8d 45 d8	 lea	 eax, DWORD PTR $T54[ebp]
  0038d	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 6
  00394	50		 push	 eax
  00395	8b ce		 mov	 ecx, esi
  00397	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0039c	8b 55 ec	 mov	 edx, DWORD PTR $T54[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 42   : 				vec_stPathes.push_back ("d:/ymir work/npc_pet/");

  0039f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  003a6	83 fa 10	 cmp	 edx, 16			; 00000010H
  003a9	72 2c		 jb	 SHORT $LN368@GetRaceRes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003ab	8b 4d d8	 mov	 ecx, DWORD PTR $T54[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  003ae	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003af	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  003b1	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  003b7	72 14		 jb	 SHORT $LN378@GetRaceRes

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  003b9	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  003bc	83 c2 23	 add	 edx, 35			; 00000023H
  003bf	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003c1	83 c0 fc	 add	 eax, -4			; fffffffcH
  003c4	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  003c7	0f 87 0a 0f 00
	00		 ja	 $LN1407@GetRaceRes
$LN378@GetRaceRes:

; 264  :         ::operator delete(_Ptr, _Bytes);

  003cd	52		 push	 edx
  003ce	51		 push	 ecx
  003cf	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  003d4	83 c4 08	 add	 esp, 8
$LN368@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  003d7	6a 12		 push	 18			; 00000012H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  003d9	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T53[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  003e0	8d 4d d8	 lea	 ecx, DWORD PTR $T53[ebp]
  003e3	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DIPFLAGN@d?3?1ymir?5work?1npc2?1@

; 4596 :         _My_data._Mysize = 0;

  003e8	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T53[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  003ef	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T53[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  003f6	c6 45 d8 00	 mov	 BYTE PTR $T53[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  003fa	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 43   : 				vec_stPathes.push_back ("d:/ymir work/npc2/");

  003ff	c7 45 fc 07 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 7

; 44   : 			}

  00406	e9 88 00 00 00	 jmp	 $LN1443@GetRaceRes
$LN8@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0040b	6a 12		 push	 18			; 00000012H
  0040d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DIPFLAGN@d?3?1ymir?5work?1npc2?1@
  00412	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 47   : 				vec_stPathes.push_back ("d:/ymir work/npc2/");

  00417	8d 45 d8	 lea	 eax, DWORD PTR $T52[ebp]
  0041a	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 8
  00421	50		 push	 eax
  00422	8b ce		 mov	 ecx, esi
  00424	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00429	8b 55 ec	 mov	 edx, DWORD PTR $T52[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 47   : 				vec_stPathes.push_back ("d:/ymir work/npc2/");

  0042c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00433	83 fa 10	 cmp	 edx, 16			; 00000010H
  00436	72 2c		 jb	 SHORT $LN454@GetRaceRes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00438	8b 4d d8	 mov	 ecx, DWORD PTR $T52[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0043b	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0043c	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0043e	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00444	72 14		 jb	 SHORT $LN464@GetRaceRes

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00446	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00449	83 c2 23	 add	 edx, 35			; 00000023H
  0044c	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0044e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00451	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00454	0f 87 7d 0e 00
	00		 ja	 $LN1407@GetRaceRes
$LN464@GetRaceRes:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0045a	52		 push	 edx
  0045b	51		 push	 ecx
  0045c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00461	83 c4 08	 add	 esp, 8
$LN454@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00464	6a 15		 push	 21			; 00000015H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00466	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T51[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0046d	8d 4d d8	 lea	 ecx, DWORD PTR $T51[ebp]
  00470	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@CKCIELCO@d?3?1ymir?5work?1npc_pet?1@

; 4596 :         _My_data._Mysize = 0;

  00475	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T51[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0047c	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T51[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00483	c6 45 d8 00	 mov	 BYTE PTR $T51[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00487	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 48   : 				vec_stPathes.push_back ("d:/ymir work/npc_pet/");

  0048c	c7 45 fc 09 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 9
$LN1443@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00493	8d 45 d8	 lea	 eax, DWORD PTR $T51[ebp]
  00496	8b ce		 mov	 ecx, esi
  00498	50		 push	 eax
  00499	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  0049e	8b 55 ec	 mov	 edx, DWORD PTR $T51[ebp+20]
  004a1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  004a8	83 fa 10	 cmp	 edx, 16			; 00000010H
  004ab	72 2c		 jb	 SHORT $LN497@GetRaceRes
  004ad	8b 4d d8	 mov	 ecx, DWORD PTR $T51[ebp]
  004b0	42		 inc	 edx
  004b1	8b c1		 mov	 eax, ecx
  004b3	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  004b9	72 14		 jb	 SHORT $LN507@GetRaceRes
  004bb	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  004be	83 c2 23	 add	 edx, 35			; 00000023H
  004c1	2b c1		 sub	 eax, ecx
  004c3	83 c0 fc	 add	 eax, -4			; fffffffcH
  004c6	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  004c9	0f 87 08 0e 00
	00		 ja	 $LN1407@GetRaceRes
$LN507@GetRaceRes:
  004cf	52		 push	 edx
  004d0	51		 push	 ecx
  004d1	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  004d6	83 c4 08	 add	 esp, 8
$LN497@GetRaceRes:

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  004d9	6a 11		 push	 17			; 00000011H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  004db	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T50[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  004e2	8d 4d d8	 lea	 ecx, DWORD PTR $T50[ebp]
  004e5	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@HJMPPIOH@d?3?1ymir?5work?1npc?1@

; 4596 :         _My_data._Mysize = 0;

  004ea	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T50[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  004f1	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T50[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  004f8	c6 45 d8 00	 mov	 BYTE PTR $T50[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  004fc	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 50   : 			vec_stPathes.push_back ("d:/ymir work/npc/");

  00501	8d 45 d8	 lea	 eax, DWORD PTR $T50[ebp]
  00504	c7 45 fc 0a 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  0050b	50		 push	 eax
  0050c	8b ce		 mov	 ecx, esi
  0050e	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00513	8b 55 ec	 mov	 edx, DWORD PTR $T50[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 50   : 			vec_stPathes.push_back ("d:/ymir work/npc/");

  00516	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0051d	83 fa 10	 cmp	 edx, 16			; 00000010H
  00520	72 2c		 jb	 SHORT $LN540@GetRaceRes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00522	8b 4d d8	 mov	 ecx, DWORD PTR $T50[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00525	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00526	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00528	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0052e	72 14		 jb	 SHORT $LN550@GetRaceRes

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00530	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00533	83 c2 23	 add	 edx, 35			; 00000023H
  00536	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00538	83 c0 fc	 add	 eax, -4			; fffffffcH
  0053b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0053e	0f 87 93 0d 00
	00		 ja	 $LN1407@GetRaceRes
$LN550@GetRaceRes:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00544	52		 push	 edx
  00545	51		 push	 ecx
  00546	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0054b	83 c4 08	 add	 esp, 8
$LN540@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0054e	6a 17		 push	 23			; 00000017H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00550	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T49[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00557	8d 4d d8	 lea	 ecx, DWORD PTR $T49[ebp]
  0055a	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@BCLHILHN@d?3?1ymir?5work?1npc_mount?1@

; 4596 :         _My_data._Mysize = 0;

  0055f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T49[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00566	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T49[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0056d	c6 45 d8 00	 mov	 BYTE PTR $T49[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00571	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 51   : 			vec_stPathes.push_back ("d:/ymir work/npc_mount/");

  00576	8d 45 d8	 lea	 eax, DWORD PTR $T49[ebp]
  00579	c7 45 fc 0b 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  00580	50		 push	 eax
  00581	8b ce		 mov	 ecx, esi
  00583	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00588	8b 55 ec	 mov	 edx, DWORD PTR $T49[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 51   : 			vec_stPathes.push_back ("d:/ymir work/npc_mount/");

  0058b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00592	83 fa 10	 cmp	 edx, 16			; 00000010H
  00595	72 2c		 jb	 SHORT $LN583@GetRaceRes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00597	8b 4d d8	 mov	 ecx, DWORD PTR $T49[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0059a	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0059b	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0059d	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  005a3	72 14		 jb	 SHORT $LN593@GetRaceRes

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  005a5	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  005a8	83 c2 23	 add	 edx, 35			; 00000023H
  005ab	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  005ad	83 c0 fc	 add	 eax, -4			; fffffffcH
  005b0	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  005b3	0f 87 1e 0d 00
	00		 ja	 $LN1407@GetRaceRes
$LN593@GetRaceRes:

; 264  :         ::operator delete(_Ptr, _Bytes);

  005b9	52		 push	 edx
  005ba	51		 push	 ecx
  005bb	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  005c0	83 c4 08	 add	 esp, 8
$LN583@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  005c3	6a 15		 push	 21			; 00000015H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  005c5	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T48[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  005cc	8d 4d d8	 lea	 ecx, DWORD PTR $T48[ebp]
  005cf	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FGIKCKJD@d?3?1ymir?5work?1monster?1@

; 4596 :         _My_data._Mysize = 0;

  005d4	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T48[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  005db	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T48[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  005e2	c6 45 d8 00	 mov	 BYTE PTR $T48[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  005e6	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 52   : 			vec_stPathes.push_back ("d:/ymir work/monster/");

  005eb	8d 45 d8	 lea	 eax, DWORD PTR $T48[ebp]
  005ee	c7 45 fc 0c 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  005f5	50		 push	 eax
  005f6	8b ce		 mov	 ecx, esi
  005f8	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  005fd	8b 55 ec	 mov	 edx, DWORD PTR $T48[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 52   : 			vec_stPathes.push_back ("d:/ymir work/monster/");

  00600	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00607	83 fa 10	 cmp	 edx, 16			; 00000010H
  0060a	72 2c		 jb	 SHORT $LN626@GetRaceRes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0060c	8b 4d d8	 mov	 ecx, DWORD PTR $T48[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0060f	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00610	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00612	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00618	72 14		 jb	 SHORT $LN636@GetRaceRes

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0061a	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0061d	83 c2 23	 add	 edx, 35			; 00000023H
  00620	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00622	83 c0 fc	 add	 eax, -4			; fffffffcH
  00625	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00628	0f 87 a9 0c 00
	00		 ja	 $LN1407@GetRaceRes
$LN636@GetRaceRes:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0062e	52		 push	 edx
  0062f	51		 push	 ecx
  00630	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00635	83 c4 08	 add	 esp, 8
$LN626@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00638	6a 16		 push	 22			; 00000016H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0063a	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T47[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00641	8d 4d d8	 lea	 ecx, DWORD PTR $T47[ebp]
  00644	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@GPLCEAJK@d?3?1ymir?5work?1monster2?1@

; 4596 :         _My_data._Mysize = 0;

  00649	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T47[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00650	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T47[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00657	c6 45 d8 00	 mov	 BYTE PTR $T47[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0065b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 53   : 			vec_stPathes.push_back ("d:/ymir work/monster2/");

  00660	8d 45 d8	 lea	 eax, DWORD PTR $T47[ebp]
  00663	c7 45 fc 0d 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  0066a	50		 push	 eax
  0066b	8b ce		 mov	 ecx, esi
  0066d	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00672	8b 55 ec	 mov	 edx, DWORD PTR $T47[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 53   : 			vec_stPathes.push_back ("d:/ymir work/monster2/");

  00675	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0067c	83 fa 10	 cmp	 edx, 16			; 00000010H
  0067f	72 2c		 jb	 SHORT $LN669@GetRaceRes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00681	8b 4d d8	 mov	 ecx, DWORD PTR $T47[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00684	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00685	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00687	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0068d	72 14		 jb	 SHORT $LN679@GetRaceRes

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0068f	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00692	83 c2 23	 add	 edx, 35			; 00000023H
  00695	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00697	83 c0 fc	 add	 eax, -4			; fffffffcH
  0069a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0069d	0f 87 34 0c 00
	00		 ja	 $LN1407@GetRaceRes
$LN679@GetRaceRes:

; 264  :         ::operator delete(_Ptr, _Bytes);

  006a3	52		 push	 edx
  006a4	51		 push	 ecx
  006a5	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  006aa	83 c4 08	 add	 esp, 8
$LN669@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  006ad	6a 13		 push	 19			; 00000013H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  006af	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T46[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  006b6	8d 4d d8	 lea	 ecx, DWORD PTR $T46[ebp]
  006b9	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@PJNPAGEJ@d?3?1ymir?5work?1guild?1@

; 4596 :         _My_data._Mysize = 0;

  006be	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T46[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  006c5	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T46[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  006cc	c6 45 d8 00	 mov	 BYTE PTR $T46[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  006d0	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 54   : 			vec_stPathes.push_back ("d:/ymir work/guild/");

  006d5	c7 45 fc 0e 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 14 ; 0000000eH

; 55   : 		}

  006dc	e9 d8 fb ff ff	 jmp	 $LN1448@GetRaceRes
$LN6@GetRaceRes:

; 56   : 		else
; 57   : 		{
; 58   : 			if (race>=20233 && race<=20299) // last known 20247

  006e1	8d 87 f7 b0 ff
	ff		 lea	 eax, DWORD PTR [edi-20233]
  006e7	83 f8 42	 cmp	 eax, 66			; 00000042H
  006ea	0f 87 8d 00 00
	00		 ja	 $LN10@GetRaceRes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  006f0	6a 17		 push	 23			; 00000017H
  006f2	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@BCLHILHN@d?3?1ymir?5work?1npc_mount?1@
  006f7	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 60   : 				vec_stPathes.push_back ("d:/ymir work/npc_mount/");

  006fc	8d 45 d8	 lea	 eax, DWORD PTR $T45[ebp]
  006ff	c7 45 fc 0f 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  00706	50		 push	 eax
  00707	8b ce		 mov	 ecx, esi
  00709	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0070e	8b 55 ec	 mov	 edx, DWORD PTR $T45[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 60   : 				vec_stPathes.push_back ("d:/ymir work/npc_mount/");

  00711	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00718	83 fa 10	 cmp	 edx, 16			; 00000010H
  0071b	72 2c		 jb	 SHORT $LN755@GetRaceRes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0071d	8b 4d d8	 mov	 ecx, DWORD PTR $T45[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00720	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00721	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00723	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00729	72 14		 jb	 SHORT $LN765@GetRaceRes

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0072b	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0072e	83 c2 23	 add	 edx, 35			; 00000023H
  00731	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00733	83 c0 fc	 add	 eax, -4			; fffffffcH
  00736	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00739	0f 87 98 0b 00
	00		 ja	 $LN1407@GetRaceRes
$LN765@GetRaceRes:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0073f	52		 push	 edx
  00740	51		 push	 ecx
  00741	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00746	83 c4 08	 add	 esp, 8
$LN755@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00749	6a 11		 push	 17			; 00000011H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0074b	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T44[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00752	8d 4d d8	 lea	 ecx, DWORD PTR $T44[ebp]
  00755	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@HJMPPIOH@d?3?1ymir?5work?1npc?1@

; 4596 :         _My_data._Mysize = 0;

  0075a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T44[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00761	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T44[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00768	c6 45 d8 00	 mov	 BYTE PTR $T44[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0076c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 61   : 				vec_stPathes.push_back ("d:/ymir work/npc/");

  00771	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 16 ; 00000010H

; 62   : 			}

  00778	e9 88 00 00 00	 jmp	 $LN1447@GetRaceRes
$LN10@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0077d	6a 11		 push	 17			; 00000011H
  0077f	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@HJMPPIOH@d?3?1ymir?5work?1npc?1@
  00784	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 65   : 				vec_stPathes.push_back ("d:/ymir work/npc/");

  00789	8d 45 d8	 lea	 eax, DWORD PTR $T43[ebp]
  0078c	c7 45 fc 11 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 17 ; 00000011H
  00793	50		 push	 eax
  00794	8b ce		 mov	 ecx, esi
  00796	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0079b	8b 55 ec	 mov	 edx, DWORD PTR $T43[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 65   : 				vec_stPathes.push_back ("d:/ymir work/npc/");

  0079e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  007a5	83 fa 10	 cmp	 edx, 16			; 00000010H
  007a8	72 2c		 jb	 SHORT $LN841@GetRaceRes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  007aa	8b 4d d8	 mov	 ecx, DWORD PTR $T43[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  007ad	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  007ae	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  007b0	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  007b6	72 14		 jb	 SHORT $LN851@GetRaceRes

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  007b8	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  007bb	83 c2 23	 add	 edx, 35			; 00000023H
  007be	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  007c0	83 c0 fc	 add	 eax, -4			; fffffffcH
  007c3	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  007c6	0f 87 0b 0b 00
	00		 ja	 $LN1407@GetRaceRes
$LN851@GetRaceRes:

; 264  :         ::operator delete(_Ptr, _Bytes);

  007cc	52		 push	 edx
  007cd	51		 push	 ecx
  007ce	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  007d3	83 c4 08	 add	 esp, 8
$LN841@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  007d6	6a 17		 push	 23			; 00000017H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  007d8	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T42[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  007df	8d 4d d8	 lea	 ecx, DWORD PTR $T42[ebp]
  007e2	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@BCLHILHN@d?3?1ymir?5work?1npc_mount?1@

; 4596 :         _My_data._Mysize = 0;

  007e7	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T42[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  007ee	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T42[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  007f5	c6 45 d8 00	 mov	 BYTE PTR $T42[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  007f9	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 66   : 				vec_stPathes.push_back ("d:/ymir work/npc_mount/");

  007fe	c7 45 fc 12 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 18 ; 00000012H
$LN1447@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00805	8d 45 d8	 lea	 eax, DWORD PTR $T42[ebp]
  00808	8b ce		 mov	 ecx, esi
  0080a	50		 push	 eax
  0080b	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  00810	8b 55 ec	 mov	 edx, DWORD PTR $T42[ebp+20]
  00813	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0081a	83 fa 10	 cmp	 edx, 16			; 00000010H
  0081d	72 2c		 jb	 SHORT $LN884@GetRaceRes
  0081f	8b 4d d8	 mov	 ecx, DWORD PTR $T42[ebp]
  00822	42		 inc	 edx
  00823	8b c1		 mov	 eax, ecx
  00825	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0082b	72 14		 jb	 SHORT $LN894@GetRaceRes
  0082d	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00830	83 c2 23	 add	 edx, 35			; 00000023H
  00833	2b c1		 sub	 eax, ecx
  00835	83 c0 fc	 add	 eax, -4			; fffffffcH
  00838	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0083b	0f 87 96 0a 00
	00		 ja	 $LN1407@GetRaceRes
$LN894@GetRaceRes:
  00841	52		 push	 edx
  00842	51		 push	 ecx
  00843	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00848	83 c4 08	 add	 esp, 8
$LN884@GetRaceRes:

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0084b	6a 12		 push	 18			; 00000012H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0084d	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T41[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00854	8d 4d d8	 lea	 ecx, DWORD PTR $T41[ebp]
  00857	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DIPFLAGN@d?3?1ymir?5work?1npc2?1@

; 4596 :         _My_data._Mysize = 0;

  0085c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T41[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00863	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T41[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0086a	c6 45 d8 00	 mov	 BYTE PTR $T41[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0086e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 68   : 			vec_stPathes.push_back ("d:/ymir work/npc2/");

  00873	8d 45 d8	 lea	 eax, DWORD PTR $T41[ebp]
  00876	c7 45 fc 13 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 19 ; 00000013H
  0087d	50		 push	 eax
  0087e	8b ce		 mov	 ecx, esi
  00880	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00885	8b 55 ec	 mov	 edx, DWORD PTR $T41[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 68   : 			vec_stPathes.push_back ("d:/ymir work/npc2/");

  00888	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0088f	83 fa 10	 cmp	 edx, 16			; 00000010H
  00892	72 2c		 jb	 SHORT $LN927@GetRaceRes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00894	8b 4d d8	 mov	 ecx, DWORD PTR $T41[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00897	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00898	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0089a	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  008a0	72 14		 jb	 SHORT $LN937@GetRaceRes

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  008a2	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  008a5	83 c2 23	 add	 edx, 35			; 00000023H
  008a8	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  008aa	83 c0 fc	 add	 eax, -4			; fffffffcH
  008ad	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  008b0	0f 87 21 0a 00
	00		 ja	 $LN1407@GetRaceRes
$LN937@GetRaceRes:

; 264  :         ::operator delete(_Ptr, _Bytes);

  008b6	52		 push	 edx
  008b7	51		 push	 ecx
  008b8	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  008bd	83 c4 08	 add	 esp, 8
$LN927@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  008c0	6a 15		 push	 21			; 00000015H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  008c2	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T40[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  008c9	8d 4d d8	 lea	 ecx, DWORD PTR $T40[ebp]
  008cc	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@CKCIELCO@d?3?1ymir?5work?1npc_pet?1@

; 4596 :         _My_data._Mysize = 0;

  008d1	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T40[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  008d8	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T40[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  008df	c6 45 d8 00	 mov	 BYTE PTR $T40[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  008e3	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 69   : 			vec_stPathes.push_back ("d:/ymir work/npc_pet/");

  008e8	8d 45 d8	 lea	 eax, DWORD PTR $T40[ebp]
  008eb	c7 45 fc 14 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 20 ; 00000014H
  008f2	50		 push	 eax
  008f3	8b ce		 mov	 ecx, esi
  008f5	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  008fa	8b 55 ec	 mov	 edx, DWORD PTR $T40[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 69   : 			vec_stPathes.push_back ("d:/ymir work/npc_pet/");

  008fd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00904	83 fa 10	 cmp	 edx, 16			; 00000010H
  00907	72 2c		 jb	 SHORT $LN970@GetRaceRes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00909	8b 4d d8	 mov	 ecx, DWORD PTR $T40[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0090c	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0090d	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0090f	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00915	72 14		 jb	 SHORT $LN980@GetRaceRes

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00917	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0091a	83 c2 23	 add	 edx, 35			; 00000023H
  0091d	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0091f	83 c0 fc	 add	 eax, -4			; fffffffcH
  00922	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00925	0f 87 ac 09 00
	00		 ja	 $LN1407@GetRaceRes
$LN980@GetRaceRes:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0092b	52		 push	 edx
  0092c	51		 push	 ecx
  0092d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00932	83 c4 08	 add	 esp, 8
$LN970@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00935	6a 15		 push	 21			; 00000015H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00937	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T39[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0093e	8d 4d d8	 lea	 ecx, DWORD PTR $T39[ebp]
  00941	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FGIKCKJD@d?3?1ymir?5work?1monster?1@

; 4596 :         _My_data._Mysize = 0;

  00946	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T39[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0094d	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T39[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00954	c6 45 d8 00	 mov	 BYTE PTR $T39[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00958	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 70   : 			vec_stPathes.push_back ("d:/ymir work/monster/");

  0095d	8d 45 d8	 lea	 eax, DWORD PTR $T39[ebp]
  00960	c7 45 fc 15 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 21 ; 00000015H
  00967	50		 push	 eax
  00968	8b ce		 mov	 ecx, esi
  0096a	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0096f	8b 55 ec	 mov	 edx, DWORD PTR $T39[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 70   : 			vec_stPathes.push_back ("d:/ymir work/monster/");

  00972	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00979	83 fa 10	 cmp	 edx, 16			; 00000010H
  0097c	72 2c		 jb	 SHORT $LN1013@GetRaceRes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0097e	8b 4d d8	 mov	 ecx, DWORD PTR $T39[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00981	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00982	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00984	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0098a	72 14		 jb	 SHORT $LN1023@GetRaceRes

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0098c	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0098f	83 c2 23	 add	 edx, 35			; 00000023H
  00992	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00994	83 c0 fc	 add	 eax, -4			; fffffffcH
  00997	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0099a	0f 87 37 09 00
	00		 ja	 $LN1407@GetRaceRes
$LN1023@GetRaceRes:

; 264  :         ::operator delete(_Ptr, _Bytes);

  009a0	52		 push	 edx
  009a1	51		 push	 ecx
  009a2	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  009a7	83 c4 08	 add	 esp, 8
$LN1013@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  009aa	6a 16		 push	 22			; 00000016H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  009ac	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T38[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  009b3	8d 4d d8	 lea	 ecx, DWORD PTR $T38[ebp]
  009b6	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@GPLCEAJK@d?3?1ymir?5work?1monster2?1@

; 4596 :         _My_data._Mysize = 0;

  009bb	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T38[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  009c2	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T38[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  009c9	c6 45 d8 00	 mov	 BYTE PTR $T38[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  009cd	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 71   : 			vec_stPathes.push_back ("d:/ymir work/monster2/");

  009d2	8d 45 d8	 lea	 eax, DWORD PTR $T38[ebp]
  009d5	c7 45 fc 16 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 22 ; 00000016H
  009dc	50		 push	 eax
  009dd	8b ce		 mov	 ecx, esi
  009df	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  009e4	8b 55 ec	 mov	 edx, DWORD PTR $T38[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 71   : 			vec_stPathes.push_back ("d:/ymir work/monster2/");

  009e7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  009ee	83 fa 10	 cmp	 edx, 16			; 00000010H
  009f1	72 2c		 jb	 SHORT $LN1056@GetRaceRes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  009f3	8b 4d d8	 mov	 ecx, DWORD PTR $T38[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  009f6	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  009f7	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  009f9	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  009ff	72 14		 jb	 SHORT $LN1066@GetRaceRes

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00a01	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00a04	83 c2 23	 add	 edx, 35			; 00000023H
  00a07	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00a09	83 c0 fc	 add	 eax, -4			; fffffffcH
  00a0c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00a0f	0f 87 c2 08 00
	00		 ja	 $LN1407@GetRaceRes
$LN1066@GetRaceRes:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00a15	52		 push	 edx
  00a16	51		 push	 ecx
  00a17	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00a1c	83 c4 08	 add	 esp, 8
$LN1056@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00a1f	6a 13		 push	 19			; 00000013H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00a21	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T37[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00a28	8d 4d d8	 lea	 ecx, DWORD PTR $T37[ebp]
  00a2b	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@PJNPAGEJ@d?3?1ymir?5work?1guild?1@

; 4596 :         _My_data._Mysize = 0;

  00a30	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T37[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00a37	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T37[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00a3e	c6 45 d8 00	 mov	 BYTE PTR $T37[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00a42	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 72   : 			vec_stPathes.push_back ("d:/ymir work/guild/");

  00a47	c7 45 fc 17 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 23 ; 00000017H

; 73   : 		}
; 74   : 	}

  00a4e	e9 66 f8 ff ff	 jmp	 $LN1448@GetRaceRes
$LN4@GetRaceRes:

; 75   : 	//    
; 76   : 	else if (8507 == race || 8510 == race)

  00a53	81 ff 3b 21 00
	00		 cmp	 edi, 8507		; 0000213bH
  00a59	0f 84 fa 04 00
	00		 je	 $LN14@GetRaceRes
  00a5f	81 ff 3e 21 00
	00		 cmp	 edi, 8510		; 0000213eH
  00a65	0f 84 ee 04 00
	00		 je	 $LN14@GetRaceRes

; 85   : 	}
; 86   : 	else if (race > 8000)

  00a6b	8d 4d d8	 lea	 ecx, DWORD PTR $T29[ebp]
  00a6e	81 ff 40 1f 00
	00		 cmp	 edi, 8000		; 00001f40H
  00a74	0f 86 2a 01 00
	00		 jbe	 $LN15@GetRaceRes

; 87   : 	{
; 88   : 		vec_stPathes.push_back ("d:/ymir work/monster/");

  00a7a	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FGIKCKJD@d?3?1ymir?5work?1monster?1@
  00a7f	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00a84	8d 45 d8	 lea	 eax, DWORD PTR $T29[ebp]
  00a87	c7 45 fc 1f 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 31 ; 0000001fH
  00a8e	50		 push	 eax
  00a8f	8b ce		 mov	 ecx, esi
  00a91	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  00a96	8d 4d d8	 lea	 ecx, DWORD PTR $T29[ebp]
  00a99	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00aa0	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 89   : 		vec_stPathes.push_back ("d:/ymir work/monster2/");

  00aa5	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@GPLCEAJK@d?3?1ymir?5work?1monster2?1@
  00aaa	8d 4d d8	 lea	 ecx, DWORD PTR $T28[ebp]
  00aad	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00ab2	8d 45 d8	 lea	 eax, DWORD PTR $T28[ebp]
  00ab5	c7 45 fc 20 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 32 ; 00000020H
  00abc	50		 push	 eax
  00abd	8b ce		 mov	 ecx, esi
  00abf	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  00ac4	8d 4d d8	 lea	 ecx, DWORD PTR $T28[ebp]
  00ac7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00ace	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 90   : 		vec_stPathes.push_back ("d:/ymir work/npc/");

  00ad3	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@HJMPPIOH@d?3?1ymir?5work?1npc?1@
  00ad8	8d 4d d8	 lea	 ecx, DWORD PTR $T27[ebp]
  00adb	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00ae0	8d 45 d8	 lea	 eax, DWORD PTR $T27[ebp]
  00ae3	c7 45 fc 21 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 33 ; 00000021H
  00aea	50		 push	 eax
  00aeb	8b ce		 mov	 ecx, esi
  00aed	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  00af2	8d 4d d8	 lea	 ecx, DWORD PTR $T27[ebp]
  00af5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00afc	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 91   : 		vec_stPathes.push_back ("d:/ymir work/npc2/");

  00b01	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DIPFLAGN@d?3?1ymir?5work?1npc2?1@
  00b06	8d 4d d8	 lea	 ecx, DWORD PTR $T26[ebp]
  00b09	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00b0e	8d 45 d8	 lea	 eax, DWORD PTR $T26[ebp]
  00b11	c7 45 fc 22 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 34 ; 00000022H
  00b18	50		 push	 eax
  00b19	8b ce		 mov	 ecx, esi
  00b1b	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  00b20	8d 4d d8	 lea	 ecx, DWORD PTR $T26[ebp]
  00b23	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00b2a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 92   : 		vec_stPathes.push_back ("d:/ymir work/npc_pet/");

  00b2f	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@CKCIELCO@d?3?1ymir?5work?1npc_pet?1@
  00b34	8d 4d d8	 lea	 ecx, DWORD PTR $T25[ebp]
  00b37	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00b3c	8d 45 d8	 lea	 eax, DWORD PTR $T25[ebp]
  00b3f	c7 45 fc 23 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 35 ; 00000023H
  00b46	50		 push	 eax
  00b47	8b ce		 mov	 ecx, esi
  00b49	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  00b4e	8d 4d d8	 lea	 ecx, DWORD PTR $T25[ebp]
  00b51	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00b58	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 93   : 		vec_stPathes.push_back ("d:/ymir work/npc_mount/");

  00b5d	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@BCLHILHN@d?3?1ymir?5work?1npc_mount?1@
  00b62	8d 4d d8	 lea	 ecx, DWORD PTR $T24[ebp]
  00b65	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00b6a	8d 45 d8	 lea	 eax, DWORD PTR $T24[ebp]
  00b6d	c7 45 fc 24 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 36 ; 00000024H
  00b74	50		 push	 eax
  00b75	8b ce		 mov	 ecx, esi
  00b77	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  00b7c	8d 4d d8	 lea	 ecx, DWORD PTR $T24[ebp]
  00b7f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00b86	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 94   : 		vec_stPathes.push_back ("d:/ymir work/guild/");

  00b8b	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@PJNPAGEJ@d?3?1ymir?5work?1guild?1@
  00b90	8d 4d d8	 lea	 ecx, DWORD PTR $T23[ebp]
  00b93	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00b98	c7 45 fc 25 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 37 ; 00000025H

; 95   : 	}

  00b9f	e9 6c 02 00 00	 jmp	 $LN1449@GetRaceRes
$LN15@GetRaceRes:

; 96   : 	else if (race > 2000)

  00ba4	81 ff d0 07 00
	00		 cmp	 edi, 2000		; 000007d0H
  00baa	0f 86 2a 01 00
	00		 jbe	 $LN17@GetRaceRes

; 97   : 	{
; 98   : 		vec_stPathes.push_back ("d:/ymir work/monster2/");

  00bb0	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@GPLCEAJK@d?3?1ymir?5work?1monster2?1@
  00bb5	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00bba	8d 45 d8	 lea	 eax, DWORD PTR $T22[ebp]
  00bbd	c7 45 fc 26 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 38 ; 00000026H
  00bc4	50		 push	 eax
  00bc5	8b ce		 mov	 ecx, esi
  00bc7	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  00bcc	8d 4d d8	 lea	 ecx, DWORD PTR $T22[ebp]
  00bcf	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00bd6	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 99   : 		vec_stPathes.push_back ("d:/ymir work/monster/");

  00bdb	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FGIKCKJD@d?3?1ymir?5work?1monster?1@
  00be0	8d 4d d8	 lea	 ecx, DWORD PTR $T21[ebp]
  00be3	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00be8	8d 45 d8	 lea	 eax, DWORD PTR $T21[ebp]
  00beb	c7 45 fc 27 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 39 ; 00000027H
  00bf2	50		 push	 eax
  00bf3	8b ce		 mov	 ecx, esi
  00bf5	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  00bfa	8d 4d d8	 lea	 ecx, DWORD PTR $T21[ebp]
  00bfd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00c04	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 100  : 		vec_stPathes.push_back ("d:/ymir work/npc/");

  00c09	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@HJMPPIOH@d?3?1ymir?5work?1npc?1@
  00c0e	8d 4d d8	 lea	 ecx, DWORD PTR $T20[ebp]
  00c11	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00c16	8d 45 d8	 lea	 eax, DWORD PTR $T20[ebp]
  00c19	c7 45 fc 28 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 40 ; 00000028H
  00c20	50		 push	 eax
  00c21	8b ce		 mov	 ecx, esi
  00c23	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  00c28	8d 4d d8	 lea	 ecx, DWORD PTR $T20[ebp]
  00c2b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00c32	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 101  : 		vec_stPathes.push_back ("d:/ymir work/npc2/");

  00c37	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DIPFLAGN@d?3?1ymir?5work?1npc2?1@
  00c3c	8d 4d d8	 lea	 ecx, DWORD PTR $T19[ebp]
  00c3f	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00c44	8d 45 d8	 lea	 eax, DWORD PTR $T19[ebp]
  00c47	c7 45 fc 29 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 41 ; 00000029H
  00c4e	50		 push	 eax
  00c4f	8b ce		 mov	 ecx, esi
  00c51	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  00c56	8d 4d d8	 lea	 ecx, DWORD PTR $T19[ebp]
  00c59	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00c60	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 102  : 		vec_stPathes.push_back ("d:/ymir work/npc_pet/");

  00c65	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@CKCIELCO@d?3?1ymir?5work?1npc_pet?1@
  00c6a	8d 4d d8	 lea	 ecx, DWORD PTR $T18[ebp]
  00c6d	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00c72	8d 45 d8	 lea	 eax, DWORD PTR $T18[ebp]
  00c75	c7 45 fc 2a 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 42 ; 0000002aH
  00c7c	50		 push	 eax
  00c7d	8b ce		 mov	 ecx, esi
  00c7f	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  00c84	8d 4d d8	 lea	 ecx, DWORD PTR $T18[ebp]
  00c87	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00c8e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 103  : 		vec_stPathes.push_back ("d:/ymir work/npc_mount/");

  00c93	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@BCLHILHN@d?3?1ymir?5work?1npc_mount?1@
  00c98	8d 4d d8	 lea	 ecx, DWORD PTR $T17[ebp]
  00c9b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00ca0	8d 45 d8	 lea	 eax, DWORD PTR $T17[ebp]
  00ca3	c7 45 fc 2b 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 43 ; 0000002bH
  00caa	50		 push	 eax
  00cab	8b ce		 mov	 ecx, esi
  00cad	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  00cb2	8d 4d d8	 lea	 ecx, DWORD PTR $T17[ebp]
  00cb5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00cbc	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 104  : 		vec_stPathes.push_back ("d:/ymir work/guild/");

  00cc1	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@PJNPAGEJ@d?3?1ymir?5work?1guild?1@
  00cc6	8d 4d d8	 lea	 ecx, DWORD PTR $T16[ebp]
  00cc9	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00cce	c7 45 fc 2c 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 44 ; 0000002cH

; 105  : 	}

  00cd5	e9 36 01 00 00	 jmp	 $LN1449@GetRaceRes
$LN17@GetRaceRes:

; 106  : 	else if (race>=1400 && race<=1700)

  00cda	8d 87 88 fa ff
	ff		 lea	 eax, DWORD PTR [edi-1400]
  00ce0	3d 2c 01 00 00	 cmp	 eax, 300		; 0000012cH
  00ce5	0f 87 44 01 00
	00		 ja	 $LN19@GetRaceRes

; 107  : 	{
; 108  : 		vec_stPathes.push_back ("d:/ymir work/monster2/");

  00ceb	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@GPLCEAJK@d?3?1ymir?5work?1monster2?1@
  00cf0	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00cf5	8d 45 d8	 lea	 eax, DWORD PTR $T15[ebp]
  00cf8	c7 45 fc 2d 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 45 ; 0000002dH
  00cff	50		 push	 eax
  00d00	8b ce		 mov	 ecx, esi
  00d02	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  00d07	8d 4d d8	 lea	 ecx, DWORD PTR $T15[ebp]
  00d0a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00d11	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 109  : 		vec_stPathes.push_back ("d:/ymir work/monster/");

  00d16	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FGIKCKJD@d?3?1ymir?5work?1monster?1@
  00d1b	8d 4d d8	 lea	 ecx, DWORD PTR $T14[ebp]
  00d1e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00d23	8d 45 d8	 lea	 eax, DWORD PTR $T14[ebp]
  00d26	c7 45 fc 2e 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 46 ; 0000002eH
  00d2d	50		 push	 eax
  00d2e	8b ce		 mov	 ecx, esi
  00d30	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  00d35	8d 4d d8	 lea	 ecx, DWORD PTR $T14[ebp]
  00d38	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00d3f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 110  : 		vec_stPathes.push_back ("d:/ymir work/npc/");

  00d44	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@HJMPPIOH@d?3?1ymir?5work?1npc?1@
  00d49	8d 4d d8	 lea	 ecx, DWORD PTR $T13[ebp]
  00d4c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00d51	8d 45 d8	 lea	 eax, DWORD PTR $T13[ebp]
  00d54	c7 45 fc 2f 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 47 ; 0000002fH
  00d5b	50		 push	 eax
  00d5c	8b ce		 mov	 ecx, esi
  00d5e	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  00d63	8d 4d d8	 lea	 ecx, DWORD PTR $T13[ebp]
  00d66	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00d6d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 111  : 		vec_stPathes.push_back ("d:/ymir work/npc2/");

  00d72	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DIPFLAGN@d?3?1ymir?5work?1npc2?1@
  00d77	8d 4d d8	 lea	 ecx, DWORD PTR $T12[ebp]
  00d7a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00d7f	8d 45 d8	 lea	 eax, DWORD PTR $T12[ebp]
  00d82	c7 45 fc 30 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 48 ; 00000030H
  00d89	50		 push	 eax
  00d8a	8b ce		 mov	 ecx, esi
  00d8c	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  00d91	8d 4d d8	 lea	 ecx, DWORD PTR $T12[ebp]
  00d94	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00d9b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 112  : 		vec_stPathes.push_back ("d:/ymir work/npc_pet/");

  00da0	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@CKCIELCO@d?3?1ymir?5work?1npc_pet?1@
  00da5	8d 4d d8	 lea	 ecx, DWORD PTR $T11[ebp]
  00da8	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00dad	8d 45 d8	 lea	 eax, DWORD PTR $T11[ebp]
  00db0	c7 45 fc 31 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 49 ; 00000031H
  00db7	50		 push	 eax
  00db8	8b ce		 mov	 ecx, esi
  00dba	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  00dbf	8d 4d d8	 lea	 ecx, DWORD PTR $T11[ebp]
  00dc2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00dc9	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 113  : 		vec_stPathes.push_back ("d:/ymir work/npc_mount/");

  00dce	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@BCLHILHN@d?3?1ymir?5work?1npc_mount?1@
  00dd3	8d 4d d8	 lea	 ecx, DWORD PTR $T10[ebp]
  00dd6	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00ddb	8d 45 d8	 lea	 eax, DWORD PTR $T10[ebp]
  00dde	c7 45 fc 32 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 50 ; 00000032H
  00de5	50		 push	 eax
  00de6	8b ce		 mov	 ecx, esi
  00de8	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  00ded	8d 4d d8	 lea	 ecx, DWORD PTR $T10[ebp]
  00df0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00df7	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 114  : 		vec_stPathes.push_back ("d:/ymir work/guild/");

  00dfc	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@PJNPAGEJ@d?3?1ymir?5work?1guild?1@
  00e01	8d 4d d8	 lea	 ecx, DWORD PTR $T9[ebp]
  00e04	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00e09	c7 45 fc 33 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 51 ; 00000033H
$LN1449@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  00e10	8d 45 d8	 lea	 eax, DWORD PTR $T9[ebp]
  00e13	8b ce		 mov	 ecx, esi
  00e15	50		 push	 eax
  00e16	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  00e1b	8d 4d d8	 lea	 ecx, DWORD PTR $T9[ebp]
  00e1e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00e25	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00e2a	e9 d0 f4 ff ff	 jmp	 $LN1400@GetRaceRes
$LN19@GetRaceRes:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 118  : 		vec_stPathes.push_back ("d:/ymir work/monster/");

  00e2f	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FGIKCKJD@d?3?1ymir?5work?1monster?1@
  00e34	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00e39	8d 45 d8	 lea	 eax, DWORD PTR $T8[ebp]
  00e3c	c7 45 fc 34 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 52 ; 00000034H
  00e43	50		 push	 eax
  00e44	8b ce		 mov	 ecx, esi
  00e46	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  00e4b	8d 4d d8	 lea	 ecx, DWORD PTR $T8[ebp]
  00e4e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00e55	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 119  : 		vec_stPathes.push_back ("d:/ymir work/monster2/");

  00e5a	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@GPLCEAJK@d?3?1ymir?5work?1monster2?1@
  00e5f	8d 4d d8	 lea	 ecx, DWORD PTR $T7[ebp]
  00e62	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00e67	8d 45 d8	 lea	 eax, DWORD PTR $T7[ebp]
  00e6a	c7 45 fc 35 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 53 ; 00000035H
  00e71	50		 push	 eax
  00e72	8b ce		 mov	 ecx, esi
  00e74	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  00e79	8d 4d d8	 lea	 ecx, DWORD PTR $T7[ebp]
  00e7c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00e83	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 120  : 		vec_stPathes.push_back ("d:/ymir work/npc/");

  00e88	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@HJMPPIOH@d?3?1ymir?5work?1npc?1@
  00e8d	8d 4d d8	 lea	 ecx, DWORD PTR $T6[ebp]
  00e90	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00e95	8d 45 d8	 lea	 eax, DWORD PTR $T6[ebp]
  00e98	c7 45 fc 36 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 54 ; 00000036H
  00e9f	50		 push	 eax
  00ea0	8b ce		 mov	 ecx, esi
  00ea2	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  00ea7	8d 4d d8	 lea	 ecx, DWORD PTR $T6[ebp]
  00eaa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00eb1	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 121  : 		vec_stPathes.push_back ("d:/ymir work/npc2/");

  00eb6	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DIPFLAGN@d?3?1ymir?5work?1npc2?1@
  00ebb	8d 4d d8	 lea	 ecx, DWORD PTR $T5[ebp]
  00ebe	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00ec3	8d 45 d8	 lea	 eax, DWORD PTR $T5[ebp]
  00ec6	c7 45 fc 37 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 55 ; 00000037H
  00ecd	50		 push	 eax
  00ece	8b ce		 mov	 ecx, esi
  00ed0	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  00ed5	8d 4d d8	 lea	 ecx, DWORD PTR $T5[ebp]
  00ed8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00edf	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 122  : 		vec_stPathes.push_back ("d:/ymir work/npc_pet/");

  00ee4	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@CKCIELCO@d?3?1ymir?5work?1npc_pet?1@
  00ee9	8d 4d d8	 lea	 ecx, DWORD PTR $T4[ebp]
  00eec	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00ef1	8d 45 d8	 lea	 eax, DWORD PTR $T4[ebp]
  00ef4	c7 45 fc 38 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 56 ; 00000038H
  00efb	50		 push	 eax
  00efc	8b ce		 mov	 ecx, esi
  00efe	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  00f03	8d 4d d8	 lea	 ecx, DWORD PTR $T4[ebp]
  00f06	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00f0d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 123  : 		vec_stPathes.push_back ("d:/ymir work/npc_mount/");

  00f12	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@BCLHILHN@d?3?1ymir?5work?1npc_mount?1@
  00f17	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00f1a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00f1f	8d 45 d8	 lea	 eax, DWORD PTR $T3[ebp]
  00f22	c7 45 fc 39 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 57 ; 00000039H
  00f29	50		 push	 eax
  00f2a	8b ce		 mov	 ecx, esi
  00f2c	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
  00f31	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00f34	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00f3b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 124  : 		vec_stPathes.push_back ("d:/ymir work/guild/");

  00f40	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@PJNPAGEJ@d?3?1ymir?5work?1guild?1@
  00f45	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  00f48	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00f4d	c7 45 fc 3a 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 58 ; 0000003aH
  00f54	e9 b7 fe ff ff	 jmp	 $LN1449@GetRaceRes
$LN14@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00f59	6a 16		 push	 22			; 00000016H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00f5b	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T36[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00f62	8d 4d d8	 lea	 ecx, DWORD PTR $T36[ebp]
  00f65	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@GPLCEAJK@d?3?1ymir?5work?1monster2?1@

; 4596 :         _My_data._Mysize = 0;

  00f6a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T36[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00f71	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T36[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00f78	c6 45 d8 00	 mov	 BYTE PTR $T36[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00f7c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 78   : 		vec_stPathes.push_back ("d:/ymir work/monster2/");

  00f81	8d 45 d8	 lea	 eax, DWORD PTR $T36[ebp]
  00f84	c7 45 fc 18 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 24 ; 00000018H
  00f8b	50		 push	 eax
  00f8c	8b ce		 mov	 ecx, esi
  00f8e	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00f93	8b 55 ec	 mov	 edx, DWORD PTR $T36[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 78   : 		vec_stPathes.push_back ("d:/ymir work/monster2/");

  00f96	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00f9d	83 fa 10	 cmp	 edx, 16			; 00000010H
  00fa0	72 2c		 jb	 SHORT $LN1142@GetRaceRes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00fa2	8b 4d d8	 mov	 ecx, DWORD PTR $T36[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00fa5	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00fa6	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00fa8	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00fae	72 14		 jb	 SHORT $LN1152@GetRaceRes

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00fb0	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00fb3	83 c2 23	 add	 edx, 35			; 00000023H
  00fb6	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00fb8	83 c0 fc	 add	 eax, -4			; fffffffcH
  00fbb	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00fbe	0f 87 13 03 00
	00		 ja	 $LN1407@GetRaceRes
$LN1152@GetRaceRes:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00fc4	52		 push	 edx
  00fc5	51		 push	 ecx
  00fc6	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00fcb	83 c4 08	 add	 esp, 8
$LN1142@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00fce	6a 15		 push	 21			; 00000015H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00fd0	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T35[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00fd7	8d 4d d8	 lea	 ecx, DWORD PTR $T35[ebp]
  00fda	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FGIKCKJD@d?3?1ymir?5work?1monster?1@

; 4596 :         _My_data._Mysize = 0;

  00fdf	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T35[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00fe6	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T35[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00fed	c6 45 d8 00	 mov	 BYTE PTR $T35[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00ff1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 79   : 		vec_stPathes.push_back ("d:/ymir work/monster/");

  00ff6	8d 45 d8	 lea	 eax, DWORD PTR $T35[ebp]
  00ff9	c7 45 fc 19 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 25 ; 00000019H
  01000	50		 push	 eax
  01001	8b ce		 mov	 ecx, esi
  01003	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  01008	8b 55 ec	 mov	 edx, DWORD PTR $T35[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 79   : 		vec_stPathes.push_back ("d:/ymir work/monster/");

  0100b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  01012	83 fa 10	 cmp	 edx, 16			; 00000010H
  01015	72 2c		 jb	 SHORT $LN1185@GetRaceRes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  01017	8b 4d d8	 mov	 ecx, DWORD PTR $T35[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0101a	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0101b	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0101d	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  01023	72 14		 jb	 SHORT $LN1195@GetRaceRes

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  01025	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  01028	83 c2 23	 add	 edx, 35			; 00000023H
  0102b	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0102d	83 c0 fc	 add	 eax, -4			; fffffffcH
  01030	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  01033	0f 87 9e 02 00
	00		 ja	 $LN1407@GetRaceRes
$LN1195@GetRaceRes:

; 264  :         ::operator delete(_Ptr, _Bytes);

  01039	52		 push	 edx
  0103a	51		 push	 ecx
  0103b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  01040	83 c4 08	 add	 esp, 8
$LN1185@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  01043	6a 11		 push	 17			; 00000011H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  01045	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T34[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0104c	8d 4d d8	 lea	 ecx, DWORD PTR $T34[ebp]
  0104f	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@HJMPPIOH@d?3?1ymir?5work?1npc?1@

; 4596 :         _My_data._Mysize = 0;

  01054	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T34[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0105b	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T34[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  01062	c6 45 d8 00	 mov	 BYTE PTR $T34[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  01066	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 80   : 		vec_stPathes.push_back ("d:/ymir work/npc/");

  0106b	8d 45 d8	 lea	 eax, DWORD PTR $T34[ebp]
  0106e	c7 45 fc 1a 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 26 ; 0000001aH
  01075	50		 push	 eax
  01076	8b ce		 mov	 ecx, esi
  01078	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0107d	8b 55 ec	 mov	 edx, DWORD PTR $T34[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 80   : 		vec_stPathes.push_back ("d:/ymir work/npc/");

  01080	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  01087	83 fa 10	 cmp	 edx, 16			; 00000010H
  0108a	72 2c		 jb	 SHORT $LN1228@GetRaceRes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0108c	8b 4d d8	 mov	 ecx, DWORD PTR $T34[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0108f	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  01090	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  01092	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  01098	72 14		 jb	 SHORT $LN1238@GetRaceRes

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0109a	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0109d	83 c2 23	 add	 edx, 35			; 00000023H
  010a0	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  010a2	83 c0 fc	 add	 eax, -4			; fffffffcH
  010a5	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  010a8	0f 87 29 02 00
	00		 ja	 $LN1407@GetRaceRes
$LN1238@GetRaceRes:

; 264  :         ::operator delete(_Ptr, _Bytes);

  010ae	52		 push	 edx
  010af	51		 push	 ecx
  010b0	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  010b5	83 c4 08	 add	 esp, 8
$LN1228@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  010b8	6a 12		 push	 18			; 00000012H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  010ba	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T33[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  010c1	8d 4d d8	 lea	 ecx, DWORD PTR $T33[ebp]
  010c4	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DIPFLAGN@d?3?1ymir?5work?1npc2?1@

; 4596 :         _My_data._Mysize = 0;

  010c9	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T33[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  010d0	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T33[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  010d7	c6 45 d8 00	 mov	 BYTE PTR $T33[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  010db	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 81   : 		vec_stPathes.push_back ("d:/ymir work/npc2/");

  010e0	8d 45 d8	 lea	 eax, DWORD PTR $T33[ebp]
  010e3	c7 45 fc 1b 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 27 ; 0000001bH
  010ea	50		 push	 eax
  010eb	8b ce		 mov	 ecx, esi
  010ed	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  010f2	8b 55 ec	 mov	 edx, DWORD PTR $T33[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 81   : 		vec_stPathes.push_back ("d:/ymir work/npc2/");

  010f5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  010fc	83 fa 10	 cmp	 edx, 16			; 00000010H
  010ff	72 2c		 jb	 SHORT $LN1271@GetRaceRes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  01101	8b 4d d8	 mov	 ecx, DWORD PTR $T33[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  01104	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  01105	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  01107	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0110d	72 14		 jb	 SHORT $LN1281@GetRaceRes

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0110f	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  01112	83 c2 23	 add	 edx, 35			; 00000023H
  01115	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  01117	83 c0 fc	 add	 eax, -4			; fffffffcH
  0111a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0111d	0f 87 b4 01 00
	00		 ja	 $LN1407@GetRaceRes
$LN1281@GetRaceRes:

; 264  :         ::operator delete(_Ptr, _Bytes);

  01123	52		 push	 edx
  01124	51		 push	 ecx
  01125	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0112a	83 c4 08	 add	 esp, 8
$LN1271@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0112d	6a 15		 push	 21			; 00000015H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0112f	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T32[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  01136	8d 4d d8	 lea	 ecx, DWORD PTR $T32[ebp]
  01139	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@CKCIELCO@d?3?1ymir?5work?1npc_pet?1@

; 4596 :         _My_data._Mysize = 0;

  0113e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T32[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  01145	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T32[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0114c	c6 45 d8 00	 mov	 BYTE PTR $T32[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  01150	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 82   : 		vec_stPathes.push_back ("d:/ymir work/npc_pet/");

  01155	8d 45 d8	 lea	 eax, DWORD PTR $T32[ebp]
  01158	c7 45 fc 1c 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 28 ; 0000001cH
  0115f	50		 push	 eax
  01160	8b ce		 mov	 ecx, esi
  01162	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  01167	8b 55 ec	 mov	 edx, DWORD PTR $T32[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 82   : 		vec_stPathes.push_back ("d:/ymir work/npc_pet/");

  0116a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  01171	83 fa 10	 cmp	 edx, 16			; 00000010H
  01174	72 2c		 jb	 SHORT $LN1314@GetRaceRes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  01176	8b 4d d8	 mov	 ecx, DWORD PTR $T32[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  01179	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0117a	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0117c	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  01182	72 14		 jb	 SHORT $LN1324@GetRaceRes

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  01184	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  01187	83 c2 23	 add	 edx, 35			; 00000023H
  0118a	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0118c	83 c0 fc	 add	 eax, -4			; fffffffcH
  0118f	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  01192	0f 87 3f 01 00
	00		 ja	 $LN1407@GetRaceRes
$LN1324@GetRaceRes:

; 264  :         ::operator delete(_Ptr, _Bytes);

  01198	52		 push	 edx
  01199	51		 push	 ecx
  0119a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0119f	83 c4 08	 add	 esp, 8
$LN1314@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  011a2	6a 17		 push	 23			; 00000017H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  011a4	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T31[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  011ab	8d 4d d8	 lea	 ecx, DWORD PTR $T31[ebp]
  011ae	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@BCLHILHN@d?3?1ymir?5work?1npc_mount?1@

; 4596 :         _My_data._Mysize = 0;

  011b3	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T31[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  011ba	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T31[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  011c1	c6 45 d8 00	 mov	 BYTE PTR $T31[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  011c5	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 83   : 		vec_stPathes.push_back ("d:/ymir work/npc_mount/");

  011ca	8d 45 d8	 lea	 eax, DWORD PTR $T31[ebp]
  011cd	c7 45 fc 1d 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 29 ; 0000001dH
  011d4	50		 push	 eax
  011d5	8b ce		 mov	 ecx, esi
  011d7	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  011dc	8b 55 ec	 mov	 edx, DWORD PTR $T31[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 83   : 		vec_stPathes.push_back ("d:/ymir work/npc_mount/");

  011df	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  011e6	83 fa 10	 cmp	 edx, 16			; 00000010H
  011e9	72 2c		 jb	 SHORT $LN1357@GetRaceRes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  011eb	8b 4d d8	 mov	 ecx, DWORD PTR $T31[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  011ee	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  011ef	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  011f1	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  011f7	72 14		 jb	 SHORT $LN1367@GetRaceRes

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  011f9	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  011fc	83 c2 23	 add	 edx, 35			; 00000023H
  011ff	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  01201	83 c0 fc	 add	 eax, -4			; fffffffcH
  01204	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  01207	0f 87 ca 00 00
	00		 ja	 $LN1407@GetRaceRes
$LN1367@GetRaceRes:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0120d	52		 push	 edx
  0120e	51		 push	 ecx
  0120f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  01214	83 c4 08	 add	 esp, 8
$LN1357@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  01217	6a 13		 push	 19			; 00000013H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  01219	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T30[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  01220	8d 4d d8	 lea	 ecx, DWORD PTR $T30[ebp]
  01223	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@PJNPAGEJ@d?3?1ymir?5work?1guild?1@

; 4596 :         _My_data._Mysize = 0;

  01228	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T30[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0122f	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T30[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  01236	c6 45 d8 00	 mov	 BYTE PTR $T30[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0123a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 84   : 		vec_stPathes.push_back ("d:/ymir work/guild/");

  0123f	8d 45 d8	 lea	 eax, DWORD PTR $T30[ebp]
  01242	c7 45 fc 1e 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 30 ; 0000001eH
  01249	50		 push	 eax
  0124a	8b ce		 mov	 ecx, esi
  0124c	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  01251	8b 55 ec	 mov	 edx, DWORD PTR $T30[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 84   : 		vec_stPathes.push_back ("d:/ymir work/guild/");

  01254	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  0125b	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0125e	0f 82 9b f0 ff
	ff		 jb	 $LN1400@GetRaceRes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  01264	8b 4d d8	 mov	 ecx, DWORD PTR $T30[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  01267	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  01268	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0126a	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  01270	0f 82 7f f0 ff
	ff		 jb	 $LN1410@GetRaceRes

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  01276	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  01279	83 c2 23	 add	 edx, 35			; 00000023H
  0127c	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0127e	83 c0 fc	 add	 eax, -4			; fffffffcH
  01281	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  01284	77 51		 ja	 SHORT $LN1407@GetRaceRes
  01286	e9 6a f0 ff ff	 jmp	 $LN1410@GetRaceRes
$LN1416@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0128b	68 00 00 00 00	 push	 OFFSET ??_C@_0O@PEPGGFH@?$CDseason1?1npc?1@
  01290	50		 push	 eax
  01291	8b ce		 mov	 ecx, esi
  01293	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@AAY0O@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@AAY0O@$$CBD@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<char const (&)[14]>
$LN1415@GetRaceRes:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 128  : 	vec_stPathes.emplace_back("#season2/npc/");

  01298	68 00 00 00 00	 push	 OFFSET ??_C@_0O@DOKHHMMK@?$CDseason2?1npc?1@
  0129d	8b ce		 mov	 ecx, esi
  0129f	e8 00 00 00 00	 call	 ??$emplace_back@AAY0O@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?A_TAAY0O@$$CBD@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::emplace_back<char const (&)[14]>

; 129  : 	vec_stPathes.emplace_back("#season1/monster/");

  012a4	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@DOJALNLB@?$CDseason1?1monster?1@
  012a9	8b ce		 mov	 ecx, esi
  012ab	e8 00 00 00 00	 call	 ??$emplace_back@AAY0BC@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?A_TAAY0BC@$$CBD@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::emplace_back<char const (&)[18]>

; 130  : 	vec_stPathes.emplace_back("#season2/monster/");

  012b0	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KHHCNLLA@?$CDseason2?1monster?1@
  012b5	8b ce		 mov	 ecx, esi
  012b7	e8 00 00 00 00	 call	 ??$emplace_back@AAY0BC@$$CBD@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?A_TAAY0BC@$$CBD@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::emplace_back<char const (&)[18]>

; 131  : }

  012bc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  012bf	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  012c6	59		 pop	 ecx
  012c7	5f		 pop	 edi
  012c8	5e		 pop	 esi
  012c9	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  012cc	33 cd		 xor	 ecx, ebp
  012ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  012d3	8b e5		 mov	 esp, ebp
  012d5	5d		 pop	 ebp
  012d6	c3		 ret	 0
$LN1407@GetRaceRes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  012d7	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1439@GetRaceRes:
  012dc	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T60[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$1:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR $T59[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$2:
  00010	8d 4d d8	 lea	 ecx, DWORD PTR $T58[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$3:
  00018	8d 4d d8	 lea	 ecx, DWORD PTR $T57[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$4:
  00020	8d 4d d8	 lea	 ecx, DWORD PTR $T56[ebp]
  00023	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$5:
  00028	8d 4d d8	 lea	 ecx, DWORD PTR $T55[ebp]
  0002b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$6:
  00030	8d 4d d8	 lea	 ecx, DWORD PTR $T54[ebp]
  00033	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$7:
  00038	8d 4d d8	 lea	 ecx, DWORD PTR $T53[ebp]
  0003b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$8:
  00040	8d 4d d8	 lea	 ecx, DWORD PTR $T52[ebp]
  00043	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$9:
  00048	8d 4d d8	 lea	 ecx, DWORD PTR $T51[ebp]
  0004b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$10:
  00050	8d 4d d8	 lea	 ecx, DWORD PTR $T50[ebp]
  00053	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$11:
  00058	8d 4d d8	 lea	 ecx, DWORD PTR $T49[ebp]
  0005b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$12:
  00060	8d 4d d8	 lea	 ecx, DWORD PTR $T48[ebp]
  00063	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$13:
  00068	8d 4d d8	 lea	 ecx, DWORD PTR $T47[ebp]
  0006b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$14:
  00070	8d 4d d8	 lea	 ecx, DWORD PTR $T46[ebp]
  00073	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$15:
  00078	8d 4d d8	 lea	 ecx, DWORD PTR $T45[ebp]
  0007b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$16:
  00080	8d 4d d8	 lea	 ecx, DWORD PTR $T44[ebp]
  00083	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$17:
  00088	8d 4d d8	 lea	 ecx, DWORD PTR $T43[ebp]
  0008b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$18:
  00090	8d 4d d8	 lea	 ecx, DWORD PTR $T42[ebp]
  00093	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$19:
  00098	8d 4d d8	 lea	 ecx, DWORD PTR $T41[ebp]
  0009b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$20:
  000a0	8d 4d d8	 lea	 ecx, DWORD PTR $T40[ebp]
  000a3	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$21:
  000a8	8d 4d d8	 lea	 ecx, DWORD PTR $T39[ebp]
  000ab	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$22:
  000b0	8d 4d d8	 lea	 ecx, DWORD PTR $T38[ebp]
  000b3	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$23:
  000b8	8d 4d d8	 lea	 ecx, DWORD PTR $T37[ebp]
  000bb	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$31:
  000c0	8d 4d d8	 lea	 ecx, DWORD PTR $T29[ebp]
  000c3	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$32:
  000c8	8d 4d d8	 lea	 ecx, DWORD PTR $T28[ebp]
  000cb	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$33:
  000d0	8d 4d d8	 lea	 ecx, DWORD PTR $T27[ebp]
  000d3	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$34:
  000d8	8d 4d d8	 lea	 ecx, DWORD PTR $T26[ebp]
  000db	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$35:
  000e0	8d 4d d8	 lea	 ecx, DWORD PTR $T25[ebp]
  000e3	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$36:
  000e8	8d 4d d8	 lea	 ecx, DWORD PTR $T24[ebp]
  000eb	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$37:
  000f0	8d 4d d8	 lea	 ecx, DWORD PTR $T23[ebp]
  000f3	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$38:
  000f8	8d 4d d8	 lea	 ecx, DWORD PTR $T22[ebp]
  000fb	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$39:
  00100	8d 4d d8	 lea	 ecx, DWORD PTR $T21[ebp]
  00103	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$40:
  00108	8d 4d d8	 lea	 ecx, DWORD PTR $T20[ebp]
  0010b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$41:
  00110	8d 4d d8	 lea	 ecx, DWORD PTR $T19[ebp]
  00113	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$42:
  00118	8d 4d d8	 lea	 ecx, DWORD PTR $T18[ebp]
  0011b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$43:
  00120	8d 4d d8	 lea	 ecx, DWORD PTR $T17[ebp]
  00123	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$44:
  00128	8d 4d d8	 lea	 ecx, DWORD PTR $T16[ebp]
  0012b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$45:
  00130	8d 4d d8	 lea	 ecx, DWORD PTR $T15[ebp]
  00133	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$46:
  00138	8d 4d d8	 lea	 ecx, DWORD PTR $T14[ebp]
  0013b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$47:
  00140	8d 4d d8	 lea	 ecx, DWORD PTR $T13[ebp]
  00143	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$48:
  00148	8d 4d d8	 lea	 ecx, DWORD PTR $T12[ebp]
  0014b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$49:
  00150	8d 4d d8	 lea	 ecx, DWORD PTR $T11[ebp]
  00153	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$50:
  00158	8d 4d d8	 lea	 ecx, DWORD PTR $T10[ebp]
  0015b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$51:
  00160	8d 4d d8	 lea	 ecx, DWORD PTR $T9[ebp]
  00163	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$52:
  00168	8d 4d d8	 lea	 ecx, DWORD PTR $T8[ebp]
  0016b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$53:
  00170	8d 4d d8	 lea	 ecx, DWORD PTR $T7[ebp]
  00173	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$54:
  00178	8d 4d d8	 lea	 ecx, DWORD PTR $T6[ebp]
  0017b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$55:
  00180	8d 4d d8	 lea	 ecx, DWORD PTR $T5[ebp]
  00183	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$56:
  00188	8d 4d d8	 lea	 ecx, DWORD PTR $T4[ebp]
  0018b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$57:
  00190	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00193	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$58:
  00198	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  0019b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$24:
  001a0	8d 4d d8	 lea	 ecx, DWORD PTR $T36[ebp]
  001a3	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$25:
  001a8	8d 4d d8	 lea	 ecx, DWORD PTR $T35[ebp]
  001ab	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$26:
  001b0	8d 4d d8	 lea	 ecx, DWORD PTR $T34[ebp]
  001b3	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$27:
  001b8	8d 4d d8	 lea	 ecx, DWORD PTR $T33[ebp]
  001bb	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$28:
  001c0	8d 4d d8	 lea	 ecx, DWORD PTR $T32[ebp]
  001c3	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$29:
  001c8	8d 4d d8	 lea	 ecx, DWORD PTR $T31[ebp]
  001cb	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$30:
  001d0	8d 4d d8	 lea	 ecx, DWORD PTR $T30[ebp]
  001d3	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  001d8	cc		 int	 3
  001d9	cc		 int	 3
  001da	cc		 int	 3
  001db	cc		 int	 3
  001dc	cc		 int	 3
__ehhandler$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z:
  001dd	90		 npad	 1
  001de	90		 npad	 1
  001df	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  001e3	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  001e6	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  001e9	33 c8		 xor	 ecx, eax
  001eb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f0	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  001f3	33 c8		 xor	 ecx, eax
  001f5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001fa	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
  001ff	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ENDP ; __GetRaceResourcePathes
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
;	COMDAT ?__IsNPCRace@@YA_NI@Z
_TEXT	SEGMENT
_race$ = 8						; size = 4
?__IsNPCRace@@YA_NI@Z PROC				; __IsNPCRace, COMDAT

; 18   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19   : 	if (race > 9000)

  00003	81 7d 08 28 23
	00 00		 cmp	 DWORD PTR _race$[ebp], 9000 ; 00002328H
  0000a	0f 97 c0	 seta	 al

; 20   : 		return true;
; 21   : 
; 22   : 	return false;
; 23   : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?__IsNPCRace@@YA_NI@Z ENDP				; __IsNPCRace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
;	COMDAT ?__IsGuildRace@@YA_NI@Z
_TEXT	SEGMENT
_race$ = 8						; size = 4
?__IsGuildRace@@YA_NI@Z PROC				; __IsGuildRace, COMDAT

; 7    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 8    : 	if (race >= 14000 && race < 15000)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _race$[ebp]
  00006	8d 81 50 c9 ff
	ff		 lea	 eax, DWORD PTR [ecx-14000]
  0000c	3d e7 03 00 00	 cmp	 eax, 999		; 000003e7H
  00011	76 0c		 jbe	 SHORT $LN5@IsGuildRac

; 9    : 		return true;
; 10   : 
; 11   : 	if (20043 == race)

  00013	81 f9 4b 4e 00
	00		 cmp	 ecx, 20043		; 00004e4bH
  00019	74 04		 je	 SHORT $LN5@IsGuildRac

; 13   : 
; 14   : 	return false;

  0001b	32 c0		 xor	 al, al

; 15   : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
$LN5@IsGuildRac:

; 12   : 		return true;

  0001f	b0 01		 mov	 al, 1

; 15   : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
?__IsGuildRace@@YA_NI@Z ENDP				; __IsGuildRace
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCRaceManager@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCRaceManager@@UAEPAXI@Z PROC			; CRaceManager::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CRaceManager@@UAE@XZ	; CRaceManager::~CRaceManager
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 38		 push	 56			; 00000038H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GCRaceManager@@UAEPAXI@Z ENDP			; CRaceManager::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 758  :         _Erase_tree(_Al, _Myhead->_Parent);

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 70 04	 push	 DWORD PTR [eax+4]
  00008	56		 push	 esi
  00009	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  0000e	6a 40		 push	 64			; 00000040H
  00010	ff 36		 push	 DWORD PTR [esi]
  00012	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00017	83 c4 08	 add	 esp, 8
  0001a	5e		 pop	 esi
  0001b	c3		 ret	 0
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@2@QAU32@@Z
_TEXT	SEGMENT
__Head$1$ = -8						; size = 4
_this$1$ = -4						; size = 4
__Loc$ = 8						; size = 8
__Newnode$ = 16						; size = 4
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@2@QAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Insert_node, COMDAT
; _this$ = ecx

; 650  :     _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 651  :         ++_Mysize;
; 652  :         const auto _Head  = _Myhead;
; 653  :         _Newnode->_Parent = _Loc._Parent;

  00006	8b 55 08	 mov	 edx, DWORD PTR __Loc$[ebp]
  00009	8b c1		 mov	 eax, ecx
  0000b	89 45 fc	 mov	 DWORD PTR _this$1$[ebp], eax
  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00010	ff 40 04	 inc	 DWORD PTR [eax+4]
  00013	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00016	89 4d f8	 mov	 DWORD PTR __Head$1$[ebp], ecx
  00019	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 654  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

  0001c	3b d1		 cmp	 edx, ecx
  0001e	75 12		 jne	 SHORT $LN5@Insert_nod

; 655  :             _Head->_Left     = _Newnode;

  00020	89 01		 mov	 DWORD PTR [ecx], eax

; 656  :             _Head->_Parent   = _Newnode;

  00022	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 657  :             _Head->_Right    = _Newnode;

  00025	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 658  :             _Newnode->_Color = _Black; // the root is black

  00028	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 717  :     }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 0c 00	 ret	 12			; 0000000cH
$LN5@Insert_nod:

; 659  :             return _Newnode;
; 660  :         }
; 661  : 
; 662  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 663  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

  00032	83 7d 0c 00	 cmp	 DWORD PTR __Loc$[ebp+4], 0
  00036	75 0d		 jne	 SHORT $LN6@Insert_nod

; 664  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 665  :             _Loc._Parent->_Right = _Newnode;

  00038	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 666  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

  0003b	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003e	75 0d		 jne	 SHORT $LN9@Insert_nod

; 667  :                 _Head->_Right = _Newnode;

  00040	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 668  :             }
; 669  :         } else { // add to left of _Loc._Parent

  00043	eb 08		 jmp	 SHORT $LN9@Insert_nod
$LN6@Insert_nod:

; 670  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 671  :             _Loc._Parent->_Left = _Newnode;

  00045	89 02		 mov	 DWORD PTR [edx], eax

; 672  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

  00047	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00049	75 02		 jne	 SHORT $LN9@Insert_nod

; 673  :                 _Head->_Left = _Newnode;

  0004b	89 01		 mov	 DWORD PTR [ecx], eax
$LN9@Insert_nod:

; 674  :             }
; 675  :         }
; 676  : 
; 677  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  0004d	8b d0		 mov	 edx, eax
  0004f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00052	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  00056	0f 85 99 01 00
	00		 jne	 $LN3@Insert_nod
  0005c	53		 push	 ebx
  0005d	56		 push	 esi
  0005e	57		 push	 edi
  0005f	90		 npad	 1
$LL2@Insert_nod:

; 678  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

  00060	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00063	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
  00066	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00069	8d 59 04	 lea	 ebx, DWORD PTR [ecx+4]
  0006c	8b 06		 mov	 eax, DWORD PTR [esi]
  0006e	3b c8		 cmp	 ecx, eax
  00070	0f 85 ba 00 00
	00		 jne	 $LN10@Insert_nod

; 679  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

  00076	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 680  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00079	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  0007d	0f 84 b3 00 00
	00		 je	 $LN53@Insert_nod

; 681  :                     _Pnode->_Parent->_Color          = _Black;
; 682  :                     _Parent_sibling->_Color          = _Black;
; 683  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 684  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 685  :                 } else { // parent's sibling has red and black children
; 686  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

  00083	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00086	3b d6		 cmp	 edx, esi
  00088	75 47		 jne	 SHORT $LN51@Insert_nod

; 466  :         _Wherenode->_Right = _Pnode->_Left;

  0008a	8b 06		 mov	 eax, DWORD PTR [esi]

; 687  :                         _Pnode = _Pnode->_Parent;

  0008c	8b d1		 mov	 edx, ecx

; 466  :         _Wherenode->_Right = _Pnode->_Left;

  0008e	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 467  : 
; 468  :         if (!_Pnode->_Left->_Isnil) {

  00091	8b 06		 mov	 eax, DWORD PTR [esi]
  00093	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00097	75 03		 jne	 SHORT $LN20@Insert_nod

; 469  :             _Pnode->_Left->_Parent = _Wherenode;

  00099	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN20@Insert_nod:

; 470  :         }
; 471  : 
; 472  :         _Pnode->_Parent = _Wherenode->_Parent;

  0009c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0009e	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 473  : 
; 474  :         if (_Wherenode == _Myhead->_Parent) {

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  000a4	8b 00		 mov	 eax, DWORD PTR [eax]
  000a6	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  000a9	75 0b		 jne	 SHORT $LN21@Insert_nod

; 475  :             _Myhead->_Parent = _Pnode;

  000ab	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 483  :         _Wherenode->_Parent = _Pnode;

  000ae	8b fb		 mov	 edi, ebx
  000b0	89 16		 mov	 DWORD PTR [esi], edx
  000b2	89 33		 mov	 DWORD PTR [ebx], esi
  000b4	eb 1d		 jmp	 SHORT $LN49@Insert_nod
$LN21@Insert_nod:

; 476  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  000b6	8b 03		 mov	 eax, DWORD PTR [ebx]
  000b8	3b 10		 cmp	 edx, DWORD PTR [eax]
  000ba	75 0a		 jne	 SHORT $LN23@Insert_nod

; 477  :             _Wherenode->_Parent->_Left = _Pnode;

  000bc	89 30		 mov	 DWORD PTR [eax], esi

; 483  :         _Wherenode->_Parent = _Pnode;

  000be	8b fb		 mov	 edi, ebx
  000c0	89 16		 mov	 DWORD PTR [esi], edx
  000c2	89 33		 mov	 DWORD PTR [ebx], esi
  000c4	eb 0d		 jmp	 SHORT $LN49@Insert_nod
$LN23@Insert_nod:

; 479  :             _Wherenode->_Parent->_Right = _Pnode;

  000c6	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 483  :         _Wherenode->_Parent = _Pnode;

  000c9	8b fb		 mov	 edi, ebx
  000cb	89 16		 mov	 DWORD PTR [esi], edx
  000cd	89 33		 mov	 DWORD PTR [ebx], esi
  000cf	eb 02		 jmp	 SHORT $LN49@Insert_nod
$LN51@Insert_nod:
  000d1	8b f1		 mov	 esi, ecx
$LN49@Insert_nod:

; 688  :                         _Lrotate(_Pnode);
; 689  :                     }
; 690  : 
; 691  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  000d3	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1

; 692  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  000d7	8b 07		 mov	 eax, DWORD PTR [edi]
  000d9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000dc	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 693  :                     _Rrotate(_Pnode->_Parent->_Parent);

  000e0	8b 07		 mov	 eax, DWORD PTR [edi]
  000e2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 487  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  000e5	8b 31		 mov	 esi, DWORD PTR [ecx]

; 488  :         _Wherenode->_Left = _Pnode->_Right;

  000e7	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ea	89 01		 mov	 DWORD PTR [ecx], eax

; 489  : 
; 490  :         if (!_Pnode->_Right->_Isnil) {

  000ec	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ef	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000f3	75 03		 jne	 SHORT $LN27@Insert_nod

; 491  :             _Pnode->_Right->_Parent = _Wherenode;

  000f5	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN27@Insert_nod:

; 492  :         }
; 493  : 
; 494  :         _Pnode->_Parent = _Wherenode->_Parent;

  000f8	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000fb	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 495  : 
; 496  :         if (_Wherenode == _Myhead->_Parent) {

  000fe	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00101	8b 00		 mov	 eax, DWORD PTR [eax]
  00103	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00106	75 0b		 jne	 SHORT $LN28@Insert_nod

; 497  :             _Myhead->_Parent = _Pnode;

  00108	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 502  :         }
; 503  : 
; 504  :         _Pnode->_Right      = _Wherenode;

  0010b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 694  :                 }
; 695  :             } else { // fixup red-red in right subtree

  0010e	e9 cc 00 00 00	 jmp	 $LN52@Insert_nod
$LN28@Insert_nod:

; 498  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00113	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00116	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00119	75 0b		 jne	 SHORT $LN30@Insert_nod

; 499  :             _Wherenode->_Parent->_Right = _Pnode;

  0011b	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 502  :         }
; 503  : 
; 504  :         _Pnode->_Right      = _Wherenode;

  0011e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 694  :                 }
; 695  :             } else { // fixup red-red in right subtree

  00121	e9 b9 00 00 00	 jmp	 $LN52@Insert_nod
$LN30@Insert_nod:

; 501  :             _Wherenode->_Parent->_Left = _Pnode;

  00126	89 30		 mov	 DWORD PTR [eax], esi

; 502  :         }
; 503  : 
; 504  :         _Pnode->_Right      = _Wherenode;

  00128	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 694  :                 }
; 695  :             } else { // fixup red-red in right subtree

  0012b	e9 af 00 00 00	 jmp	 $LN52@Insert_nod
$LN10@Insert_nod:

; 696  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;
; 697  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00130	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  00134	75 1b		 jne	 SHORT $LN15@Insert_nod
$LN53@Insert_nod:

; 674  :             }
; 675  :         }
; 676  : 
; 677  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  00136	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1
  0013a	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  0013e	8b 07		 mov	 eax, DWORD PTR [edi]
  00140	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00143	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0
  00147	8b 07		 mov	 eax, DWORD PTR [edi]
  00149	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0014c	e9 91 00 00 00	 jmp	 $LN46@Insert_nod
$LN15@Insert_nod:

; 698  :                     _Pnode->_Parent->_Color          = _Black;
; 699  :                     _Parent_sibling->_Color          = _Black;
; 700  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 701  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 702  :                 } else { // parent's sibling has red and black children
; 703  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

  00151	8b 01		 mov	 eax, DWORD PTR [ecx]
  00153	3b d0		 cmp	 edx, eax
  00155	75 3e		 jne	 SHORT $LN39@Insert_nod

; 704  :                         _Pnode = _Pnode->_Parent;

  00157	8b d1		 mov	 edx, ecx

; 487  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  00159	8b c8		 mov	 ecx, eax

; 488  :         _Wherenode->_Left = _Pnode->_Right;

  0015b	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0015e	89 02		 mov	 DWORD PTR [edx], eax

; 489  : 
; 490  :         if (!_Pnode->_Right->_Isnil) {

  00160	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00163	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00167	75 03		 jne	 SHORT $LN34@Insert_nod

; 491  :             _Pnode->_Right->_Parent = _Wherenode;

  00169	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN34@Insert_nod:

; 492  :         }
; 493  : 
; 494  :         _Pnode->_Parent = _Wherenode->_Parent;

  0016c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0016e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 495  : 
; 496  :         if (_Wherenode == _Myhead->_Parent) {

  00171	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00174	8b 00		 mov	 eax, DWORD PTR [eax]
  00176	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00179	75 05		 jne	 SHORT $LN35@Insert_nod

; 497  :             _Myhead->_Parent = _Pnode;

  0017b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0017e	eb 0e		 jmp	 SHORT $LN38@Insert_nod
$LN35@Insert_nod:

; 498  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00180	8b 03		 mov	 eax, DWORD PTR [ebx]
  00182	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  00185	75 05		 jne	 SHORT $LN37@Insert_nod

; 499  :             _Wherenode->_Parent->_Right = _Pnode;

  00187	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 500  :         } else {

  0018a	eb 02		 jmp	 SHORT $LN38@Insert_nod
$LN37@Insert_nod:

; 501  :             _Wherenode->_Parent->_Left = _Pnode;

  0018c	89 08		 mov	 DWORD PTR [eax], ecx
$LN38@Insert_nod:

; 502  :         }
; 503  : 
; 504  :         _Pnode->_Right      = _Wherenode;

  0018e	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 505  :         _Wherenode->_Parent = _Pnode;

  00191	8b fb		 mov	 edi, ebx
  00193	89 0b		 mov	 DWORD PTR [ebx], ecx
$LN39@Insert_nod:

; 705  :                         _Rrotate(_Pnode);
; 706  :                     }
; 707  : 
; 708  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  00195	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 709  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00199	8b 07		 mov	 eax, DWORD PTR [edi]
  0019b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019e	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 710  :                     _Lrotate(_Pnode->_Parent->_Parent);

  001a2	8b 07		 mov	 eax, DWORD PTR [edi]
  001a4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 465  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  001a7	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]

; 466  :         _Wherenode->_Right = _Pnode->_Left;

  001aa	8b 06		 mov	 eax, DWORD PTR [esi]
  001ac	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 467  : 
; 468  :         if (!_Pnode->_Left->_Isnil) {

  001af	8b 06		 mov	 eax, DWORD PTR [esi]
  001b1	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  001b5	75 03		 jne	 SHORT $LN41@Insert_nod

; 469  :             _Pnode->_Left->_Parent = _Wherenode;

  001b7	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN41@Insert_nod:

; 470  :         }
; 471  : 
; 472  :         _Pnode->_Parent = _Wherenode->_Parent;

  001ba	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001bd	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 473  : 
; 474  :         if (_Wherenode == _Myhead->_Parent) {

  001c0	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  001c3	8b 00		 mov	 eax, DWORD PTR [eax]
  001c5	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  001c8	75 05		 jne	 SHORT $LN42@Insert_nod

; 475  :             _Myhead->_Parent = _Pnode;

  001ca	89 70 04	 mov	 DWORD PTR [eax+4], esi
  001cd	eb 0e		 jmp	 SHORT $LN45@Insert_nod
$LN42@Insert_nod:

; 476  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  001cf	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001d2	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001d4	75 04		 jne	 SHORT $LN44@Insert_nod

; 477  :             _Wherenode->_Parent->_Left = _Pnode;

  001d6	89 30		 mov	 DWORD PTR [eax], esi

; 478  :         } else {

  001d8	eb 03		 jmp	 SHORT $LN45@Insert_nod
$LN44@Insert_nod:

; 479  :             _Wherenode->_Parent->_Right = _Pnode;

  001da	89 70 08	 mov	 DWORD PTR [eax+8], esi
$LN45@Insert_nod:

; 480  :         }
; 481  : 
; 482  :         _Pnode->_Left       = _Wherenode;

  001dd	89 0e		 mov	 DWORD PTR [esi], ecx
$LN52@Insert_nod:

; 674  :             }
; 675  :         }
; 676  : 
; 677  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  001df	89 71 04	 mov	 DWORD PTR [ecx+4], esi
$LN46@Insert_nod:
  001e2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001e5	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  001e9	0f 84 71 fe ff
	ff		 je	 $LL2@Insert_nod
  001ef	8b 4d f8	 mov	 ecx, DWORD PTR __Head$1$[ebp]
  001f2	5f		 pop	 edi
  001f3	5e		 pop	 esi
  001f4	5b		 pop	 ebx
$LN3@Insert_nod:

; 711  :                 }
; 712  :             }
; 713  :         }
; 714  : 
; 715  :         _Head->_Parent->_Color = _Black; // root is always black

  001f5	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001f8	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 716  :         return _Newnode;

  001fc	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]

; 717  :     }

  001ff	8b e5		 mov	 esp, ebp
  00201	5d		 pop	 ebp
  00202	c2 0c 00	 ret	 12			; 0000000cH
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@2@QAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
;	COMDAT ?__DestroyRaceDataMap@CRaceManager@@IAEXXZ
_TEXT	SEGMENT
?__DestroyRaceDataMap@CRaceManager@@IAEXXZ PROC		; CRaceManager::__DestroyRaceDataMap, COMDAT
; _this$ = ecx

; 468  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1143 :         return iterator(_Scary->_Myhead->_Left, _Scary);

  00002	8d 59 04	 lea	 ebx, DWORD PTR [ecx+4]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 468  : {

  00005	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1143 :         return iterator(_Scary->_Myhead->_Left, _Scary);

  00006	8b 3b		 mov	 edi, DWORD PTR [ebx]

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00008	8b 37		 mov	 esi, DWORD PTR [edi]
  0000a	3b f7		 cmp	 esi, edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 470  : 	for (i=m_RaceDataMap.begin(); i!=m_RaceDataMap.end(); ++i)

  0000c	74 54		 je	 SHORT $LN3@DestroyRac
  0000e	66 90		 npad	 2
$LL28@DestroyRac:

; 471  : 		CRaceData::Delete(i->second);

  00010	ff 76 14	 push	 DWORD PTR [esi+20]
  00013	e8 00 00 00 00	 call	 ?Delete@CRaceData@@SAXPAV1@@Z ; CRaceData::Delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 52   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  00018	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 471  : 		CRaceData::Delete(i->second);

  0001b	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 52   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  0001e	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00022	74 20		 je	 SHORT $LN27@DestroyRac

; 53   :             _Nodeptr _Pnode;
; 54   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

  00024	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00027	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0002b	75 13		 jne	 SHORT $LN102@DestroyRac
  0002d	0f 1f 00	 npad	 3
$LL25@DestroyRac:
  00030	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00033	75 0b		 jne	 SHORT $LN102@DestroyRac

; 55   :                 _Ptr = _Pnode; // ==> parent while right subtree

  00035	8b f0		 mov	 esi, eax
  00037	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003a	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0003e	74 f0		 je	 SHORT $LL25@DestroyRac
$LN102@DestroyRac:

; 56   :             }
; 57   : 
; 58   :             _Ptr = _Pnode; // ==> parent (head if end())

  00040	8b f0		 mov	 esi, eax

; 59   :         } else {

  00042	eb 18		 jmp	 SHORT $LN32@DestroyRac
$LN27@DestroyRac:

; 60   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

  00044	8b f0		 mov	 esi, eax

; 457  :         while (!_Pnode->_Left->_Isnil) {

  00046	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00048	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0004c	75 0e		 jne	 SHORT $LN32@DestroyRac
  0004e	66 90		 npad	 2
$LL31@DestroyRac:
  00050	8b 01		 mov	 eax, DWORD PTR [ecx]

; 458  :             _Pnode = _Pnode->_Left;

  00052	8b f1		 mov	 esi, ecx
  00054	8b c8		 mov	 ecx, eax
  00056	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0005a	74 f4		 je	 SHORT $LL31@DestroyRac
$LN32@DestroyRac:

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0005c	8b 3b		 mov	 edi, DWORD PTR [ebx]

; 236  :         return this->_Ptr == _Right._Ptr;

  0005e	3b f7		 cmp	 esi, edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 470  : 	for (i=m_RaceDataMap.begin(); i!=m_RaceDataMap.end(); ++i)

  00060	75 ae		 jne	 SHORT $LL28@DestroyRac
$LN3@DestroyRac:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1351 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

  00062	8b 77 04	 mov	 esi, DWORD PTR [edi+4]

; 749  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00065	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00069	75 25		 jne	 SHORT $LN56@DestroyRac
  0006b	0f 1f 44 00 00	 npad	 5
$LL55@DestroyRac:

; 750  :             _Erase_tree(_Al, _Rootnode->_Right);

  00070	ff 76 08	 push	 DWORD PTR [esi+8]
  00073	8b cb		 mov	 ecx, ebx
  00075	53		 push	 ebx
  00076	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCRaceData@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CRaceData *> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CRaceData *>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 616  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0007b	8b c6		 mov	 eax, esi

; 617  :     _Val         = static_cast<_Other&&>(_New_val);

  0007d	8b 36		 mov	 esi, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  0007f	6a 18		 push	 24			; 00000018H
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00087	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 749  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  0008a	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0008e	74 e0		 je	 SHORT $LL55@DestroyRac
$LN56@DestroyRac:

; 1352 :         _Head->_Parent  = _Head;

  00090	89 7f 04	 mov	 DWORD PTR [edi+4], edi

; 1353 :         _Head->_Left    = _Head;

  00093	89 3f		 mov	 DWORD PTR [edi], edi

; 1354 :         _Head->_Right   = _Head;

  00095	89 7f 08	 mov	 DWORD PTR [edi+8], edi

; 1355 :         _Scary->_Mysize = 0;

  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0
  000a1	5b		 pop	 ebx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 474  : }

  000a2	c3		 ret	 0
?__DestroyRaceDataMap@CRaceManager@@IAEXXZ ENDP		; CRaceManager::__DestroyRaceDataMap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
;	COMDAT ?__Initialize@CRaceManager@@IAEXXZ
_TEXT	SEGMENT
?__Initialize@CRaceManager@@IAEXXZ PROC			; CRaceManager::__Initialize, COMDAT
; _this$ = ecx

; 464  : 	m_pSelectedRaceData = NULL;

  00000	c7 41 34 00 00
	00 00		 mov	 DWORD PTR [ecx+52], 0

; 465  : }

  00007	c3		 ret	 0
?__Initialize@CRaceManager@@IAEXXZ ENDP			; CRaceManager::__Initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
;	COMDAT ?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z
_TEXT	SEGMENT
_kTextFileLoader$ = -1304				; size = 16
_pathName$GSCopy$1$ = -1288				; size = 4
_pvData$ = -1284					; size = 4
tv9339 = -1280						; size = 4
$T2 = -1280						; size = 4
_motionListFileName$GSCopy$1$ = -1276			; size = 4
_uLineCount$1$ = -1276					; size = 4
_nPercent$ = -1272					; size = 4
_rkRaceData$GSCopy$1$ = -1268				; size = 4
_isSpawn$1$ = -1261					; size = 1
$T3 = -1260						; size = 12
$T4 = -1260						; size = 12
$T5 = -1260						; size = 12
$T6 = -1256						; size = 8
$T7 = -1256						; size = 8
$T8 = -1256						; size = 8
$T9 = -1256						; size = 8
$T10 = -1256						; size = 8
$T11 = -1256						; size = 8
$T12 = -1256						; size = 8
$T13 = -1256						; size = 8
$T14 = -1256						; size = 8
$T15 = -1256						; size = 8
$T16 = -1256						; size = 8
$T17 = -1256						; size = 8
$T18 = -1256						; size = 8
$T19 = -1256						; size = 8
$T20 = -1256						; size = 8
$T21 = -1256						; size = 8
$T22 = -1256						; size = 8
$T23 = -1256						; size = 8
$T24 = -1256						; size = 8
$T25 = -1256						; size = 8
$T26 = -1256						; size = 8
$T27 = -1256						; size = 8
$T28 = -1256						; size = 8
$T29 = -1256						; size = 8
$T30 = -1256						; size = 8
$T31 = -1256						; size = 8
$T32 = -1256						; size = 8
$T33 = -1256						; size = 8
$T34 = -1256						; size = 8
$T35 = -1256						; size = 8
$T36 = -1256						; size = 8
$T37 = -1256						; size = 8
$T38 = -1256						; size = 8
$T39 = -1256						; size = 8
$T40 = -1256						; size = 8
$T41 = -1256						; size = 8
$T42 = -1256						; size = 8
$T43 = -1256						; size = 8
$T44 = -1256						; size = 8
$T45 = -1256						; size = 8
$T46 = -1256						; size = 8
$T47 = -1256						; size = 8
$T48 = -1256						; size = 8
$T49 = -1256						; size = 8
$T50 = -1256						; size = 8
$T51 = -1256						; size = 8
$T52 = -1256						; size = 8
$T53 = -1256						; size = 8
$T54 = -1256						; size = 8
_fTypeIndex$55 = -1252					; size = 4
$T56 = -1252						; size = 4
$T57 = -1252						; size = 4
$T58 = -1252						; size = 4
$T59 = -1252						; size = 4
$T60 = -1252						; size = 4
$T61 = -1252						; size = 4
$T62 = -1252						; size = 4
$T63 = -1252						; size = 4
$T64 = -1252						; size = 4
$T65 = -1252						; size = 4
$T66 = -1252						; size = 4
$T67 = -1252						; size = 4
$T68 = -1252						; size = 4
$T69 = -1252						; size = 4
$T70 = -1252						; size = 4
$T71 = -1252						; size = 4
$T72 = -1252						; size = 4
$T73 = -1252						; size = 4
$T74 = -1252						; size = 4
$T75 = -1252						; size = 4
$T76 = -1252						; size = 4
$T77 = -1252						; size = 4
_kMappedFile$ = -1248					; size = 324
$T78 = -924						; size = 28
$T79 = -896						; size = 28
$T80 = -868						; size = 28
$T81 = -840						; size = 28
_typeName$82 = -836					; size = 24
$T83 = -836						; size = 24
__Loc$84 = -824						; size = 12
__Loc$85 = -824						; size = 12
__Loc$86 = -824						; size = 12
$T87 = -812						; size = 28
$T88 = -812						; size = 28
$T89 = -812						; size = 28
$T90 = -812						; size = 28
$T91 = -812						; size = 28
$T92 = -812						; size = 28
$T93 = -812						; size = 28
$T94 = -812						; size = 28
$T95 = -812						; size = 28
$T96 = -812						; size = 28
$T97 = -812						; size = 28
$T98 = -812						; size = 28
$T99 = -812						; size = 28
$T100 = -812						; size = 28
$T101 = -812						; size = 28
$T102 = -812						; size = 28
$T103 = -812						; size = 28
$T104 = -812						; size = 28
$T105 = -812						; size = 28
$T106 = -812						; size = 28
$T107 = -812						; size = 28
$T108 = -812						; size = 28
$T109 = -812						; size = 28
$T110 = -812						; size = 28
$T111 = -812						; size = 28
$T112 = -812						; size = 28
$T113 = -812						; size = 28
$T114 = -812						; size = 28
$T115 = -812						; size = 28
$T116 = -812						; size = 28
$T117 = -812						; size = 28
$T118 = -812						; size = 28
$T119 = -812						; size = 28
$T120 = -812						; size = 28
$T121 = -812						; size = 28
$T122 = -812						; size = 28
$T123 = -812						; size = 28
$T124 = -812						; size = 28
$T125 = -812						; size = 28
$T126 = -812						; size = 28
$T127 = -812						; size = 28
$T128 = -812						; size = 28
$T129 = -812						; size = 28
$T130 = -812						; size = 28
$T131 = -812						; size = 28
$T132 = -808						; size = 24
_szMode$ = -784						; size = 256
_szFile$ = -528						; size = 256
_szType$ = -272						; size = 256
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_rkRaceData$ = 8					; size = 4
_pathName$ = 12						; size = 4
_motionListFileName$ = 16				; size = 4
?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z PROC ; CRaceManager::__LoadRaceMotionList, COMDAT
; _this$ = ecx

; 225  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 0c 05 00
	00		 sub	 esp, 1292		; 0000050cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b 45 0c	 mov	 eax, DWORD PTR _pathName$[ebp]

; 226  : 	static std::map<std::string, DWORD> s_kMap_stType_dwIndex;

  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __tls_index
  00037	8b 7d 08	 mov	 edi, DWORD PTR _rkRaceData$[ebp]
  0003a	89 85 f8 fa ff
	ff		 mov	 DWORD PTR _pathName$GSCopy$1$[ebp], eax
  00040	8b 45 10	 mov	 eax, DWORD PTR _motionListFileName$[ebp]
  00043	89 85 04 fb ff
	ff		 mov	 DWORD PTR _motionListFileName$GSCopy$1$[ebp], eax
  00049	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__tls_array
  0004f	89 bd 0c fb ff
	ff		 mov	 DWORD PTR _rkRaceData$GSCopy$1$[ebp], edi
  00055	8b 1c 88	 mov	 ebx, DWORD PTR [eax+ecx*4]
  00058	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$TSS0@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4HA
  0005d	89 9d 00 fb ff
	ff		 mov	 DWORD PTR tv9339[ebp], ebx
  00063	3b 83 00 00 00
	00		 cmp	 eax, DWORD PTR __Init_thread_epoch[ebx]
  00069	0f 8f c3 1c 00
	00		 jg	 $LN2103@LoadRaceMo
$LN2@LoadRaceMo:

; 227  : 	static bool s_isInit=false;
; 228  : 
; 229  : 	if (!s_isInit)

  0006f	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?s_isInit@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4_NA, 0
  00076	0f 85 97 19 00
	00		 jne	 $LN13@LoadRaceMo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0007c	a0 04 00 00 00	 mov	 al, BYTE PTR ??_C@_05NIJFIOCI@SPAWN@+4

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00081	bf 0f 00 00 00	 mov	 edi, 15			; 0000000fH

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00086	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ??_C@_05NIJFIOCI@SPAWN@
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 231  : 		s_isInit=true;

  0008c	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?s_isInit@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4_NA, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00093	89 bd e8 fc ff
	ff		 mov	 DWORD PTR $T131[ebp+20], edi

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  00099	c7 85 e4 fc ff
	ff 05 00 00 00	 mov	 DWORD PTR $T131[ebp+16], 5

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  000a3	89 b5 d4 fc ff
	ff		 mov	 DWORD PTR $T131[ebp], esi
  000a9	88 85 d8 fc ff
	ff		 mov	 BYTE PTR $T131[ebp+4], al

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  000af	c6 85 d9 fc ff
	ff 00		 mov	 BYTE PTR $T131[ebp+5], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  000b6	c7 85 ec fc ff
	ff 19 00 00 00	 mov	 DWORD PTR $T131[ebp+24], 25 ; 00000019H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1014 :             _Loc                = _Find_lower_bound(_Keyval);

  000c0	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T131[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 233  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("SPAWN", CRaceMotionData::NAME_SPAWN));

  000c6	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1014 :             _Loc                = _Find_lower_bound(_Keyval);

  000cd	50		 push	 eax
  000ce	8d 85 14 fb ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  000d4	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  000df	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  000e3	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000e6	66 0f d6 85 c8
	fc ff ff	 movq	 QWORD PTR __Loc$86[ebp], xmm0

; 1599 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  000ee	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000f2	75 1b		 jne	 SHORT $LN195@LoadRaceMo
  000f4	83 c0 10	 add	 eax, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef

; 127  :         return _Left < _Right;

  000f7	50		 push	 eax
  000f8	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T131[ebp]
  000fe	50		 push	 eax
  000ff	e8 00 00 00 00	 call	 ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
  00104	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1599 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00107	84 c0		 test	 al, al
  00109	0f 84 8d 00 00
	00		 je	 $LN308@LoadRaceMo
$LN195@LoadRaceMo:

; 1623 :         if (max_size() == _Get_scary()->_Mysize) {

  0010f	81 3d 04 00 00
	00 5d 74 d1 05	 cmp	 DWORD PTR ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A+4, 97612893 ; 05d1745dH
  00119	0f 84 71 1c 00
	00		 je	 $LN2104@LoadRaceMo

; 1020 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  0011f	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1012 :     _CONSTEXPR20_DYNALLOC explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00125	c7 85 18 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp], OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A

; 85   :         return ::operator new(_Bytes);

  0012f	6a 2c		 push	 44			; 0000002cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 790  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00131	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1019 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00135	c7 85 1c fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+4], 0

; 85   :         return ::operator new(_Bytes);

  0013f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 244  :         return _Traits::_Allocate(_Bytes);

  00144	8b f8		 mov	 edi, eax

; 85   :         return ::operator new(_Bytes);

  00146	83 c4 04	 add	 esp, 4

; 1020 :         _Ptr = _Al.allocate(1);

  00149	89 bd 1c fb ff
	ff		 mov	 DWORD PTR $T8[ebp+4], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 213  :     pair(pair&&)      = default;

  0014f	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T131[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 811  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

  00155	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 213  :     pair(pair&&)      = default;

  00159	50		 push	 eax
  0015a	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  0015d	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00162	8b 85 ec fc ff
	ff		 mov	 eax, DWORD PTR $T131[ebp+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1039 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00168	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  0016d	57		 push	 edi
  0016e	ff b5 cc fc ff
	ff		 push	 DWORD PTR __Loc$86[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 213  :     pair(pair&&)      = default;

  00174	89 47 28	 mov	 DWORD PTR [edi+40], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1039 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00177	ff b5 c8 fc ff
	ff		 push	 DWORD PTR __Loc$86[ebp]

; 813  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  0017d	89 1f		 mov	 DWORD PTR [edi], ebx

; 814  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  0017f	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 815  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  00182	89 5f 08	 mov	 DWORD PTR [edi+8], ebx

; 816  :         this->_Ptr->_Color = _Red;

  00185	66 c7 47 0c 00
	00		 mov	 WORD PTR [edi+12], 0

; 1039 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  0018b	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> > >::_Insert_node
  00190	8b bd e8 fc ff
	ff		 mov	 edi, DWORD PTR $T131[ebp+20]
  00196	8b b5 d4 fc ff
	ff		 mov	 esi, DWORD PTR $T131[ebp]
$LN308@LoadRaceMo:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 233  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("SPAWN", CRaceMotionData::NAME_SPAWN));

  0019c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  001a3	83 ff 10	 cmp	 edi, 16			; 00000010H
  001a6	72 2b		 jb	 SHORT $LN333@LoadRaceMo

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  001a8	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001ab	8b c6		 mov	 eax, esi

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  001ad	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  001b3	72 14		 jb	 SHORT $LN343@LoadRaceMo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001b5	8b 76 fc	 mov	 esi, DWORD PTR [esi-4]
  001b8	83 c1 23	 add	 ecx, 35			; 00000023H
  001bb	2b c6		 sub	 eax, esi

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001bd	83 c0 fc	 add	 eax, -4			; fffffffcH
  001c0	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001c3	0f 87 d6 1b 00
	00		 ja	 $LN2016@LoadRaceMo
$LN343@LoadRaceMo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  001c9	51		 push	 ecx
  001ca	56		 push	 esi
  001cb	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001d0	83 c4 08	 add	 esp, 8
$LN333@LoadRaceMo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  001d3	bf 0f 00 00 00	 mov	 edi, 15			; 0000000fH

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  001d8	c7 85 e4 fc ff
	ff 04 00 00 00	 mov	 DWORD PTR $T130[ebp+16], 4

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  001e2	be 57 41 49 54	 mov	 esi, 1414086999		; 54494157H

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  001e7	89 bd e8 fc ff
	ff		 mov	 DWORD PTR $T130[ebp+20], edi

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  001ed	89 b5 d4 fc ff
	ff		 mov	 DWORD PTR $T130[ebp], esi

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  001f3	c6 85 d8 fc ff
	ff 00		 mov	 BYTE PTR $T130[ebp+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  001fa	c7 85 ec fc ff
	ff 01 00 00 00	 mov	 DWORD PTR $T130[ebp+24], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1014 :             _Loc                = _Find_lower_bound(_Keyval);

  00204	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T130[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 234  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("WAIT", CRaceMotionData::NAME_WAIT));

  0020a	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1014 :             _Loc                = _Find_lower_bound(_Keyval);

  00211	50		 push	 eax
  00212	8d 85 14 fb ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  00218	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  0021d	50		 push	 eax
  0021e	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00223	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00227	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0022a	66 0f d6 85 c8
	fc ff ff	 movq	 QWORD PTR __Loc$85[ebp], xmm0

; 1599 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00232	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00236	75 1b		 jne	 SHORT $LN433@LoadRaceMo
  00238	83 c0 10	 add	 eax, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef

; 127  :         return _Left < _Right;

  0023b	50		 push	 eax
  0023c	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T130[ebp]
  00242	50		 push	 eax
  00243	e8 00 00 00 00	 call	 ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
  00248	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1599 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0024b	84 c0		 test	 al, al
  0024d	0f 84 8d 00 00
	00		 je	 $LN546@LoadRaceMo
$LN433@LoadRaceMo:

; 1623 :         if (max_size() == _Get_scary()->_Mysize) {

  00253	81 3d 04 00 00
	00 5d 74 d1 05	 cmp	 DWORD PTR ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A+4, 97612893 ; 05d1745dH
  0025d	0f 84 32 1b 00
	00		 je	 $LN2105@LoadRaceMo

; 1020 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  00263	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1012 :     _CONSTEXPR20_DYNALLOC explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00269	c7 85 18 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp], OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A

; 85   :         return ::operator new(_Bytes);

  00273	6a 2c		 push	 44			; 0000002cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 790  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00275	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1019 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00279	c7 85 1c fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+4], 0

; 85   :         return ::operator new(_Bytes);

  00283	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 244  :         return _Traits::_Allocate(_Bytes);

  00288	8b f8		 mov	 edi, eax

; 85   :         return ::operator new(_Bytes);

  0028a	83 c4 04	 add	 esp, 4

; 1020 :         _Ptr = _Al.allocate(1);

  0028d	89 bd 1c fb ff
	ff		 mov	 DWORD PTR $T7[ebp+4], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 213  :     pair(pair&&)      = default;

  00293	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T130[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 811  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

  00299	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 213  :     pair(pair&&)      = default;

  0029d	50		 push	 eax
  0029e	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  002a1	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  002a6	8b 85 ec fc ff
	ff		 mov	 eax, DWORD PTR $T130[ebp+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1039 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  002ac	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  002b1	57		 push	 edi
  002b2	ff b5 cc fc ff
	ff		 push	 DWORD PTR __Loc$85[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 213  :     pair(pair&&)      = default;

  002b8	89 47 28	 mov	 DWORD PTR [edi+40], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1039 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  002bb	ff b5 c8 fc ff
	ff		 push	 DWORD PTR __Loc$85[ebp]

; 813  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  002c1	89 1f		 mov	 DWORD PTR [edi], ebx

; 814  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  002c3	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 815  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  002c6	89 5f 08	 mov	 DWORD PTR [edi+8], ebx

; 816  :         this->_Ptr->_Color = _Red;

  002c9	66 c7 47 0c 00
	00		 mov	 WORD PTR [edi+12], 0

; 1039 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  002cf	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> > >::_Insert_node
  002d4	8b bd e8 fc ff
	ff		 mov	 edi, DWORD PTR $T130[ebp+20]
  002da	8b b5 d4 fc ff
	ff		 mov	 esi, DWORD PTR $T130[ebp]
$LN546@LoadRaceMo:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 234  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("WAIT", CRaceMotionData::NAME_WAIT));

  002e0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  002e7	83 ff 10	 cmp	 edi, 16			; 00000010H
  002ea	72 2b		 jb	 SHORT $LN571@LoadRaceMo

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  002ec	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002ef	8b c6		 mov	 eax, esi

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  002f1	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  002f7	72 14		 jb	 SHORT $LN581@LoadRaceMo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  002f9	8b 76 fc	 mov	 esi, DWORD PTR [esi-4]
  002fc	83 c1 23	 add	 ecx, 35			; 00000023H
  002ff	2b c6		 sub	 eax, esi

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00301	83 c0 fc	 add	 eax, -4			; fffffffcH
  00304	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00307	0f 87 92 1a 00
	00		 ja	 $LN2016@LoadRaceMo
$LN581@LoadRaceMo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0030d	51		 push	 ecx
  0030e	56		 push	 esi
  0030f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00314	83 c4 08	 add	 esp, 8
$LN571@LoadRaceMo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00317	a0 04 00 00 00	 mov	 al, BYTE PTR ??_C@_05HBNBIBID@WAIT1@+4

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0031c	bf 0f 00 00 00	 mov	 edi, 15			; 0000000fH

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00321	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ??_C@_05HBNBIBID@WAIT1@

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00327	89 bd e8 fc ff
	ff		 mov	 DWORD PTR $T129[ebp+20], edi

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  0032d	c7 85 e4 fc ff
	ff 05 00 00 00	 mov	 DWORD PTR $T129[ebp+16], 5

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00337	89 b5 d4 fc ff
	ff		 mov	 DWORD PTR $T129[ebp], esi
  0033d	88 85 d8 fc ff
	ff		 mov	 BYTE PTR $T129[ebp+4], al

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00343	c6 85 d9 fc ff
	ff 00		 mov	 BYTE PTR $T129[ebp+5], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0034a	c7 85 ec fc ff
	ff 01 00 00 00	 mov	 DWORD PTR $T129[ebp+24], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1014 :             _Loc                = _Find_lower_bound(_Keyval);

  00354	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T129[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 235  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("WAIT1", CRaceMotionData::NAME_WAIT));

  0035a	c7 45 fc 07 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 7
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1014 :             _Loc                = _Find_lower_bound(_Keyval);

  00361	50		 push	 eax
  00362	8d 85 14 fb ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00368	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  0036d	50		 push	 eax
  0036e	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00373	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00377	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0037a	66 0f d6 85 c8
	fc ff ff	 movq	 QWORD PTR __Loc$84[ebp], xmm0

; 1599 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00382	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00386	75 1b		 jne	 SHORT $LN671@LoadRaceMo
  00388	83 c0 10	 add	 eax, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef

; 127  :         return _Left < _Right;

  0038b	50		 push	 eax
  0038c	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T129[ebp]
  00392	50		 push	 eax
  00393	e8 00 00 00 00	 call	 ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
  00398	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1599 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0039b	84 c0		 test	 al, al
  0039d	0f 84 8d 00 00
	00		 je	 $LN784@LoadRaceMo
$LN671@LoadRaceMo:

; 1623 :         if (max_size() == _Get_scary()->_Mysize) {

  003a3	81 3d 04 00 00
	00 5d 74 d1 05	 cmp	 DWORD PTR ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A+4, 97612893 ; 05d1745dH
  003ad	0f 84 e7 19 00
	00		 je	 $LN2106@LoadRaceMo

; 1020 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  003b3	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1012 :     _CONSTEXPR20_DYNALLOC explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  003b9	c7 85 18 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp], OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A

; 85   :         return ::operator new(_Bytes);

  003c3	6a 2c		 push	 44			; 0000002cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 790  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  003c5	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1019 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  003c9	c7 85 1c fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+4], 0

; 85   :         return ::operator new(_Bytes);

  003d3	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 244  :         return _Traits::_Allocate(_Bytes);

  003d8	8b f8		 mov	 edi, eax

; 85   :         return ::operator new(_Bytes);

  003da	83 c4 04	 add	 esp, 4

; 1020 :         _Ptr = _Al.allocate(1);

  003dd	89 bd 1c fb ff
	ff		 mov	 DWORD PTR $T6[ebp+4], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 213  :     pair(pair&&)      = default;

  003e3	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T129[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 811  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

  003e9	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 213  :     pair(pair&&)      = default;

  003ed	50		 push	 eax
  003ee	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  003f1	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  003f6	8b 85 ec fc ff
	ff		 mov	 eax, DWORD PTR $T129[ebp+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1039 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  003fc	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  00401	57		 push	 edi
  00402	ff b5 cc fc ff
	ff		 push	 DWORD PTR __Loc$84[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 213  :     pair(pair&&)      = default;

  00408	89 47 28	 mov	 DWORD PTR [edi+40], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1039 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  0040b	ff b5 c8 fc ff
	ff		 push	 DWORD PTR __Loc$84[ebp]

; 813  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  00411	89 1f		 mov	 DWORD PTR [edi], ebx

; 814  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  00413	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 815  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  00416	89 5f 08	 mov	 DWORD PTR [edi+8], ebx

; 816  :         this->_Ptr->_Color = _Red;

  00419	66 c7 47 0c 00
	00		 mov	 WORD PTR [edi+12], 0

; 1039 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  0041f	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> > >::_Insert_node
  00424	8b bd e8 fc ff
	ff		 mov	 edi, DWORD PTR $T129[ebp+20]
  0042a	8b b5 d4 fc ff
	ff		 mov	 esi, DWORD PTR $T129[ebp]
$LN784@LoadRaceMo:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 235  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("WAIT1", CRaceMotionData::NAME_WAIT));

  00430	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00437	83 ff 10	 cmp	 edi, 16			; 00000010H
  0043a	72 2b		 jb	 SHORT $LN809@LoadRaceMo

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0043c	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0043f	8b c6		 mov	 eax, esi

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00441	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00447	72 14		 jb	 SHORT $LN819@LoadRaceMo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00449	8b 76 fc	 mov	 esi, DWORD PTR [esi-4]
  0044c	83 c1 23	 add	 ecx, 35			; 00000023H
  0044f	2b c6		 sub	 eax, esi

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00451	83 c0 fc	 add	 eax, -4			; fffffffcH
  00454	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00457	0f 87 42 19 00
	00		 ja	 $LN2016@LoadRaceMo
$LN819@LoadRaceMo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0045d	51		 push	 ecx
  0045e	56		 push	 esi
  0045f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00464	83 c4 08	 add	 esp, 8
$LN809@LoadRaceMo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00467	6a 05		 push	 5

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00469	c7 85 d4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T128[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00473	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T128[ebp]
  00479	68 00 00 00 00	 push	 OFFSET ??_C@_05FKPMNCEA@WAIT2@

; 4596 :         _My_data._Mysize = 0;

  0047e	c7 85 e4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T128[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00488	c7 85 e8 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T128[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00492	c6 85 d4 fc ff
	ff 00		 mov	 BYTE PTR $T128[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00499	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0049e	c7 85 ec fc ff
	ff 01 00 00 00	 mov	 DWORD PTR $T128[ebp+24], 1
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 236  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("WAIT2", CRaceMotionData::NAME_WAIT));

  004a8	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T128[ebp]
  004ae	c7 45 fc 0a 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  004b5	50		 push	 eax
  004b6	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T54[ebp]
  004bc	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  004c1	50		 push	 eax
  004c2	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  004c7	8b 95 e8 fc ff
	ff		 mov	 edx, DWORD PTR $T128[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 236  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("WAIT2", CRaceMotionData::NAME_WAIT));

  004cd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  004d4	83 fa 10	 cmp	 edx, 16			; 00000010H
  004d7	72 2f		 jb	 SHORT $LN859@LoadRaceMo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  004d9	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR $T128[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  004df	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  004e0	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  004e2	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  004e8	72 14		 jb	 SHORT $LN869@LoadRaceMo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  004ea	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  004ed	83 c2 23	 add	 edx, 35			; 00000023H
  004f0	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  004f2	83 c0 fc	 add	 eax, -4			; fffffffcH
  004f5	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  004f8	0f 87 a1 18 00
	00		 ja	 $LN2016@LoadRaceMo
$LN869@LoadRaceMo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  004fe	52		 push	 edx
  004ff	51		 push	 ecx
  00500	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00505	83 c4 08	 add	 esp, 8
$LN859@LoadRaceMo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00508	6a 04		 push	 4

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0050a	c7 85 d4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T127[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00514	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T127[ebp]
  0051a	68 00 00 00 00	 push	 OFFSET ??_C@_04PKELMGAL@WALK@

; 4596 :         _My_data._Mysize = 0;

  0051f	c7 85 e4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T127[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00529	c7 85 e8 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T127[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00533	c6 85 d4 fc ff
	ff 00		 mov	 BYTE PTR $T127[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0053a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0053f	c7 85 ec fc ff
	ff 02 00 00 00	 mov	 DWORD PTR $T127[ebp+24], 2
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 237  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("WALK", CRaceMotionData::NAME_WALK));

  00549	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T127[ebp]
  0054f	c7 45 fc 0b 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  00556	50		 push	 eax
  00557	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T53[ebp]
  0055d	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  00562	50		 push	 eax
  00563	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00568	8b 95 e8 fc ff
	ff		 mov	 edx, DWORD PTR $T127[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 237  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("WALK", CRaceMotionData::NAME_WALK));

  0056e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00575	83 fa 10	 cmp	 edx, 16			; 00000010H
  00578	72 2f		 jb	 SHORT $LN909@LoadRaceMo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0057a	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR $T127[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00580	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00581	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00583	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00589	72 14		 jb	 SHORT $LN919@LoadRaceMo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0058b	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0058e	83 c2 23	 add	 edx, 35			; 00000023H
  00591	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00593	83 c0 fc	 add	 eax, -4			; fffffffcH
  00596	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00599	0f 87 00 18 00
	00		 ja	 $LN2016@LoadRaceMo
$LN919@LoadRaceMo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0059f	52		 push	 edx
  005a0	51		 push	 ecx
  005a1	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  005a6	83 c4 08	 add	 esp, 8
$LN909@LoadRaceMo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  005a9	6a 05		 push	 5

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  005ab	c7 85 d4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T126[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  005b5	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T126[ebp]
  005bb	68 00 00 00 00	 push	 OFFSET ??_C@_05FBHFJFPM@WALK1@

; 4596 :         _My_data._Mysize = 0;

  005c0	c7 85 e4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T126[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  005ca	c7 85 e8 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T126[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  005d4	c6 85 d4 fc ff
	ff 00		 mov	 BYTE PTR $T126[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  005db	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  005e0	c7 85 ec fc ff
	ff 02 00 00 00	 mov	 DWORD PTR $T126[ebp+24], 2
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 238  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("WALK1", CRaceMotionData::NAME_WALK));

  005ea	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T126[ebp]
  005f0	c7 45 fc 0c 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  005f7	50		 push	 eax
  005f8	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T52[ebp]
  005fe	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  00603	50		 push	 eax
  00604	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00609	8b 95 e8 fc ff
	ff		 mov	 edx, DWORD PTR $T126[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 238  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("WALK1", CRaceMotionData::NAME_WALK));

  0060f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00616	83 fa 10	 cmp	 edx, 16			; 00000010H
  00619	72 2f		 jb	 SHORT $LN959@LoadRaceMo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0061b	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR $T126[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00621	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00622	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00624	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0062a	72 14		 jb	 SHORT $LN969@LoadRaceMo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0062c	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0062f	83 c2 23	 add	 edx, 35			; 00000023H
  00632	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00634	83 c0 fc	 add	 eax, -4			; fffffffcH
  00637	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0063a	0f 87 5f 17 00
	00		 ja	 $LN2016@LoadRaceMo
$LN969@LoadRaceMo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00640	52		 push	 edx
  00641	51		 push	 ecx
  00642	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00647	83 c4 08	 add	 esp, 8
$LN959@LoadRaceMo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0064a	6a 05		 push	 5

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0064c	c7 85 d4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T125[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00656	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T125[ebp]
  0065c	68 00 00 00 00	 push	 OFFSET ??_C@_05HKFIMGDP@WALK2@

; 4596 :         _My_data._Mysize = 0;

  00661	c7 85 e4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T125[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0066b	c7 85 e8 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T125[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00675	c6 85 d4 fc ff
	ff 00		 mov	 BYTE PTR $T125[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0067c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00681	c7 85 ec fc ff
	ff 02 00 00 00	 mov	 DWORD PTR $T125[ebp+24], 2
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 239  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("WALK2", CRaceMotionData::NAME_WALK));

  0068b	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T125[ebp]
  00691	c7 45 fc 0d 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  00698	50		 push	 eax
  00699	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T51[ebp]
  0069f	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  006a4	50		 push	 eax
  006a5	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  006aa	8b 95 e8 fc ff
	ff		 mov	 edx, DWORD PTR $T125[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 239  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("WALK2", CRaceMotionData::NAME_WALK));

  006b0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  006b7	83 fa 10	 cmp	 edx, 16			; 00000010H
  006ba	72 2f		 jb	 SHORT $LN1009@LoadRaceMo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  006bc	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR $T125[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  006c2	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  006c3	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  006c5	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  006cb	72 14		 jb	 SHORT $LN1019@LoadRaceMo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  006cd	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  006d0	83 c2 23	 add	 edx, 35			; 00000023H
  006d3	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  006d5	83 c0 fc	 add	 eax, -4			; fffffffcH
  006d8	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  006db	0f 87 be 16 00
	00		 ja	 $LN2016@LoadRaceMo
$LN1019@LoadRaceMo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  006e1	52		 push	 edx
  006e2	51		 push	 ecx
  006e3	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  006e8	83 c4 08	 add	 esp, 8
$LN1009@LoadRaceMo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  006eb	6a 03		 push	 3

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  006ed	c7 85 d4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T124[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  006f7	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T124[ebp]
  006fd	68 00 00 00 00	 push	 OFFSET ??_C@_03LLDCGJBK@RUN@

; 4596 :         _My_data._Mysize = 0;

  00702	c7 85 e4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T124[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0070c	c7 85 e8 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T124[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00716	c6 85 d4 fc ff
	ff 00		 mov	 BYTE PTR $T124[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0071d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00722	c7 85 ec fc ff
	ff 03 00 00 00	 mov	 DWORD PTR $T124[ebp+24], 3
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 240  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("RUN", CRaceMotionData::NAME_RUN));

  0072c	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T124[ebp]
  00732	c7 45 fc 0e 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  00739	50		 push	 eax
  0073a	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T50[ebp]
  00740	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  00745	50		 push	 eax
  00746	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0074b	8b 95 e8 fc ff
	ff		 mov	 edx, DWORD PTR $T124[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 240  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("RUN", CRaceMotionData::NAME_RUN));

  00751	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00758	83 fa 10	 cmp	 edx, 16			; 00000010H
  0075b	72 2f		 jb	 SHORT $LN1059@LoadRaceMo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0075d	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR $T124[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00763	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00764	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00766	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0076c	72 14		 jb	 SHORT $LN1069@LoadRaceMo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0076e	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00771	83 c2 23	 add	 edx, 35			; 00000023H
  00774	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00776	83 c0 fc	 add	 eax, -4			; fffffffcH
  00779	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0077c	0f 87 1d 16 00
	00		 ja	 $LN2016@LoadRaceMo
$LN1069@LoadRaceMo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00782	52		 push	 edx
  00783	51		 push	 ecx
  00784	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00789	83 c4 08	 add	 esp, 8
$LN1059@LoadRaceMo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0078c	6a 04		 push	 4

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0078e	c7 85 d4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T123[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00798	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T123[ebp]
  0079e	68 00 00 00 00	 push	 OFFSET ??_C@_04DLIEMMKB@RUN1@

; 4596 :         _My_data._Mysize = 0;

  007a3	c7 85 e4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T123[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  007ad	c7 85 e8 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T123[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  007b7	c6 85 d4 fc ff
	ff 00		 mov	 BYTE PTR $T123[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  007be	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  007c3	c7 85 ec fc ff
	ff 03 00 00 00	 mov	 DWORD PTR $T123[ebp+24], 3
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 241  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("RUN1", CRaceMotionData::NAME_RUN));

  007cd	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T123[ebp]
  007d3	c7 45 fc 0f 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  007da	50		 push	 eax
  007db	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T49[ebp]
  007e1	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  007e6	50		 push	 eax
  007e7	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  007ec	8b 95 e8 fc ff
	ff		 mov	 edx, DWORD PTR $T123[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 241  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("RUN1", CRaceMotionData::NAME_RUN));

  007f2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  007f9	83 fa 10	 cmp	 edx, 16			; 00000010H
  007fc	72 2f		 jb	 SHORT $LN1109@LoadRaceMo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  007fe	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR $T123[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00804	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00805	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00807	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0080d	72 14		 jb	 SHORT $LN1119@LoadRaceMo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0080f	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00812	83 c2 23	 add	 edx, 35			; 00000023H
  00815	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00817	83 c0 fc	 add	 eax, -4			; fffffffcH
  0081a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0081d	0f 87 7c 15 00
	00		 ja	 $LN2016@LoadRaceMo
$LN1119@LoadRaceMo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00823	52		 push	 edx
  00824	51		 push	 ecx
  00825	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0082a	83 c4 08	 add	 esp, 8
$LN1109@LoadRaceMo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0082d	6a 04		 push	 4

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0082f	c7 85 d4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T122[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00839	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T122[ebp]
  0083f	68 00 00 00 00	 push	 OFFSET ??_C@_04BAKJJPGC@RUN2@

; 4596 :         _My_data._Mysize = 0;

  00844	c7 85 e4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T122[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0084e	c7 85 e8 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T122[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00858	c6 85 d4 fc ff
	ff 00		 mov	 BYTE PTR $T122[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0085f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00864	c7 85 ec fc ff
	ff 03 00 00 00	 mov	 DWORD PTR $T122[ebp+24], 3
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 242  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("RUN2", CRaceMotionData::NAME_RUN));

  0086e	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T122[ebp]
  00874	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 16 ; 00000010H
  0087b	50		 push	 eax
  0087c	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T48[ebp]
  00882	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  00887	50		 push	 eax
  00888	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0088d	8b 95 e8 fc ff
	ff		 mov	 edx, DWORD PTR $T122[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 242  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("RUN2", CRaceMotionData::NAME_RUN));

  00893	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0089a	83 fa 10	 cmp	 edx, 16			; 00000010H
  0089d	72 2f		 jb	 SHORT $LN1159@LoadRaceMo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0089f	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR $T122[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  008a5	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  008a6	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  008a8	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  008ae	72 14		 jb	 SHORT $LN1169@LoadRaceMo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  008b0	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  008b3	83 c2 23	 add	 edx, 35			; 00000023H
  008b6	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  008b8	83 c0 fc	 add	 eax, -4			; fffffffcH
  008bb	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  008be	0f 87 db 14 00
	00		 ja	 $LN2016@LoadRaceMo
$LN1169@LoadRaceMo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  008c4	52		 push	 edx
  008c5	51		 push	 ecx
  008c6	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  008cb	83 c4 08	 add	 esp, 8
$LN1159@LoadRaceMo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  008ce	6a 04		 push	 4

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  008d0	c7 85 d4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T121[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  008da	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T121[ebp]
  008e0	68 00 00 00 00	 push	 OFFSET ??_C@_04MDHMLCKF@STOP@

; 4596 :         _My_data._Mysize = 0;

  008e5	c7 85 e4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T121[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  008ef	c7 85 e8 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T121[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  008f9	c6 85 d4 fc ff
	ff 00		 mov	 BYTE PTR $T121[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00900	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00905	c7 85 ec fc ff
	ff 20 00 00 00	 mov	 DWORD PTR $T121[ebp+24], 32 ; 00000020H
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 243  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("STOP", CRaceMotionData::NAME_STOP));

  0090f	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T121[ebp]
  00915	c7 45 fc 11 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 17 ; 00000011H
  0091c	50		 push	 eax
  0091d	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T47[ebp]
  00923	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  00928	50		 push	 eax
  00929	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0092e	8b 95 e8 fc ff
	ff		 mov	 edx, DWORD PTR $T121[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 243  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("STOP", CRaceMotionData::NAME_STOP));

  00934	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0093b	83 fa 10	 cmp	 edx, 16			; 00000010H
  0093e	72 2f		 jb	 SHORT $LN1209@LoadRaceMo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00940	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR $T121[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00946	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00947	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00949	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0094f	72 14		 jb	 SHORT $LN1219@LoadRaceMo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00951	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00954	83 c2 23	 add	 edx, 35			; 00000023H
  00957	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00959	83 c0 fc	 add	 eax, -4			; fffffffcH
  0095c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0095f	0f 87 3a 14 00
	00		 ja	 $LN2016@LoadRaceMo
$LN1219@LoadRaceMo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00965	52		 push	 edx
  00966	51		 push	 ecx
  00967	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0096c	83 c4 08	 add	 esp, 8
$LN1209@LoadRaceMo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0096f	6a 04		 push	 4

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00971	c7 85 d4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T120[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0097b	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T120[ebp]
  00981	68 00 00 00 00	 push	 OFFSET ??_C@_04NNCJDDJC@DEAD@

; 4596 :         _My_data._Mysize = 0;

  00986	c7 85 e4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T120[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00990	c7 85 e8 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T120[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0099a	c6 85 d4 fc ff
	ff 00		 mov	 BYTE PTR $T120[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  009a1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  009a6	c7 85 ec fc ff
	ff 0b 00 00 00	 mov	 DWORD PTR $T120[ebp+24], 11 ; 0000000bH
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 244  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("DEAD", CRaceMotionData::NAME_DEAD));

  009b0	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T120[ebp]
  009b6	c7 45 fc 12 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 18 ; 00000012H
  009bd	50		 push	 eax
  009be	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T46[ebp]
  009c4	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  009c9	50		 push	 eax
  009ca	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  009cf	8b 95 e8 fc ff
	ff		 mov	 edx, DWORD PTR $T120[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 244  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("DEAD", CRaceMotionData::NAME_DEAD));

  009d5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  009dc	83 fa 10	 cmp	 edx, 16			; 00000010H
  009df	72 2f		 jb	 SHORT $LN1259@LoadRaceMo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  009e1	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR $T120[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  009e7	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  009e8	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  009ea	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  009f0	72 14		 jb	 SHORT $LN1269@LoadRaceMo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  009f2	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  009f5	83 c2 23	 add	 edx, 35			; 00000023H
  009f8	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  009fa	83 c0 fc	 add	 eax, -4			; fffffffcH
  009fd	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00a00	0f 87 99 13 00
	00		 ja	 $LN2016@LoadRaceMo
$LN1269@LoadRaceMo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00a06	52		 push	 edx
  00a07	51		 push	 ecx
  00a08	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00a0d	83 c4 08	 add	 esp, 8
$LN1259@LoadRaceMo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00a10	6a 0c		 push	 12			; 0000000cH

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00a12	c7 85 d4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T119[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00a1c	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T119[ebp]
  00a22	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ECIMAFHI@COMBO_ATTACK@

; 4596 :         _My_data._Mysize = 0;

  00a27	c7 85 e4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T119[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00a31	c7 85 e8 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T119[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00a3b	c6 85 d4 fc ff
	ff 00		 mov	 BYTE PTR $T119[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00a42	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00a47	c7 85 ec fc ff
	ff 0e 00 00 00	 mov	 DWORD PTR $T119[ebp+24], 14 ; 0000000eH
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 245  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("COMBO_ATTACK", CRaceMotionData::NAME_COMBO_ATTACK_1));

  00a51	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T119[ebp]
  00a57	c7 45 fc 13 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 19 ; 00000013H
  00a5e	50		 push	 eax
  00a5f	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T45[ebp]
  00a65	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  00a6a	50		 push	 eax
  00a6b	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00a70	8b 95 e8 fc ff
	ff		 mov	 edx, DWORD PTR $T119[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 245  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("COMBO_ATTACK", CRaceMotionData::NAME_COMBO_ATTACK_1));

  00a76	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00a7d	83 fa 10	 cmp	 edx, 16			; 00000010H
  00a80	72 2f		 jb	 SHORT $LN1309@LoadRaceMo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00a82	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR $T119[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00a88	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00a89	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00a8b	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00a91	72 14		 jb	 SHORT $LN1319@LoadRaceMo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00a93	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00a96	83 c2 23	 add	 edx, 35			; 00000023H
  00a99	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00a9b	83 c0 fc	 add	 eax, -4			; fffffffcH
  00a9e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00aa1	0f 87 f8 12 00
	00		 ja	 $LN2016@LoadRaceMo
$LN1319@LoadRaceMo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00aa7	52		 push	 edx
  00aa8	51		 push	 ecx
  00aa9	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00aae	83 c4 08	 add	 esp, 8
$LN1309@LoadRaceMo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00ab1	6a 0d		 push	 13			; 0000000dH

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00ab3	c7 85 d4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T118[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00abd	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T118[ebp]
  00ac3	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JIMBHCLJ@COMBO_ATTACK1@

; 4596 :         _My_data._Mysize = 0;

  00ac8	c7 85 e4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T118[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00ad2	c7 85 e8 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T118[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00adc	c6 85 d4 fc ff
	ff 00		 mov	 BYTE PTR $T118[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00ae3	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00ae8	c7 85 ec fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T118[ebp+24], 15 ; 0000000fH
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 246  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("COMBO_ATTACK1", CRaceMotionData::NAME_COMBO_ATTACK_2));

  00af2	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T118[ebp]
  00af8	c7 45 fc 14 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 20 ; 00000014H
  00aff	50		 push	 eax
  00b00	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T44[ebp]
  00b06	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  00b0b	50		 push	 eax
  00b0c	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00b11	8b 95 e8 fc ff
	ff		 mov	 edx, DWORD PTR $T118[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 246  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("COMBO_ATTACK1", CRaceMotionData::NAME_COMBO_ATTACK_2));

  00b17	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00b1e	83 fa 10	 cmp	 edx, 16			; 00000010H
  00b21	72 2f		 jb	 SHORT $LN1359@LoadRaceMo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00b23	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR $T118[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00b29	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00b2a	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00b2c	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00b32	72 14		 jb	 SHORT $LN1369@LoadRaceMo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00b34	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00b37	83 c2 23	 add	 edx, 35			; 00000023H
  00b3a	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00b3c	83 c0 fc	 add	 eax, -4			; fffffffcH
  00b3f	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00b42	0f 87 57 12 00
	00		 ja	 $LN2016@LoadRaceMo
$LN1369@LoadRaceMo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00b48	52		 push	 edx
  00b49	51		 push	 ecx
  00b4a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00b4f	83 c4 08	 add	 esp, 8
$LN1359@LoadRaceMo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00b52	6a 0d		 push	 13			; 0000000dH

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00b54	c7 85 d4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T117[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00b5e	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T117[ebp]
  00b64	68 00 00 00 00	 push	 OFFSET ??_C@_0O@LDOMCBHK@COMBO_ATTACK2@

; 4596 :         _My_data._Mysize = 0;

  00b69	c7 85 e4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T117[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00b73	c7 85 e8 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T117[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00b7d	c6 85 d4 fc ff
	ff 00		 mov	 BYTE PTR $T117[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00b84	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00b89	c7 85 ec fc ff
	ff 10 00 00 00	 mov	 DWORD PTR $T117[ebp+24], 16 ; 00000010H
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 247  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("COMBO_ATTACK2", CRaceMotionData::NAME_COMBO_ATTACK_3));

  00b93	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T117[ebp]
  00b99	c7 45 fc 15 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 21 ; 00000015H
  00ba0	50		 push	 eax
  00ba1	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T43[ebp]
  00ba7	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  00bac	50		 push	 eax
  00bad	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00bb2	8b 95 e8 fc ff
	ff		 mov	 edx, DWORD PTR $T117[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 247  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("COMBO_ATTACK2", CRaceMotionData::NAME_COMBO_ATTACK_3));

  00bb8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00bbf	83 fa 10	 cmp	 edx, 16			; 00000010H
  00bc2	72 2f		 jb	 SHORT $LN1409@LoadRaceMo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00bc4	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR $T117[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00bca	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00bcb	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00bcd	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00bd3	72 14		 jb	 SHORT $LN1419@LoadRaceMo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00bd5	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00bd8	83 c2 23	 add	 edx, 35			; 00000023H
  00bdb	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00bdd	83 c0 fc	 add	 eax, -4			; fffffffcH
  00be0	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00be3	0f 87 b6 11 00
	00		 ja	 $LN2016@LoadRaceMo
$LN1419@LoadRaceMo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00be9	52		 push	 edx
  00bea	51		 push	 ecx
  00beb	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00bf0	83 c4 08	 add	 esp, 8
$LN1409@LoadRaceMo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00bf3	6a 0d		 push	 13			; 0000000dH

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00bf5	c7 85 d4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T116[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00bff	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T116[ebp]
  00c05	68 00 00 00 00	 push	 OFFSET ??_C@_0O@MMNGEKGD@NORMAL_ATTACK@

; 4596 :         _My_data._Mysize = 0;

  00c0a	c7 85 e4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T116[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00c14	c7 85 e8 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T116[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00c1e	c6 85 d4 fc ff
	ff 00		 mov	 BYTE PTR $T116[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00c25	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00c2a	c7 85 ec fc ff
	ff 0d 00 00 00	 mov	 DWORD PTR $T116[ebp+24], 13 ; 0000000dH
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 248  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("NORMAL_ATTACK", CRaceMotionData::NAME_NORMAL_ATTACK));

  00c34	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T116[ebp]
  00c3a	c7 45 fc 16 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 22 ; 00000016H
  00c41	50		 push	 eax
  00c42	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T42[ebp]
  00c48	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  00c4d	50		 push	 eax
  00c4e	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00c53	8b 95 e8 fc ff
	ff		 mov	 edx, DWORD PTR $T116[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 248  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("NORMAL_ATTACK", CRaceMotionData::NAME_NORMAL_ATTACK));

  00c59	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00c60	83 fa 10	 cmp	 edx, 16			; 00000010H
  00c63	72 2f		 jb	 SHORT $LN1459@LoadRaceMo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00c65	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR $T116[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00c6b	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00c6c	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00c6e	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00c74	72 14		 jb	 SHORT $LN1469@LoadRaceMo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00c76	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00c79	83 c2 23	 add	 edx, 35			; 00000023H
  00c7c	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00c7e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00c81	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00c84	0f 87 15 11 00
	00		 ja	 $LN2016@LoadRaceMo
$LN1469@LoadRaceMo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00c8a	52		 push	 edx
  00c8b	51		 push	 ecx
  00c8c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00c91	83 c4 08	 add	 esp, 8
$LN1459@LoadRaceMo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00c94	6a 0e		 push	 14			; 0000000eH

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00c96	c7 85 d4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T115[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00ca0	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T115[ebp]
  00ca6	68 00 00 00 00	 push	 OFFSET ??_C@_0P@BCCKOBBK@NORMAL_ATTACK1@

; 4596 :         _My_data._Mysize = 0;

  00cab	c7 85 e4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T115[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00cb5	c7 85 e8 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T115[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00cbf	c6 85 d4 fc ff
	ff 00		 mov	 BYTE PTR $T115[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00cc6	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00ccb	c7 85 ec fc ff
	ff 0d 00 00 00	 mov	 DWORD PTR $T115[ebp+24], 13 ; 0000000dH
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 249  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("NORMAL_ATTACK1", CRaceMotionData::NAME_NORMAL_ATTACK));

  00cd5	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T115[ebp]
  00cdb	c7 45 fc 17 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 23 ; 00000017H
  00ce2	50		 push	 eax
  00ce3	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T41[ebp]
  00ce9	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  00cee	50		 push	 eax
  00cef	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00cf4	8b 95 e8 fc ff
	ff		 mov	 edx, DWORD PTR $T115[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 249  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("NORMAL_ATTACK1", CRaceMotionData::NAME_NORMAL_ATTACK));

  00cfa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00d01	83 fa 10	 cmp	 edx, 16			; 00000010H
  00d04	72 2f		 jb	 SHORT $LN1509@LoadRaceMo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00d06	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR $T115[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00d0c	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00d0d	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00d0f	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00d15	72 14		 jb	 SHORT $LN1519@LoadRaceMo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00d17	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00d1a	83 c2 23	 add	 edx, 35			; 00000023H
  00d1d	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00d1f	83 c0 fc	 add	 eax, -4			; fffffffcH
  00d22	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00d25	0f 87 74 10 00
	00		 ja	 $LN2016@LoadRaceMo
$LN1519@LoadRaceMo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00d2b	52		 push	 edx
  00d2c	51		 push	 ecx
  00d2d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00d32	83 c4 08	 add	 esp, 8
$LN1509@LoadRaceMo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00d35	6a 0e		 push	 14			; 0000000eH

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00d37	c7 85 d4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T114[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00d41	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T114[ebp]
  00d47	68 00 00 00 00	 push	 OFFSET ??_C@_0P@DJAHLCNJ@NORMAL_ATTACK2@

; 4596 :         _My_data._Mysize = 0;

  00d4c	c7 85 e4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T114[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00d56	c7 85 e8 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T114[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00d60	c6 85 d4 fc ff
	ff 00		 mov	 BYTE PTR $T114[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00d67	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00d6c	c7 85 ec fc ff
	ff 0d 00 00 00	 mov	 DWORD PTR $T114[ebp+24], 13 ; 0000000dH
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 250  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("NORMAL_ATTACK2", CRaceMotionData::NAME_NORMAL_ATTACK));

  00d76	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T114[ebp]
  00d7c	c7 45 fc 18 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 24 ; 00000018H
  00d83	50		 push	 eax
  00d84	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T40[ebp]
  00d8a	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  00d8f	50		 push	 eax
  00d90	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00d95	8b 95 e8 fc ff
	ff		 mov	 edx, DWORD PTR $T114[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 250  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("NORMAL_ATTACK2", CRaceMotionData::NAME_NORMAL_ATTACK));

  00d9b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00da2	83 fa 10	 cmp	 edx, 16			; 00000010H
  00da5	72 2f		 jb	 SHORT $LN1559@LoadRaceMo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00da7	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR $T114[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00dad	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00dae	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00db0	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00db6	72 14		 jb	 SHORT $LN1569@LoadRaceMo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00db8	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00dbb	83 c2 23	 add	 edx, 35			; 00000023H
  00dbe	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00dc0	83 c0 fc	 add	 eax, -4			; fffffffcH
  00dc3	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00dc6	0f 87 d3 0f 00
	00		 ja	 $LN2016@LoadRaceMo
$LN1569@LoadRaceMo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00dcc	52		 push	 edx
  00dcd	51		 push	 ecx
  00dce	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00dd3	83 c4 08	 add	 esp, 8
$LN1559@LoadRaceMo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00dd6	6a 0c		 push	 12			; 0000000cH

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00dd8	c7 85 d4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T113[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00de2	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T113[ebp]
  00de8	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FEIIBDLE@FRONT_DAMAGE@

; 4596 :         _My_data._Mysize = 0;

  00ded	c7 85 e4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T113[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00df7	c7 85 e8 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T113[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00e01	c6 85 d4 fc ff
	ff 00		 mov	 BYTE PTR $T113[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00e08	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00e0d	c7 85 ec fc ff
	ff 05 00 00 00	 mov	 DWORD PTR $T113[ebp+24], 5
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 251  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("FRONT_DAMAGE", CRaceMotionData::NAME_DAMAGE));

  00e17	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T113[ebp]
  00e1d	c7 45 fc 19 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 25 ; 00000019H
  00e24	50		 push	 eax
  00e25	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T39[ebp]
  00e2b	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  00e30	50		 push	 eax
  00e31	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00e36	8b 95 e8 fc ff
	ff		 mov	 edx, DWORD PTR $T113[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 251  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("FRONT_DAMAGE", CRaceMotionData::NAME_DAMAGE));

  00e3c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00e43	83 fa 10	 cmp	 edx, 16			; 00000010H
  00e46	72 2f		 jb	 SHORT $LN1609@LoadRaceMo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00e48	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR $T113[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00e4e	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00e4f	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00e51	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00e57	72 14		 jb	 SHORT $LN1619@LoadRaceMo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00e59	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00e5c	83 c2 23	 add	 edx, 35			; 00000023H
  00e5f	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00e61	83 c0 fc	 add	 eax, -4			; fffffffcH
  00e64	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00e67	0f 87 32 0f 00
	00		 ja	 $LN2016@LoadRaceMo
$LN1619@LoadRaceMo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00e6d	52		 push	 edx
  00e6e	51		 push	 ecx
  00e6f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00e74	83 c4 08	 add	 esp, 8
$LN1609@LoadRaceMo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00e77	6a 0d		 push	 13			; 0000000dH

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00e79	c7 85 d4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T112[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00e83	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T112[ebp]
  00e89	68 00 00 00 00	 push	 OFFSET ??_C@_0O@KAFPIDE@FRONT_DAMAGE1@

; 4596 :         _My_data._Mysize = 0;

  00e8e	c7 85 e4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T112[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00e98	c7 85 e8 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T112[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00ea2	c6 85 d4 fc ff
	ff 00		 mov	 BYTE PTR $T112[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00ea9	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00eae	c7 85 ec fc ff
	ff 05 00 00 00	 mov	 DWORD PTR $T112[ebp+24], 5
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 252  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("FRONT_DAMAGE1", CRaceMotionData::NAME_DAMAGE));

  00eb8	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T112[ebp]
  00ebe	c7 45 fc 1a 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 26 ; 0000001aH
  00ec5	50		 push	 eax
  00ec6	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T38[ebp]
  00ecc	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  00ed1	50		 push	 eax
  00ed2	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00ed7	8b 95 e8 fc ff
	ff		 mov	 edx, DWORD PTR $T112[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 252  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("FRONT_DAMAGE1", CRaceMotionData::NAME_DAMAGE));

  00edd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00ee4	83 fa 10	 cmp	 edx, 16			; 00000010H
  00ee7	72 2f		 jb	 SHORT $LN1659@LoadRaceMo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00ee9	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR $T112[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00eef	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00ef0	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00ef2	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00ef8	72 14		 jb	 SHORT $LN1669@LoadRaceMo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00efa	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00efd	83 c2 23	 add	 edx, 35			; 00000023H
  00f00	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00f02	83 c0 fc	 add	 eax, -4			; fffffffcH
  00f05	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00f08	0f 87 91 0e 00
	00		 ja	 $LN2016@LoadRaceMo
$LN1669@LoadRaceMo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00f0e	52		 push	 edx
  00f0f	51		 push	 ecx
  00f10	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00f15	83 c4 08	 add	 esp, 8
$LN1659@LoadRaceMo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00f18	6a 0d		 push	 13			; 0000000dH

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00f1a	c7 85 d4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T111[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00f24	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T111[ebp]
  00f2a	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CBCIKLPH@FRONT_DAMAGE2@

; 4596 :         _My_data._Mysize = 0;

  00f2f	c7 85 e4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T111[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00f39	c7 85 e8 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T111[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00f43	c6 85 d4 fc ff
	ff 00		 mov	 BYTE PTR $T111[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00f4a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00f4f	c7 85 ec fc ff
	ff 05 00 00 00	 mov	 DWORD PTR $T111[ebp+24], 5
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 253  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("FRONT_DAMAGE2", CRaceMotionData::NAME_DAMAGE));

  00f59	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T111[ebp]
  00f5f	c7 45 fc 1b 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 27 ; 0000001bH
  00f66	50		 push	 eax
  00f67	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T37[ebp]
  00f6d	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  00f72	50		 push	 eax
  00f73	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00f78	8b 95 e8 fc ff
	ff		 mov	 edx, DWORD PTR $T111[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 253  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("FRONT_DAMAGE2", CRaceMotionData::NAME_DAMAGE));

  00f7e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00f85	83 fa 10	 cmp	 edx, 16			; 00000010H
  00f88	72 2f		 jb	 SHORT $LN1709@LoadRaceMo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00f8a	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR $T111[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00f90	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00f91	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00f93	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00f99	72 14		 jb	 SHORT $LN1719@LoadRaceMo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00f9b	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00f9e	83 c2 23	 add	 edx, 35			; 00000023H
  00fa1	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00fa3	83 c0 fc	 add	 eax, -4			; fffffffcH
  00fa6	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00fa9	0f 87 f0 0d 00
	00		 ja	 $LN2016@LoadRaceMo
$LN1719@LoadRaceMo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00faf	52		 push	 edx
  00fb0	51		 push	 ecx
  00fb1	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00fb6	83 c4 08	 add	 esp, 8
$LN1709@LoadRaceMo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00fb9	6a 0d		 push	 13			; 0000000dH

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00fbb	c7 85 d4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T110[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00fc5	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T110[ebp]
  00fcb	68 00 00 00 00	 push	 OFFSET ??_C@_0O@DIDDJKLG@FRONT_DAMAGE3@

; 4596 :         _My_data._Mysize = 0;

  00fd0	c7 85 e4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T110[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00fda	c7 85 e8 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T110[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00fe4	c6 85 d4 fc ff
	ff 00		 mov	 BYTE PTR $T110[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00feb	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00ff0	c7 85 ec fc ff
	ff 05 00 00 00	 mov	 DWORD PTR $T110[ebp+24], 5
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 254  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("FRONT_DAMAGE3", CRaceMotionData::NAME_DAMAGE));

  00ffa	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T110[ebp]
  01000	c7 45 fc 1c 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 28 ; 0000001cH
  01007	50		 push	 eax
  01008	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T36[ebp]
  0100e	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  01013	50		 push	 eax
  01014	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  01019	8b 95 e8 fc ff
	ff		 mov	 edx, DWORD PTR $T110[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 254  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("FRONT_DAMAGE3", CRaceMotionData::NAME_DAMAGE));

  0101f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  01026	83 fa 10	 cmp	 edx, 16			; 00000010H
  01029	72 2f		 jb	 SHORT $LN1759@LoadRaceMo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0102b	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR $T110[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  01031	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  01032	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  01034	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0103a	72 14		 jb	 SHORT $LN1769@LoadRaceMo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0103c	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0103f	83 c2 23	 add	 edx, 35			; 00000023H
  01042	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  01044	83 c0 fc	 add	 eax, -4			; fffffffcH
  01047	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0104a	0f 87 4f 0d 00
	00		 ja	 $LN2016@LoadRaceMo
$LN1769@LoadRaceMo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  01050	52		 push	 edx
  01051	51		 push	 ecx
  01052	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  01057	83 c4 08	 add	 esp, 8
$LN1759@LoadRaceMo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0105a	6a 0a		 push	 10			; 0000000aH

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0105c	c7 85 d4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T109[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  01066	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T109[ebp]
  0106c	68 00 00 00 00	 push	 OFFSET ??_C@_0L@OEOOJLDF@FRONT_DEAD@

; 4596 :         _My_data._Mysize = 0;

  01071	c7 85 e4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T109[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0107b	c7 85 e8 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T109[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  01085	c6 85 d4 fc ff
	ff 00		 mov	 BYTE PTR $T109[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0108c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  01091	c7 85 ec fc ff
	ff 0b 00 00 00	 mov	 DWORD PTR $T109[ebp+24], 11 ; 0000000bH
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 255  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("FRONT_DEAD", CRaceMotionData::NAME_DEAD));

  0109b	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T109[ebp]
  010a1	c7 45 fc 1d 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 29 ; 0000001dH
  010a8	50		 push	 eax
  010a9	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T35[ebp]
  010af	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  010b4	50		 push	 eax
  010b5	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  010ba	8b 95 e8 fc ff
	ff		 mov	 edx, DWORD PTR $T109[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 255  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("FRONT_DEAD", CRaceMotionData::NAME_DEAD));

  010c0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  010c7	83 fa 10	 cmp	 edx, 16			; 00000010H
  010ca	72 2f		 jb	 SHORT $LN1809@LoadRaceMo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  010cc	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR $T109[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  010d2	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  010d3	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  010d5	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  010db	72 14		 jb	 SHORT $LN1819@LoadRaceMo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  010dd	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  010e0	83 c2 23	 add	 edx, 35			; 00000023H
  010e3	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  010e5	83 c0 fc	 add	 eax, -4			; fffffffcH
  010e8	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  010eb	0f 87 ae 0c 00
	00		 ja	 $LN2016@LoadRaceMo
$LN1819@LoadRaceMo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  010f1	52		 push	 edx
  010f2	51		 push	 ecx
  010f3	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  010f8	83 c4 08	 add	 esp, 8
$LN1809@LoadRaceMo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  010fb	6a 0b		 push	 11			; 0000000bH

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  010fd	c7 85 d4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T108[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  01107	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T108[ebp]
  0110d	68 00 00 00 00	 push	 OFFSET ??_C@_0M@JAAKCNAK@FRONT_DEAD1@

; 4596 :         _My_data._Mysize = 0;

  01112	c7 85 e4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T108[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0111c	c7 85 e8 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T108[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  01126	c6 85 d4 fc ff
	ff 00		 mov	 BYTE PTR $T108[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0112d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  01132	c7 85 ec fc ff
	ff 0b 00 00 00	 mov	 DWORD PTR $T108[ebp+24], 11 ; 0000000bH
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 256  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("FRONT_DEAD1", CRaceMotionData::NAME_DEAD));

  0113c	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T108[ebp]
  01142	c7 45 fc 1e 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 30 ; 0000001eH
  01149	50		 push	 eax
  0114a	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T34[ebp]
  01150	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  01155	50		 push	 eax
  01156	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0115b	8b 95 e8 fc ff
	ff		 mov	 edx, DWORD PTR $T108[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 256  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("FRONT_DEAD1", CRaceMotionData::NAME_DEAD));

  01161	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  01168	83 fa 10	 cmp	 edx, 16			; 00000010H
  0116b	72 2f		 jb	 SHORT $LN1859@LoadRaceMo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0116d	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR $T108[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  01173	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  01174	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  01176	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0117c	72 14		 jb	 SHORT $LN1869@LoadRaceMo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0117e	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  01181	83 c2 23	 add	 edx, 35			; 00000023H
  01184	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  01186	83 c0 fc	 add	 eax, -4			; fffffffcH
  01189	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0118c	0f 87 0d 0c 00
	00		 ja	 $LN2016@LoadRaceMo
$LN1869@LoadRaceMo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  01192	52		 push	 edx
  01193	51		 push	 ecx
  01194	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  01199	83 c4 08	 add	 esp, 8
$LN1859@LoadRaceMo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0119c	6a 0b		 push	 11			; 0000000bH

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0119e	c7 85 d4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T107[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  011a8	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T107[ebp]
  011ae	68 00 00 00 00	 push	 OFFSET ??_C@_0M@LLCHHOMJ@FRONT_DEAD2@

; 4596 :         _My_data._Mysize = 0;

  011b3	c7 85 e4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T107[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  011bd	c7 85 e8 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T107[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  011c7	c6 85 d4 fc ff
	ff 00		 mov	 BYTE PTR $T107[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  011ce	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  011d3	c7 85 ec fc ff
	ff 0b 00 00 00	 mov	 DWORD PTR $T107[ebp+24], 11 ; 0000000bH
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 257  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("FRONT_DEAD2", CRaceMotionData::NAME_DEAD));

  011dd	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T107[ebp]
  011e3	c7 45 fc 1f 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 31 ; 0000001fH
  011ea	50		 push	 eax
  011eb	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T33[ebp]
  011f1	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  011f6	50		 push	 eax
  011f7	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  011fc	8b 95 e8 fc ff
	ff		 mov	 edx, DWORD PTR $T107[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 257  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("FRONT_DEAD2", CRaceMotionData::NAME_DEAD));

  01202	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  01209	83 fa 10	 cmp	 edx, 16			; 00000010H
  0120c	72 2f		 jb	 SHORT $LN1909@LoadRaceMo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0120e	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR $T107[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  01214	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  01215	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  01217	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0121d	72 14		 jb	 SHORT $LN1919@LoadRaceMo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0121f	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  01222	83 c2 23	 add	 edx, 35			; 00000023H
  01225	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  01227	83 c0 fc	 add	 eax, -4			; fffffffcH
  0122a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0122d	0f 87 6c 0b 00
	00		 ja	 $LN2016@LoadRaceMo
$LN1919@LoadRaceMo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  01233	52		 push	 edx
  01234	51		 push	 ecx
  01235	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0123a	83 c4 08	 add	 esp, 8
$LN1909@LoadRaceMo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0123d	6a 0f		 push	 15			; 0000000fH

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0123f	c7 85 d4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T106[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  01249	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T106[ebp]
  0124f	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@DFAPGFAO@FRONT_KNOCKDOWN@

; 4596 :         _My_data._Mysize = 0;

  01254	c7 85 e4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T106[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0125e	c7 85 e8 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T106[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  01268	c6 85 d4 fc ff
	ff 00		 mov	 BYTE PTR $T106[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0126f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  01274	c7 85 ec fc ff
	ff 06 00 00 00	 mov	 DWORD PTR $T106[ebp+24], 6
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 258  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("FRONT_KNOCKDOWN", CRaceMotionData::NAME_DAMAGE_FLYING));

  0127e	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T106[ebp]
  01284	c7 45 fc 20 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 32 ; 00000020H
  0128b	50		 push	 eax
  0128c	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T32[ebp]
  01292	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  01297	50		 push	 eax
  01298	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0129d	8b 95 e8 fc ff
	ff		 mov	 edx, DWORD PTR $T106[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 258  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("FRONT_KNOCKDOWN", CRaceMotionData::NAME_DAMAGE_FLYING));

  012a3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  012aa	83 fa 10	 cmp	 edx, 16			; 00000010H
  012ad	72 2f		 jb	 SHORT $LN1959@LoadRaceMo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  012af	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR $T106[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  012b5	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  012b6	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  012b8	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  012be	72 14		 jb	 SHORT $LN1969@LoadRaceMo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  012c0	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  012c3	83 c2 23	 add	 edx, 35			; 00000023H
  012c6	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  012c8	83 c0 fc	 add	 eax, -4			; fffffffcH
  012cb	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  012ce	0f 87 cb 0a 00
	00		 ja	 $LN2016@LoadRaceMo
$LN1969@LoadRaceMo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  012d4	52		 push	 edx
  012d5	51		 push	 ecx
  012d6	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  012db	83 c4 08	 add	 esp, 8
$LN1959@LoadRaceMo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  012de	6a 10		 push	 16			; 00000010H

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  012e0	c7 85 d4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T105[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  012ea	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T105[ebp]
  012f0	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@CBNACFNA@FRONT_KNOCKDOWN1@

; 4596 :         _My_data._Mysize = 0;

  012f5	c7 85 e4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T105[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  012ff	c7 85 e8 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T105[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  01309	c6 85 d4 fc ff
	ff 00		 mov	 BYTE PTR $T105[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  01310	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  01315	c7 85 ec fc ff
	ff 06 00 00 00	 mov	 DWORD PTR $T105[ebp+24], 6
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 259  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("FRONT_KNOCKDOWN1", CRaceMotionData::NAME_DAMAGE_FLYING));

  0131f	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T105[ebp]
  01325	c7 45 fc 21 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 33 ; 00000021H
  0132c	50		 push	 eax
  0132d	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T31[ebp]
  01333	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  01338	50		 push	 eax
  01339	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0133e	8b 95 e8 fc ff
	ff		 mov	 edx, DWORD PTR $T105[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 259  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("FRONT_KNOCKDOWN1", CRaceMotionData::NAME_DAMAGE_FLYING));

  01344	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0134b	83 fa 10	 cmp	 edx, 16			; 00000010H
  0134e	72 2f		 jb	 SHORT $LN2009@LoadRaceMo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  01350	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR $T105[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  01356	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  01357	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  01359	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0135f	72 14		 jb	 SHORT $LN2019@LoadRaceMo

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  01361	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  01364	83 c2 23	 add	 edx, 35			; 00000023H
  01367	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  01369	83 c0 fc	 add	 eax, -4			; fffffffcH
  0136c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0136f	0f 87 2a 0a 00
	00		 ja	 $LN2016@LoadRaceMo
$LN2019@LoadRaceMo:

; 264  :         ::operator delete(_Ptr, _Bytes);

  01375	52		 push	 edx
  01376	51		 push	 ecx
  01377	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0137c	83 c4 08	 add	 esp, 8
$LN2009@LoadRaceMo:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 260  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("FRONT_STANDUP", CRaceMotionData::NAME_STAND_UP));

  0137f	8d 85 1c fb ff
	ff		 lea	 eax, DWORD PTR $T77[ebp]
  01385	c7 85 1c fb ff
	ff 07 00 00 00	 mov	 DWORD PTR $T77[ebp], 7
  0138f	50		 push	 eax
  01390	68 00 00 00 00	 push	 OFFSET ??_C@_0O@MOHKHCLN@FRONT_STANDUP@
  01395	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T104[ebp]
  0139b	e8 00 00 00 00	 call	 ??$?0AAY0O@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0O@$$CBD$$QAW4EName@CRaceMotionData@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[14],enum CRaceMotionData::EName,0>
  013a0	50		 push	 eax
  013a1	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T30[ebp]
  013a7	c7 45 fc 22 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 34 ; 00000022H
  013ae	50		 push	 eax
  013af	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  013b4	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
  013b9	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T104[ebp]
  013bf	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  013c6	e8 00 00 00 00	 call	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ

; 261  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("FRONT_STANDUP1", CRaceMotionData::NAME_STAND_UP));

  013cb	8d 85 1c fb ff
	ff		 lea	 eax, DWORD PTR $T76[ebp]
  013d1	c7 85 1c fb ff
	ff 07 00 00 00	 mov	 DWORD PTR $T76[ebp], 7
  013db	50		 push	 eax
  013dc	68 00 00 00 00	 push	 OFFSET ??_C@_0P@HDEDLCPB@FRONT_STANDUP1@
  013e1	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T103[ebp]
  013e7	e8 00 00 00 00	 call	 ??$?0AAY0P@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0P@$$CBD$$QAW4EName@CRaceMotionData@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[15],enum CRaceMotionData::EName,0>
  013ec	50		 push	 eax
  013ed	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T29[ebp]
  013f3	c7 45 fc 23 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 35 ; 00000023H
  013fa	50		 push	 eax
  013fb	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  01400	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
  01405	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T103[ebp]
  0140b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01412	e8 00 00 00 00	 call	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ

; 262  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("BACK_DAMAGE", CRaceMotionData::NAME_DAMAGE_BACK));

  01417	8d 85 1c fb ff
	ff		 lea	 eax, DWORD PTR $T75[ebp]
  0141d	c7 85 1c fb ff
	ff 08 00 00 00	 mov	 DWORD PTR $T75[ebp], 8
  01427	50		 push	 eax
  01428	68 00 00 00 00	 push	 OFFSET ??_C@_0M@OFKIBNMF@BACK_DAMAGE@
  0142d	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T102[ebp]
  01433	e8 00 00 00 00	 call	 ??$?0AAY0M@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0M@$$CBD$$QAW4EName@CRaceMotionData@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[12],enum CRaceMotionData::EName,0>
  01438	50		 push	 eax
  01439	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T28[ebp]
  0143f	c7 45 fc 24 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 36 ; 00000024H
  01446	50		 push	 eax
  01447	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  0144c	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
  01451	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T102[ebp]
  01457	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0145e	e8 00 00 00 00	 call	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ

; 263  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("BACK_DAMAGE1", CRaceMotionData::NAME_DAMAGE_BACK));

  01463	8d 85 1c fb ff
	ff		 lea	 eax, DWORD PTR $T74[ebp]
  01469	c7 85 1c fb ff
	ff 08 00 00 00	 mov	 DWORD PTR $T74[ebp], 8
  01473	50		 push	 eax
  01474	68 00 00 00 00	 push	 OFFSET ??_C@_0N@CNLGJJJA@BACK_DAMAGE1@
  01479	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T101[ebp]
  0147f	e8 00 00 00 00	 call	 ??$?0AAY0N@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0N@$$CBD$$QAW4EName@CRaceMotionData@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[13],enum CRaceMotionData::EName,0>
  01484	50		 push	 eax
  01485	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T27[ebp]
  0148b	c7 45 fc 25 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 37 ; 00000025H
  01492	50		 push	 eax
  01493	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  01498	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
  0149d	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T101[ebp]
  014a3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  014aa	e8 00 00 00 00	 call	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ

; 264  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("BACK_DEAD", CRaceMotionData::NAME_DEAD_BACK));

  014af	8d 85 1c fb ff
	ff		 lea	 eax, DWORD PTR $T73[ebp]
  014b5	c7 85 1c fb ff
	ff 0c 00 00 00	 mov	 DWORD PTR $T73[ebp], 12	; 0000000cH
  014bf	50		 push	 eax
  014c0	68 00 00 00 00	 push	 OFFSET ??_C@_09LHOBDCIP@BACK_DEAD@
  014c5	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T100[ebp]
  014cb	e8 00 00 00 00	 call	 ??$?0AAY09$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY09$$CBD$$QAW4EName@CRaceMotionData@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[10],enum CRaceMotionData::EName,0>
  014d0	50		 push	 eax
  014d1	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T26[ebp]
  014d7	c7 45 fc 26 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 38 ; 00000026H
  014de	50		 push	 eax
  014df	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  014e4	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
  014e9	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T100[ebp]
  014ef	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  014f6	e8 00 00 00 00	 call	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ

; 265  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("BACK_DEAD1", CRaceMotionData::NAME_DEAD_BACK));

  014fb	c7 85 1c fb ff
	ff 0c 00 00 00	 mov	 DWORD PTR $T72[ebp], 12	; 0000000cH
  01505	8d 85 1c fb ff
	ff		 lea	 eax, DWORD PTR $T72[ebp]
  0150b	50		 push	 eax
  0150c	68 00 00 00 00	 push	 OFFSET ??_C@_0L@LLONHIDB@BACK_DEAD1@
  01511	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T99[ebp]
  01517	e8 00 00 00 00	 call	 ??$?0AAY0L@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0L@$$CBD$$QAW4EName@CRaceMotionData@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[11],enum CRaceMotionData::EName,0>
  0151c	50		 push	 eax
  0151d	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T25[ebp]
  01523	c7 45 fc 27 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 39 ; 00000027H
  0152a	50		 push	 eax
  0152b	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  01530	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
  01535	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T99[ebp]
  0153b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01542	e8 00 00 00 00	 call	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ

; 266  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("BACK_DEAD2", CRaceMotionData::NAME_DEAD_BACK));

  01547	8d 85 1c fb ff
	ff		 lea	 eax, DWORD PTR $T71[ebp]
  0154d	c7 85 1c fb ff
	ff 0c 00 00 00	 mov	 DWORD PTR $T71[ebp], 12	; 0000000cH
  01557	50		 push	 eax
  01558	68 00 00 00 00	 push	 OFFSET ??_C@_0L@JAMACLPC@BACK_DEAD2@
  0155d	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T98[ebp]
  01563	e8 00 00 00 00	 call	 ??$?0AAY0L@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0L@$$CBD$$QAW4EName@CRaceMotionData@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[11],enum CRaceMotionData::EName,0>
  01568	50		 push	 eax
  01569	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T24[ebp]
  0156f	c7 45 fc 28 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 40 ; 00000028H
  01576	50		 push	 eax
  01577	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  0157c	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
  01581	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T98[ebp]
  01587	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0158e	e8 00 00 00 00	 call	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ

; 267  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("BACK_KNOCKDOWN", CRaceMotionData::NAME_DAMAGE_FLYING_BACK));

  01593	8d 85 1c fb ff
	ff		 lea	 eax, DWORD PTR $T70[ebp]
  01599	c7 85 1c fb ff
	ff 09 00 00 00	 mov	 DWORD PTR $T70[ebp], 9
  015a3	50		 push	 eax
  015a4	68 00 00 00 00	 push	 OFFSET ??_C@_0P@MFNBGKJO@BACK_KNOCKDOWN@
  015a9	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T97[ebp]
  015af	e8 00 00 00 00	 call	 ??$?0AAY0P@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0P@$$CBD$$QAW4EName@CRaceMotionData@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[15],enum CRaceMotionData::EName,0>
  015b4	50		 push	 eax
  015b5	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T23[ebp]
  015bb	c7 45 fc 29 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 41 ; 00000029H
  015c2	50		 push	 eax
  015c3	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  015c8	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
  015cd	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T97[ebp]
  015d3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  015da	e8 00 00 00 00	 call	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ

; 268  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("BACK_KNOCKDOWN1", CRaceMotionData::NAME_DAMAGE_FLYING_BACK));

  015df	8d 85 1c fb ff
	ff		 lea	 eax, DWORD PTR $T69[ebp]
  015e5	c7 85 1c fb ff
	ff 09 00 00 00	 mov	 DWORD PTR $T69[ebp], 9
  015ef	50		 push	 eax
  015f0	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@NBCPGIJL@BACK_KNOCKDOWN1@
  015f5	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T96[ebp]
  015fb	e8 00 00 00 00	 call	 ??$?0AAY0BA@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0BA@$$CBD$$QAW4EName@CRaceMotionData@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[16],enum CRaceMotionData::EName,0>
  01600	50		 push	 eax
  01601	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T22[ebp]
  01607	c7 45 fc 2a 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 42 ; 0000002aH
  0160e	50		 push	 eax
  0160f	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  01614	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
  01619	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T96[ebp]
  0161f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01626	e8 00 00 00 00	 call	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ

; 269  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("BACK_STANDUP", CRaceMotionData::NAME_STAND_UP_BACK));

  0162b	8d 85 1c fb ff
	ff		 lea	 eax, DWORD PTR $T68[ebp]
  01631	c7 85 1c fb ff
	ff 0a 00 00 00	 mov	 DWORD PTR $T68[ebp], 10	; 0000000aH
  0163b	50		 push	 eax
  0163c	68 00 00 00 00	 push	 OFFSET ??_C@_0N@OJMJBDBJ@BACK_STANDUP@
  01641	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T95[ebp]
  01647	e8 00 00 00 00	 call	 ??$?0AAY0N@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0N@$$CBD$$QAW4EName@CRaceMotionData@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[13],enum CRaceMotionData::EName,0>
  0164c	50		 push	 eax
  0164d	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T21[ebp]
  01653	c7 45 fc 2b 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 43 ; 0000002bH
  0165a	50		 push	 eax
  0165b	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  01660	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
  01665	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T95[ebp]
  0166b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01672	e8 00 00 00 00	 call	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ

; 270  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("BACK_STANDUP1", CRaceMotionData::NAME_STAND_UP_BACK));

  01677	c7 85 1c fb ff
	ff 0a 00 00 00	 mov	 DWORD PTR $T67[ebp], 10	; 0000000aH
  01681	8d 85 1c fb ff
	ff		 lea	 eax, DWORD PTR $T67[ebp]
  01687	50		 push	 eax
  01688	68 00 00 00 00	 push	 OFFSET ??_C@_0O@KCNPGGGB@BACK_STANDUP1@
  0168d	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T94[ebp]
  01693	e8 00 00 00 00	 call	 ??$?0AAY0O@$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY0O@$$CBD$$QAW4EName@CRaceMotionData@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[14],enum CRaceMotionData::EName,0>
  01698	50		 push	 eax
  01699	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T20[ebp]
  0169f	c7 45 fc 2c 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 44 ; 0000002cH
  016a6	50		 push	 eax
  016a7	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  016ac	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
  016b1	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T94[ebp]
  016b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  016be	e8 00 00 00 00	 call	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ

; 271  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("SPECIAL", CRaceMotionData::NAME_SPECIAL_1));

  016c3	8d 85 1c fb ff
	ff		 lea	 eax, DWORD PTR $T66[ebp]
  016c9	c7 85 1c fb ff
	ff 21 00 00 00	 mov	 DWORD PTR $T66[ebp], 33	; 00000021H
  016d3	50		 push	 eax
  016d4	68 00 00 00 00	 push	 OFFSET ??_C@_07OJOPHEAL@SPECIAL@
  016d9	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T93[ebp]
  016df	e8 00 00 00 00	 call	 ??$?0AAY07$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY07$$CBD$$QAW4EName@CRaceMotionData@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[8],enum CRaceMotionData::EName,0>
  016e4	50		 push	 eax
  016e5	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T19[ebp]
  016eb	c7 45 fc 2d 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 45 ; 0000002dH
  016f2	50		 push	 eax
  016f3	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  016f8	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
  016fd	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T93[ebp]
  01703	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0170a	e8 00 00 00 00	 call	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ

; 272  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("SPECIAL1", CRaceMotionData::NAME_SPECIAL_2));

  0170f	8d 85 1c fb ff
	ff		 lea	 eax, DWORD PTR $T65[ebp]
  01715	c7 85 1c fb ff
	ff 22 00 00 00	 mov	 DWORD PTR $T65[ebp], 34	; 00000022H
  0171f	50		 push	 eax
  01720	68 00 00 00 00	 push	 OFFSET ??_C@_08FBGGDBEO@SPECIAL1@
  01725	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T92[ebp]
  0172b	e8 00 00 00 00	 call	 ??$?0AAY08$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY08$$CBD$$QAW4EName@CRaceMotionData@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[9],enum CRaceMotionData::EName,0>
  01730	50		 push	 eax
  01731	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T18[ebp]
  01737	c7 45 fc 2e 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 46 ; 0000002eH
  0173e	50		 push	 eax
  0173f	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  01744	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
  01749	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T92[ebp]
  0174f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01756	e8 00 00 00 00	 call	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ

; 273  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("SPECIAL2", CRaceMotionData::NAME_SPECIAL_3));

  0175b	8d 85 1c fb ff
	ff		 lea	 eax, DWORD PTR $T64[ebp]
  01761	c7 85 1c fb ff
	ff 23 00 00 00	 mov	 DWORD PTR $T64[ebp], 35	; 00000023H
  0176b	50		 push	 eax
  0176c	68 00 00 00 00	 push	 OFFSET ??_C@_08HKELGCIN@SPECIAL2@
  01771	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T91[ebp]
  01777	e8 00 00 00 00	 call	 ??$?0AAY08$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY08$$CBD$$QAW4EName@CRaceMotionData@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[9],enum CRaceMotionData::EName,0>
  0177c	50		 push	 eax
  0177d	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T17[ebp]
  01783	c7 45 fc 2f 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 47 ; 0000002fH
  0178a	50		 push	 eax
  0178b	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  01790	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
  01795	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T91[ebp]
  0179b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  017a2	e8 00 00 00 00	 call	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ

; 274  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("SPECIAL3", CRaceMotionData::NAME_SPECIAL_4));

  017a7	8d 85 1c fb ff
	ff		 lea	 eax, DWORD PTR $T63[ebp]
  017ad	c7 85 1c fb ff
	ff 24 00 00 00	 mov	 DWORD PTR $T63[ebp], 36	; 00000024H
  017b7	50		 push	 eax
  017b8	68 00 00 00 00	 push	 OFFSET ??_C@_08GDFAFDMM@SPECIAL3@
  017bd	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T90[ebp]
  017c3	e8 00 00 00 00	 call	 ??$?0AAY08$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY08$$CBD$$QAW4EName@CRaceMotionData@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[9],enum CRaceMotionData::EName,0>
  017c8	50		 push	 eax
  017c9	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T16[ebp]
  017cf	c7 45 fc 30 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 48 ; 00000030H
  017d6	50		 push	 eax
  017d7	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  017dc	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
  017e1	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T90[ebp]
  017e7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  017ee	e8 00 00 00 00	 call	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ

; 275  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("SPECIAL4", CRaceMotionData::NAME_SPECIAL_5));

  017f3	8d 85 1c fb ff
	ff		 lea	 eax, DWORD PTR $T62[ebp]
  017f9	c7 85 1c fb ff
	ff 25 00 00 00	 mov	 DWORD PTR $T62[ebp], 37	; 00000025H
  01803	50		 push	 eax
  01804	68 00 00 00 00	 push	 OFFSET ??_C@_08CMBBMFAL@SPECIAL4@
  01809	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T89[ebp]
  0180f	e8 00 00 00 00	 call	 ??$?0AAY08$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY08$$CBD$$QAW4EName@CRaceMotionData@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[9],enum CRaceMotionData::EName,0>
  01814	50		 push	 eax
  01815	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T15[ebp]
  0181b	c7 45 fc 31 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 49 ; 00000031H
  01822	50		 push	 eax
  01823	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  01828	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
  0182d	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T89[ebp]
  01833	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0183a	e8 00 00 00 00	 call	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ

; 276  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("SPECIAL5", CRaceMotionData::NAME_SPECIAL_6));

  0183f	8d 85 1c fb ff
	ff		 lea	 eax, DWORD PTR $T61[ebp]
  01845	c7 85 1c fb ff
	ff 26 00 00 00	 mov	 DWORD PTR $T61[ebp], 38	; 00000026H
  0184f	50		 push	 eax
  01850	68 00 00 00 00	 push	 OFFSET ??_C@_08DFAKPEEK@SPECIAL5@
  01855	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T88[ebp]
  0185b	e8 00 00 00 00	 call	 ??$?0AAY08$$CBDW4EName@CRaceMotionData@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY08$$CBD$$QAW4EName@CRaceMotionData@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[9],enum CRaceMotionData::EName,0>
  01860	50		 push	 eax
  01861	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  01867	c7 45 fc 32 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 50 ; 00000032H
  0186e	50		 push	 eax
  0186f	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  01874	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
  01879	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T88[ebp]
  0187f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01886	e8 00 00 00 00	 call	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ

; 277  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("SKILL1", CRaceMotionData::NAME_SKILL+121));

  0188b	8d 85 1c fb ff
	ff		 lea	 eax, DWORD PTR $T60[ebp]
  01891	c7 85 1c fb ff
	ff ab 00 00 00	 mov	 DWORD PTR $T60[ebp], 171 ; 000000abH
  0189b	50		 push	 eax
  0189c	68 00 00 00 00	 push	 OFFSET ??_C@_06COMNIHKP@SKILL1@
  018a1	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T87[ebp]
  018a7	e8 00 00 00 00	 call	 ??$?0AAY06$$CBDH$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY06$$CBD$$QAH@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[7],int,0>
  018ac	50		 push	 eax
  018ad	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T13[ebp]
  018b3	c7 45 fc 33 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 51 ; 00000033H
  018ba	50		 push	 eax
  018bb	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  018c0	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
  018c5	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T87[ebp]
  018cb	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  018d2	e8 00 00 00 00	 call	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ

; 278  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("SKILL2", CRaceMotionData::NAME_SKILL+122));

  018d7	8d 85 1c fb ff
	ff		 lea	 eax, DWORD PTR $T59[ebp]
  018dd	c7 85 1c fb ff
	ff ac 00 00 00	 mov	 DWORD PTR $T59[ebp], 172 ; 000000acH
  018e7	50		 push	 eax
  018e8	68 00 00 00 00	 push	 OFFSET ??_C@_06FOANEGM@SKILL2@
  018ed	8d 8d b8 fc ff
	ff		 lea	 ecx, DWORD PTR $T81[ebp]
  018f3	e8 00 00 00 00	 call	 ??$?0AAY06$$CBDH$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY06$$CBD$$QAH@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[7],int,0>
  018f8	50		 push	 eax
  018f9	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T12[ebp]
  018ff	c7 45 fc 34 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 52 ; 00000034H
  01906	50		 push	 eax
  01907	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  0190c	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
  01911	8d 8d b8 fc ff
	ff		 lea	 ecx, DWORD PTR $T81[ebp]
  01917	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0191e	e8 00 00 00 00	 call	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ

; 279  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("SKILL3", CRaceMotionData::NAME_SKILL+123));

  01923	8d 85 1c fb ff
	ff		 lea	 eax, DWORD PTR $T58[ebp]
  01929	c7 85 1c fb ff
	ff ad 00 00 00	 mov	 DWORD PTR $T58[ebp], 173 ; 000000adH
  01933	50		 push	 eax
  01934	68 00 00 00 00	 push	 OFFSET ??_C@_06BMPLOFCN@SKILL3@
  01939	8d 8d 9c fc ff
	ff		 lea	 ecx, DWORD PTR $T80[ebp]
  0193f	e8 00 00 00 00	 call	 ??$?0AAY06$$CBDH$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY06$$CBD$$QAH@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[7],int,0>
  01944	50		 push	 eax
  01945	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  0194b	c7 45 fc 35 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 53 ; 00000035H
  01952	50		 push	 eax
  01953	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  01958	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
  0195d	8d 8d 9c fc ff
	ff		 lea	 ecx, DWORD PTR $T80[ebp]
  01963	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0196a	e8 00 00 00 00	 call	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ

; 280  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("SKILL4", CRaceMotionData::NAME_SKILL+124));

  0196f	8d 85 1c fb ff
	ff		 lea	 eax, DWORD PTR $T57[ebp]
  01975	c7 85 1c fb ff
	ff ae 00 00 00	 mov	 DWORD PTR $T57[ebp], 174 ; 000000aeH
  0197f	50		 push	 eax
  01980	68 00 00 00 00	 push	 OFFSET ??_C@_06FDLKHDOK@SKILL4@
  01985	8d 8d 80 fc ff
	ff		 lea	 ecx, DWORD PTR $T79[ebp]
  0198b	e8 00 00 00 00	 call	 ??$?0AAY06$$CBDH$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY06$$CBD$$QAH@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[7],int,0>
  01990	50		 push	 eax
  01991	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  01997	c7 45 fc 36 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 54 ; 00000036H
  0199e	50		 push	 eax
  0199f	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  019a4	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
  019a9	8d 8d 80 fc ff
	ff		 lea	 ecx, DWORD PTR $T79[ebp]
  019af	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  019b6	e8 00 00 00 00	 call	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ

; 281  : 		s_kMap_stType_dwIndex.insert(std::map<std::string, DWORD>::value_type("SKILL5", CRaceMotionData::NAME_SKILL+125));

  019bb	8d 85 1c fb ff
	ff		 lea	 eax, DWORD PTR $T56[ebp]
  019c1	c7 85 1c fb ff
	ff af 00 00 00	 mov	 DWORD PTR $T56[ebp], 175 ; 000000afH
  019cb	50		 push	 eax
  019cc	68 00 00 00 00	 push	 OFFSET ??_C@_06EKKBECKL@SKILL5@
  019d1	8d 8d 64 fc ff
	ff		 lea	 ecx, DWORD PTR $T78[ebp]
  019d7	e8 00 00 00 00	 call	 ??$?0AAY06$$CBDH$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@AAY06$$CBD$$QAH@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long><char const (&)[7],int,0>
  019dc	50		 push	 eax
  019dd	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  019e3	c7 45 fc 37 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 55 ; 00000037H
  019ea	50		 push	 eax
  019eb	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  019f0	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::insert<0,0>
  019f5	8d 8d 64 fc ff
	ff		 lea	 ecx, DWORD PTR $T78[ebp]
  019fb	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01a02	e8 00 00 00 00	 call	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
  01a07	8b bd 0c fb ff
	ff		 mov	 edi, DWORD PTR _rkRaceData$GSCopy$1$[ebp]
  01a0d	8b 9d 00 fb ff
	ff		 mov	 ebx, DWORD PTR tv9339[ebp]
$LN13@LoadRaceMo:

; 282  : 	}
; 283  : 
; 284  : 	const void * pvData;
; 285  : 	CMappedFile kMappedFile;

  01a13	8d 8d 20 fb ff
	ff		 lea	 ecx, DWORD PTR _kMappedFile$[ebp]
  01a19	e8 00 00 00 00	 call	 ??0CMappedFile@@QAE@XZ	; CMappedFile::CMappedFile

; 286  : 	if (!CEterPackManager::Instance().Get(kMappedFile, motionListFileName, &pvData))

  01a1e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  01a24	8d 85 fc fa ff
	ff		 lea	 eax, DWORD PTR _pvData$[ebp]
  01a2a	50		 push	 eax
  01a2b	ff b5 04 fb ff
	ff		 push	 DWORD PTR _motionListFileName$GSCopy$1$[ebp]
  01a31	8d 85 20 fb ff
	ff		 lea	 eax, DWORD PTR _kMappedFile$[ebp]
  01a37	c7 45 fc 38 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 56 ; 00000038H
  01a3e	50		 push	 eax
  01a3f	e8 00 00 00 00	 call	 ?Get@CEterPackManager@@QAE_NAAVCMappedFile@@PBDPAPBX@Z ; CEterPackManager::Get
  01a44	84 c0		 test	 al, al
  01a46	75 07		 jne	 SHORT $LN14@LoadRaceMo
  01a48	32 db		 xor	 bl, bl
  01a4a	e9 b8 02 00 00	 jmp	 $LN78@LoadRaceMo
$LN14@LoadRaceMo:

; 287  : 		return false;
; 288  : 
; 289  : 
; 290  : 	CMemoryTextFileLoader kTextFileLoader;

  01a4f	8d 8d e8 fa ff
	ff		 lea	 ecx, DWORD PTR _kTextFileLoader$[ebp]
  01a55	e8 00 00 00 00	 call	 ??0CMemoryTextFileLoader@@QAE@XZ ; CMemoryTextFileLoader::CMemoryTextFileLoader

; 291  : 	kTextFileLoader.Bind(kMappedFile.Size(), pvData);

  01a5a	ff b5 fc fa ff
	ff		 push	 DWORD PTR _pvData$[ebp]
  01a60	8d 8d 20 fb ff
	ff		 lea	 ecx, DWORD PTR _kMappedFile$[ebp]
  01a66	c6 45 fc 39	 mov	 BYTE PTR __$EHRec$[ebp+8], 57 ; 00000039H
  01a6a	e8 00 00 00 00	 call	 ?Size@CMappedFile@@QAEKXZ ; CMappedFile::Size
  01a6f	50		 push	 eax
  01a70	8d 8d e8 fa ff
	ff		 lea	 ecx, DWORD PTR _kTextFileLoader$[ebp]
  01a76	e8 00 00 00 00	 call	 ?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z ; CMemoryTextFileLoader::Bind

; 292  : 
; 293  : 	rkRaceData.RegisterMotionMode(CRaceMotionData::MODE_GENERAL);

  01a7b	6a 01		 push	 1
  01a7d	8b cf		 mov	 ecx, edi
  01a7f	e8 00 00 00 00	 call	 ?RegisterMotionMode@CRaceData@@QAEXG@Z ; CRaceData::RegisterMotionMode

; 302  : 	static std::string stSpawnMotionFileName;

  01a84	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$TSS1@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4HA
  01a89	c7 85 08 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _nPercent$[ebp], 0
  01a93	c6 85 13 fb ff
	ff 00		 mov	 BYTE PTR _isSpawn$1$[ebp], 0
  01a9a	3b 83 00 00 00
	00		 cmp	 eax, DWORD PTR __Init_thread_epoch[ebx]
  01aa0	0f 8f fe 02 00
	00		 jg	 $LN2107@LoadRaceMo
$LN3@LoadRaceMo:

; 303  : 	static std::string stMotionFileName;

  01aa6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$TSS2@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4HA
  01aab	3b 83 00 00 00
	00		 cmp	 eax, DWORD PTR __Init_thread_epoch[ebx]
  01ab1	0f 8f 23 03 00
	00		 jg	 $LN2108@LoadRaceMo
$LN4@LoadRaceMo:

; 304  : 
; 305  : 	stSpawnMotionFileName = "";

  01ab7	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  01abc	b9 00 00 00 00	 mov	 ecx, OFFSET ?stSpawnMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  01ac1	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 306  : 	stMotionFileName = "";

  01ac6	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  01acb	b9 00 00 00 00	 mov	 ecx, OFFSET ?stMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  01ad0	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 307  : 
; 308  : 	UINT uLineCount=kTextFileLoader.GetLineCount();

  01ad5	8d 8d e8 fa ff
	ff		 lea	 ecx, DWORD PTR _kTextFileLoader$[ebp]
  01adb	e8 00 00 00 00	 call	 ?GetLineCount@CMemoryTextFileLoader@@QAEKXZ ; CMemoryTextFileLoader::GetLineCount

; 309  : 	for (UINT uLineIndex=0; uLineIndex<uLineCount; ++uLineIndex)

  01ae0	33 db		 xor	 ebx, ebx
  01ae2	89 85 04 fb ff
	ff		 mov	 DWORD PTR _uLineCount$1$[ebp], eax
  01ae8	85 c0		 test	 eax, eax
  01aea	0f 84 cd 01 00
	00		 je	 $LN2092@LoadRaceMo
$LL7@LoadRaceMo:

; 310  : 	{
; 311  : 		DWORD motionType = CRaceMotionData::NAME_NONE;
; 312  : 
; 313  : 		const std::string & c_rstLine=kTextFileLoader.GetLineString(uLineIndex);

  01af0	53		 push	 ebx
  01af1	8d 8d e8 fa ff
	ff		 lea	 ecx, DWORD PTR _kTextFileLoader$[ebp]
  01af7	e8 00 00 00 00	 call	 ?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; CMemoryTextFileLoader::GetLineString

; 314  : 		sscanf(c_rstLine.c_str(), "%s %s %s %d", szMode, szType, szFile, &nPercent);

  01afc	8d 8d 08 fb ff
	ff		 lea	 ecx, DWORD PTR _nPercent$[ebp]
  01b02	51		 push	 ecx
  01b03	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _szFile$[ebp]
  01b09	51		 push	 ecx
  01b0a	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _szType$[ebp]
  01b10	51		 push	 ecx
  01b11	8d 8d f0 fc ff
	ff		 lea	 ecx, DWORD PTR _szMode$[ebp]
  01b17	51		 push	 ecx
  01b18	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HPBHEBFF@?$CFs?5?$CFs?5?$CFs?5?$CFd@
  01b1d	8b c8		 mov	 ecx, eax
  01b1f	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  01b24	50		 push	 eax
  01b25	e8 00 00 00 00	 call	 _sscanf
  01b2a	83 c4 18	 add	 esp, 24			; 00000018H

; 315  : 
; 316  : 		std::map<std::string, DWORD>::iterator fTypeIndex=s_kMap_stType_dwIndex.find(szType);

  01b2d	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _szType$[ebp]
  01b33	8d 8d bc fc ff
	ff		 lea	 ecx, DWORD PTR $T83[ebp]
  01b39	50		 push	 eax
  01b3a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  01b3f	8d 85 bc fc ff
	ff		 lea	 eax, DWORD PTR $T83[ebp]
  01b45	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  01b4a	50		 push	 eax
  01b4b	8d 85 1c fb ff
	ff		 lea	 eax, DWORD PTR _fTypeIndex$55[ebp]
  01b51	50		 push	 eax
  01b52	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::find
  01b57	8d 8d bc fc ff
	ff		 lea	 ecx, DWORD PTR $T83[ebp]
  01b5d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 317  : 
; 318  : 		if (s_kMap_stType_dwIndex.end() == fTypeIndex)

  01b62	8b b5 1c fb ff
	ff		 mov	 esi, DWORD PTR _fTypeIndex$55[ebp]
  01b68	39 35 00 00 00
	00		 cmp	 DWORD PTR ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A, esi
  01b6e	0f 85 d0 00 00
	00		 jne	 $LN18@LoadRaceMo

; 319  : 		{
; 320  : 			//   WAIT, WAIT4, WAIT20      ,
; 321  : 			// WAIT4, WAIT20 WAIT    
; 322  : 			const size_t c_cutLengthLimit = 2;
; 323  : 			bool bFound = false;
; 324  : 
; 325  : 			if (c_cutLengthLimit < strlen(szType) + 1)

  01b74	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _szType$[ebp]
  01b7a	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  01b7d	0f 1f 00	 npad	 3
$LL2096@LoadRaceMo:
  01b80	8a 01		 mov	 al, BYTE PTR [ecx]
  01b82	41		 inc	 ecx
  01b83	84 c0		 test	 al, al
  01b85	75 f9		 jne	 SHORT $LL2096@LoadRaceMo
  01b87	2b ca		 sub	 ecx, edx
  01b89	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  01b8c	83 f8 02	 cmp	 eax, 2
  01b8f	0f 86 11 01 00
	00		 jbe	 $LN2099@LoadRaceMo

; 326  : 			{
; 327  : 				for (size_t i = 1; i <= c_cutLengthLimit; ++i)

  01b95	bf 01 00 00 00	 mov	 edi, 1
  01b9a	66 0f 1f 44 00
	00		 npad	 6
$LL10@LoadRaceMo:

; 328  : 				{
; 329  : 					std::string typeName = std::string(szType).substr(0, strlen(szType) - i);

  01ba0	8d b5 f0 fe ff
	ff		 lea	 esi, DWORD PTR _szType$[ebp]
  01ba6	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  01ba9	0f 1f 80 00 00
	00 00		 npad	 7
$LL2097@LoadRaceMo:
  01bb0	8a 06		 mov	 al, BYTE PTR [esi]
  01bb2	46		 inc	 esi
  01bb3	84 c0		 test	 al, al
  01bb5	75 f9		 jne	 SHORT $LL2097@LoadRaceMo
  01bb7	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _szType$[ebp]
  01bbd	2b f1		 sub	 esi, ecx
  01bbf	50		 push	 eax
  01bc0	8d 8d d8 fc ff
	ff		 lea	 ecx, DWORD PTR $T132[ebp]
  01bc6	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  01bcb	2b f7		 sub	 esi, edi
  01bcd	c6 45 fc 3a	 mov	 BYTE PTR __$EHRec$[ebp+8], 58 ; 0000003aH
  01bd1	56		 push	 esi
  01bd2	6a 00		 push	 0
  01bd4	8d 8d bc fc ff
	ff		 lea	 ecx, DWORD PTR _typeName$82[ebp]
  01bda	51		 push	 ecx
  01bdb	8b c8		 mov	 ecx, eax
  01bdd	e8 00 00 00 00	 call	 ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
  01be2	8d 8d d8 fc ff
	ff		 lea	 ecx, DWORD PTR $T132[ebp]
  01be8	c6 45 fc 39	 mov	 BYTE PTR __$EHRec$[ebp+8], 57 ; 00000039H
  01bec	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 330  : 					fTypeIndex = s_kMap_stType_dwIndex.find(typeName);

  01bf1	8d 85 bc fc ff
	ff		 lea	 eax, DWORD PTR _typeName$82[ebp]
  01bf7	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A
  01bfc	50		 push	 eax
  01bfd	8d 85 00 fb ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  01c03	50		 push	 eax
  01c04	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::find

; 332  : 					if (s_kMap_stType_dwIndex.end() != fTypeIndex)

  01c09	8d 8d bc fc ff
	ff		 lea	 ecx, DWORD PTR _typeName$82[ebp]
  01c0f	8b 30		 mov	 esi, DWORD PTR [eax]
  01c11	89 b5 1c fb ff
	ff		 mov	 DWORD PTR _fTypeIndex$55[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  01c17	39 35 00 00 00
	00		 cmp	 DWORD PTR ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A, esi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 332  : 					if (s_kMap_stType_dwIndex.end() != fTypeIndex)

  01c1d	75 1a		 jne	 SHORT $LN2081@LoadRaceMo

; 336  : 					}
; 337  : 				}

  01c1f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01c24	47		 inc	 edi
  01c25	83 ff 02	 cmp	 edi, 2
  01c28	0f 86 72 ff ff
	ff		 jbe	 $LL10@LoadRaceMo

; 332  : 					if (s_kMap_stType_dwIndex.end() != fTypeIndex)

  01c2e	8b bd 0c fb ff
	ff		 mov	 edi, DWORD PTR _rkRaceData$GSCopy$1$[ebp]
  01c34	e9 6d 00 00 00	 jmp	 $LN2099@LoadRaceMo
$LN2081@LoadRaceMo:

; 333  : 					{
; 334  : 						bFound = true;
; 335  : 						break;

  01c39	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01c3e	8b bd 0c fb ff
	ff		 mov	 edi, DWORD PTR _rkRaceData$GSCopy$1$[ebp]
$LN18@LoadRaceMo:

; 338  : 			}
; 339  : 
; 340  : 			if (false == bFound)
; 341  : 				continue;
; 342  : 		}
; 343  : 
; 344  : 		motionType = fTypeIndex->second;
; 345  : 
; 346  : 		stMotionFileName = pathName;

  01c44	ff b5 f8 fa ff
	ff		 push	 DWORD PTR _pathName$GSCopy$1$[ebp]
  01c4a	8b 76 28	 mov	 esi, DWORD PTR [esi+40]
  01c4d	b9 00 00 00 00	 mov	 ecx, OFFSET ?stMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  01c52	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 347  : 		stMotionFileName += szFile;

  01c57	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _szFile$[ebp]
  01c5d	b9 00 00 00 00	 mov	 ecx, OFFSET ?stMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  01c62	50		 push	 eax
  01c63	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 348  : 
; 349  : 		rkRaceData.RegisterMotionData(CRaceMotionData::MODE_GENERAL, motionType, stMotionFileName.c_str(), nPercent);

  01c68	ff b5 08 fb ff
	ff		 push	 DWORD PTR _nPercent$[ebp]
  01c6e	b9 00 00 00 00	 mov	 ecx, OFFSET ?stMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  01c73	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  01c78	50		 push	 eax
  01c79	56		 push	 esi
  01c7a	6a 01		 push	 1
  01c7c	8b cf		 mov	 ecx, edi
  01c7e	e8 00 00 00 00	 call	 ?RegisterMotionData@CRaceData@@QAEPAVCGraphicThing@@GGPBDE@Z ; CRaceData::RegisterMotionData

; 350  : 
; 351  : 		switch (motionType)

  01c83	83 fe 05	 cmp	 esi, 5
  01c86	74 0f		 je	 SHORT $LN20@LoadRaceMo
  01c88	83 fe 19	 cmp	 esi, 25			; 00000019H
  01c8b	75 19		 jne	 SHORT $LN2099@LoadRaceMo

; 352  : 		{
; 353  : 			case CRaceMotionData::NAME_SPAWN:
; 354  : 				isSpawn=true;

  01c8d	b0 01		 mov	 al, 1
  01c8f	88 85 13 fb ff
	ff		 mov	 BYTE PTR _isSpawn$1$[ebp], al

; 355  : 				break;

  01c95	eb 15		 jmp	 SHORT $LN5@LoadRaceMo
$LN20@LoadRaceMo:

; 356  : 			case CRaceMotionData::NAME_DAMAGE:
; 357  : 				stSpawnMotionFileName=stMotionFileName;

  01c97	68 00 00 00 00	 push	 OFFSET ?stMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  01c9c	b9 00 00 00 00	 mov	 ecx, OFFSET ?stSpawnMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  01ca1	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
$LN2099@LoadRaceMo:

; 309  : 	for (UINT uLineIndex=0; uLineIndex<uLineCount; ++uLineIndex)

  01ca6	8a 85 13 fb ff
	ff		 mov	 al, BYTE PTR _isSpawn$1$[ebp]
$LN5@LoadRaceMo:
  01cac	43		 inc	 ebx
  01cad	3b 9d 04 fb ff
	ff		 cmp	 ebx, DWORD PTR _uLineCount$1$[ebp]
  01cb3	0f 82 37 fe ff
	ff		 jb	 $LL7@LoadRaceMo

; 358  : 				break;
; 359  : 		}
; 360  : 	}
; 361  : 
; 362  : 	if (!isSpawn && stSpawnMotionFileName!="")

  01cb9	84 c0		 test	 al, al
  01cbb	75 32		 jne	 SHORT $LN21@LoadRaceMo
$LN2092@LoadRaceMo:
  01cbd	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  01cc2	68 00 00 00 00	 push	 OFFSET ?stSpawnMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  01cc7	e8 00 00 00 00	 call	 ??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
  01ccc	83 c4 08	 add	 esp, 8
  01ccf	84 c0		 test	 al, al
  01cd1	74 1c		 je	 SHORT $LN21@LoadRaceMo

; 363  : 		rkRaceData.RegisterMotionData(CRaceMotionData::MODE_GENERAL, CRaceMotionData::NAME_SPAWN, stSpawnMotionFileName.c_str(), nPercent);

  01cd3	ff b5 08 fb ff
	ff		 push	 DWORD PTR _nPercent$[ebp]
  01cd9	b9 00 00 00 00	 mov	 ecx, OFFSET ?stSpawnMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  01cde	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  01ce3	50		 push	 eax
  01ce4	6a 19		 push	 25			; 00000019H
  01ce6	6a 01		 push	 1
  01ce8	8b cf		 mov	 ecx, edi
  01cea	e8 00 00 00 00	 call	 ?RegisterMotionData@CRaceData@@QAEPAVCGraphicThing@@GGPBDE@Z ; CRaceData::RegisterMotionData
$LN21@LoadRaceMo:

; 364  : 
; 365  : 	rkRaceData.RegisterNormalAttack(CRaceMotionData::MODE_GENERAL, CRaceMotionData::NAME_NORMAL_ATTACK);

  01cef	6a 0d		 push	 13			; 0000000dH
  01cf1	6a 01		 push	 1
  01cf3	8b cf		 mov	 ecx, edi
  01cf5	e8 00 00 00 00	 call	 ?RegisterNormalAttack@CRaceData@@QAEXGG@Z ; CRaceData::RegisterNormalAttack

; 366  : 
; 367  : 	return true;

  01cfa	8d 8d e8 fa ff
	ff		 lea	 ecx, DWORD PTR _kTextFileLoader$[ebp]
  01d00	b3 01		 mov	 bl, 1
  01d02	e8 00 00 00 00	 call	 ??1CMemoryTextFileLoader@@UAE@XZ ; CMemoryTextFileLoader::~CMemoryTextFileLoader
$LN78@LoadRaceMo:
  01d07	8d 8d 20 fb ff
	ff		 lea	 ecx, DWORD PTR _kMappedFile$[ebp]
  01d0d	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  01d12	8a c3		 mov	 al, bl

; 368  : }

  01d14	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01d17	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  01d1e	59		 pop	 ecx
  01d1f	5f		 pop	 edi
  01d20	5e		 pop	 esi
  01d21	5b		 pop	 ebx
  01d22	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01d25	33 cd		 xor	 ecx, ebp
  01d27	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01d2c	8b e5		 mov	 esp, ebp
  01d2e	5d		 pop	 ebp
  01d2f	c2 0c 00	 ret	 12			; 0000000cH
$LN2103@LoadRaceMo:

; 226  : 	static std::map<std::string, DWORD> s_kMap_stType_dwIndex;

  01d32	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4HA
  01d37	e8 00 00 00 00	 call	 __Init_thread_header
  01d3c	83 c4 04	 add	 esp, 4
  01d3f	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4HA, -1
  01d46	0f 85 23 e3 ff
	ff		 jne	 $LN2@LoadRaceMo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 85   :         return ::operator new(_Bytes);

  01d4c	6a 2c		 push	 44			; 0000002cH
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 226  : 	static std::map<std::string, DWORD> s_kMap_stType_dwIndex;

  01d4e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 85   :         return ::operator new(_Bytes);

  01d55	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 226  : 	static std::map<std::string, DWORD> s_kMap_stType_dwIndex;

  01d5a	68 00 00 00 00	 push	 OFFSET ??__Fs_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@YAXXZ ; `CRaceManager::__LoadRaceMotionList'::`2'::`dynamic atexit destructor for 's_kMap_stType_dwIndex''
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 350  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  01d5f	89 00		 mov	 DWORD PTR [eax], eax

; 351  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  01d61	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 352  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  01d64	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 353  :         _Pnode->_Color = _Black;

  01d67	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 1925 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  01d6d	a3 00 00 00 00	 mov	 DWORD PTR ?s_kMap_stType_dwIndex@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@@std@@A, eax
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 226  : 	static std::map<std::string, DWORD> s_kMap_stType_dwIndex;

  01d72	e8 00 00 00 00	 call	 _atexit
  01d77	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4HA
  01d7c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01d83	e8 00 00 00 00	 call	 __Init_thread_footer
  01d88	83 c4 0c	 add	 esp, 12			; 0000000cH
  01d8b	e9 df e2 ff ff	 jmp	 $LN2@LoadRaceMo
$LN2104@LoadRaceMo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1624 :             _Throw_tree_length_error();

  01d90	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN2105@LoadRaceMo:
  01d95	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN2106@LoadRaceMo:
  01d9a	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN2016@LoadRaceMo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  01d9f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2107@LoadRaceMo:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 302  : 	static std::string stSpawnMotionFileName;

  01da4	68 00 00 00 00	 push	 OFFSET ?$TSS1@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4HA
  01da9	e8 00 00 00 00	 call	 __Init_thread_header
  01dae	83 c4 04	 add	 esp, 4
  01db1	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS1@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4HA, -1
  01db8	0f 85 e8 fc ff
	ff		 jne	 $LN3@LoadRaceMo
  01dbe	68 00 00 00 00	 push	 OFFSET ??__FstSpawnMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@YAXXZ ; `CRaceManager::__LoadRaceMotionList'::`2'::`dynamic atexit destructor for 'stSpawnMotionFileName''
  01dc3	e8 00 00 00 00	 call	 _atexit
  01dc8	68 00 00 00 00	 push	 OFFSET ?$TSS1@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4HA
  01dcd	e8 00 00 00 00	 call	 __Init_thread_footer
  01dd2	83 c4 08	 add	 esp, 8
  01dd5	e9 cc fc ff ff	 jmp	 $LN3@LoadRaceMo
$LN2108@LoadRaceMo:

; 303  : 	static std::string stMotionFileName;

  01dda	68 00 00 00 00	 push	 OFFSET ?$TSS2@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4HA
  01ddf	e8 00 00 00 00	 call	 __Init_thread_header
  01de4	83 c4 04	 add	 esp, 4
  01de7	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS2@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4HA, -1
  01dee	0f 85 c3 fc ff
	ff		 jne	 $LN4@LoadRaceMo
  01df4	68 00 00 00 00	 push	 OFFSET ??__FstMotionFileName@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@YAXXZ ; `CRaceManager::__LoadRaceMotionList'::`2'::`dynamic atexit destructor for 'stMotionFileName''
  01df9	e8 00 00 00 00	 call	 _atexit
  01dfe	68 00 00 00 00	 push	 OFFSET ?$TSS2@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4HA
  01e03	e8 00 00 00 00	 call	 __Init_thread_footer
  01e08	83 c4 08	 add	 esp, 8
  01e0b	e9 a7 fc ff ff	 jmp	 $LN4@LoadRaceMo
$LN2101@LoadRaceMo:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$1:
  00000	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T131[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$61:
  0000b	8d 8d 18 fb ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>,void *> > >
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$60:
  00016	8d 8d 18 fb ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$2:
  00021	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T130[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$74:
  0002c	8d 8d 18 fb ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>,void *> > >
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$73:
  00037	8d 8d 18 fb ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$3:
  00042	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T129[ebp]
  00048	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$87:
  0004d	8d 8d 18 fb ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00053	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long>,void *> > >
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$86:
  00058	8d 8d 18 fb ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  0005e	e9 00 00 00 00	 jmp	 ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@PAX@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$4:
  00063	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T128[ebp]
  00069	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$5:
  0006e	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T127[ebp]
  00074	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$6:
  00079	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T126[ebp]
  0007f	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$7:
  00084	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T125[ebp]
  0008a	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$8:
  0008f	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T124[ebp]
  00095	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$9:
  0009a	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T123[ebp]
  000a0	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$10:
  000a5	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T122[ebp]
  000ab	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$11:
  000b0	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T121[ebp]
  000b6	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$12:
  000bb	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T120[ebp]
  000c1	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$13:
  000c6	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T119[ebp]
  000cc	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$14:
  000d1	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T118[ebp]
  000d7	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$15:
  000dc	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T117[ebp]
  000e2	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$16:
  000e7	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T116[ebp]
  000ed	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$17:
  000f2	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T115[ebp]
  000f8	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$18:
  000fd	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T114[ebp]
  00103	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$19:
  00108	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T113[ebp]
  0010e	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$20:
  00113	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T112[ebp]
  00119	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$21:
  0011e	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T111[ebp]
  00124	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$22:
  00129	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T110[ebp]
  0012f	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$23:
  00134	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T109[ebp]
  0013a	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$24:
  0013f	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T108[ebp]
  00145	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$25:
  0014a	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T107[ebp]
  00150	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$26:
  00155	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T106[ebp]
  0015b	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$27:
  00160	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T105[ebp]
  00166	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$28:
  0016b	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T104[ebp]
  00171	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$29:
  00176	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T103[ebp]
  0017c	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$30:
  00181	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T102[ebp]
  00187	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$31:
  0018c	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T101[ebp]
  00192	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$32:
  00197	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T100[ebp]
  0019d	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$33:
  001a2	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T99[ebp]
  001a8	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$34:
  001ad	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T98[ebp]
  001b3	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$35:
  001b8	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T97[ebp]
  001be	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$36:
  001c3	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T96[ebp]
  001c9	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$37:
  001ce	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T95[ebp]
  001d4	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$38:
  001d9	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T94[ebp]
  001df	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$39:
  001e4	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T93[ebp]
  001ea	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$40:
  001ef	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T92[ebp]
  001f5	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$41:
  001fa	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T91[ebp]
  00200	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$42:
  00205	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T90[ebp]
  0020b	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$43:
  00210	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T89[ebp]
  00216	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$44:
  0021b	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T88[ebp]
  00221	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$45:
  00226	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T87[ebp]
  0022c	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$46:
  00231	8d 8d b8 fc ff
	ff		 lea	 ecx, DWORD PTR $T81[ebp]
  00237	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$47:
  0023c	8d 8d 9c fc ff
	ff		 lea	 ecx, DWORD PTR $T80[ebp]
  00242	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$48:
  00247	8d 8d 80 fc ff
	ff		 lea	 ecx, DWORD PTR $T79[ebp]
  0024d	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$49:
  00252	8d 8d 64 fc ff
	ff		 lea	 ecx, DWORD PTR $T78[ebp]
  00258	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@QAE@XZ
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$50:
  0025d	8d 8d 20 fb ff
	ff		 lea	 ecx, DWORD PTR _kMappedFile$[ebp]
  00263	e9 00 00 00 00	 jmp	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$51:
  00268	8d 8d e8 fa ff
	ff		 lea	 ecx, DWORD PTR _kTextFileLoader$[ebp]
  0026e	e9 00 00 00 00	 jmp	 ??1CMemoryTextFileLoader@@UAE@XZ ; CMemoryTextFileLoader::~CMemoryTextFileLoader
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$53:
  00273	8d 8d d8 fc ff
	ff		 lea	 ecx, DWORD PTR $T132[ebp]
  00279	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z$0:
  0027e	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z@4HA
  00283	e8 00 00 00 00	 call	 __Init_thread_abort
  00288	59		 pop	 ecx
  00289	c3		 ret	 0
  0028a	cc		 int	 3
  0028b	cc		 int	 3
  0028c	cc		 int	 3
  0028d	cc		 int	 3
  0028e	cc		 int	 3
__ehhandler$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z:
  0028f	90		 npad	 1
  00290	90		 npad	 1
  00291	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00295	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00298	8b 8a e4 fa ff
	ff		 mov	 ecx, DWORD PTR [edx-1308]
  0029e	33 c8		 xor	 ecx, eax
  002a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002a5	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  002a8	33 c8		 xor	 ecx, eax
  002aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002af	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z
  002b4	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z ENDP ; CRaceManager::__LoadRaceMotionList
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
;	COMDAT ?__LoadRaceData@CRaceManager@@IAEPAVCRaceData@@K@Z
_TEXT	SEGMENT
__Loc$2 = -648						; size = 12
__Scary$1$ = -636					; size = 4
$T3 = -632						; size = 4
tv2439 = -628						; size = 4
__Loc$4 = -624						; size = 12
_vec_stFullPathName$ = -624				; size = 12
_this$GSCopy$1$ = -612					; size = 4
_i$1$ = -608						; size = 4
$T5 = -604						; size = 4
_stMotionListFileName$6 = -600				; size = 24
_stFullPathName$7 = -576				; size = 24
_stMSMFileName$8 = -552					; size = 24
_motionListFileName$9 = -528				; size = 256
_shapeFileName$10 = -272				; size = 256
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_dwRaceIndex$ = 8					; size = 4
?__LoadRaceData@CRaceManager@@IAEPAVCRaceData@@K@Z PROC	; CRaceManager::__LoadRaceData, COMDAT
; _this$ = ecx

; 134  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?__LoadRaceData@CRaceManager@@IAEPAVCRaceData@@K@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 7c 02 00
	00		 sub	 esp, 636		; 0000027cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b c1		 mov	 eax, ecx
  00030	89 85 9c fd ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], eax

; 135  : 	std::map<DWORD, std::string>::iterator fRaceName=m_kMap_dwRaceKey_stRaceName.find(dwRaceIndex);

  00036	8d 78 14	 lea	 edi, DWORD PTR [eax+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1361 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00039	8d 45 08	 lea	 eax, DWORD PTR _dwRaceIndex$[ebp]
  0003c	8b cf		 mov	 ecx, edi
  0003e	50		 push	 eax
  0003f	8d 85 90 fd ff
	ff		 lea	 eax, DWORD PTR __Loc$4[ebp]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find_lower_bound<unsigned long>

; 1599 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0004b	8b b5 98 fd ff
	ff		 mov	 esi, DWORD PTR __Loc$4[ebp+8]
  00051	8b 5d 08	 mov	 ebx, DWORD PTR _dwRaceIndex$[ebp]
  00054	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00058	75 05		 jne	 SHORT $LN25@LoadRaceDa
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef

; 127  :         return _Left < _Right;

  0005a	3b 5e 10	 cmp	 ebx, DWORD PTR [esi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1599 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0005d	73 02		 jae	 SHORT $LN24@LoadRaceDa
$LN25@LoadRaceDa:

; 1366 :         return _Get_scary()->_Myhead;

  0005f	8b 37		 mov	 esi, DWORD PTR [edi]
$LN24@LoadRaceDa:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 136  : 	if (m_kMap_dwRaceKey_stRaceName.end()==fRaceName)

  00061	39 37		 cmp	 DWORD PTR [edi], esi
  00063	0f 84 99 00 00
	00		 je	 $LN627@LoadRaceDa

; 137  : 		return NULL;
; 138  : 
; 139  : 	const std::string & c_rstRaceName=fRaceName->second;

  00069	83 c6 14	 add	 esi, 20			; 00000014H

; 140  : 
; 141  : 	if (c_rstRaceName.empty())

  0006c	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  00070	0f 84 8c 00 00
	00		 je	 $LN627@LoadRaceDa
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00076	8b 46 14	 mov	 eax, DWORD PTR [esi+20]

; 2305 :         const value_type* _Result = _Bx._Buf;

  00079	8b ce		 mov	 ecx, esi

; 2306 :         if (_Large_string_engaged()) {

  0007b	83 f8 10	 cmp	 eax, 16			; 00000010H
  0007e	72 02		 jb	 SHORT $LN625@LoadRaceDa

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  00080	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN625@LoadRaceDa:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 145  : 	if (c_rstRaceName[0] == '#')

  00082	80 39 23	 cmp	 BYTE PTR [ecx], 35	; 00000023H
  00085	0f 85 af 00 00
	00		 jne	 $LN7@LoadRaceDa
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  0008b	83 f8 10	 cmp	 eax, 16			; 00000010H

; 2306 :         if (_Large_string_engaged()) {

  0008e	72 02		 jb	 SHORT $LN67@LoadRaceDa

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  00090	8b 36		 mov	 esi, DWORD PTR [esi]
$LN67@LoadRaceDa:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 147  : 		const char * pathName = c_rstRaceName.c_str() + 1;

  00092	8d 7e 01	 lea	 edi, DWORD PTR [esi+1]

; 148  : 		char shapeFileName[256];
; 149  : 		char motionListFileName[256];
; 150  : 		_snprintf(shapeFileName, sizeof(shapeFileName), "%sshape.msm", pathName);

  00095	57		 push	 edi
  00096	68 00 00 00 00	 push	 OFFSET ??_C@_0M@PECPBC@?$CFsshape?4msm@
  0009b	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _shapeFileName$10[ebp]
  000a1	68 00 01 00 00	 push	 256			; 00000100H
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 __snprintf

; 151  : 		_snprintf(motionListFileName, sizeof(motionListFileName), "%smotlist.txt", pathName);

  000ac	57		 push	 edi
  000ad	68 00 00 00 00	 push	 OFFSET ??_C@_0O@FJBDMFMI@?$CFsmotlist?4txt@
  000b2	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _motionListFileName$9[ebp]
  000b8	68 00 01 00 00	 push	 256			; 00000100H
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 __snprintf
  000c3	83 c4 20	 add	 esp, 32			; 00000020H

; 152  : 
; 153  : 		CRaceData * pRaceData = CRaceData::New();

  000c6	e8 00 00 00 00	 call	 ?New@CRaceData@@SAPAV1@XZ ; CRaceData::New
  000cb	8b f0		 mov	 esi, eax

; 154  : 		pRaceData->SetRace(dwRaceIndex);

  000cd	53		 push	 ebx
  000ce	8b ce		 mov	 ecx, esi
  000d0	e8 00 00 00 00	 call	 ?SetRace@CRaceData@@QAEXK@Z ; CRaceData::SetRace

; 155  : 		if (!pRaceData->LoadRaceData(shapeFileName))

  000d5	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _shapeFileName$10[ebp]
  000db	8b ce		 mov	 ecx, esi
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 ?LoadRaceData@CRaceData@@QAEHPBD@Z ; CRaceData::LoadRaceData
  000e3	85 c0		 test	 eax, eax
  000e5	75 3b		 jne	 SHORT $LN8@LoadRaceDa

; 156  : 		{
; 157  : 			TraceError("CRaceManager::RegisterRacePath(race=%u).LoadRaceData(%s)", dwRaceIndex, shapeFileName);

  000e7	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _shapeFileName$10[ebp]
  000ed	50		 push	 eax
  000ee	53		 push	 ebx
  000ef	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@FBAOJDFF@CRaceManager?3?3RegisterRacePath?$CI@
  000f4	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError

; 158  : 			CRaceData::Delete(pRaceData);

  000f9	56		 push	 esi
  000fa	e8 00 00 00 00	 call	 ?Delete@CRaceData@@SAXPAV1@@Z ; CRaceData::Delete
  000ff	83 c4 10	 add	 esp, 16			; 00000010H
$LN627@LoadRaceDa:

; 222  : }

  00102	33 c0		 xor	 eax, eax
$LN1@LoadRaceDa:
  00104	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00107	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0010e	59		 pop	 ecx
  0010f	5f		 pop	 edi
  00110	5e		 pop	 esi
  00111	5b		 pop	 ebx
  00112	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00115	33 cd		 xor	 ecx, ebp
  00117	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011c	8b e5		 mov	 esp, ebp
  0011e	5d		 pop	 ebp
  0011f	c2 04 00	 ret	 4
$LN8@LoadRaceDa:

; 159  : 			return NULL;
; 160  : 		}
; 161  : 
; 162  : 		__LoadRaceMotionList(*pRaceData, pathName, motionListFileName);

  00122	8b 8d 9c fd ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00128	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _motionListFileName$9[ebp]
  0012e	50		 push	 eax
  0012f	57		 push	 edi
  00130	56		 push	 esi
  00131	e8 00 00 00 00	 call	 ?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z ; CRaceManager::__LoadRaceMotionList

; 163  : 
; 164  : 		return pRaceData;

  00136	8b c6		 mov	 eax, esi
  00138	eb ca		 jmp	 SHORT $LN1@LoadRaceDa
$LN7@LoadRaceDa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0013a	c7 85 90 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _vec_stFullPathName$[ebp], 0
  00144	c7 85 94 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _vec_stFullPathName$[ebp+4], 0
  0014e	c7 85 98 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _vec_stFullPathName$[ebp+8], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 168  : 	__GetRaceResourcePathes(dwRaceIndex, vec_stFullPathName);

  00158	8d 85 90 fd ff
	ff		 lea	 eax, DWORD PTR _vec_stFullPathName$[ebp]
  0015e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00165	50		 push	 eax
  00166	53		 push	 ebx
  00167	e8 00 00 00 00	 call	 ?__GetRaceResourcePathes@@YAXIAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; __GetRaceResourcePathes
  0016c	83 c4 08	 add	 esp, 8

; 169  : 
; 170  : 	CRaceData * pRaceData = CRaceData::New();

  0016f	e8 00 00 00 00	 call	 ?New@CRaceData@@SAPAV1@XZ ; CRaceData::New

; 171  : 	pRaceData->SetRace(dwRaceIndex);

  00174	53		 push	 ebx
  00175	8b c8		 mov	 ecx, eax
  00177	89 85 a4 fd ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
  0017d	e8 00 00 00 00	 call	 ?SetRace@CRaceData@@QAEXK@Z ; CRaceData::SetRace
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00182	8b 8d 94 fd ff
	ff		 mov	 ecx, DWORD PTR _vec_stFullPathName$[ebp+4]
  00188	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0018d	8b bd 90 fd ff
	ff		 mov	 edi, DWORD PTR _vec_stFullPathName$[ebp]
  00193	2b cf		 sub	 ecx, edi
  00195	f7 e9		 imul	 ecx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 173  : 	for (int i = 0; i < vec_stFullPathName.size(); i++)

  00197	c7 85 a0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$1$[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  001a1	c1 fa 02	 sar	 edx, 2
  001a4	8b c2		 mov	 eax, edx
  001a6	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001a9	03 c2		 add	 eax, edx
  001ab	89 85 88 fd ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 173  : 	for (int i = 0; i < vec_stFullPathName.size(); i++)

  001b1	0f 84 a3 02 00
	00		 je	 $LN3@LoadRaceDa
  001b7	8b 9d 9c fd ff
	ff		 mov	 ebx, DWORD PTR _this$GSCopy$1$[ebp]
  001bd	8b c7		 mov	 eax, edi
  001bf	83 c3 0c	 add	 ebx, 12			; 0000000cH
  001c2	89 bd 8c fd ff
	ff		 mov	 DWORD PTR tv2439[ebp], edi
  001c8	89 9d 84 fd ff
	ff		 mov	 DWORD PTR __Scary$1$[ebp], ebx
  001ce	66 90		 npad	 2
$LL4@LoadRaceDa:

; 175  : 		std::string stFullPathName = vec_stFullPathName[i];

  001d0	50		 push	 eax
  001d1	8d 8d c0 fd ff
	ff		 lea	 ecx, DWORD PTR _stFullPathName$7[ebp]
  001d7	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1361 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  001dc	56		 push	 esi
  001dd	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR __Loc$2[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 175  : 		std::string stFullPathName = vec_stFullPathName[i];

  001e3	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1361 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  001e7	50		 push	 eax
  001e8	8b cb		 mov	 ecx, ebx
  001ea	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 1599 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  001ef	8b bd 80 fd ff
	ff		 mov	 edi, DWORD PTR __Loc$2[ebp+8]
  001f5	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  001f9	75 11		 jne	 SHORT $LN84@LoadRaceDa
  001fb	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef

; 127  :         return _Left < _Right;

  001fe	50		 push	 eax
  001ff	56		 push	 esi
  00200	e8 00 00 00 00	 call	 ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
  00205	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1599 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00208	84 c0		 test	 al, al
  0020a	74 02		 je	 SHORT $LN83@LoadRaceDa
$LN84@LoadRaceDa:

; 1366 :         return _Get_scary()->_Myhead;

  0020c	8b 3b		 mov	 edi, DWORD PTR [ebx]
$LN83@LoadRaceDa:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 178  : 			if (m_kMap_stRaceName_stSrcName.end()==fRaceSrcName)

  0020e	39 3b		 cmp	 DWORD PTR [ebx], edi
  00210	75 0f		 jne	 SHORT $LN9@LoadRaceDa
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2306 :         if (_Large_string_engaged()) {

  00212	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00216	8b c6		 mov	 eax, esi
  00218	72 02		 jb	 SHORT $LN626@LoadRaceDa

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  0021a	8b 06		 mov	 eax, DWORD PTR [esi]
$LN626@LoadRaceDa:

; 3124 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0021c	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 179  : 				stFullPathName+=c_rstRaceName;

  0021f	eb 0f		 jmp	 SHORT $LN10@LoadRaceDa
$LN9@LoadRaceDa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2306 :         if (_Large_string_engaged()) {

  00221	83 7f 3c 10	 cmp	 DWORD PTR [edi+60], 16	; 00000010H
  00225	8d 47 28	 lea	 eax, DWORD PTR [edi+40]
  00228	72 03		 jb	 SHORT $LN128@LoadRaceDa

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  0022a	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
$LN128@LoadRaceDa:

; 3124 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0022d	8b 4f 38	 mov	 ecx, DWORD PTR [edi+56]
$LN10@LoadRaceDa:

; 3175 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00230	51		 push	 ecx
  00231	50		 push	 eax
  00232	8d 8d c0 fd ff
	ff		 lea	 ecx, DWORD PTR _stFullPathName$7[ebp]
  00238	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0023d	6a 01		 push	 1
  0023f	68 00 00 00 00	 push	 OFFSET ??_C@_01KMDKNFGN@?1@
  00244	8d 8d c0 fd ff
	ff		 lea	 ecx, DWORD PTR _stFullPathName$7[ebp]
  0024a	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 186  : 		string stMSMFileName=stFullPathName;

  0024f	8d 85 c0 fd ff
	ff		 lea	 eax, DWORD PTR _stFullPathName$7[ebp]
  00255	50		 push	 eax
  00256	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR _stMSMFileName$8[ebp]
  0025c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2297 :         if (_Large_string_engaged()) {

  00261	8b 9d d4 fd ff
	ff		 mov	 ebx, DWORD PTR _stFullPathName$7[ebp+20]
  00267	8d 85 c0 fd ff
	ff		 lea	 eax, DWORD PTR _stFullPathName$7[ebp]
  0026d	8b bd c0 fd ff
	ff		 mov	 edi, DWORD PTR _stFullPathName$7[ebp]
  00273	83 fb 10	 cmp	 ebx, 16			; 00000010H
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 186  : 		string stMSMFileName=stFullPathName;

  00276	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2297 :         if (_Large_string_engaged()) {

  0027a	0f 43 c7	 cmovae	 eax, edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 187  : 		if (stFullPathName[0] == '#') // @fixme021 #season reads shape.msm only

  0027d	80 38 23	 cmp	 BYTE PTR [eax], 35	; 00000023H
  00280	0f 85 8b 00 00
	00		 jne	 $LN11@LoadRaceDa
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3175 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00286	6a 09		 push	 9
  00288	68 00 00 00 00	 push	 OFFSET ??_C@_09HPPJBJBB@shape?4msm@
  0028d	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR _stMSMFileName$8[ebp]
  00293	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2342 :         return (_STD min)(_Size, _Mysize - _Off);

  00298	8b 85 d0 fd ff
	ff		 mov	 eax, DWORD PTR _stFullPathName$7[ebp+16]

; 2296 :         value_type* _Result = _Bx._Buf;

  0029e	8d 8d c0 fd ff
	ff		 lea	 ecx, DWORD PTR _stFullPathName$7[ebp]

; 2342 :         return (_STD min)(_Size, _Mysize - _Off);

  002a4	ba 01 00 00 00	 mov	 edx, 1
  002a9	3b c2		 cmp	 eax, edx
  002ab	0f 42 d0	 cmovb	 edx, eax

; 2297 :         if (_Large_string_engaged()) {

  002ae	83 fb 10	 cmp	 ebx, 16			; 00000010H
  002b1	0f 43 cf	 cmovae	 ecx, edi

; 3465 :         const size_type _New_size = _Old_size - _Count;

  002b4	2b c2		 sub	 eax, edx

; 3466 :         _Mypair._Myval2._Mysize   = _New_size;

  002b6	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _stFullPathName$7[ebp+16], eax

; 3467 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  002bc	40		 inc	 eax

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  002bd	50		 push	 eax

; 3467 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  002be	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  002c1	50		 push	 eax
  002c2	51		 push	 ecx
  002c3	e8 00 00 00 00	 call	 _memmove

; 2342 :         return (_STD min)(_Size, _Mysize - _Off);

  002c8	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _stMSMFileName$8[ebp+16]

; 2296 :         value_type* _Result = _Bx._Buf;

  002ce	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR _stMSMFileName$8[ebp]

; 2342 :         return (_STD min)(_Size, _Mysize - _Off);

  002d4	ba 01 00 00 00	 mov	 edx, 1
  002d9	3b c2		 cmp	 eax, edx
  002db	0f 42 d0	 cmovb	 edx, eax

; 2297 :         if (_Large_string_engaged()) {

  002de	83 bd ec fd ff
	ff 10		 cmp	 DWORD PTR _stMSMFileName$8[ebp+20], 16 ; 00000010H
  002e5	0f 43 8d d8 fd
	ff ff		 cmovae	 ecx, DWORD PTR _stMSMFileName$8[ebp]

; 3465 :         const size_type _New_size = _Old_size - _Count;

  002ec	2b c2		 sub	 eax, edx

; 3466 :         _Mypair._Myval2._Mysize   = _New_size;

  002ee	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _stMSMFileName$8[ebp+16], eax

; 3467 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  002f4	40		 inc	 eax

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  002f5	50		 push	 eax

; 3467 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  002f6	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  002f9	50		 push	 eax
  002fa	51		 push	 ecx
  002fb	e8 00 00 00 00	 call	 _memmove
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 192  : 		}

  00300	8b 9d d4 fd ff
	ff		 mov	 ebx, DWORD PTR _stFullPathName$7[ebp+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00306	83 c4 18	 add	 esp, 24			; 00000018H
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 192  : 		}

  00309	8b bd c0 fd ff
	ff		 mov	 edi, DWORD PTR _stFullPathName$7[ebp]
  0030f	eb 2b		 jmp	 SHORT $LN12@LoadRaceDa
$LN11@LoadRaceDa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2306 :         if (_Large_string_engaged()) {

  00311	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00315	8b c6		 mov	 eax, esi
  00317	72 02		 jb	 SHORT $LN195@LoadRaceDa

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  00319	8b 06		 mov	 eax, DWORD PTR [esi]
$LN195@LoadRaceDa:

; 3124 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0031b	ff 76 10	 push	 DWORD PTR [esi+16]
  0031e	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR _stMSMFileName$8[ebp]
  00324	50		 push	 eax
  00325	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 3175 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0032a	6a 04		 push	 4
  0032c	68 00 00 00 00	 push	 OFFSET ??_C@_04IIEHFLK@?4msm@
  00331	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR _stMSMFileName$8[ebp]
  00337	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN12@LoadRaceDa:

; 2306 :         if (_Large_string_engaged()) {

  0033c	83 bd ec fd ff
	ff 10		 cmp	 DWORD PTR _stMSMFileName$8[ebp+20], 16 ; 00000010H
  00343	8d 85 d8 fd ff
	ff		 lea	 eax, DWORD PTR _stMSMFileName$8[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 199  : 		if (!pRaceData->LoadRaceData(stMSMFileName.c_str()))

  00349	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2306 :         if (_Large_string_engaged()) {

  0034f	0f 43 85 d8 fd
	ff ff		 cmovae	 eax, DWORD PTR _stMSMFileName$8[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 199  : 		if (!pRaceData->LoadRaceData(stMSMFileName.c_str()))

  00356	50		 push	 eax
  00357	e8 00 00 00 00	 call	 ?LoadRaceData@CRaceData@@QAEHPBD@Z ; CRaceData::LoadRaceData
  0035c	85 c0		 test	 eax, eax
  0035e	0f 85 f9 01 00
	00		 jne	 $LN13@LoadRaceDa

; 200  : 		{
; 201  : 			if (i != vec_stFullPathName.size() - 1)

  00364	8b 85 88 fd ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  0036a	48		 dec	 eax
  0036b	39 85 a0 fd ff
	ff		 cmp	 DWORD PTR _i$1$[ebp], eax
  00371	8d 85 d8 fd ff
	ff		 lea	 eax, DWORD PTR _stMSMFileName$8[ebp]
  00377	0f 84 a9 01 00
	00		 je	 $LN14@LoadRaceDa
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2306 :         if (_Large_string_engaged()) {

  0037d	83 bd ec fd ff
	ff 10		 cmp	 DWORD PTR _stMSMFileName$8[ebp+20], 16 ; 00000010H
  00384	0f 43 85 d8 fd
	ff ff		 cmovae	 eax, DWORD PTR _stMSMFileName$8[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 203  : 				Tracenf("CRaceManager::RegisterRacePath : RACE[%u] LOAD MSMFILE[%s] ERROR. Will Find Another Path.", dwRaceIndex, stMSMFileName.c_str()); // @warme668

  0038b	50		 push	 eax
  0038c	ff 75 08	 push	 DWORD PTR _dwRaceIndex$[ebp]
  0038f	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@NGFDIHNH@CRaceManager?3?3RegisterRacePath?5@
  00394	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00399	8b 95 ec fd ff
	ff		 mov	 edx, DWORD PTR _stMSMFileName$8[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 203  : 				Tracenf("CRaceManager::RegisterRacePath : RACE[%u] LOAD MSMFILE[%s] ERROR. Will Find Another Path.", dwRaceIndex, stMSMFileName.c_str()); // @warme668

  0039f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 204  : 				continue;

  003a2	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  003a6	83 fa 10	 cmp	 edx, 16			; 00000010H
  003a9	72 2f		 jb	 SHORT $LN233@LoadRaceDa
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003ab	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _stMSMFileName$8[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  003b1	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003b2	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  003b4	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  003ba	72 14		 jb	 SHORT $LN243@LoadRaceDa

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  003bc	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  003bf	83 c2 23	 add	 edx, 35			; 00000023H
  003c2	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003c4	83 c0 fc	 add	 eax, -4			; fffffffcH
  003c7	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  003ca	0f 87 b8 02 00
	00		 ja	 $LN469@LoadRaceDa
$LN243@LoadRaceDa:

; 264  :         ::operator delete(_Ptr, _Bytes);

  003d0	52		 push	 edx
  003d1	51		 push	 ecx
  003d2	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  003d7	83 c4 08	 add	 esp, 8
$LN233@LoadRaceDa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  003da	c7 85 e8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _stMSMFileName$8[ebp+16], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  003e4	c7 85 ec fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR _stMSMFileName$8[ebp+20], 15 ; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  003ee	c6 85 d8 fd ff
	ff 00		 mov	 BYTE PTR _stMSMFileName$8[ebp], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 204  : 				continue;

  003f5	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  003f9	83 fb 10	 cmp	 ebx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  003fc	72 2b		 jb	 SHORT $LN260@LoadRaceDa

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  003fe	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00401	8b c7		 mov	 eax, edi

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00403	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00409	72 14		 jb	 SHORT $LN270@LoadRaceDa

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0040b	8b 7f fc	 mov	 edi, DWORD PTR [edi-4]
  0040e	83 c1 23	 add	 ecx, 35			; 00000023H
  00411	2b c7		 sub	 eax, edi

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00413	83 c0 fc	 add	 eax, -4			; fffffffcH
  00416	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00419	0f 87 69 02 00
	00		 ja	 $LN469@LoadRaceDa
$LN270@LoadRaceDa:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0041f	51		 push	 ecx
  00420	57		 push	 edi
  00421	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00426	83 c4 08	 add	 esp, 8
$LN260@LoadRaceDa:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 173  : 	for (int i = 0; i < vec_stFullPathName.size(); i++)

  00429	8b 9d a0 fd ff
	ff		 mov	 ebx, DWORD PTR _i$1$[ebp]
  0042f	8b 85 8c fd ff
	ff		 mov	 eax, DWORD PTR tv2439[ebp]
  00435	43		 inc	 ebx
  00436	83 c0 18	 add	 eax, 24			; 00000018H
  00439	89 9d a0 fd ff
	ff		 mov	 DWORD PTR _i$1$[ebp], ebx
  0043f	3b 9d 88 fd ff
	ff		 cmp	 ebx, DWORD PTR $T3[ebp]
  00445	8b 9d 84 fd ff
	ff		 mov	 ebx, DWORD PTR __Scary$1$[ebp]
  0044b	89 85 8c fd ff
	ff		 mov	 DWORD PTR tv2439[ebp], eax
  00451	0f 82 79 fd ff
	ff		 jb	 $LL4@LoadRaceDa
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2324 :         if (_Mysize < _Off) {

  00457	8b 5d 08	 mov	 ebx, DWORD PTR _dwRaceIndex$[ebp]
$LN3@LoadRaceDa:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 219  : 	TraceError("CRaceManager::RegisterRacePath : RACE[%u] HAVE NO PATH ERROR", dwRaceIndex);

  0045a	53		 push	 ebx
  0045b	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@CNIFOKKO@CRaceManager?3?3RegisterRacePath?5@
  00460	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError

; 220  : 	CRaceData::Delete(pRaceData);

  00465	ff b5 a4 fd ff
	ff		 push	 DWORD PTR $T5[ebp]
  0046b	e8 00 00 00 00	 call	 ?Delete@CRaceData@@SAXPAV1@@Z ; CRaceData::Delete
  00470	83 c4 0c	 add	 esp, 12			; 0000000cH

; 221  : 	return NULL;

  00473	33 f6		 xor	 esi, esi
  00475	89 b5 a4 fd ff
	ff		 mov	 DWORD PTR $T5[ebp], esi
$LN21@LoadRaceDa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  0047b	8b 9d 90 fd ff
	ff		 mov	 ebx, DWORD PTR _vec_stFullPathName$[ebp]
  00481	85 db		 test	 ebx, ebx
  00483	0f 84 f3 01 00
	00		 je	 $LN547@LoadRaceDa

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00489	8b bd 94 fd ff
	ff		 mov	 edi, DWORD PTR _vec_stFullPathName$[ebp+4]
  0048f	8b f3		 mov	 esi, ebx
  00491	3b f7		 cmp	 esi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 949  :         for (; _First != _Last; ++_First) {

  00493	74 4b		 je	 SHORT $LN553@LoadRaceDa
$LL554@LoadRaceDa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00495	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00498	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0049b	72 2b		 jb	 SHORT $LN573@LoadRaceDa
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0049d	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0049f	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  004a0	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  004a6	72 16		 jb	 SHORT $LN583@LoadRaceDa

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  004a8	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  004ab	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  004ae	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  004b0	83 c0 fc	 add	 eax, -4			; fffffffcH
  004b3	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  004b6	0f 87 c7 01 00
	00		 ja	 $LN604@LoadRaceDa

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  004bc	8b c2		 mov	 eax, edx
$LN583@LoadRaceDa:

; 264  :         ::operator delete(_Ptr, _Bytes);

  004be	51		 push	 ecx
  004bf	50		 push	 eax
  004c0	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  004c5	83 c4 08	 add	 esp, 8
$LN573@LoadRaceDa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  004c8	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  004cf	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  004d6	c6 06 00	 mov	 BYTE PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 949  :         for (; _First != _Last; ++_First) {

  004d9	83 c6 18	 add	 esi, 24			; 00000018H
  004dc	3b f7		 cmp	 esi, edi
  004de	75 b5		 jne	 SHORT $LL554@LoadRaceDa
$LN553@LoadRaceDa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  004e0	8b 8d 98 fd ff
	ff		 mov	 ecx, DWORD PTR _vec_stFullPathName$[ebp+8]
  004e6	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  004eb	2b cb		 sub	 ecx, ebx
  004ed	f7 e9		 imul	 ecx
  004ef	c1 fa 02	 sar	 edx, 2
  004f2	8b c2		 mov	 eax, edx
  004f4	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  004f7	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  004f9	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  004fc	8b c3		 mov	 eax, ebx
  004fe	c1 e1 03	 shl	 ecx, 3

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00501	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00507	0f 82 5f 01 00
	00		 jb	 $LN607@LoadRaceDa

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0050d	8b 5b fc	 mov	 ebx, DWORD PTR [ebx-4]
  00510	83 c1 23	 add	 ecx, 35			; 00000023H
  00513	2b c3		 sub	 eax, ebx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00515	83 c0 fc	 add	 eax, -4			; fffffffcH
  00518	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0051b	0f 87 62 01 00
	00		 ja	 $LN604@LoadRaceDa
  00521	e9 46 01 00 00	 jmp	 $LN607@LoadRaceDa
$LN14@LoadRaceDa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00526	83 bd ec fd ff
	ff 10		 cmp	 DWORD PTR _stMSMFileName$8[ebp+20], 16 ; 00000010H

; 2306 :         if (_Large_string_engaged()) {

  0052d	0f 43 85 d8 fd
	ff ff		 cmovae	 eax, DWORD PTR _stMSMFileName$8[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 207  : 			TraceError("CRaceManager::RegisterRacePath : RACE[%u] LOAD MSMFILE[%s] ERROR", dwRaceIndex, stMSMFileName.c_str());

  00534	50		 push	 eax
  00535	ff 75 08	 push	 DWORD PTR _dwRaceIndex$[ebp]
  00538	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@IDBEOJF@CRaceManager?3?3RegisterRacePath?5@
  0053d	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError

; 208  : 			CRaceData::Delete(pRaceData);

  00542	ff b5 a4 fd ff
	ff		 push	 DWORD PTR $T5[ebp]
  00548	e8 00 00 00 00	 call	 ?Delete@CRaceData@@SAXPAV1@@Z ; CRaceData::Delete
  0054d	83 c4 10	 add	 esp, 16			; 00000010H
  00550	33 f6		 xor	 esi, esi
  00552	89 b5 a4 fd ff
	ff		 mov	 DWORD PTR $T5[ebp], esi
  00558	e9 8b 00 00 00	 jmp	 $LN20@LoadRaceDa
$LN13@LoadRaceDa:

; 209  : 			return NULL;
; 210  : 		}
; 211  : 
; 212  : 		std::string stMotionListFileName=stFullPathName;

  0055d	8d 85 c0 fd ff
	ff		 lea	 eax, DWORD PTR _stFullPathName$7[ebp]
  00563	50		 push	 eax
  00564	8d 8d a8 fd ff
	ff		 lea	 ecx, DWORD PTR _stMotionListFileName$6[ebp]
  0056a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 213  : 		stMotionListFileName+=pRaceData->GetMotionListFileName();

  0056f	8b b5 a4 fd ff
	ff		 mov	 esi, DWORD PTR $T5[ebp]
  00575	8b ce		 mov	 ecx, esi
  00577	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0057b	e8 00 00 00 00	 call	 ?GetMotionListFileName@CRaceData@@QBEPBDXZ ; CRaceData::GetMotionListFileName
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00580	8b d0		 mov	 edx, eax
  00582	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL628@LoadRaceDa:
  00585	8a 0a		 mov	 cl, BYTE PTR [edx]
  00587	42		 inc	 edx
  00588	84 c9		 test	 cl, cl
  0058a	75 f9		 jne	 SHORT $LL628@LoadRaceDa
  0058c	2b d7		 sub	 edx, edi

; 3175 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0058e	8d 8d a8 fd ff
	ff		 lea	 ecx, DWORD PTR _stMotionListFileName$6[ebp]
  00594	52		 push	 edx
  00595	50		 push	 eax
  00596	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2319 :         return _BUF_SIZE <= _Myres;

  0059b	83 bd bc fd ff
	ff 10		 cmp	 DWORD PTR _stMotionListFileName$6[ebp+20], 16 ; 00000010H

; 2305 :         const value_type* _Result = _Bx._Buf;

  005a2	8d 8d a8 fd ff
	ff		 lea	 ecx, DWORD PTR _stMotionListFileName$6[ebp]
  005a8	8d 85 c0 fd ff
	ff		 lea	 eax, DWORD PTR _stFullPathName$7[ebp]

; 2306 :         if (_Large_string_engaged()) {

  005ae	0f 43 8d a8 fd
	ff ff		 cmovae	 ecx, DWORD PTR _stMotionListFileName$6[ebp]

; 2319 :         return _BUF_SIZE <= _Myres;

  005b5	83 bd d4 fd ff
	ff 10		 cmp	 DWORD PTR _stFullPathName$7[ebp+20], 16 ; 00000010H
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 215  : 		__LoadRaceMotionList(*pRaceData, stFullPathName.c_str(), stMotionListFileName.c_str());

  005bc	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2306 :         if (_Large_string_engaged()) {

  005bd	0f 43 85 c0 fd
	ff ff		 cmovae	 eax, DWORD PTR _stFullPathName$7[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 215  : 		__LoadRaceMotionList(*pRaceData, stFullPathName.c_str(), stMotionListFileName.c_str());

  005c4	8b 8d 9c fd ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  005ca	50		 push	 eax
  005cb	56		 push	 esi
  005cc	e8 00 00 00 00	 call	 ?__LoadRaceMotionList@CRaceManager@@IAE_NAAVCRaceData@@PBD1@Z ; CRaceManager::__LoadRaceMotionList

; 216  : 
; 217  : 		return pRaceData;

  005d1	8d 8d a8 fd ff
	ff		 lea	 ecx, DWORD PTR _stMotionListFileName$6[ebp]
  005d7	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  005dc	8b 9d d4 fd ff
	ff		 mov	 ebx, DWORD PTR _stFullPathName$7[ebp+20]
  005e2	8b bd c0 fd ff
	ff		 mov	 edi, DWORD PTR _stFullPathName$7[ebp]
$LN20@LoadRaceDa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  005e8	8b 95 ec fd ff
	ff		 mov	 edx, DWORD PTR _stMSMFileName$8[ebp+20]
  005ee	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  005f1	72 2b		 jb	 SHORT $LN435@LoadRaceDa
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  005f3	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _stMSMFileName$8[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  005f9	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  005fa	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  005fc	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00602	72 10		 jb	 SHORT $LN445@LoadRaceDa

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00604	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00607	83 c2 23	 add	 edx, 35			; 00000023H
  0060a	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0060c	83 c0 fc	 add	 eax, -4			; fffffffcH
  0060f	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00612	77 74		 ja	 SHORT $LN469@LoadRaceDa
$LN445@LoadRaceDa:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00614	52		 push	 edx
  00615	51		 push	 ecx
  00616	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0061b	83 c4 08	 add	 esp, 8
$LN435@LoadRaceDa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  0061e	c7 85 e8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _stMSMFileName$8[ebp+16], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00628	c7 85 ec fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR _stMSMFileName$8[ebp+20], 15 ; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00632	c6 85 d8 fd ff
	ff 00		 mov	 BYTE PTR _stMSMFileName$8[ebp], 0

; 2319 :         return _BUF_SIZE <= _Myres;

  00639	83 fb 10	 cmp	 ebx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0063c	0f 82 39 fe ff
	ff		 jb	 $LN21@LoadRaceDa

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00642	43		 inc	 ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00643	8b c7		 mov	 eax, edi

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00645	81 fb 00 10 00
	00		 cmp	 ebx, 4096		; 00001000H
  0064b	72 10		 jb	 SHORT $LN472@LoadRaceDa

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0064d	8b 7f fc	 mov	 edi, DWORD PTR [edi-4]
  00650	83 c3 23	 add	 ebx, 35			; 00000023H
  00653	2b c7		 sub	 eax, edi

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00655	83 c0 fc	 add	 eax, -4			; fffffffcH
  00658	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0065b	77 2b		 ja	 SHORT $LN469@LoadRaceDa
$LN472@LoadRaceDa:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0065d	53		 push	 ebx
  0065e	57		 push	 edi
  0065f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00664	83 c4 08	 add	 esp, 8
  00667	e9 0f fe ff ff	 jmp	 $LN21@LoadRaceDa
$LN607@LoadRaceDa:
  0066c	51		 push	 ecx
  0066d	53		 push	 ebx
  0066e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00673	8b b5 a4 fd ff
	ff		 mov	 esi, DWORD PTR $T5[ebp]
  00679	83 c4 08	 add	 esp, 8
$LN547@LoadRaceDa:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 221  : 	return NULL;

  0067c	8b c6		 mov	 eax, esi
  0067e	e9 81 fa ff ff	 jmp	 $LN1@LoadRaceDa
$LN604@LoadRaceDa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00683	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN469@LoadRaceDa:
  00688	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN631@LoadRaceDa:
  0068d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__LoadRaceData@CRaceManager@@IAEPAVCRaceData@@K@Z$0:
  00000	8d 8d 90 fd ff
	ff		 lea	 ecx, DWORD PTR _vec_stFullPathName$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?__LoadRaceData@CRaceManager@@IAEPAVCRaceData@@K@Z$1:
  0000b	8d 8d c0 fd ff
	ff		 lea	 ecx, DWORD PTR _stFullPathName$7[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__LoadRaceData@CRaceManager@@IAEPAVCRaceData@@K@Z$2:
  00016	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR _stMSMFileName$8[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__LoadRaceData@CRaceManager@@IAEPAVCRaceData@@K@Z$3:
  00021	8d 8d a8 fd ff
	ff		 lea	 ecx, DWORD PTR _stMotionListFileName$6[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002c	cc		 int	 3
  0002d	cc		 int	 3
  0002e	cc		 int	 3
  0002f	cc		 int	 3
  00030	cc		 int	 3
__ehhandler$?__LoadRaceData@CRaceManager@@IAEPAVCRaceData@@K@Z:
  00031	90		 npad	 1
  00032	90		 npad	 1
  00033	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00037	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003a	8b 8a 74 fd ff
	ff		 mov	 ecx, DWORD PTR [edx-652]
  00040	33 c8		 xor	 ecx, eax
  00042	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00047	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0004a	33 c8		 xor	 ecx, eax
  0004c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00051	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__LoadRaceData@CRaceManager@@IAEPAVCRaceData@@K@Z
  00056	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__LoadRaceData@CRaceManager@@IAEPAVCRaceData@@K@Z ENDP	; CRaceManager::__LoadRaceData
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
;	COMDAT ?GetRaceDataPointer@CRaceManager@@QAEHKPAPAVCRaceData@@@Z
_TEXT	SEGMENT
__Loc$1 = -20						; size = 12
$T2 = -16						; size = 8
$T3 = -8						; size = 8
_dwRaceIndex$ = 8					; size = 4
_ppRaceData$ = 12					; size = 4
?GetRaceDataPointer@CRaceManager@@QAEHKPAPAVCRaceData@@@Z PROC ; CRaceManager::GetRaceDataPointer, COMDAT
; _this$ = ecx

; 413  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1361 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  0000b	8d 45 08	 lea	 eax, DWORD PTR _dwRaceIndex$[ebp]
  0000e	50		 push	 eax
  0000f	8d 45 ec	 lea	 eax, DWORD PTR __Loc$1[ebp]
  00012	50		 push	 eax
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 414  : 	TRaceDataIterator itor = m_RaceDataMap.find(dwRaceIndex);

  00013	8d 5f 04	 lea	 ebx, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1361 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00016	8b cb		 mov	 ecx, ebx
  00018	e8 00 00 00 00	 call	 ??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@1@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CRaceData *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRaceData *> >,0> >::_Find_lower_bound<unsigned long>

; 1599 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0001d	8b 4d f4	 mov	 ecx, DWORD PTR __Loc$1[ebp+8]
  00020	8b 75 08	 mov	 esi, DWORD PTR _dwRaceIndex$[ebp]
  00023	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00027	75 1f		 jne	 SHORT $LN41@GetRaceDat
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef

; 127  :         return _Left < _Right;

  00029	3b 71 10	 cmp	 esi, DWORD PTR [ecx+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1599 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0002c	72 1a		 jb	 SHORT $LN41@GetRaceDat

; 236  :         return this->_Ptr == _Right._Ptr;

  0002e	39 0b		 cmp	 DWORD PTR [ebx], ecx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 416  : 	if (m_RaceDataMap.end() == itor)

  00030	74 16		 je	 SHORT $LN41@GetRaceDat

; 429  : 	}
; 430  : 
; 431  : 	*ppRaceData = itor->second;

  00032	8b 45 0c	 mov	 eax, DWORD PTR _ppRaceData$[ebp]
  00035	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00038	5f		 pop	 edi

; 432  : 	return TRUE;
; 433  : }

  00039	5e		 pop	 esi
  0003a	89 08		 mov	 DWORD PTR [eax], ecx
  0003c	b8 01 00 00 00	 mov	 eax, 1
  00041	5b		 pop	 ebx
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 08 00	 ret	 8
$LN41@GetRaceDat:

; 417  : 	{
; 418  : 		CRaceData * pRaceData = __LoadRaceData(dwRaceIndex);

  00048	56		 push	 esi
  00049	8b cf		 mov	 ecx, edi
  0004b	e8 00 00 00 00	 call	 ?__LoadRaceData@CRaceManager@@IAEPAVCRaceData@@K@Z ; CRaceManager::__LoadRaceData
  00050	8b f8		 mov	 edi, eax

; 419  : 
; 420  : 		if (pRaceData)

  00052	85 ff		 test	 edi, edi
  00054	74 28		 je	 SHORT $LN3@GetRaceDat

; 422  : 			m_RaceDataMap.insert(TRaceDataMap::value_type(dwRaceIndex, pRaceData));

  00056	8d 45 f8	 lea	 eax, DWORD PTR $T3[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00059	89 75 f8	 mov	 DWORD PTR $T3[ebp], esi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 422  : 			m_RaceDataMap.insert(TRaceDataMap::value_type(dwRaceIndex, pRaceData));

  0005c	50		 push	 eax
  0005d	8d 45 f0	 lea	 eax, DWORD PTR $T2[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00060	89 7d fc	 mov	 DWORD PTR $T3[ebp+4], edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 422  : 			m_RaceDataMap.insert(TRaceDataMap::value_type(dwRaceIndex, pRaceData));

  00063	50		 push	 eax
  00064	8b cb		 mov	 ecx, ebx
  00066	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCRaceData@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBKPAVCRaceData@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CRaceData *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRaceData *> >,0> >::insert<0,0>

; 423  : 			*ppRaceData = pRaceData;

  0006b	8b 45 0c	 mov	 eax, DWORD PTR _ppRaceData$[ebp]
  0006e	89 38		 mov	 DWORD PTR [eax], edi

; 424  : 			return TRUE;

  00070	b8 01 00 00 00	 mov	 eax, 1
  00075	5f		 pop	 edi

; 432  : 	return TRUE;
; 433  : }

  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 08 00	 ret	 8
$LN3@GetRaceDat:

; 425  : 		}
; 426  : 
; 427  : 		TraceError("CRaceManager::GetRaceDataPointer: cannot load data by dwRaceIndex %lu", dwRaceIndex);

  0007e	56		 push	 esi
  0007f	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@LLEJKJIA@CRaceManager?3?3GetRaceDataPointe@
  00084	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00089	83 c4 08	 add	 esp, 8

; 428  : 		return FALSE;

  0008c	33 c0		 xor	 eax, eax
  0008e	5f		 pop	 edi

; 432  : 	return TRUE;
; 433  : }

  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 08 00	 ret	 8
?GetRaceDataPointer@CRaceManager@@QAEHKPAPAVCRaceData@@@Z ENDP ; CRaceManager::GetRaceDataPointer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
;	COMDAT ?GetSelectedRaceDataPointer@CRaceManager@@QAEPAVCRaceData@@XZ
_TEXT	SEGMENT
?GetSelectedRaceDataPointer@CRaceManager@@QAEPAVCRaceData@@XZ PROC ; CRaceManager::GetSelectedRaceDataPointer, COMDAT
; _this$ = ecx

; 409  : 	return m_pSelectedRaceData;

  00000	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]

; 410  : }

  00003	c3		 ret	 0
?GetSelectedRaceDataPointer@CRaceManager@@QAEPAVCRaceData@@XZ ENDP ; CRaceManager::GetSelectedRaceDataPointer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
;	COMDAT ?SelectRace@CRaceManager@@QAEXK@Z
_TEXT	SEGMENT
__Loc$1 = -12						; size = 12
_dwRaceIndex$ = 8					; size = 4
?SelectRace@CRaceManager@@QAEXK@Z PROC			; CRaceManager::SelectRace, COMDAT
; _this$ = ecx

; 396  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1361 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  0000a	8d 45 08	 lea	 eax, DWORD PTR _dwRaceIndex$[ebp]
  0000d	50		 push	 eax
  0000e	8d 45 f4	 lea	 eax, DWORD PTR __Loc$1[ebp]
  00011	50		 push	 eax
  00012	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00015	e8 00 00 00 00	 call	 ??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@1@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CRaceData *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRaceData *> >,0> >::_Find_lower_bound<unsigned long>

; 1599 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR __Loc$1[ebp+8]
  0001d	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00021	75 13		 jne	 SHORT $LN1@SelectRace
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef

; 127  :         return _Left < _Right;

  00023	8b 45 08	 mov	 eax, DWORD PTR _dwRaceIndex$[ebp]
  00026	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1599 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00029	72 0b		 jb	 SHORT $LN1@SelectRace

; 236  :         return this->_Ptr == _Right._Ptr;

  0002b	39 4e 04	 cmp	 DWORD PTR [esi+4], ecx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 398  : 	if (m_RaceDataMap.end() == itor)

  0002e	74 06		 je	 SHORT $LN1@SelectRace

; 399  : 	{
; 400  : 		assert(!"Failed to select race data!");
; 401  : 		return;
; 402  : 	}
; 403  : 
; 404  : 	m_pSelectedRaceData = itor->second;

  00030	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00033	89 46 34	 mov	 DWORD PTR [esi+52], eax
$LN1@SelectRace:

; 405  : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
?SelectRace@CRaceManager@@QAEXK@Z ENDP			; CRaceManager::SelectRace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
;	COMDAT ?CreateRace@CRaceManager@@QAEXK@Z
_TEXT	SEGMENT
__Loc$1 = -20						; size = 12
$T2 = -16						; size = 8
$T3 = -8						; size = 8
_dwRaceIndex$ = 8					; size = 4
?CreateRace@CRaceManager@@QAEXK@Z PROC			; CRaceManager::CreateRace, COMDAT
; _this$ = ecx

; 381  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx
  00007	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1361 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00008	8d 45 08	 lea	 eax, DWORD PTR _dwRaceIndex$[ebp]
  0000b	50		 push	 eax
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 382  : 	if (m_RaceDataMap.end() != m_RaceDataMap.find(dwRaceIndex))

  0000c	8d 59 04	 lea	 ebx, DWORD PTR [ecx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1361 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  0000f	8d 45 ec	 lea	 eax, DWORD PTR __Loc$1[ebp]
  00012	8b cb		 mov	 ecx, ebx
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@1@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CRaceData *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRaceData *> >,0> >::_Find_lower_bound<unsigned long>

; 1599 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0001a	8b 45 f4	 mov	 eax, DWORD PTR __Loc$1[ebp+8]
  0001d	8b 7d 08	 mov	 edi, DWORD PTR _dwRaceIndex$[ebp]
  00020	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00024	75 1f		 jne	 SHORT $LN2@CreateRace
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef

; 127  :         return _Left < _Right;

  00026	3b 78 10	 cmp	 edi, DWORD PTR [eax+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1599 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00029	72 1a		 jb	 SHORT $LN2@CreateRace

; 236  :         return this->_Ptr == _Right._Ptr;

  0002b	39 03		 cmp	 DWORD PTR [ebx], eax
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 382  : 	if (m_RaceDataMap.end() != m_RaceDataMap.find(dwRaceIndex))

  0002d	74 16		 je	 SHORT $LN2@CreateRace

; 383  : 	{
; 384  : 		TraceError("RaceManager::CreateRace : Race %u already created", dwRaceIndex);

  0002f	57		 push	 edi
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@LBGILCOK@RaceManager?3?3CreateRace?5?3?5Race?5@
  00035	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0003a	83 c4 08	 add	 esp, 8
  0003d	5f		 pop	 edi

; 393  : }

  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
$LN2@CreateRace:
  00045	56		 push	 esi

; 385  : 		return;
; 386  : 	}
; 387  : 
; 388  : 	CRaceData * pRaceData = CRaceData::New();

  00046	e8 00 00 00 00	 call	 ?New@CRaceData@@SAPAV1@XZ ; CRaceData::New
  0004b	8b f0		 mov	 esi, eax

; 389  : 	pRaceData->SetRace(dwRaceIndex);

  0004d	57		 push	 edi
  0004e	8b ce		 mov	 ecx, esi
  00050	e8 00 00 00 00	 call	 ?SetRace@CRaceData@@QAEXK@Z ; CRaceData::SetRace

; 390  : 	m_RaceDataMap.insert(TRaceDataMap::value_type(dwRaceIndex, pRaceData));

  00055	8d 45 f8	 lea	 eax, DWORD PTR $T3[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00058	89 7d f8	 mov	 DWORD PTR $T3[ebp], edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 390  : 	m_RaceDataMap.insert(TRaceDataMap::value_type(dwRaceIndex, pRaceData));

  0005b	50		 push	 eax
  0005c	8d 45 f0	 lea	 eax, DWORD PTR $T2[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0005f	89 75 fc	 mov	 DWORD PTR $T3[ebp+4], esi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 390  : 	m_RaceDataMap.insert(TRaceDataMap::value_type(dwRaceIndex, pRaceData));

  00062	50		 push	 eax
  00063	8b cb		 mov	 ecx, ebx
  00065	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCRaceData@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBKPAVCRaceData@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CRaceData *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRaceData *> >,0> >::insert<0,0>

; 391  : 
; 392  : 	Tracenf("CRaceManager::CreateRace(dwRaceIndex=%d)", dwRaceIndex);

  0006a	57		 push	 edi
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@LEJBEJHD@CRaceManager?3?3CreateRace?$CIdwRace@
  00070	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  00075	83 c4 08	 add	 esp, 8
  00078	5e		 pop	 esi
  00079	5f		 pop	 edi

; 393  : }

  0007a	5b		 pop	 ebx
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 04 00	 ret	 4
?CreateRace@CRaceManager@@QAEXK@Z ENDP			; CRaceManager::CreateRace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
;	COMDAT ?GetFullPathFileName@CRaceManager@@QAEPBDPBD@Z
_TEXT	SEGMENT
_c_szFileName$ = 8					; size = 4
?GetFullPathFileName@CRaceManager@@QAEPBDPBD@Z PROC	; CRaceManager::GetFullPathFileName, COMDAT
; _this$ = ecx

; 441  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 442  : 	static std::string s_stFileName;

  00003	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__tls_array
  00009	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __tls_index
  0000f	56		 push	 esi
  00010	57		 push	 edi
  00011	8b f9		 mov	 edi, ecx
  00013	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$TSS0@?1??GetFullPathFileName@CRaceManager@@QAEPBDPBD@Z@4HA
  0001b	3b 82 00 00 00
	00		 cmp	 eax, DWORD PTR __Init_thread_epoch[edx]
  00021	7f 7b		 jg	 SHORT $LN51@GetFullPat
$LN2@GetFullPat:

; 443  : 
; 444  : 	if (c_szFileName[0] != '.')

  00023	8b 75 08	 mov	 esi, DWORD PTR _c_szFileName$[ebp]
  00026	80 3e 2e	 cmp	 BYTE PTR [esi], 46	; 0000002eH
  00029	74 3e		 je	 SHORT $LN3@GetFullPat

; 445  : 	{
; 446  : 		s_stFileName = m_strPathName;

  0002b	8d 47 1c	 lea	 eax, DWORD PTR [edi+28]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3077 :         if (this != _STD addressof(_Right)) {

  0002e	3d 00 00 00 00	 cmp	 eax, OFFSET ?s_stFileName@?1??GetFullPathFileName@CRaceManager@@QAEPBDPBD@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  00033	74 18		 je	 SHORT $LN20@GetFullPat

; 2319 :         return _BUF_SIZE <= _Myres;

  00035	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 2305 :         const value_type* _Result = _Bx._Buf;

  00039	8b c8		 mov	 ecx, eax

; 2306 :         if (_Large_string_engaged()) {

  0003b	72 02		 jb	 SHORT $LN25@GetFullPat

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
$LN25@GetFullPat:

; 3035 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0003f	ff 70 10	 push	 DWORD PTR [eax+16]
  00042	51		 push	 ecx
  00043	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_stFileName@?1??GetFullPathFileName@CRaceManager@@QAEPBDPBD@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  00048	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN20@GetFullPat:

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0004d	8b d6		 mov	 edx, esi
  0004f	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL48@GetFullPat:
  00052	8a 02		 mov	 al, BYTE PTR [edx]
  00054	42		 inc	 edx
  00055	84 c0		 test	 al, al
  00057	75 f9		 jne	 SHORT $LL48@GetFullPat
  00059	2b d7		 sub	 edx, edi

; 3175 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0005b	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_stFileName@?1??GetFullPathFileName@CRaceManager@@QAEPBDPBD@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  00060	52		 push	 edx
  00061	56		 push	 esi
  00062	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 448  : 	}

  00067	eb 1c		 jmp	 SHORT $LN4@GetFullPat
$LN3@GetFullPat:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00069	8b ce		 mov	 ecx, esi
  0006b	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0006e	66 90		 npad	 2
$LL49@GetFullPat:
  00070	8a 01		 mov	 al, BYTE PTR [ecx]
  00072	41		 inc	 ecx
  00073	84 c0		 test	 al, al
  00075	75 f9		 jne	 SHORT $LL49@GetFullPat
  00077	2b ca		 sub	 ecx, edx

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00079	51		 push	 ecx
  0007a	56		 push	 esi
  0007b	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_stFileName@?1??GetFullPathFileName@CRaceManager@@QAEPBDPBD@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  00080	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN4@GetFullPat:

; 2319 :         return _BUF_SIZE <= _Myres;

  00085	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?s_stFileName@?1??GetFullPathFileName@CRaceManager@@QAEPBDPBD@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H

; 2305 :         const value_type* _Result = _Bx._Buf;

  0008c	b8 00 00 00 00	 mov	 eax, OFFSET ?s_stFileName@?1??GetFullPathFileName@CRaceManager@@QAEPBDPBD@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 452  : 	return s_stFileName.c_str();

  00091	5f		 pop	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2306 :         if (_Large_string_engaged()) {

  00092	0f 43 05 00 00
	00 00		 cmovae	 eax, DWORD PTR ?s_stFileName@?1??GetFullPathFileName@CRaceManager@@QAEPBDPBD@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 452  : 	return s_stFileName.c_str();

  00099	5e		 pop	 esi

; 453  : }

  0009a	5d		 pop	 ebp
  0009b	c2 04 00	 ret	 4
$LN51@GetFullPat:

; 442  : 	static std::string s_stFileName;

  0009e	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??GetFullPathFileName@CRaceManager@@QAEPBDPBD@Z@4HA
  000a3	e8 00 00 00 00	 call	 __Init_thread_header
  000a8	83 c4 04	 add	 esp, 4
  000ab	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??GetFullPathFileName@CRaceManager@@QAEPBDPBD@Z@4HA, -1
  000b2	0f 85 6b ff ff
	ff		 jne	 $LN2@GetFullPat
  000b8	68 00 00 00 00	 push	 OFFSET ??__Fs_stFileName@?1??GetFullPathFileName@CRaceManager@@QAEPBDPBD@Z@YAXXZ ; `CRaceManager::GetFullPathFileName'::`2'::`dynamic atexit destructor for 's_stFileName''
  000bd	e8 00 00 00 00	 call	 _atexit
  000c2	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??GetFullPathFileName@CRaceManager@@QAEPBDPBD@Z@4HA
  000c7	e8 00 00 00 00	 call	 __Init_thread_footer
  000cc	83 c4 08	 add	 esp, 8
  000cf	e9 4f ff ff ff	 jmp	 $LN2@GetFullPat
?GetFullPathFileName@CRaceManager@@QAEPBDPBD@Z ENDP	; CRaceManager::GetFullPathFileName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
;	COMDAT ?SetPathName@CRaceManager@@QAEXPBD@Z
_TEXT	SEGMENT
_c_szPathName$ = 8					; size = 4
?SetPathName@CRaceManager@@QAEXPBD@Z PROC		; CRaceManager::SetPathName, COMDAT
; _this$ = ecx

; 436  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00003	8b 55 08	 mov	 edx, DWORD PTR _c_szPathName$[ebp]
  00006	8b c2		 mov	 eax, edx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 436  : {

  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0000c	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000f	90		 npad	 1
$LL9@SetPathNam:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL9@SetPathNam
  00017	2b c7		 sub	 eax, edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 437  : 	m_strPathName = c_szPathName;

  00019	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0001c	50		 push	 eax
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 438  : }

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?SetPathName@CRaceManager@@QAEXPBD@Z ENDP		; CRaceManager::SetPathName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
;	COMDAT ?RegisterRaceSrcName@CRaceManager@@QAEXPBD0@Z
_TEXT	SEGMENT
__Loc$2 = -96						; size = 12
$T3 = -84						; size = 12
$T4 = -80						; size = 8
__Myhead$1$ = -72					; size = 4
_this$GSCopy$1$ = -68					; size = 4
$T5 = -64						; size = 48
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_c_szName$ = 8						; size = 4
_c_szSrcName$ = 12					; size = 4
?RegisterRaceSrcName@CRaceManager@@QAEXPBD0@Z PROC	; CRaceManager::RegisterRaceSrcName, COMDAT
; _this$ = ecx

; 371  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RegisterRaceSrcName@CRaceManager@@QAEXPBD0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 54	 sub	 esp, 84			; 00000054H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d bc	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  0002d	8b 55 08	 mov	 edx, DWORD PTR _c_szName$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00030	8b ca		 mov	 ecx, edx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 371  : {

  00032	8b 7d 0c	 mov	 edi, DWORD PTR _c_szSrcName$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00035	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR $T5[ebp], 0

; 4596 :         _My_data._Mysize = 0;

  0003c	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T5[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00043	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR $T5[ebp+20], 15 ; 0000000fH

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0004a	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]

; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0004d	c6 45 c0 00	 mov	 BYTE PTR $T5[ebp], 0
$LL225@RegisterRa:

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00051	8a 01		 mov	 al, BYTE PTR [ecx]
  00053	41		 inc	 ecx
  00054	84 c0		 test	 al, al
  00056	75 f9		 jne	 SHORT $LL225@RegisterRa
  00058	2b ce		 sub	 ecx, esi

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0005a	51		 push	 ecx
  0005b	52		 push	 edx
  0005c	8d 4d c0	 lea	 ecx, DWORD PTR $T5[ebp]
  0005f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00064	8b cf		 mov	 ecx, edi

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00066	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T5[ebp+24], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0006d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4596 :         _My_data._Mysize = 0;

  00074	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T5[ebp+40], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0007b	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T5[ebp+44], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00082	c6 45 d8 00	 mov	 BYTE PTR $T5[ebp+24], 0

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00086	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  00089	0f 1f 80 00 00
	00 00		 npad	 7
$LL226@RegisterRa:
  00090	8a 01		 mov	 al, BYTE PTR [ecx]
  00092	41		 inc	 ecx
  00093	84 c0		 test	 al, al
  00095	75 f9		 jne	 SHORT $LL226@RegisterRa
  00097	2b ca		 sub	 ecx, edx

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00099	51		 push	 ecx
  0009a	57		 push	 edi
  0009b	8d 4d d8	 lea	 ecx, DWORD PTR $T5[ebp+24]
  0009e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 372  : 	m_kMap_stRaceName_stSrcName.insert(std::map<std::string, std::string>::value_type(c_szName, c_szSrcName));

  000a3	8b 75 bc	 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1014 :             _Loc                = _Find_lower_bound(_Keyval);

  000a6	8d 45 c0	 lea	 eax, DWORD PTR $T5[ebp]
  000a9	50		 push	 eax
  000aa	8d 45 ac	 lea	 eax, DWORD PTR $T3[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 372  : 	m_kMap_stRaceName_stSrcName.insert(std::map<std::string, std::string>::value_type(c_szName, c_szSrcName));

  000ad	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000b4	83 c6 0c	 add	 esi, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1014 :             _Loc                = _Find_lower_bound(_Keyval);

  000b7	50		 push	 eax
  000b8	8b ce		 mov	 ecx, esi
  000ba	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  000bf	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  000c3	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c6	66 0f d6 45 a0	 movq	 QWORD PTR __Loc$2[ebp], xmm0

; 1599 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  000cb	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000cf	75 51		 jne	 SHORT $LN48@RegisterRa
  000d1	83 c0 10	 add	 eax, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef

; 127  :         return _Left < _Right;

  000d4	50		 push	 eax
  000d5	8d 45 c0	 lea	 eax, DWORD PTR $T5[ebp]
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
  000de	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1599 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  000e1	84 c0		 test	 al, al
  000e3	75 3d		 jne	 SHORT $LN48@RegisterRa
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  000e5	8b 55 ec	 mov	 edx, DWORD PTR $T5[ebp+44]
  000e8	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  000eb	0f 82 b3 00 00
	00		 jb	 $LN180@RegisterRa
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000f1	8b 4d d8	 mov	 ecx, DWORD PTR $T5[ebp+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  000f4	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000f5	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000f7	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  000fd	72 14		 jb	 SHORT $LN190@RegisterRa

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000ff	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00102	83 c2 23	 add	 edx, 35			; 00000023H
  00105	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00107	83 c0 fc	 add	 eax, -4			; fffffffcH
  0010a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0010d	0f 87 e3 00 00
	00		 ja	 $LN215@RegisterRa
$LN190@RegisterRa:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00113	52		 push	 edx
  00114	51		 push	 ecx
  00115	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0011a	83 c4 08	 add	 esp, 8
  0011d	e9 82 00 00 00	 jmp	 $LN180@RegisterRa
$LN48@RegisterRa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1623 :         if (max_size() == _Get_scary()->_Mysize) {

  00122	81 7e 04 ff ff
	ff 03		 cmp	 DWORD PTR [esi+4], 67108863 ; 03ffffffH
  00129	0f 84 c2 00 00
	00		 je	 $LN230@RegisterRa

; 1020 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  0012f	8b 06		 mov	 eax, DWORD PTR [esi]
  00131	89 45 b8	 mov	 DWORD PTR __Myhead$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1012 :     _CONSTEXPR20_DYNALLOC explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00134	89 75 b0	 mov	 DWORD PTR $T4[ebp], esi

; 85   :         return ::operator new(_Bytes);

  00137	6a 40		 push	 64			; 00000040H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 790  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00139	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1019 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  0013d	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+4], 0

; 85   :         return ::operator new(_Bytes);

  00144	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 244  :         return _Traits::_Allocate(_Bytes);

  00149	8b f8		 mov	 edi, eax

; 85   :         return ::operator new(_Bytes);

  0014b	83 c4 04	 add	 esp, 4

; 1020 :         _Ptr = _Al.allocate(1);

  0014e	89 7d b4	 mov	 DWORD PTR $T4[ebp+4], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 213  :     pair(pair&&)      = default;

  00151	8d 45 c0	 lea	 eax, DWORD PTR $T5[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 811  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

  00154	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 213  :     pair(pair&&)      = default;

  00158	50		 push	 eax
  00159	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  0015c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00161	0f 10 45 d8	 movups	 xmm0, XMMWORD PTR $T5[ebp+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 813  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  00165	8b 45 b8	 mov	 eax, DWORD PTR __Myhead$1$[ebp]

; 1039 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00168	8b 4d bc	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2355 :     size_type _Mysize = 0; // current length of string

  0016b	c7 47 38 00 00
	00 00		 mov	 DWORD PTR [edi+56], 0

; 2356 :     size_type _Myres  = 0; // current storage reserved for string

  00172	c7 47 3c 00 00
	00 00		 mov	 DWORD PTR [edi+60], 0

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00179	0f 11 47 28	 movups	 XMMWORD PTR [edi+40], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1039 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  0017d	8d 49 0c	 lea	 ecx, DWORD PTR [ecx+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00180	f3 0f 7e 45 e8	 movq	 xmm0, QWORD PTR $T5[ebp+40]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1039 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00185	57		 push	 edi
  00186	ff 75 a4	 push	 DWORD PTR __Loc$2[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00189	66 0f d6 47 38	 movq	 QWORD PTR [edi+56], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1039 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  0018e	ff 75 a0	 push	 DWORD PTR __Loc$2[ebp]

; 813  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  00191	89 07		 mov	 DWORD PTR [edi], eax

; 814  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  00193	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 815  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  00196	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 816  :         this->_Ptr->_Color = _Red;

  00199	66 c7 47 0c 00
	00		 mov	 WORD PTR [edi+12], 0

; 1039 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  0019f	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Insert_node
$LN180@RegisterRa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  001a4	8b 55 d4	 mov	 edx, DWORD PTR $T5[ebp+20]
  001a7	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  001aa	72 28		 jb	 SHORT $LN208@RegisterRa
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001ac	8b 4d c0	 mov	 ecx, DWORD PTR $T5[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  001af	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001b0	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  001b2	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001b8	72 10		 jb	 SHORT $LN218@RegisterRa

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001ba	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  001bd	83 c2 23	 add	 edx, 35			; 00000023H
  001c0	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001c2	83 c0 fc	 add	 eax, -4			; fffffffcH
  001c5	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001c8	77 2c		 ja	 SHORT $LN215@RegisterRa
$LN218@RegisterRa:

; 264  :         ::operator delete(_Ptr, _Bytes);

  001ca	52		 push	 edx
  001cb	51		 push	 ecx
  001cc	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001d1	83 c4 08	 add	 esp, 8
$LN208@RegisterRa:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 373  : }

  001d4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001d7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001de	59		 pop	 ecx
  001df	5f		 pop	 edi
  001e0	5e		 pop	 esi
  001e1	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e4	33 cd		 xor	 ecx, ebp
  001e6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001eb	8b e5		 mov	 esp, ebp
  001ed	5d		 pop	 ebp
  001ee	c2 08 00	 ret	 8
$LN230@RegisterRa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1624 :             _Throw_tree_length_error();

  001f1	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN215@RegisterRa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001f6	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN228@RegisterRa:
  001fb	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RegisterRaceSrcName@CRaceManager@@QAEXPBD0@Z$1:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR $T5[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?RegisterRaceSrcName@CRaceManager@@QAEXPBD0@Z$0:
  00008	8d 4d c0	 lea	 ecx, DWORD PTR $T5[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ
__unwindfunclet$?RegisterRaceSrcName@CRaceManager@@QAEXPBD0@Z$9:
  00010	8d 4d b0	 lea	 ecx, DWORD PTR $T4[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
__unwindfunclet$?RegisterRaceSrcName@CRaceManager@@QAEXPBD0@Z$8:
  00018	8d 4d b0	 lea	 ecx, DWORD PTR $T4[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@QAE@XZ
  00020	cc		 int	 3
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
  00024	cc		 int	 3
__ehhandler$?RegisterRaceSrcName@CRaceManager@@QAEXPBD0@Z:
  00025	90		 npad	 1
  00026	90		 npad	 1
  00027	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002e	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  00031	33 c8		 xor	 ecx, eax
  00033	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00038	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0003b	33 c8		 xor	 ecx, eax
  0003d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00042	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RegisterRaceSrcName@CRaceManager@@QAEXPBD0@Z
  00047	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RegisterRaceSrcName@CRaceManager@@QAEXPBD0@Z ENDP	; CRaceManager::RegisterRaceSrcName
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
;	COMDAT ?RegisterRaceName@CRaceManager@@QAEXKPBD@Z
_TEXT	SEGMENT
__Loc$2 = -68						; size = 12
$T3 = -56						; size = 12
$T4 = -52						; size = 8
$T5 = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_dwRaceIndex$ = 8					; size = 4
_c_szName$ = 12						; size = 4
?RegisterRaceName@CRaceManager@@QAEXKPBD@Z PROC		; CRaceManager::RegisterRaceName, COMDAT
; _this$ = ecx

; 376  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RegisterRaceName@CRaceManager@@QAEXKPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b f9		 mov	 edi, ecx
  0002c	8b 55 0c	 mov	 edx, DWORD PTR _c_szName$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0002f	8b ca		 mov	 ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00031	8b 45 08	 mov	 eax, DWORD PTR _dwRaceIndex$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00034	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T5[ebp+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 193  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0003b	89 45 d4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4596 :         _My_data._Mysize = 0;

  0003e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T5[ebp+20], 0

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00045	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00048	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T5[ebp+24], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0004f	c6 45 d8 00	 mov	 BYTE PTR $T5[ebp+4], 0
$LL175@RegisterRa:

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00053	8a 01		 mov	 al, BYTE PTR [ecx]
  00055	41		 inc	 ecx
  00056	84 c0		 test	 al, al
  00058	75 f9		 jne	 SHORT $LL175@RegisterRa
  0005a	2b ce		 sub	 ecx, esi

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0005c	51		 push	 ecx
  0005d	52		 push	 edx
  0005e	8d 4d d8	 lea	 ecx, DWORD PTR $T5[ebp+4]
  00061	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1014 :             _Loc                = _Find_lower_bound(_Keyval);

  00066	8d 45 d4	 lea	 eax, DWORD PTR $T5[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 377  : 	m_kMap_dwRaceKey_stRaceName.insert(std::map<DWORD, std::string>::value_type(dwRaceIndex, c_szName));

  00069	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1014 :             _Loc                = _Find_lower_bound(_Keyval);

  00070	50		 push	 eax
  00071	8d 45 c8	 lea	 eax, DWORD PTR $T3[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 377  : 	m_kMap_dwRaceKey_stRaceName.insert(std::map<DWORD, std::string>::value_type(dwRaceIndex, c_szName));

  00074	83 c7 14	 add	 edi, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1014 :             _Loc                = _Find_lower_bound(_Keyval);

  00077	50		 push	 eax
  00078	8b cf		 mov	 ecx, edi
  0007a	e8 00 00 00 00	 call	 ??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find_lower_bound<unsigned long>
  0007f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00082	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00086	66 0f d6 45 bc	 movq	 QWORD PTR __Loc$2[ebp], xmm0

; 1599 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0008b	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0008f	75 42		 jne	 SHORT $LN31@RegisterRa
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstddef

; 127  :         return _Left < _Right;

  00091	8b 45 d4	 mov	 eax, DWORD PTR $T5[ebp]
  00094	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1599 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00097	72 3a		 jb	 SHORT $LN31@RegisterRa
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00099	8b 55 ec	 mov	 edx, DWORD PTR $T5[ebp+24]
  0009c	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0009f	0f 82 93 00 00
	00		 jb	 $LN157@RegisterRa
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a5	8b 4d d8	 mov	 ecx, DWORD PTR $T5[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  000a8	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a9	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000ab	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  000b1	72 14		 jb	 SHORT $LN167@RegisterRa

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000b3	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  000b6	83 c2 23	 add	 edx, 35			; 00000023H
  000b9	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000bb	83 c0 fc	 add	 eax, -4			; fffffffcH
  000be	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000c1	0f 87 8e 00 00
	00		 ja	 $LN179@RegisterRa
$LN167@RegisterRa:

; 264  :         ::operator delete(_Ptr, _Bytes);

  000c7	52		 push	 edx
  000c8	51		 push	 ecx
  000c9	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000ce	83 c4 08	 add	 esp, 8
  000d1	eb 65		 jmp	 SHORT $LN157@RegisterRa
$LN31@RegisterRa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1623 :         if (max_size() == _Get_scary()->_Mysize) {

  000d3	81 7f 04 5d 74
	d1 05		 cmp	 DWORD PTR [edi+4], 97612893 ; 05d1745dH
  000da	74 7e		 je	 SHORT $LN180@RegisterRa

; 1020 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  000dc	8b 37		 mov	 esi, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1012 :     _CONSTEXPR20_DYNALLOC explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  000de	89 7d cc	 mov	 DWORD PTR $T4[ebp], edi

; 85   :         return ::operator new(_Bytes);

  000e1	6a 2c		 push	 44			; 0000002cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 790  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  000e3	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1019 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  000e7	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+4], 0

; 85   :         return ::operator new(_Bytes);

  000ee	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  000f3	0f 10 45 d8	 movups	 xmm0, XMMWORD PTR $T5[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 213  :     pair(pair&&)      = default;

  000f7	8b 4d d4	 mov	 ecx, DWORD PTR $T5[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 85   :         return ::operator new(_Bytes);

  000fa	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 213  :     pair(pair&&)      = default;

  000fd	89 48 10	 mov	 DWORD PTR [eax+16], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1039 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00100	8b cf		 mov	 ecx, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2355 :     size_type _Mysize = 0; // current length of string

  00102	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 2356 :     size_type _Myres  = 0; // current storage reserved for string

  00109	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00110	0f 11 40 14	 movups	 XMMWORD PTR [eax+20], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1039 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00114	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00115	f3 0f 7e 45 e8	 movq	 xmm0, QWORD PTR $T5[ebp+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1039 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  0011a	ff 75 c0	 push	 DWORD PTR __Loc$2[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0011d	66 0f d6 40 24	 movq	 QWORD PTR [eax+36], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1039 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00122	ff 75 bc	 push	 DWORD PTR __Loc$2[ebp]

; 813  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  00125	89 30		 mov	 DWORD PTR [eax], esi

; 814  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  00127	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 815  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  0012a	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 816  :         this->_Ptr->_Color = _Red;

  0012d	66 c7 40 0c 00
	00		 mov	 WORD PTR [eax+12], 0

; 1039 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00133	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Insert_node
$LN157@RegisterRa:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 378  : }

  00138	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0013b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00142	59		 pop	 ecx
  00143	5f		 pop	 edi
  00144	5e		 pop	 esi
  00145	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00148	33 cd		 xor	 ecx, ebp
  0014a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014f	8b e5		 mov	 esp, ebp
  00151	5d		 pop	 ebp
  00152	c2 08 00	 ret	 8
$LN179@RegisterRa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00155	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN180@RegisterRa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1624 :             _Throw_tree_length_error();

  0015a	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN177@RegisterRa:
  0015f	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RegisterRaceName@CRaceManager@@QAEXKPBD@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR $T5[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
__unwindfunclet$?RegisterRaceName@CRaceManager@@QAEXKPBD@Z$6:
  00008	8d 4d cc	 lea	 ecx, DWORD PTR $T4[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?RegisterRaceName@CRaceManager@@QAEXKPBD@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RegisterRaceName@CRaceManager@@QAEXKPBD@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RegisterRaceName@CRaceManager@@QAEXKPBD@Z ENDP		; CRaceManager::RegisterRaceName
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
;	COMDAT ?Destroy@CRaceManager@@QAEXXZ
_TEXT	SEGMENT
?Destroy@CRaceManager@@QAEXXZ PROC			; CRaceManager::Destroy, COMDAT
; _this$ = ecx

; 477  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 478  : 	__DestroyRaceDataMap();

  00003	e8 00 00 00 00	 call	 ?__DestroyRaceDataMap@CRaceManager@@IAEXXZ ; CRaceManager::__DestroyRaceDataMap

; 479  : 
; 480  : 	__Initialize();

  00008	8b ce		 mov	 ecx, esi
  0000a	5e		 pop	 esi
  0000b	e9 00 00 00 00	 jmp	 ?__Initialize@CRaceManager@@IAEXXZ ; CRaceManager::__Initialize
?Destroy@CRaceManager@@QAEXXZ ENDP			; CRaceManager::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
;	COMDAT ?Create@CRaceManager@@QAEXXZ
_TEXT	SEGMENT
?Create@CRaceManager@@QAEXXZ PROC			; CRaceManager::Create, COMDAT
; _this$ = ecx

; 458  : 	CRaceMotionData::CreateSystem(2048);

  00000	68 00 08 00 00	 push	 2048			; 00000800H
  00005	e8 00 00 00 00	 call	 ?CreateSystem@CRaceMotionData@@SAXI@Z ; CRaceMotionData::CreateSystem

; 459  : 	CRaceData::CreateSystem(256, 512);

  0000a	68 00 02 00 00	 push	 512			; 00000200H
  0000f	68 00 01 00 00	 push	 256			; 00000100H
  00014	e8 00 00 00 00	 call	 ?CreateSystem@CRaceData@@SAXII@Z ; CRaceData::CreateSystem
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 460  : }

  0001c	c3		 ret	 0
?Create@CRaceManager@@QAEXXZ ENDP			; CRaceManager::Create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterBase\Singleton.h
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
;	COMDAT ??1CRaceManager@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1CRaceManager@@UAE@XZ PROC				; CRaceManager::~CRaceManager, COMDAT
; _this$ = ecx

; 489  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CRaceManager@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f9		 mov	 edi, ecx
  00026	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CRaceManager@@6B@

; 490  : 	Destroy();

  0002c	e8 00 00 00 00	 call	 ?Destroy@CRaceManager@@QAEXXZ ; CRaceManager::Destroy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00031	8b 4f 30	 mov	 ecx, DWORD PTR [edi+48]
  00034	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00037	72 2c		 jb	 SHORT $LN15@CRaceManag
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00039	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0003c	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0003d	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00043	72 16		 jb	 SHORT $LN25@CRaceManag

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00045	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00048	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0004b	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004d	83 c0 fc	 add	 eax, -4			; fffffffcH
  00050	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00053	0f 87 80 00 00
	00		 ja	 $LN22@CRaceManag

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00059	8b c2		 mov	 eax, edx
$LN25@CRaceManag:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0005b	51		 push	 ecx
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00062	83 c4 08	 add	 esp, 8
$LN15@CRaceManag:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 491  : }

  00065	8d 77 14	 lea	 esi, DWORD PTR [edi+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  00068	c7 47 2c 00 00
	00 00		 mov	 DWORD PTR [edi+44], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0006f	c7 47 30 0f 00
	00 00		 mov	 DWORD PTR [edi+48], 15	; 0000000fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 758  :         _Erase_tree(_Al, _Myhead->_Parent);

  00076	8b ce		 mov	 ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00078	c6 47 1c 00	 mov	 BYTE PTR [edi+28], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 758  :         _Erase_tree(_Al, _Myhead->_Parent);

  0007c	8b 06		 mov	 eax, DWORD PTR [esi]
  0007e	ff 70 04	 push	 DWORD PTR [eax+4]
  00081	56		 push	 esi
  00082	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00087	6a 2c		 push	 44			; 0000002cH
  00089	ff 36		 push	 DWORD PTR [esi]
  0008b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 758  :         _Erase_tree(_Al, _Myhead->_Parent);

  00090	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 491  : }

  00093	8d 77 0c	 lea	 esi, DWORD PTR [edi+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00096	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 758  :         _Erase_tree(_Al, _Myhead->_Parent);

  00099	8b ce		 mov	 ecx, esi
  0009b	ff 70 04	 push	 DWORD PTR [eax+4]
  0009e	56		 push	 esi
  0009f	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  000a4	6a 40		 push	 64			; 00000040H
  000a6	ff 36		 push	 DWORD PTR [esi]
  000a8	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000ad	83 c4 08	 add	 esp, 8
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 491  : }

  000b0	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  000b3	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CRaceData *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRaceData *> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,CRaceData *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRaceData *> >,0> >
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterBase\Singleton.h

; 19   : 	{

  000b8	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$CSingleton@VCRaceManager@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0;

  000be	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCRaceManager@@@@0PAVCRaceManager@@A, 0 ; CSingleton<CRaceManager>::ms_singleton
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 491  : }

  000c8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000cb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d2	59		 pop	 ecx
  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c3		 ret	 0
$LN22@CRaceManag:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000d9	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN97@CRaceManag:
  000de	cc		 int	 3
  000df	cc		 int	 3
  000e0	cc		 int	 3
  000e1	cc		 int	 3
  000e2	cc		 int	 3
  000e3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CRaceManager@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CRaceManager@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CRaceManager@@UAE@XZ ENDP				; CRaceManager::~CRaceManager
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterBase\Singleton.h
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
;	COMDAT ??0CRaceManager@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -20						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CRaceManager@@QAE@XZ PROC				; CRaceManager::CRaceManager, COMDAT
; _this$ = ecx

; 484  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CRaceManager@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterBase\Singleton.h

; 15   : 		ms_singleton = (T*) ((int) this + offset);

  0002c	89 3d 00 00 00
	00		 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCRaceManager@@@@0PAVCRaceManager@@A, edi ; CSingleton<CRaceManager>::ms_singleton
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 484  : {

  00032	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  00035	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CRaceManager@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 85   :         return ::operator new(_Bytes);

  0003b	6a 18		 push	 24			; 00000018H
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 484  : {

  0003d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00044	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 441  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00047	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0004d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 85   :         return ::operator new(_Bytes);

  00054	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 350  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  00059	89 00		 mov	 DWORD PTR [eax], eax

; 351  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  0005b	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 352  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0005e	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 353  :         _Pnode->_Color = _Black;

  00061	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 1925 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  00067	89 06		 mov	 DWORD PTR [esi], eax
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 484  : {

  00069	8d 77 0c	 lea	 esi, DWORD PTR [edi+12]
  0006c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 85   :         return ::operator new(_Bytes);

  00070	6a 40		 push	 64			; 00000040H
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 484  : {

  00072	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 441  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00075	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0007b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 85   :         return ::operator new(_Bytes);

  00082	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 350  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  00087	89 00		 mov	 DWORD PTR [eax], eax

; 351  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00089	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 352  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0008c	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 353  :         _Pnode->_Color = _Black;

  0008f	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 1925 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  00095	89 06		 mov	 DWORD PTR [esi], eax
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 484  : {

  00097	8d 77 14	 lea	 esi, DWORD PTR [edi+20]
  0009a	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 85   :         return ::operator new(_Bytes);

  0009e	6a 2c		 push	 44			; 0000002cH
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 484  : {

  000a0	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 441  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  000a3	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  000a9	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 85   :         return ::operator new(_Bytes);

  000b0	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000b5	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 485  : 	__Initialize();

  000b8	8b cf		 mov	 ecx, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 350  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  000ba	89 00		 mov	 DWORD PTR [eax], eax

; 351  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  000bc	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 352  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  000bf	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 353  :         _Pnode->_Color = _Black;

  000c2	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 1925 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  000c8	89 06		 mov	 DWORD PTR [esi], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  000ca	c7 47 1c 00 00
	00 00		 mov	 DWORD PTR [edi+28], 0

; 4596 :         _My_data._Mysize = 0;

  000d1	c7 47 2c 00 00
	00 00		 mov	 DWORD PTR [edi+44], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  000d8	c7 47 30 0f 00
	00 00		 mov	 DWORD PTR [edi+48], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  000df	c6 47 1c 00	 mov	 BYTE PTR [edi+28], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp

; 485  : 	__Initialize();

  000e3	e8 00 00 00 00	 call	 ?__Initialize@CRaceManager@@IAEXXZ ; CRaceManager::__Initialize

; 486  : }

  000e8	8b c7		 mov	 eax, edi
  000ea	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ed	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f4	59		 pop	 ecx
  000f5	5f		 pop	 edi
  000f6	5e		 pop	 esi
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CRaceManager@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CSingleton@VCRaceManager@@@@UAE@XZ ; CSingleton<CRaceManager>::~CSingleton<CRaceManager>
__unwindfunclet$??0CRaceManager@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1?$map@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@@std@@QAE@XZ
__unwindfunclet$??0CRaceManager@@QAE@XZ$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00019	e9 00 00 00 00	 jmp	 ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ
  0001e	cc		 int	 3
  0001f	cc		 int	 3
  00020	cc		 int	 3
  00021	cc		 int	 3
  00022	cc		 int	 3
__ehhandler$??0CRaceManager@@QAE@XZ:
  00023	90		 npad	 1
  00024	90		 npad	 1
  00025	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00029	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002c	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0002f	33 c8		 xor	 ecx, eax
  00031	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00036	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CRaceManager@@QAE@XZ
  0003b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CRaceManager@@QAE@XZ ENDP				; CRaceManager::CRaceManager
; Function compile flags: /Ogtp
;	COMDAT ??1?$map@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$map@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@@std@@QAE@XZ PROC ; std::map<unsigned long,CRaceData *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRaceData *> > >::~map<unsigned long,CRaceData *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRaceData *> > >, COMDAT
; _this$ = ecx
  00000	e9 00 00 00 00	 jmp	 ??1?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CRaceData *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRaceData *> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,CRaceData *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRaceData *> >,0> >
??1?$map@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<unsigned long,CRaceData *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRaceData *> > >::~map<unsigned long,CRaceData *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRaceData *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCRaceData@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@2@QAU32@@Z
_TEXT	SEGMENT
__Head$1$ = -8						; size = 4
_this$1$ = -4						; size = 4
__Loc$ = 8						; size = 8
__Newnode$ = 16						; size = 4
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCRaceData@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@2@QAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CRaceData *> > >::_Insert_node, COMDAT
; _this$ = ecx

; 650  :     _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 651  :         ++_Mysize;
; 652  :         const auto _Head  = _Myhead;
; 653  :         _Newnode->_Parent = _Loc._Parent;

  00006	8b 55 08	 mov	 edx, DWORD PTR __Loc$[ebp]
  00009	8b c1		 mov	 eax, ecx
  0000b	89 45 fc	 mov	 DWORD PTR _this$1$[ebp], eax
  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00010	ff 40 04	 inc	 DWORD PTR [eax+4]
  00013	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00016	89 4d f8	 mov	 DWORD PTR __Head$1$[ebp], ecx
  00019	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 654  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

  0001c	3b d1		 cmp	 edx, ecx
  0001e	75 12		 jne	 SHORT $LN5@Insert_nod

; 655  :             _Head->_Left     = _Newnode;

  00020	89 01		 mov	 DWORD PTR [ecx], eax

; 656  :             _Head->_Parent   = _Newnode;

  00022	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 657  :             _Head->_Right    = _Newnode;

  00025	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 658  :             _Newnode->_Color = _Black; // the root is black

  00028	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 717  :     }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 0c 00	 ret	 12			; 0000000cH
$LN5@Insert_nod:

; 659  :             return _Newnode;
; 660  :         }
; 661  : 
; 662  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 663  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

  00032	83 7d 0c 00	 cmp	 DWORD PTR __Loc$[ebp+4], 0
  00036	75 0d		 jne	 SHORT $LN6@Insert_nod

; 664  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 665  :             _Loc._Parent->_Right = _Newnode;

  00038	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 666  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

  0003b	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003e	75 0d		 jne	 SHORT $LN9@Insert_nod

; 667  :                 _Head->_Right = _Newnode;

  00040	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 668  :             }
; 669  :         } else { // add to left of _Loc._Parent

  00043	eb 08		 jmp	 SHORT $LN9@Insert_nod
$LN6@Insert_nod:

; 670  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 671  :             _Loc._Parent->_Left = _Newnode;

  00045	89 02		 mov	 DWORD PTR [edx], eax

; 672  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

  00047	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00049	75 02		 jne	 SHORT $LN9@Insert_nod

; 673  :                 _Head->_Left = _Newnode;

  0004b	89 01		 mov	 DWORD PTR [ecx], eax
$LN9@Insert_nod:

; 674  :             }
; 675  :         }
; 676  : 
; 677  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  0004d	8b d0		 mov	 edx, eax
  0004f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00052	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  00056	0f 85 99 01 00
	00		 jne	 $LN3@Insert_nod
  0005c	53		 push	 ebx
  0005d	56		 push	 esi
  0005e	57		 push	 edi
  0005f	90		 npad	 1
$LL2@Insert_nod:

; 678  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

  00060	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00063	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
  00066	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00069	8d 59 04	 lea	 ebx, DWORD PTR [ecx+4]
  0006c	8b 06		 mov	 eax, DWORD PTR [esi]
  0006e	3b c8		 cmp	 ecx, eax
  00070	0f 85 ba 00 00
	00		 jne	 $LN10@Insert_nod

; 679  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

  00076	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 680  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00079	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  0007d	0f 84 b3 00 00
	00		 je	 $LN53@Insert_nod

; 681  :                     _Pnode->_Parent->_Color          = _Black;
; 682  :                     _Parent_sibling->_Color          = _Black;
; 683  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 684  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 685  :                 } else { // parent's sibling has red and black children
; 686  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

  00083	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00086	3b d6		 cmp	 edx, esi
  00088	75 47		 jne	 SHORT $LN51@Insert_nod

; 466  :         _Wherenode->_Right = _Pnode->_Left;

  0008a	8b 06		 mov	 eax, DWORD PTR [esi]

; 687  :                         _Pnode = _Pnode->_Parent;

  0008c	8b d1		 mov	 edx, ecx

; 466  :         _Wherenode->_Right = _Pnode->_Left;

  0008e	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 467  : 
; 468  :         if (!_Pnode->_Left->_Isnil) {

  00091	8b 06		 mov	 eax, DWORD PTR [esi]
  00093	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00097	75 03		 jne	 SHORT $LN20@Insert_nod

; 469  :             _Pnode->_Left->_Parent = _Wherenode;

  00099	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN20@Insert_nod:

; 470  :         }
; 471  : 
; 472  :         _Pnode->_Parent = _Wherenode->_Parent;

  0009c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0009e	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 473  : 
; 474  :         if (_Wherenode == _Myhead->_Parent) {

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  000a4	8b 00		 mov	 eax, DWORD PTR [eax]
  000a6	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  000a9	75 0b		 jne	 SHORT $LN21@Insert_nod

; 475  :             _Myhead->_Parent = _Pnode;

  000ab	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 483  :         _Wherenode->_Parent = _Pnode;

  000ae	8b fb		 mov	 edi, ebx
  000b0	89 16		 mov	 DWORD PTR [esi], edx
  000b2	89 33		 mov	 DWORD PTR [ebx], esi
  000b4	eb 1d		 jmp	 SHORT $LN49@Insert_nod
$LN21@Insert_nod:

; 476  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  000b6	8b 03		 mov	 eax, DWORD PTR [ebx]
  000b8	3b 10		 cmp	 edx, DWORD PTR [eax]
  000ba	75 0a		 jne	 SHORT $LN23@Insert_nod

; 477  :             _Wherenode->_Parent->_Left = _Pnode;

  000bc	89 30		 mov	 DWORD PTR [eax], esi

; 483  :         _Wherenode->_Parent = _Pnode;

  000be	8b fb		 mov	 edi, ebx
  000c0	89 16		 mov	 DWORD PTR [esi], edx
  000c2	89 33		 mov	 DWORD PTR [ebx], esi
  000c4	eb 0d		 jmp	 SHORT $LN49@Insert_nod
$LN23@Insert_nod:

; 479  :             _Wherenode->_Parent->_Right = _Pnode;

  000c6	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 483  :         _Wherenode->_Parent = _Pnode;

  000c9	8b fb		 mov	 edi, ebx
  000cb	89 16		 mov	 DWORD PTR [esi], edx
  000cd	89 33		 mov	 DWORD PTR [ebx], esi
  000cf	eb 02		 jmp	 SHORT $LN49@Insert_nod
$LN51@Insert_nod:
  000d1	8b f1		 mov	 esi, ecx
$LN49@Insert_nod:

; 688  :                         _Lrotate(_Pnode);
; 689  :                     }
; 690  : 
; 691  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  000d3	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1

; 692  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  000d7	8b 07		 mov	 eax, DWORD PTR [edi]
  000d9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000dc	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 693  :                     _Rrotate(_Pnode->_Parent->_Parent);

  000e0	8b 07		 mov	 eax, DWORD PTR [edi]
  000e2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 487  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  000e5	8b 31		 mov	 esi, DWORD PTR [ecx]

; 488  :         _Wherenode->_Left = _Pnode->_Right;

  000e7	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ea	89 01		 mov	 DWORD PTR [ecx], eax

; 489  : 
; 490  :         if (!_Pnode->_Right->_Isnil) {

  000ec	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ef	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000f3	75 03		 jne	 SHORT $LN27@Insert_nod

; 491  :             _Pnode->_Right->_Parent = _Wherenode;

  000f5	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN27@Insert_nod:

; 492  :         }
; 493  : 
; 494  :         _Pnode->_Parent = _Wherenode->_Parent;

  000f8	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000fb	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 495  : 
; 496  :         if (_Wherenode == _Myhead->_Parent) {

  000fe	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00101	8b 00		 mov	 eax, DWORD PTR [eax]
  00103	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00106	75 0b		 jne	 SHORT $LN28@Insert_nod

; 497  :             _Myhead->_Parent = _Pnode;

  00108	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 502  :         }
; 503  : 
; 504  :         _Pnode->_Right      = _Wherenode;

  0010b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 694  :                 }
; 695  :             } else { // fixup red-red in right subtree

  0010e	e9 cc 00 00 00	 jmp	 $LN52@Insert_nod
$LN28@Insert_nod:

; 498  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00113	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00116	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00119	75 0b		 jne	 SHORT $LN30@Insert_nod

; 499  :             _Wherenode->_Parent->_Right = _Pnode;

  0011b	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 502  :         }
; 503  : 
; 504  :         _Pnode->_Right      = _Wherenode;

  0011e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 694  :                 }
; 695  :             } else { // fixup red-red in right subtree

  00121	e9 b9 00 00 00	 jmp	 $LN52@Insert_nod
$LN30@Insert_nod:

; 501  :             _Wherenode->_Parent->_Left = _Pnode;

  00126	89 30		 mov	 DWORD PTR [eax], esi

; 502  :         }
; 503  : 
; 504  :         _Pnode->_Right      = _Wherenode;

  00128	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 694  :                 }
; 695  :             } else { // fixup red-red in right subtree

  0012b	e9 af 00 00 00	 jmp	 $LN52@Insert_nod
$LN10@Insert_nod:

; 696  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;
; 697  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00130	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  00134	75 1b		 jne	 SHORT $LN15@Insert_nod
$LN53@Insert_nod:

; 674  :             }
; 675  :         }
; 676  : 
; 677  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  00136	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1
  0013a	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  0013e	8b 07		 mov	 eax, DWORD PTR [edi]
  00140	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00143	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0
  00147	8b 07		 mov	 eax, DWORD PTR [edi]
  00149	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0014c	e9 91 00 00 00	 jmp	 $LN46@Insert_nod
$LN15@Insert_nod:

; 698  :                     _Pnode->_Parent->_Color          = _Black;
; 699  :                     _Parent_sibling->_Color          = _Black;
; 700  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 701  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 702  :                 } else { // parent's sibling has red and black children
; 703  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

  00151	8b 01		 mov	 eax, DWORD PTR [ecx]
  00153	3b d0		 cmp	 edx, eax
  00155	75 3e		 jne	 SHORT $LN39@Insert_nod

; 704  :                         _Pnode = _Pnode->_Parent;

  00157	8b d1		 mov	 edx, ecx

; 487  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  00159	8b c8		 mov	 ecx, eax

; 488  :         _Wherenode->_Left = _Pnode->_Right;

  0015b	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0015e	89 02		 mov	 DWORD PTR [edx], eax

; 489  : 
; 490  :         if (!_Pnode->_Right->_Isnil) {

  00160	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00163	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00167	75 03		 jne	 SHORT $LN34@Insert_nod

; 491  :             _Pnode->_Right->_Parent = _Wherenode;

  00169	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN34@Insert_nod:

; 492  :         }
; 493  : 
; 494  :         _Pnode->_Parent = _Wherenode->_Parent;

  0016c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0016e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 495  : 
; 496  :         if (_Wherenode == _Myhead->_Parent) {

  00171	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00174	8b 00		 mov	 eax, DWORD PTR [eax]
  00176	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00179	75 05		 jne	 SHORT $LN35@Insert_nod

; 497  :             _Myhead->_Parent = _Pnode;

  0017b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0017e	eb 0e		 jmp	 SHORT $LN38@Insert_nod
$LN35@Insert_nod:

; 498  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00180	8b 03		 mov	 eax, DWORD PTR [ebx]
  00182	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  00185	75 05		 jne	 SHORT $LN37@Insert_nod

; 499  :             _Wherenode->_Parent->_Right = _Pnode;

  00187	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 500  :         } else {

  0018a	eb 02		 jmp	 SHORT $LN38@Insert_nod
$LN37@Insert_nod:

; 501  :             _Wherenode->_Parent->_Left = _Pnode;

  0018c	89 08		 mov	 DWORD PTR [eax], ecx
$LN38@Insert_nod:

; 502  :         }
; 503  : 
; 504  :         _Pnode->_Right      = _Wherenode;

  0018e	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 505  :         _Wherenode->_Parent = _Pnode;

  00191	8b fb		 mov	 edi, ebx
  00193	89 0b		 mov	 DWORD PTR [ebx], ecx
$LN39@Insert_nod:

; 705  :                         _Rrotate(_Pnode);
; 706  :                     }
; 707  : 
; 708  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  00195	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 709  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00199	8b 07		 mov	 eax, DWORD PTR [edi]
  0019b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019e	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 710  :                     _Lrotate(_Pnode->_Parent->_Parent);

  001a2	8b 07		 mov	 eax, DWORD PTR [edi]
  001a4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 465  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  001a7	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]

; 466  :         _Wherenode->_Right = _Pnode->_Left;

  001aa	8b 06		 mov	 eax, DWORD PTR [esi]
  001ac	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 467  : 
; 468  :         if (!_Pnode->_Left->_Isnil) {

  001af	8b 06		 mov	 eax, DWORD PTR [esi]
  001b1	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  001b5	75 03		 jne	 SHORT $LN41@Insert_nod

; 469  :             _Pnode->_Left->_Parent = _Wherenode;

  001b7	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN41@Insert_nod:

; 470  :         }
; 471  : 
; 472  :         _Pnode->_Parent = _Wherenode->_Parent;

  001ba	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001bd	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 473  : 
; 474  :         if (_Wherenode == _Myhead->_Parent) {

  001c0	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  001c3	8b 00		 mov	 eax, DWORD PTR [eax]
  001c5	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  001c8	75 05		 jne	 SHORT $LN42@Insert_nod

; 475  :             _Myhead->_Parent = _Pnode;

  001ca	89 70 04	 mov	 DWORD PTR [eax+4], esi
  001cd	eb 0e		 jmp	 SHORT $LN45@Insert_nod
$LN42@Insert_nod:

; 476  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  001cf	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001d2	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001d4	75 04		 jne	 SHORT $LN44@Insert_nod

; 477  :             _Wherenode->_Parent->_Left = _Pnode;

  001d6	89 30		 mov	 DWORD PTR [eax], esi

; 478  :         } else {

  001d8	eb 03		 jmp	 SHORT $LN45@Insert_nod
$LN44@Insert_nod:

; 479  :             _Wherenode->_Parent->_Right = _Pnode;

  001da	89 70 08	 mov	 DWORD PTR [eax+8], esi
$LN45@Insert_nod:

; 480  :         }
; 481  : 
; 482  :         _Pnode->_Left       = _Wherenode;

  001dd	89 0e		 mov	 DWORD PTR [esi], ecx
$LN52@Insert_nod:

; 674  :             }
; 675  :         }
; 676  : 
; 677  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  001df	89 71 04	 mov	 DWORD PTR [ecx+4], esi
$LN46@Insert_nod:
  001e2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001e5	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  001e9	0f 84 71 fe ff
	ff		 je	 $LL2@Insert_nod
  001ef	8b 4d f8	 mov	 ecx, DWORD PTR __Head$1$[ebp]
  001f2	5f		 pop	 edi
  001f3	5e		 pop	 esi
  001f4	5b		 pop	 ebx
$LN3@Insert_nod:

; 711  :                 }
; 712  :             }
; 713  :         }
; 714  : 
; 715  :         _Head->_Parent->_Color = _Black; // root is always black

  001f5	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001f8	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 716  :         return _Newnode;

  001fc	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]

; 717  :     }

  001ff	8b e5		 mov	 esp, ebp
  00201	5d		 pop	 ebp
  00202	c2 0c 00	 ret	 12			; 0000000cH
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCRaceData@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@2@QAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CRaceData *> > >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CRaceData *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRaceData *> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,CRaceData *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRaceData *> >,0> >, COMDAT
; _this$ = ecx

; 1092 :     ~_Tree() noexcept {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 758  :         _Erase_tree(_Al, _Myhead->_Parent);

  00004	8b 07		 mov	 eax, DWORD PTR [edi]
  00006	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 749  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00009	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0000d	75 23		 jne	 SHORT $LN7@Tree
  0000f	90		 npad	 1
$LL6@Tree:

; 750  :             _Erase_tree(_Al, _Rootnode->_Right);

  00010	ff 76 08	 push	 DWORD PTR [esi+8]
  00013	8b cf		 mov	 ecx, edi
  00015	57		 push	 edi
  00016	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCRaceData@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCRaceData@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CRaceData *> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CRaceData *>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 616  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0001b	8b c6		 mov	 eax, esi

; 617  :     _Val         = static_cast<_Other&&>(_New_val);

  0001d	8b 36		 mov	 esi, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  0001f	6a 18		 push	 24			; 00000018H
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 749  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  0002a	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0002e	74 e0		 je	 SHORT $LL6@Tree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00030	8b 07		 mov	 eax, DWORD PTR [edi]
$LN7@Tree:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00032	6a 18		 push	 24			; 00000018H
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003a	83 c4 08	 add	 esp, 8
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree

; 1099 :     }

  0003f	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@KPAVCRaceData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRaceData@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CRaceData *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRaceData *> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,CRaceData *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CRaceData *> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterBase\Singleton.h
;	COMDAT ??_G?$CSingleton@VCRaceManager@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CSingleton@VCRaceManager@@@@UAEPAXI@Z PROC	; CSingleton<CRaceManager>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1

; 19   : 	{

  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CSingleton@VCRaceManager@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0;

  00010	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCRaceManager@@@@0PAVCRaceManager@@A, 0 ; CSingleton<CRaceManager>::ms_singleton
  0001a	74 0b		 je	 SHORT $LN6@scalar
  0001c	6a 04		 push	 4
  0001e	56		 push	 esi
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00027	8b c6		 mov	 eax, esi
  00029	5e		 pop	 esi
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G?$CSingleton@VCRaceManager@@@@UAEPAXI@Z ENDP	; CSingleton<CRaceManager>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\eterBase\Singleton.h
;	COMDAT ??1?$CSingleton@VCRaceManager@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CSingleton@VCRaceManager@@@@UAE@XZ PROC		; CSingleton<CRaceManager>::~CSingleton<CRaceManager>, COMDAT
; _this$ = ecx

; 19   : 	{

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CSingleton@VCRaceManager@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0;

  00006	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCRaceManager@@@@0PAVCRaceManager@@A, 0 ; CSingleton<CRaceManager>::ms_singleton

; 22   : 	}

  00010	c3		 ret	 0
??1?$CSingleton@VCRaceManager@@@@UAE@XZ ENDP		; CSingleton<CRaceManager>::~CSingleton<CRaceManager>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@2@QAU32@@Z
_TEXT	SEGMENT
__Head$1$ = -8						; size = 4
_this$1$ = -4						; size = 4
__Loc$ = 8						; size = 8
__Newnode$ = 16						; size = 4
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@2@QAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Insert_node, COMDAT
; _this$ = ecx

; 650  :     _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 651  :         ++_Mysize;
; 652  :         const auto _Head  = _Myhead;
; 653  :         _Newnode->_Parent = _Loc._Parent;

  00006	8b 55 08	 mov	 edx, DWORD PTR __Loc$[ebp]
  00009	8b c1		 mov	 eax, ecx
  0000b	89 45 fc	 mov	 DWORD PTR _this$1$[ebp], eax
  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00010	ff 40 04	 inc	 DWORD PTR [eax+4]
  00013	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00016	89 4d f8	 mov	 DWORD PTR __Head$1$[ebp], ecx
  00019	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 654  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

  0001c	3b d1		 cmp	 edx, ecx
  0001e	75 12		 jne	 SHORT $LN5@Insert_nod

; 655  :             _Head->_Left     = _Newnode;

  00020	89 01		 mov	 DWORD PTR [ecx], eax

; 656  :             _Head->_Parent   = _Newnode;

  00022	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 657  :             _Head->_Right    = _Newnode;

  00025	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 658  :             _Newnode->_Color = _Black; // the root is black

  00028	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 717  :     }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 0c 00	 ret	 12			; 0000000cH
$LN5@Insert_nod:

; 659  :             return _Newnode;
; 660  :         }
; 661  : 
; 662  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 663  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

  00032	83 7d 0c 00	 cmp	 DWORD PTR __Loc$[ebp+4], 0
  00036	75 0d		 jne	 SHORT $LN6@Insert_nod

; 664  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 665  :             _Loc._Parent->_Right = _Newnode;

  00038	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 666  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

  0003b	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003e	75 0d		 jne	 SHORT $LN9@Insert_nod

; 667  :                 _Head->_Right = _Newnode;

  00040	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 668  :             }
; 669  :         } else { // add to left of _Loc._Parent

  00043	eb 08		 jmp	 SHORT $LN9@Insert_nod
$LN6@Insert_nod:

; 670  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 671  :             _Loc._Parent->_Left = _Newnode;

  00045	89 02		 mov	 DWORD PTR [edx], eax

; 672  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

  00047	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00049	75 02		 jne	 SHORT $LN9@Insert_nod

; 673  :                 _Head->_Left = _Newnode;

  0004b	89 01		 mov	 DWORD PTR [ecx], eax
$LN9@Insert_nod:

; 674  :             }
; 675  :         }
; 676  : 
; 677  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  0004d	8b d0		 mov	 edx, eax
  0004f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00052	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  00056	0f 85 99 01 00
	00		 jne	 $LN3@Insert_nod
  0005c	53		 push	 ebx
  0005d	56		 push	 esi
  0005e	57		 push	 edi
  0005f	90		 npad	 1
$LL2@Insert_nod:

; 678  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

  00060	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00063	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
  00066	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00069	8d 59 04	 lea	 ebx, DWORD PTR [ecx+4]
  0006c	8b 06		 mov	 eax, DWORD PTR [esi]
  0006e	3b c8		 cmp	 ecx, eax
  00070	0f 85 ba 00 00
	00		 jne	 $LN10@Insert_nod

; 679  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

  00076	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 680  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00079	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  0007d	0f 84 b3 00 00
	00		 je	 $LN53@Insert_nod

; 681  :                     _Pnode->_Parent->_Color          = _Black;
; 682  :                     _Parent_sibling->_Color          = _Black;
; 683  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 684  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 685  :                 } else { // parent's sibling has red and black children
; 686  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

  00083	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00086	3b d6		 cmp	 edx, esi
  00088	75 47		 jne	 SHORT $LN51@Insert_nod

; 466  :         _Wherenode->_Right = _Pnode->_Left;

  0008a	8b 06		 mov	 eax, DWORD PTR [esi]

; 687  :                         _Pnode = _Pnode->_Parent;

  0008c	8b d1		 mov	 edx, ecx

; 466  :         _Wherenode->_Right = _Pnode->_Left;

  0008e	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 467  : 
; 468  :         if (!_Pnode->_Left->_Isnil) {

  00091	8b 06		 mov	 eax, DWORD PTR [esi]
  00093	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00097	75 03		 jne	 SHORT $LN20@Insert_nod

; 469  :             _Pnode->_Left->_Parent = _Wherenode;

  00099	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN20@Insert_nod:

; 470  :         }
; 471  : 
; 472  :         _Pnode->_Parent = _Wherenode->_Parent;

  0009c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0009e	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 473  : 
; 474  :         if (_Wherenode == _Myhead->_Parent) {

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  000a4	8b 00		 mov	 eax, DWORD PTR [eax]
  000a6	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  000a9	75 0b		 jne	 SHORT $LN21@Insert_nod

; 475  :             _Myhead->_Parent = _Pnode;

  000ab	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 483  :         _Wherenode->_Parent = _Pnode;

  000ae	8b fb		 mov	 edi, ebx
  000b0	89 16		 mov	 DWORD PTR [esi], edx
  000b2	89 33		 mov	 DWORD PTR [ebx], esi
  000b4	eb 1d		 jmp	 SHORT $LN49@Insert_nod
$LN21@Insert_nod:

; 476  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  000b6	8b 03		 mov	 eax, DWORD PTR [ebx]
  000b8	3b 10		 cmp	 edx, DWORD PTR [eax]
  000ba	75 0a		 jne	 SHORT $LN23@Insert_nod

; 477  :             _Wherenode->_Parent->_Left = _Pnode;

  000bc	89 30		 mov	 DWORD PTR [eax], esi

; 483  :         _Wherenode->_Parent = _Pnode;

  000be	8b fb		 mov	 edi, ebx
  000c0	89 16		 mov	 DWORD PTR [esi], edx
  000c2	89 33		 mov	 DWORD PTR [ebx], esi
  000c4	eb 0d		 jmp	 SHORT $LN49@Insert_nod
$LN23@Insert_nod:

; 479  :             _Wherenode->_Parent->_Right = _Pnode;

  000c6	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 483  :         _Wherenode->_Parent = _Pnode;

  000c9	8b fb		 mov	 edi, ebx
  000cb	89 16		 mov	 DWORD PTR [esi], edx
  000cd	89 33		 mov	 DWORD PTR [ebx], esi
  000cf	eb 02		 jmp	 SHORT $LN49@Insert_nod
$LN51@Insert_nod:
  000d1	8b f1		 mov	 esi, ecx
$LN49@Insert_nod:

; 688  :                         _Lrotate(_Pnode);
; 689  :                     }
; 690  : 
; 691  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  000d3	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1

; 692  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  000d7	8b 07		 mov	 eax, DWORD PTR [edi]
  000d9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000dc	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 693  :                     _Rrotate(_Pnode->_Parent->_Parent);

  000e0	8b 07		 mov	 eax, DWORD PTR [edi]
  000e2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 487  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  000e5	8b 31		 mov	 esi, DWORD PTR [ecx]

; 488  :         _Wherenode->_Left = _Pnode->_Right;

  000e7	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ea	89 01		 mov	 DWORD PTR [ecx], eax

; 489  : 
; 490  :         if (!_Pnode->_Right->_Isnil) {

  000ec	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ef	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000f3	75 03		 jne	 SHORT $LN27@Insert_nod

; 491  :             _Pnode->_Right->_Parent = _Wherenode;

  000f5	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN27@Insert_nod:

; 492  :         }
; 493  : 
; 494  :         _Pnode->_Parent = _Wherenode->_Parent;

  000f8	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000fb	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 495  : 
; 496  :         if (_Wherenode == _Myhead->_Parent) {

  000fe	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00101	8b 00		 mov	 eax, DWORD PTR [eax]
  00103	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00106	75 0b		 jne	 SHORT $LN28@Insert_nod

; 497  :             _Myhead->_Parent = _Pnode;

  00108	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 502  :         }
; 503  : 
; 504  :         _Pnode->_Right      = _Wherenode;

  0010b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 694  :                 }
; 695  :             } else { // fixup red-red in right subtree

  0010e	e9 cc 00 00 00	 jmp	 $LN52@Insert_nod
$LN28@Insert_nod:

; 498  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00113	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00116	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00119	75 0b		 jne	 SHORT $LN30@Insert_nod

; 499  :             _Wherenode->_Parent->_Right = _Pnode;

  0011b	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 502  :         }
; 503  : 
; 504  :         _Pnode->_Right      = _Wherenode;

  0011e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 694  :                 }
; 695  :             } else { // fixup red-red in right subtree

  00121	e9 b9 00 00 00	 jmp	 $LN52@Insert_nod
$LN30@Insert_nod:

; 501  :             _Wherenode->_Parent->_Left = _Pnode;

  00126	89 30		 mov	 DWORD PTR [eax], esi

; 502  :         }
; 503  : 
; 504  :         _Pnode->_Right      = _Wherenode;

  00128	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 694  :                 }
; 695  :             } else { // fixup red-red in right subtree

  0012b	e9 af 00 00 00	 jmp	 $LN52@Insert_nod
$LN10@Insert_nod:

; 696  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;
; 697  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00130	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  00134	75 1b		 jne	 SHORT $LN15@Insert_nod
$LN53@Insert_nod:

; 674  :             }
; 675  :         }
; 676  : 
; 677  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  00136	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1
  0013a	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  0013e	8b 07		 mov	 eax, DWORD PTR [edi]
  00140	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00143	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0
  00147	8b 07		 mov	 eax, DWORD PTR [edi]
  00149	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0014c	e9 91 00 00 00	 jmp	 $LN46@Insert_nod
$LN15@Insert_nod:

; 698  :                     _Pnode->_Parent->_Color          = _Black;
; 699  :                     _Parent_sibling->_Color          = _Black;
; 700  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 701  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 702  :                 } else { // parent's sibling has red and black children
; 703  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

  00151	8b 01		 mov	 eax, DWORD PTR [ecx]
  00153	3b d0		 cmp	 edx, eax
  00155	75 3e		 jne	 SHORT $LN39@Insert_nod

; 704  :                         _Pnode = _Pnode->_Parent;

  00157	8b d1		 mov	 edx, ecx

; 487  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  00159	8b c8		 mov	 ecx, eax

; 488  :         _Wherenode->_Left = _Pnode->_Right;

  0015b	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0015e	89 02		 mov	 DWORD PTR [edx], eax

; 489  : 
; 490  :         if (!_Pnode->_Right->_Isnil) {

  00160	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00163	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00167	75 03		 jne	 SHORT $LN34@Insert_nod

; 491  :             _Pnode->_Right->_Parent = _Wherenode;

  00169	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN34@Insert_nod:

; 492  :         }
; 493  : 
; 494  :         _Pnode->_Parent = _Wherenode->_Parent;

  0016c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0016e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 495  : 
; 496  :         if (_Wherenode == _Myhead->_Parent) {

  00171	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00174	8b 00		 mov	 eax, DWORD PTR [eax]
  00176	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00179	75 05		 jne	 SHORT $LN35@Insert_nod

; 497  :             _Myhead->_Parent = _Pnode;

  0017b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0017e	eb 0e		 jmp	 SHORT $LN38@Insert_nod
$LN35@Insert_nod:

; 498  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00180	8b 03		 mov	 eax, DWORD PTR [ebx]
  00182	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  00185	75 05		 jne	 SHORT $LN37@Insert_nod

; 499  :             _Wherenode->_Parent->_Right = _Pnode;

  00187	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 500  :         } else {

  0018a	eb 02		 jmp	 SHORT $LN38@Insert_nod
$LN37@Insert_nod:

; 501  :             _Wherenode->_Parent->_Left = _Pnode;

  0018c	89 08		 mov	 DWORD PTR [eax], ecx
$LN38@Insert_nod:

; 502  :         }
; 503  : 
; 504  :         _Pnode->_Right      = _Wherenode;

  0018e	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 505  :         _Wherenode->_Parent = _Pnode;

  00191	8b fb		 mov	 edi, ebx
  00193	89 0b		 mov	 DWORD PTR [ebx], ecx
$LN39@Insert_nod:

; 705  :                         _Rrotate(_Pnode);
; 706  :                     }
; 707  : 
; 708  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  00195	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 709  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00199	8b 07		 mov	 eax, DWORD PTR [edi]
  0019b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019e	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 710  :                     _Lrotate(_Pnode->_Parent->_Parent);

  001a2	8b 07		 mov	 eax, DWORD PTR [edi]
  001a4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 465  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  001a7	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]

; 466  :         _Wherenode->_Right = _Pnode->_Left;

  001aa	8b 06		 mov	 eax, DWORD PTR [esi]
  001ac	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 467  : 
; 468  :         if (!_Pnode->_Left->_Isnil) {

  001af	8b 06		 mov	 eax, DWORD PTR [esi]
  001b1	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  001b5	75 03		 jne	 SHORT $LN41@Insert_nod

; 469  :             _Pnode->_Left->_Parent = _Wherenode;

  001b7	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN41@Insert_nod:

; 470  :         }
; 471  : 
; 472  :         _Pnode->_Parent = _Wherenode->_Parent;

  001ba	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001bd	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 473  : 
; 474  :         if (_Wherenode == _Myhead->_Parent) {

  001c0	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  001c3	8b 00		 mov	 eax, DWORD PTR [eax]
  001c5	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  001c8	75 05		 jne	 SHORT $LN42@Insert_nod

; 475  :             _Myhead->_Parent = _Pnode;

  001ca	89 70 04	 mov	 DWORD PTR [eax+4], esi
  001cd	eb 0e		 jmp	 SHORT $LN45@Insert_nod
$LN42@Insert_nod:

; 476  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  001cf	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001d2	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001d4	75 04		 jne	 SHORT $LN44@Insert_nod

; 477  :             _Wherenode->_Parent->_Left = _Pnode;

  001d6	89 30		 mov	 DWORD PTR [eax], esi

; 478  :         } else {

  001d8	eb 03		 jmp	 SHORT $LN45@Insert_nod
$LN44@Insert_nod:

; 479  :             _Wherenode->_Parent->_Right = _Pnode;

  001da	89 70 08	 mov	 DWORD PTR [eax+8], esi
$LN45@Insert_nod:

; 480  :         }
; 481  : 
; 482  :         _Pnode->_Left       = _Wherenode;

  001dd	89 0e		 mov	 DWORD PTR [esi], ecx
$LN52@Insert_nod:

; 674  :             }
; 675  :         }
; 676  : 
; 677  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  001df	89 71 04	 mov	 DWORD PTR [ecx+4], esi
$LN46@Insert_nod:
  001e2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001e5	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  001e9	0f 84 71 fe ff
	ff		 je	 $LL2@Insert_nod
  001ef	8b 4d f8	 mov	 ecx, DWORD PTR __Head$1$[ebp]
  001f2	5f		 pop	 edi
  001f3	5e		 pop	 esi
  001f4	5b		 pop	 ebx
$LN3@Insert_nod:

; 711  :                 }
; 712  :             }
; 713  :         }
; 714  : 
; 715  :         _Head->_Parent->_Color = _Black; // root is always black

  001f5	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001f8	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 716  :         return _Newnode;

  001fc	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]

; 717  :     }

  001ff	8b e5		 mov	 esp, ebp
  00201	5d		 pop	 ebp
  00202	c2 0c 00	 ret	 12			; 0000000cH
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@2@QAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 134  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 135  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 137  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 85   :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 138  :         _Throw_bad_array_new_length(); // add overflow
; 139  :     }
; 140  : 
; 141  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 85   :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 145  : 
; 146  : #ifdef _DEBUG
; 147  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 148  : #endif // _DEBUG
; 149  :     return _Ptr;
; 150  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength, COMDAT

; 1774 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array, COMDAT
; _this$ = ecx

; 1736 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b f9		 mov	 edi, ecx

; 1737 :         // orphan all iterators, discard old array, acquire new array
; 1738 :         auto& _My_data    = _Mypair._Myval2;
; 1739 :         pointer& _Myfirst = _My_data._Myfirst;
; 1740 :         pointer& _Mylast  = _My_data._Mylast;
; 1741 :         pointer& _Myend   = _My_data._Myend;
; 1742 : 
; 1743 :         _My_data._Orphan_all();
; 1744 : 
; 1745 :         if (_Myfirst) { // destroy and deallocate old array

  00006	8b 07		 mov	 eax, DWORD PTR [edi]
  00008	85 c0		 test	 eax, eax
  0000a	74 51		 je	 SHORT $LN10@Change_arr

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	ff 77 04	 push	 DWORD PTR [edi+4]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00017	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0001a	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001f	8b 37		 mov	 esi, DWORD PTR [edi]

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00021	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00024	2b ce		 sub	 ecx, esi
  00026	f7 e9		 imul	 ecx
  00028	c1 fa 02	 sar	 edx, 2
  0002b	8b c2		 mov	 eax, edx
  0002d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00030	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00032	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00035	c1 e1 03	 shl	 ecx, 3

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00038	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0003e	72 12		 jb	 SHORT $LN20@Change_arr

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00040	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  00043	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00046	2b f2		 sub	 esi, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00048	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  0004b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0004e	77 2f		 ja	 SHORT $LN17@Change_arr

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00050	8b f2		 mov	 esi, edx
$LN20@Change_arr:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00052	51		 push	 ecx
  00053	56		 push	 esi
  00054	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00059	83 c4 08	 add	 esp, 8
  0005c	5e		 pop	 esi
$LN10@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         _Myfirst = _Newvec;

  0005d	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]

; 1751 :         _Mylast  = _Newvec + _Newsize;

  00060	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00063	89 0f		 mov	 DWORD PTR [edi], ecx
  00065	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00068	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  0006b	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1752 :         _Myend   = _Newvec + _Newcapacity;

  0006e	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00071	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00074	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  00077	89 47 08	 mov	 DWORD PTR [edi+8], eax
  0007a	5f		 pop	 edi

; 1753 :     }

  0007b	5d		 pop	 ebp
  0007c	c2 0c 00	 ret	 12			; 0000000cH
$LN17@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0007f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@Change_arr:
  00084	cc		 int	 3
?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy, COMDAT
; _this$ = ecx

; 1678 :     _CONSTEXPR20_CONTAINER void _Destroy(pointer _First, pointer _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1679 :         // destroy [_First, _Last) using allocator
; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00003	51		 push	 ecx
  00004	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00007	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000a	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0000f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1681 :     }

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back, COMDAT
; _this$ = ecx

; 759  :     _CONSTEXPR20_CONTAINER void push_back(_Ty&& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 743  :         if (_Mylast != _My_data._Myend) {

  00003	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00006	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00009	74 40		 je	 SHORT $LN4@push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0000b	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0000e	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 2355 :     size_type _Mysize = 0; // current length of string

  00014	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0

; 2356 :     size_type _Myres  = 0; // current storage reserved for string

  0001b	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00022	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00025	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  00028	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  0002d	66 0f d6 42 10	 movq	 QWORD PTR [edx+16], xmm0

; 4596 :         _My_data._Mysize = 0;

  00032	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00039	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00040	c6 00 00	 mov	 BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 729  :         ++_Mylast;

  00043	83 41 04 18	 add	 DWORD PTR [ecx+4], 24	; 00000018H

; 760  :         // insert by moving into element at end, provide strong guarantee
; 761  :         emplace_back(_STD move(_Val));
; 762  :     }

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN4@push_back:

; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0004b	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  0004e	52		 push	 edx
  0004f	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 760  :         // insert by moving into element at end, provide strong guarantee
; 761  :         emplace_back(_STD move(_Val));
; 762  :     }

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 65		 je	 SHORT $LN4@vector

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00009	57		 push	 edi
  0000a	56		 push	 esi
  0000b	ff 76 04	 push	 DWORD PTR [esi+4]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00014	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00017	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001c	8b 3e		 mov	 edi, DWORD PTR [esi]

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00021	2b cf		 sub	 ecx, edi
  00023	f7 e9		 imul	 ecx
  00025	c1 fa 02	 sar	 edx, 2
  00028	8b c2		 mov	 eax, edx
  0002a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002d	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0002f	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00032	c1 e1 03	 shl	 ecx, 3

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00035	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0003b	72 12		 jb	 SHORT $LN22@vector

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0003d	8b 57 fc	 mov	 edx, DWORD PTR [edi-4]
  00040	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00043	2b fa		 sub	 edi, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  00048	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0004b	77 23		 ja	 SHORT $LN19@vector

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0004d	8b fa		 mov	 edi, edx
$LN22@vector:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0004f	51		 push	 ecx
  00050	57		 push	 edi
  00051	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00056	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  00059	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1768 :             _Mylast  = nullptr;

  0005f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1769 :             _Myend   = nullptr;

  00066	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0006d	5f		 pop	 edi
$LN4@vector:
  0006e	5e		 pop	 esi

; 717  :     }

  0006f	c3		 ret	 0
$LN19@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00070	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN27@vector:
  00075	cc		 int	 3
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate, COMDAT
; _this$ = ecx

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00009	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000c	c1 e1 03	 shl	 ecx, 3

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000f	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00015	72 12		 jb	 SHORT $LN15@deallocate

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00017	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001a	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001d	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001f	83 c0 fc	 add	 eax, -4			; fffffffcH
  00022	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00025	77 10		 ja	 SHORT $LN12@deallocate

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00027	8b c2		 mov	 eax, edx
$LN15@deallocate:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00029	51		 push	 ecx
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00030	83 c4 08	 add	 esp, 8

; 836  :     }

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
$LN12@deallocate:

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00037	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN18@deallocate:
  0003c	cc		 int	 3
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?_Throw_tree_length_error@std@@YAXXZ
_TEXT	SEGMENT
?_Throw_tree_length_error@std@@YAXXZ PROC		; std::_Throw_tree_length_error, COMDAT

; 421  :     _Xlength_error("map/set too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GCADKGJO@map?1set?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Throw_tree:
  0000a	cc		 int	 3
?_Throw_tree_length_error@std@@YAXXZ ENDP		; std::_Throw_tree_length_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr, COMDAT
; _this$ = ecx

; 4365 :         const size_type _Off = 0, const size_type _Count = npos) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2324 :         if (_Mysize < _Off) {

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Off$[ebp]

; 4365 :         const size_type _Off = 0, const size_type _Count = npos) const {

  00006	56		 push	 esi

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00007	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]

; 4365 :         const size_type _Off = 0, const size_type _Count = npos) const {

  0000a	57		 push	 edi

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0000b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 4596 :         _My_data._Mysize = 0;

  00011	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00018	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0001f	c6 06 00	 mov	 BYTE PTR [esi], 0

; 2324 :         if (_Mysize < _Off) {

  00022	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00025	3b c2		 cmp	 eax, edx
  00027	72 25		 jb	 SHORT $LN36@substr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00029	8b 7d 10	 mov	 edi, DWORD PTR __Count$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2342 :         return (_STD min)(_Size, _Mysize - _Off);

  0002c	2b c2		 sub	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0002e	3b c7		 cmp	 eax, edi
  00030	0f 42 f8	 cmovb	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00033	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 2306 :         if (_Large_string_engaged()) {

  00037	72 02		 jb	 SHORT $LN28@substr

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN28@substr:

; 3224 :         return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);

  0003b	03 ca		 add	 ecx, edx
  0003d	57		 push	 edi
  0003e	51		 push	 ecx
  0003f	8b ce		 mov	 ecx, esi
  00041	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 4366 :         // return [_Off, _Off + _Count) as new string
; 4367 :         return basic_string(*this, _Off, _Count, get_allocator());

  00046	5f		 pop	 edi
  00047	8b c6		 mov	 eax, esi
  00049	5e		 pop	 esi

; 4368 :     }

  0004a	5d		 pop	 ebp
  0004b	c2 0c 00	 ret	 12			; 0000000cH
$LN36@substr:

; 2325 :             _Xran();

  0004e	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN34@substr:
  00053	cc		 int	 3
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 2319 :         return _BUF_SIZE <= _Myres;

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 2306 :         if (_Large_string_engaged()) {

  00004	72 03		 jb	 SHORT $LN8@c_str

; 3922 :         return _Mypair._Myval2._Myptr();

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 3923 :     }

  00008	c3		 ret	 0
$LN8@c_str:

; 3922 :         return _Mypair._Myval2._Myptr();

  00009	8b c1		 mov	 eax, ecx

; 3923 :     }

  0000b	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Old$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
$T1 = 12						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3244 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 3245 :         // assign [_Ptr, _Ptr + _Count)
; 3246 :         if (_Count <= _Mypair._Myval2._Myres) {

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	57		 push	 edi
  0000c	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0000f	89 4d fc	 mov	 DWORD PTR __Old$1$[ebp], ecx
  00012	3b d9		 cmp	 ebx, ecx
  00014	77 28		 ja	 SHORT $LN2@assign

; 2296 :         value_type* _Result = _Bx._Buf;

  00016	8b fe		 mov	 edi, esi

; 2319 :         return _BUF_SIZE <= _Myres;

  00018	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 2297 :         if (_Large_string_engaged()) {

  0001b	72 02		 jb	 SHORT $LN5@assign

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  0001d	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN5@assign:

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0001f	53		 push	 ebx
  00020	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 3247 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3248 :             _Mypair._Myval2._Mysize = _Count;

  00023	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00026	57		 push	 edi
  00027	e8 00 00 00 00	 call	 _memmove
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3249 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0002f	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 3259 :             },
; 3260 :             _Ptr);
; 3261 :     }

  00033	8b c6		 mov	 eax, esi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
$LN2@assign:

; 4508 :         if (_New_size > max_size()) {

  0003e	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  00044	0f 87 d4 00 00
	00		 ja	 $LN60@assign

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0004a	8b fb		 mov	 edi, ebx
  0004c	83 cf 0f	 or	 edi, 15			; 0000000fH
  0004f	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH

; 4489 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00055	76 15		 jbe	 SHORT $LN19@assign

; 4490 :             return _Max;

  00057	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0005c	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00067	83 c4 04	 add	 esp, 4
  0006a	eb 52		 jmp	 SHORT $LN58@assign
$LN19@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4493 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0006c	8b d1		 mov	 edx, ecx
  0006e	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00073	d1 ea		 shr	 edx, 1
  00075	2b c2		 sub	 eax, edx
  00077	3b c8		 cmp	 ecx, eax
  00079	76 15		 jbe	 SHORT $LN20@assign

; 4494 :             return _Max;

  0007b	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00080	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0008b	83 c4 04	 add	 esp, 4
  0008e	eb 2e		 jmp	 SHORT $LN58@assign
$LN20@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4497 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00090	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00093	3b f8		 cmp	 edi, eax
  00095	0f 42 f8	 cmovb	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4515 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00098	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0009b	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000a0	72 0b		 jb	 SHORT $LN27@assign

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a8	83 c4 04	 add	 esp, 4
  000ab	eb 11		 jmp	 SHORT $LN58@assign
$LN27@assign:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  000ad	85 c0		 test	 eax, eax
  000af	74 0b		 je	 SHORT $LN28@assign

; 85   :         return ::operator new(_Bytes);

  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000b7	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  000ba	eb 02		 jmp	 SHORT $LN58@assign
$LN28@assign:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000bc	33 c0		 xor	 eax, eax
$LN58@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000be	53		 push	 ebx
  000bf	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 4523 :         _Mypair._Myval2._Mysize = _New_size;

  000c2	89 45 0c	 mov	 DWORD PTR $T1[ebp], eax

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c5	50		 push	 eax

; 4523 :         _Mypair._Myval2._Mysize = _New_size;

  000c6	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 4524 :         _Mypair._Myval2._Myres  = _New_capacity;

  000c9	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000cc	e8 00 00 00 00	 call	 _memcpy

; 3258 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000d1	8b 7d 0c	 mov	 edi, DWORD PTR $T1[ebp]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4526 :         if (_BUF_SIZE <= _Old_capacity) {

  000d7	8b 45 fc	 mov	 eax, DWORD PTR __Old$1$[ebp]

; 3258 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000da	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 4526 :         if (_BUF_SIZE <= _Old_capacity) {

  000de	83 f8 10	 cmp	 eax, 16			; 00000010H
  000e1	72 29		 jb	 SHORT $LN13@assign

; 4527 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  000e3	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e6	8b 06		 mov	 eax, DWORD PTR [esi]

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000e8	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000ee	72 12		 jb	 SHORT $LN50@assign

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f0	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000f3	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000f6	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000f8	83 c0 fc	 add	 eax, -4			; fffffffcH
  000fb	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000fe	77 19		 ja	 SHORT $LN47@assign

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00100	8b c2		 mov	 eax, edx
$LN50@assign:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00102	51		 push	 ecx
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00109	83 c4 08	 add	 esp, 8
$LN13@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3254 :         return _Reallocate_for(

  0010c	89 3e		 mov	 DWORD PTR [esi], edi

; 3259 :             },
; 3260 :             _Ptr);
; 3261 :     }

  0010e	8b c6		 mov	 eax, esi
  00110	5f		 pop	 edi
  00111	5e		 pop	 esi
  00112	5b		 pop	 ebx
  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c2 08 00	 ret	 8
$LN47@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00119	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN60@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4509 :             _Xlen_string(); // result too long

  0011e	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN56@assign:
  00123	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
tv533 = -12						; size = 4
__Old$1$ = -8						; size = 4
tv534 = -4						; size = 4
__Old_size$1$ = -4					; size = 4
__Ptr$ = 8						; size = 4
tv537 = 12						; size = 4
$T1 = 12						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 3152 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 3153 :         // append [_Ptr, _Ptr + _Count)
; 3154 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3155 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  00011	8b c2		 mov	 eax, edx
  00013	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00016	2b c1		 sub	 eax, ecx
  00018	89 4d fc	 mov	 DWORD PTR __Old_size$1$[ebp], ecx
  0001b	89 55 f8	 mov	 DWORD PTR __Old$1$[ebp], edx
  0001e	3b d8		 cmp	 ebx, eax
  00020	77 2e		 ja	 SHORT $LN2@append

; 3156 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00022	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00025	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 2296 :         value_type* _Result = _Bx._Buf;

  00028	8b c7		 mov	 eax, edi

; 2319 :         return _BUF_SIZE <= _Myres;

  0002a	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2297 :         if (_Large_string_engaged()) {

  0002d	72 02		 jb	 SHORT $LN5@append

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  0002f	8b 07		 mov	 eax, DWORD PTR [edi]
$LN5@append:

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00031	53		 push	 ebx
  00032	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 3157 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3158 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00035	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00038	56		 push	 esi
  00039	e8 00 00 00 00	 call	 _memmove
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3159 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00041	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0

; 3172 :     }

  00045	8b c7		 mov	 eax, edi
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8
$LN2@append:

; 4543 :         if (max_size() - _Old_size < _Size_increase) {

  00050	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00055	2b c1		 sub	 eax, ecx
  00057	3b c3		 cmp	 eax, ebx
  00059	0f 82 26 01 00
	00		 jb	 $LN68@append

; 4545 :         }
; 4546 : 
; 4547 :         const size_type _New_size     = _Old_size + _Size_increase;

  0005f	8d 34 19	 lea	 esi, DWORD PTR [ecx+ebx]

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00062	83 ce 0f	 or	 esi, 15			; 0000000fH
  00065	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 4489 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0006b	76 18		 jbe	 SHORT $LN19@append

; 4490 :             return _Max;

  0006d	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00072	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  00080	83 c4 04	 add	 esp, 4
  00083	eb 61		 jmp	 SHORT $LN66@append
$LN19@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4493 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00085	8b c2		 mov	 eax, edx
  00087	d1 e8		 shr	 eax, 1
  00089	89 45 0c	 mov	 DWORD PTR tv537[ebp], eax
  0008c	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00091	2b 45 0c	 sub	 eax, DWORD PTR tv537[ebp]
  00094	3b d0		 cmp	 edx, eax
  00096	76 18		 jbe	 SHORT $LN20@append

; 4494 :             return _Max;

  00098	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0009d	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  000ab	83 c4 04	 add	 esp, 4
  000ae	eb 36		 jmp	 SHORT $LN66@append
$LN20@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4497 :         return (_STD max)(_Masked, _Old + _Old / 2);

  000b0	8b 45 0c	 mov	 eax, DWORD PTR tv537[ebp]
  000b3	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  000b5	3b f0		 cmp	 esi, eax
  000b7	0f 42 f0	 cmovb	 esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4551 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  000ba	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000bd	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000c2	72 0e		 jb	 SHORT $LN27@append

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000ca	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  000cd	83 c4 04	 add	 esp, 4
  000d0	eb 14		 jmp	 SHORT $LN66@append
$LN27@append:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  000d2	85 c0		 test	 eax, eax
  000d4	74 0e		 je	 SHORT $LN28@append

; 85   :         return ::operator new(_Bytes);

  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 244  :         return _Traits::_Allocate(_Bytes);

  000dc	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]

; 85   :         return ::operator new(_Bytes);

  000df	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  000e2	eb 02		 jmp	 SHORT $LN66@append
$LN28@append:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000e4	33 c0		 xor	 eax, eax
$LN66@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4562 :         if (_BUF_SIZE <= _Old_capacity) {

  000e6	83 7d f8 10	 cmp	 DWORD PTR __Old$1$[ebp], 16 ; 00000010H
  000ea	8d 14 19	 lea	 edx, DWORD PTR [ecx+ebx]
  000ed	89 77 14	 mov	 DWORD PTR [edi+20], esi
  000f0	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  000f3	89 57 10	 mov	 DWORD PTR [edi+16], edx
  000f6	8d 14 1e	 lea	 edx, DWORD PTR [esi+ebx]
  000f9	89 45 0c	 mov	 DWORD PTR $T1[ebp], eax
  000fc	89 75 fc	 mov	 DWORD PTR tv534[ebp], esi
  000ff	89 55 f4	 mov	 DWORD PTR tv533[ebp], edx
  00102	51		 push	 ecx
  00103	72 56		 jb	 SHORT $LN13@append

; 4563 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  00105	8b 37		 mov	 esi, DWORD PTR [edi]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00107	56		 push	 esi
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 _memcpy
  0010e	53		 push	 ebx
  0010f	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00112	ff 75 fc	 push	 DWORD PTR tv534[ebp]
  00115	e8 00 00 00 00	 call	 _memcpy

; 3169 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0011a	8b 45 f4	 mov	 eax, DWORD PTR tv533[ebp]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0011d	83 c4 18	 add	 esp, 24			; 00000018H

; 4565 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  00120	8b 4d f8	 mov	 ecx, DWORD PTR __Old$1$[ebp]
  00123	41		 inc	 ecx

; 3169 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00124	c6 00 00	 mov	 BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00127	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0012d	72 12		 jb	 SHORT $LN52@append

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0012f	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  00132	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00135	2b f2		 sub	 esi, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00137	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  0013a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0013d	77 4b		 ja	 SHORT $LN49@append

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0013f	8b f2		 mov	 esi, edx
$LN52@append:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00141	51		 push	 ecx
  00142	56		 push	 esi
  00143	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3163 :         return _Reallocate_grow_by(

  00148	8b 45 0c	 mov	 eax, DWORD PTR $T1[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  0014b	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3163 :         return _Reallocate_grow_by(

  0014e	89 07		 mov	 DWORD PTR [edi], eax

; 3172 :     }

  00150	8b c7		 mov	 eax, edi
  00152	5f		 pop	 edi
  00153	5e		 pop	 esi
  00154	5b		 pop	 ebx
  00155	8b e5		 mov	 esp, ebp
  00157	5d		 pop	 ebp
  00158	c2 08 00	 ret	 8
$LN13@append:

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0015b	57		 push	 edi
  0015c	50		 push	 eax
  0015d	e8 00 00 00 00	 call	 _memcpy
  00162	53		 push	 ebx
  00163	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00166	56		 push	 esi
  00167	e8 00 00 00 00	 call	 _memcpy

; 3169 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0016c	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0016f	83 c4 18	 add	 esp, 24			; 00000018H

; 3169 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00172	c6 00 00	 mov	 BYTE PTR [eax], 0

; 3163 :         return _Reallocate_grow_by(

  00175	8b 45 0c	 mov	 eax, DWORD PTR $T1[ebp]
  00178	89 07		 mov	 DWORD PTR [edi], eax

; 3172 :     }

  0017a	8b c7		 mov	 eax, edi
  0017c	5f		 pop	 edi
  0017d	5e		 pop	 esi
  0017e	5b		 pop	 ebx
  0017f	8b e5		 mov	 esp, ebp
  00181	5d		 pop	 ebp
  00182	c2 08 00	 ret	 8
$LN68@append:

; 4544 :             _Xlen_string(); // result too long

  00185	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN49@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0018a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN64@append:
  0018f	cc		 int	 3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 3114 :     _CONSTEXPR20_CONTAINER basic_string& operator+=(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	8b c2		 mov	 eax, edx

; 3114 :     _CONSTEXPR20_CONTAINER basic_string& operator+=(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f1		 mov	 esi, ecx

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0000c	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000f	90		 npad	 1
$LL7@operator:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL7@operator
  00017	2b c7		 sub	 eax, edi

; 3175 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00019	8b ce		 mov	 ecx, esi
  0001b	50		 push	 eax
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 3115 :         return append(_Ptr);

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi

; 3116 :     }

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 3091 :     _CONSTEXPR20_CONTAINER basic_string& operator=(_In_z_ const _Elem* const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	8b c2		 mov	 eax, edx

; 3091 :     _CONSTEXPR20_CONTAINER basic_string& operator=(_In_z_ const _Elem* const _Ptr) {

  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f1		 mov	 esi, ecx

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0000c	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000f	90		 npad	 1
$LL7@operator:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL7@operator
  00017	2b c7		 sub	 eax, edi

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00019	8b ce		 mov	 ecx, esi
  0001b	50		 push	 eax
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 3092 :         return assign(_Ptr);

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi

; 3093 :     }

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 3076 :     _CONSTEXPR20_CONTAINER basic_string& operator=(const basic_string& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3077 :         if (this != _STD addressof(_Right)) {

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	3b f0		 cmp	 esi, eax
  0000b	74 15		 je	 SHORT $LN11@operator

; 2319 :         return _BUF_SIZE <= _Myres;

  0000d	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 2305 :         const value_type* _Result = _Bx._Buf;

  00011	8b c8		 mov	 ecx, eax

; 2306 :         if (_Large_string_engaged()) {

  00013	72 02		 jb	 SHORT $LN7@operator

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
$LN7@operator:

; 3035 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00017	ff 70 10	 push	 DWORD PTR [eax+16]
  0001a	51		 push	 ecx
  0001b	8b ce		 mov	 ecx, esi
  0001d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN11@operator:

; 3078 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});
; 3079 :         }
; 3080 : 
; 3081 :         return *this;
; 3082 :     }

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 3002 :     _CONSTEXPR20_CONTAINER ~basic_string() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2319 :         return _BUF_SIZE <= _Myres;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 27		 jb	 SHORT $LN12@basic_stri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0000d	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN22@basic_stri

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN19@basic_stri

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN22@basic_stri:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN12@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi

; 3010 :     }

  00044	c3		 ret	 0
$LN19@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN27@basic_stri:
  0004a	cc		 int	 3
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2517 :     _CONSTEXPR20_CONTAINER basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	8b c2		 mov	 eax, edx

; 2517 :     _CONSTEXPR20_CONTAINER basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	57		 push	 edi

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0000c	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 4596 :         _My_data._Mysize = 0;

  00015	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0001c	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
$LL17@basic_stri:

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00023	8a 08		 mov	 cl, BYTE PTR [eax]
  00025	40		 inc	 eax
  00026	84 c9		 test	 cl, cl
  00028	75 f9		 jne	 SHORT $LL17@basic_stri
  0002a	2b c7		 sub	 eax, edi

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0002c	8b ce		 mov	 ecx, esi
  0002e	50		 push	 eax
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2518 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2519 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2520 :         _Tidy_init();
; 2521 :         assign(_Ptr);
; 2522 :         _Proxy._Release();
; 2523 :     }

  00035	5f		 pop	 edi
  00036	8b c6		 mov	 eax, esi
  00038	5e		 pop	 esi
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right_size$1$ = 8					; size = 4
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2451 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	57		 push	 edi

; 2921 :         const size_type _Right_size   = _Right_data._Mysize;

  00008	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0000b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 2355 :     size_type _Mysize = 0; // current length of string

  00011	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 2356 :     size_type _Myres  = 0; // current storage reserved for string

  00018	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 2319 :         return _BUF_SIZE <= _Myres;

  0001f	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H

; 2921 :         const size_type _Right_size   = _Right_data._Mysize;

  00023	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00026	89 4d 08	 mov	 DWORD PTR __Right_size$1$[ebp], ecx

; 2306 :         if (_Large_string_engaged()) {

  00029	72 02		 jb	 SHORT $LN15@basic_stri

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  0002b	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN15@basic_stri:

; 2928 :         const bool _Stay_small = _Right_size < _BUF_SIZE;

  0002d	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 2929 : #endif // __cpp_lib_constexpr_string
; 2930 : 
; 2931 :         // NOTE: even if _Right is in large mode, we only go into large mode ourselves if the actual size of _Right
; 2932 :         // requires it
; 2933 :         if (_Stay_small) { // stay small, don't allocate

  00030	73 1a		 jae	 SHORT $LN12@basic_stri

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00032	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]

; 2936 :             _My_data._Myres  = _BUF_SIZE - 1;

  00035	bb 0f 00 00 00	 mov	 ebx, 15			; 0000000fH

; 2452 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2453 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2454 :         _Construct_lv_contents(_Right);
; 2455 :         _Proxy._Release();
; 2456 :     }

  0003a	8b c6		 mov	 eax, esi
  0003c	5f		 pop	 edi

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0003d	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0

; 2452 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2453 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2454 :         _Construct_lv_contents(_Right);
; 2455 :         _Proxy._Release();
; 2456 :     }

  00040	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  00043	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
$LN12@basic_stri:

; 2941 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  0004c	8b d9		 mov	 ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0004e	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2941 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  00053	83 cb 0f	 or	 ebx, 15			; 0000000fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00056	3b d8		 cmp	 ebx, eax
  00058	0f 47 d8	 cmova	 ebx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2942 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  0005b	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0005e	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00063	72 0d		 jb	 SHORT $LN26@basic_stri

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0006b	83 c4 04	 add	 esp, 4
  0006e	8b c8		 mov	 ecx, eax
  00070	eb 13		 jmp	 SHORT $LN25@basic_stri
$LN26@basic_stri:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  00072	85 c0		 test	 eax, eax
  00074	74 0d		 je	 SHORT $LN27@basic_stri

; 85   :         return ::operator new(_Bytes);

  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0007c	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  0007f	8b c8		 mov	 ecx, eax
  00081	eb 02		 jmp	 SHORT $LN25@basic_stri
$LN27@basic_stri:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  00083	33 c9		 xor	 ecx, ecx
$LN25@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2950 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  00085	8b 45 08	 mov	 eax, DWORD PTR __Right_size$1$[ebp]
  00088	40		 inc	 eax
  00089	89 0e		 mov	 DWORD PTR [esi], ecx

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0008b	50		 push	 eax
  0008c	57		 push	 edi
  0008d	51		 push	 ecx
  0008e	e8 00 00 00 00	 call	 _memcpy
  00093	8b 4d 08	 mov	 ecx, DWORD PTR __Right_size$1$[ebp]
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2452 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2453 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2454 :         _Construct_lv_contents(_Right);
; 2455 :         _Proxy._Release();
; 2456 :     }

  00099	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0009c	8b c6		 mov	 eax, esi
  0009e	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx
  000a4	5d		 pop	 ebp
  000a5	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 2337 :         _Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2374 :     _Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlen_strin:
  0000a	cc		 int	 3
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN12@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 142  :     }

  00003	8b c1		 mov	 eax, ecx

; 65   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 66   :     {
; 67   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 141  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN6@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 96   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 91   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 74   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _sscanf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sscanf	PROC						; COMDAT

; 2247 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2153 :         return __stdio_common_vsscanf(

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_scanf_options
  00016	ff 70 04	 push	 DWORD PTR [eax+4]
  00019	ff 30		 push	 DWORD PTR [eax]
  0001b	e8 00 00 00 00	 call	 ___stdio_common_vsscanf
  00020	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);
; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);
; 2252 :         __crt_va_end(_ArgList);
; 2253 :         return _Result;
; 2254 :     }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
_sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT __snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__snprintf PROC						; COMDAT

; 1947 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00003	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1948 :         int _Result;
; 1949 :         va_list _ArgList;
; 1950 :         __crt_va_start(_ArgList, _Format);
; 1951 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1952 :         __crt_va_end(_ArgList);
; 1953 :         return _Result;
; 1954 :     }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_scanf_options
_TEXT	SEGMENT
___local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00005	c3		 ret	 0
___local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\GameLib\RaceManager.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 16		 je	 SHORT $LN6@vector
  0000b	53		 push	 ebx
  0000c	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000f	57		 push	 edi
  00010	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00013	8b cf		 mov	 ecx, edi
  00015	ff d3		 call	 ebx
  00017	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  0001a	83 ee 01	 sub	 esi, 1
  0001d	75 f4		 jne	 SHORT $LL2@vector
  0001f	5f		 pop	 edi
  00020	5b		 pop	 ebx
$LN6@vector:
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
