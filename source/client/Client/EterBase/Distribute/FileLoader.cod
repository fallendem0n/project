; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30137.0 

	TITLE	C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\Distribute\FileLoader.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??0CMemoryTextFileLoader@@QAE@XZ		; CMemoryTextFileLoader::CMemoryTextFileLoader
PUBLIC	??1CMemoryTextFileLoader@@UAE@XZ		; CMemoryTextFileLoader::~CMemoryTextFileLoader
PUBLIC	?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z		; CMemoryTextFileLoader::Bind
PUBLIC	?GetLineCount@CMemoryTextFileLoader@@QAEKXZ	; CMemoryTextFileLoader::GetLineCount
PUBLIC	?CheckLineIndex@CMemoryTextFileLoader@@QAE_NK@Z	; CMemoryTextFileLoader::CheckLineIndex
PUBLIC	?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z ; CMemoryTextFileLoader::SplitLine
PUBLIC	?SplitLine2@CMemoryTextFileLoader@@QAEHKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z ; CMemoryTextFileLoader::SplitLine2
PUBLIC	?SplitLineByTab@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; CMemoryTextFileLoader::SplitLineByTab
PUBLIC	?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; CMemoryTextFileLoader::GetLineString
PUBLIC	?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
PUBLIC	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?_Reallocate_exactly@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate_exactly
PUBLIC	?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
PUBLIC	?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array
PUBLIC	?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
PUBLIC	??_GCMemoryTextFileLoader@@UAEPAXI@Z		; CMemoryTextFileLoader::`scalar deleting destructor'
PUBLIC	??0CMemoryFileLoader@@QAE@HPBX@Z		; CMemoryFileLoader::CMemoryFileLoader
PUBLIC	??1CMemoryFileLoader@@UAE@XZ			; CMemoryFileLoader::~CMemoryFileLoader
PUBLIC	?Read@CMemoryFileLoader@@QAE_NHPAX@Z		; CMemoryFileLoader::Read
PUBLIC	?GetPosition@CMemoryFileLoader@@QAEHXZ		; CMemoryFileLoader::GetPosition
PUBLIC	?GetSize@CMemoryFileLoader@@QAEHXZ		; CMemoryFileLoader::GetSize
PUBLIC	?IsReadableSize@CMemoryFileLoader@@IAE_NH@Z	; CMemoryFileLoader::IsReadableSize
PUBLIC	?GetCurrentPositionPointer@CMemoryFileLoader@@IAEPBDXZ ; CMemoryFileLoader::GetCurrentPositionPointer
PUBLIC	??_GCMemoryFileLoader@@UAEPAXI@Z		; CMemoryFileLoader::`scalar deleting destructor'
PUBLIC	??0CDiskFileLoader@@QAE@XZ			; CDiskFileLoader::CDiskFileLoader
PUBLIC	??1CDiskFileLoader@@UAE@XZ			; CDiskFileLoader::~CDiskFileLoader
PUBLIC	?Close@CDiskFileLoader@@QAEXXZ			; CDiskFileLoader::Close
PUBLIC	?Open@CDiskFileLoader@@QAE_NPBD@Z		; CDiskFileLoader::Open
PUBLIC	?Read@CDiskFileLoader@@QAE_NHPAX@Z		; CDiskFileLoader::Read
PUBLIC	?GetSize@CDiskFileLoader@@QAEHXZ		; CDiskFileLoader::GetSize
PUBLIC	?Initialize@CDiskFileLoader@@IAEXXZ		; CDiskFileLoader::Initialize
PUBLIC	??_GCDiskFileLoader@@UAEPAXI@Z			; CDiskFileLoader::`scalar deleting destructor'
PUBLIC	??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
PUBLIC	??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_7CMemoryTextFileLoader@@6B@			; CMemoryTextFileLoader::`vftable'
PUBLIC	??_7CMemoryFileLoader@@6B@			; CMemoryFileLoader::`vftable'
PUBLIC	??_7CDiskFileLoader@@6B@			; CDiskFileLoader::`vftable'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CMemoryTextFileLoader@@6B@			; CMemoryTextFileLoader::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCMemoryTextFileLoader@@@8		; CMemoryTextFileLoader `RTTI Type Descriptor'
PUBLIC	??_R3CMemoryTextFileLoader@@8			; CMemoryTextFileLoader::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CMemoryTextFileLoader@@8			; CMemoryTextFileLoader::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CMemoryTextFileLoader@@8		; CMemoryTextFileLoader::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CMemoryFileLoader@@6B@			; CMemoryFileLoader::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCMemoryFileLoader@@@8			; CMemoryFileLoader `RTTI Type Descriptor'
PUBLIC	??_R3CMemoryFileLoader@@8			; CMemoryFileLoader::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CMemoryFileLoader@@8			; CMemoryFileLoader::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CMemoryFileLoader@@8		; CMemoryFileLoader::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CDiskFileLoader@@6B@			; CDiskFileLoader::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCDiskFileLoader@@@8			; CDiskFileLoader `RTTI Type Descriptor'
PUBLIC	??_R3CDiskFileLoader@@8				; CDiskFileLoader::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDiskFileLoader@@8				; CDiskFileLoader::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CDiskFileLoader@@8		; CDiskFileLoader::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	_fread:PROC
EXTRN	_fseek:PROC
EXTRN	_ftell:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_ECMemoryTextFileLoader@@UAEPAXI@Z:PROC	; CMemoryTextFileLoader::`vector deleting destructor'
EXTRN	??_ECMemoryFileLoader@@UAEPAXI@Z:PROC		; CMemoryFileLoader::`vector deleting destructor'
EXTRN	??_ECDiskFileLoader@@UAEPAXI@Z:PROC		; CDiskFileLoader::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memchr:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ??_R1A@?0A@EA@CDiskFileLoader@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CDiskFileLoader@@8 DD FLAT:??_R0?AVCDiskFileLoader@@@8 ; CDiskFileLoader::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CDiskFileLoader@@8
rdata$r	ENDS
;	COMDAT ??_R2CDiskFileLoader@@8
rdata$r	SEGMENT
??_R2CDiskFileLoader@@8 DD FLAT:??_R1A@?0A@EA@CDiskFileLoader@@8 ; CDiskFileLoader::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CDiskFileLoader@@8
rdata$r	SEGMENT
??_R3CDiskFileLoader@@8 DD 00H				; CDiskFileLoader::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CDiskFileLoader@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDiskFileLoader@@@8
data$rs	SEGMENT
??_R0?AVCDiskFileLoader@@@8 DD FLAT:??_7type_info@@6B@	; CDiskFileLoader `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDiskFileLoader@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CDiskFileLoader@@6B@
rdata$r	SEGMENT
??_R4CDiskFileLoader@@6B@ DD 00H			; CDiskFileLoader::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDiskFileLoader@@@8
	DD	FLAT:??_R3CDiskFileLoader@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CMemoryFileLoader@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CMemoryFileLoader@@8 DD FLAT:??_R0?AVCMemoryFileLoader@@@8 ; CMemoryFileLoader::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CMemoryFileLoader@@8
rdata$r	ENDS
;	COMDAT ??_R2CMemoryFileLoader@@8
rdata$r	SEGMENT
??_R2CMemoryFileLoader@@8 DD FLAT:??_R1A@?0A@EA@CMemoryFileLoader@@8 ; CMemoryFileLoader::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CMemoryFileLoader@@8
rdata$r	SEGMENT
??_R3CMemoryFileLoader@@8 DD 00H			; CMemoryFileLoader::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CMemoryFileLoader@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMemoryFileLoader@@@8
data$rs	SEGMENT
??_R0?AVCMemoryFileLoader@@@8 DD FLAT:??_7type_info@@6B@ ; CMemoryFileLoader `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMemoryFileLoader@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CMemoryFileLoader@@6B@
rdata$r	SEGMENT
??_R4CMemoryFileLoader@@6B@ DD 00H			; CMemoryFileLoader::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCMemoryFileLoader@@@8
	DD	FLAT:??_R3CMemoryFileLoader@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CMemoryTextFileLoader@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CMemoryTextFileLoader@@8 DD FLAT:??_R0?AVCMemoryTextFileLoader@@@8 ; CMemoryTextFileLoader::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CMemoryTextFileLoader@@8
rdata$r	ENDS
;	COMDAT ??_R2CMemoryTextFileLoader@@8
rdata$r	SEGMENT
??_R2CMemoryTextFileLoader@@8 DD FLAT:??_R1A@?0A@EA@CMemoryTextFileLoader@@8 ; CMemoryTextFileLoader::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CMemoryTextFileLoader@@8
rdata$r	SEGMENT
??_R3CMemoryTextFileLoader@@8 DD 00H			; CMemoryTextFileLoader::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CMemoryTextFileLoader@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMemoryTextFileLoader@@@8
data$rs	SEGMENT
??_R0?AVCMemoryTextFileLoader@@@8 DD FLAT:??_7type_info@@6B@ ; CMemoryTextFileLoader `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMemoryTextFileLoader@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CMemoryTextFileLoader@@6B@
rdata$r	SEGMENT
??_R4CMemoryTextFileLoader@@6B@ DD 00H			; CMemoryTextFileLoader::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCMemoryTextFileLoader@@@8
	DD	FLAT:??_R3CMemoryTextFileLoader@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_7CDiskFileLoader@@6B@
CONST	SEGMENT
??_7CDiskFileLoader@@6B@ DD FLAT:??_R4CDiskFileLoader@@6B@ ; CDiskFileLoader::`vftable'
	DD	FLAT:??_ECDiskFileLoader@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CMemoryFileLoader@@6B@
CONST	SEGMENT
??_7CMemoryFileLoader@@6B@ DD FLAT:??_R4CMemoryFileLoader@@6B@ ; CMemoryFileLoader::`vftable'
	DD	FLAT:??_ECMemoryFileLoader@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CMemoryTextFileLoader@@6B@
CONST	SEGMENT
??_7CMemoryTextFileLoader@@6B@ DD FLAT:??_R4CMemoryTextFileLoader@@6B@ ; CMemoryTextFileLoader::`vftable'
	DD	FLAT:??_ECMemoryTextFileLoader@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z$0
__unwindtable$??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z$2
__ehfuncinfo$??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SplitLineByTab@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SplitLineByTab@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$0
__ehfuncinfo$?SplitLineByTab@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SplitLineByTab@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SplitLine2@CMemoryTextFileLoader@@QAEHKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SplitLine2@CMemoryTextFileLoader@@QAEHKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SplitLine2@CMemoryTextFileLoader@@QAEHKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z$1
__ehfuncinfo$?SplitLine2@CMemoryTextFileLoader@@QAEHKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SplitLine2@CMemoryTextFileLoader@@QAEHKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z$1
__ehfuncinfo$?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z$0
__ehfuncinfo$?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 134  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 135  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 137  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 85   :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 138  :         _Throw_bad_array_new_length(); // add overflow
; 139  :     }
; 140  : 
; 141  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 85   :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 145  : 
; 146  : #ifdef _DEBUG
; 147  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 148  : #endif // _DEBUG
; 149  :     return _Ptr;
; 150  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 1713 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1714 :     // move [_First, _Last) to raw _Dest, using _Al
; 1715 :     // note: only called internally from elsewhere in the STL
; 1716 :     using _Ptrval     = typename _Alloc::value_type*;
; 1717 :     auto _UFirst      = _Get_unwrapped(_First);
; 1718 :     const auto _ULast = _Get_unwrapped(_Last);
; 1719 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1720 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1721 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1722 :         if (!_STD is_constant_evaluated())
; 1723 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1724 :         {
; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1726 :             return _Dest + (_ULast - _UFirst);
; 1727 :         }
; 1728 :     }
; 1729 : 
; 1730 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	56		 push	 esi

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  0000a	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]

; 1714 :     // move [_First, _Last) to raw _Dest, using _Al
; 1715 :     // note: only called internally from elsewhere in the STL
; 1716 :     using _Ptrval     = typename _Alloc::value_type*;
; 1717 :     auto _UFirst      = _Get_unwrapped(_First);
; 1718 :     const auto _ULast = _Get_unwrapped(_Last);
; 1719 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1720 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1721 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1722 :         if (!_STD is_constant_evaluated())
; 1723 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1724 :         {
; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1726 :             return _Dest + (_ULast - _UFirst);
; 1727 :         }
; 1728 :     }
; 1729 : 
; 1730 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  0000d	3b c2		 cmp	 eax, edx
  0000f	74 4f		 je	 SHORT $LN3@Uninitiali

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00011	8b ce		 mov	 ecx, esi
  00013	2b c8		 sub	 ecx, eax
  00015	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@Uninitiali:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00020	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 2355 :     size_type _Mysize = 0; // current length of string

  00026	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 2356 :     size_type _Myres  = 0; // current storage reserved for string

  0002d	c7 44 01 14 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+20], 0

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00035	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00038	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  0003b	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00040	66 0f d6 46 10	 movq	 QWORD PTR [esi+16], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1632 :         ++_Last;

  00045	83 c6 18	 add	 esi, 24			; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4596 :         _My_data._Mysize = 0;

  00048	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0004f	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00056	c6 00 00	 mov	 BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1632 :         ++_Last;

  00059	83 c0 18	 add	 eax, 24			; 00000018H

; 1714 :     // move [_First, _Last) to raw _Dest, using _Al
; 1715 :     // note: only called internally from elsewhere in the STL
; 1716 :     using _Ptrval     = typename _Alloc::value_type*;
; 1717 :     auto _UFirst      = _Get_unwrapped(_First);
; 1718 :     const auto _ULast = _Get_unwrapped(_Last);
; 1719 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1720 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1721 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1722 :         if (!_STD is_constant_evaluated())
; 1723 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1724 :         {
; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1726 :             return _Dest + (_ULast - _UFirst);
; 1727 :         }
; 1728 :     }
; 1729 : 
; 1730 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  0005c	3b c2		 cmp	 eax, edx
  0005e	75 c0		 jne	 SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 1626 :         _Destroy_range(_First, _Last, _Al);

  00060	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00063	56		 push	 esi
  00064	56		 push	 esi
  00065	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1732 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1733 :     }
; 1734 : 
; 1735 :     return _Backout._Release();

  0006d	8b c6		 mov	 eax, esi
  0006f	5e		 pop	 esi

; 1736 : }

  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 945  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 949  :         for (; _First != _Last; ++_First) {

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 48		 je	 SHORT $LN45@Destroy_ra
  0000f	90		 npad	 1
$LL4@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00010	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00013	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00016	72 27		 jb	 SHORT $LN23@Destroy_ra
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00018	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0001a	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0001b	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00021	72 12		 jb	 SHORT $LN33@Destroy_ra

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00023	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00026	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00029	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0002b	83 c0 fc	 add	 eax, -4			; fffffffcH
  0002e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00031	77 28		 ja	 SHORT $LN30@Destroy_ra

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00033	8b c2		 mov	 eax, edx
$LN33@Destroy_ra:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00035	51		 push	 ecx
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003c	83 c4 08	 add	 esp, 8
$LN23@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  0003f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00046	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0004d	c6 06 00	 mov	 BYTE PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 949  :         for (; _First != _Last; ++_First) {

  00050	83 c6 18	 add	 esi, 24			; 00000018H
  00053	3b f7		 cmp	 esi, edi
  00055	75 b9		 jne	 SHORT $LL4@Destroy_ra
$LN45@Destroy_ra:
  00057	5f		 pop	 edi

; 950  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 951  :         }
; 952  :     }
; 953  : }

  00058	5e		 pop	 esi
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
$LN30@Destroy_ra:

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0005b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN46@Destroy_ra:
  00060	cc		 int	 3
??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
tv377 = -36						; size = 4
__Oldsize$1$ = -32					; size = 4
__Whereoff$1$ = -28					; size = 4
__Constructed_last$ = -28				; size = 4
$T2 = -24						; size = 4
__Newcapacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT
; _this$ = ecx

; 765  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b d9		 mov	 ebx, ecx
  0002d	89 5d d8	 mov	 DWORD PTR _this$[ebp], ebx

; 766  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 767  :         _Alty& _Al        = _Getal();
; 768  :         auto& _My_data    = _Mypair._Myval2;
; 769  :         pointer& _Myfirst = _My_data._Myfirst;
; 770  :         pointer& _Mylast  = _My_data._Mylast;
; 771  : 
; 772  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 773  : 
; 774  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00030	8b 33		 mov	 esi, DWORD PTR [ebx]
  00032	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00037	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]

; 775  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  0003a	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0003d	2b d6		 sub	 edx, esi
  0003f	f7 ea		 imul	 edx
  00041	2b ce		 sub	 ecx, esi
  00043	c1 fa 02	 sar	 edx, 2
  00046	8b c2		 mov	 eax, edx
  00048	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0004b	03 c2		 add	 eax, edx
  0004d	89 45 e4	 mov	 DWORD PTR __Whereoff$1$[ebp], eax
  00050	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00055	f7 e9		 imul	 ecx
  00057	c1 fa 02	 sar	 edx, 2
  0005a	8b c2		 mov	 eax, edx
  0005c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0005f	03 c2		 add	 eax, edx
  00061	89 45 e0	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 776  : 
; 777  :         if (_Oldsize == max_size()) {

  00064	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  00069	0f 84 29 01 00
	00		 je	 $LN47@Emplace_re

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0006f	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

  00072	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00075	2b ce		 sub	 ecx, esi
  00077	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0007c	f7 e9		 imul	 ecx

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0007e	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00083	c1 fa 02	 sar	 edx, 2
  00086	8b ca		 mov	 ecx, edx
  00088	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0008b	03 ca		 add	 ecx, edx

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0008d	8b d1		 mov	 edx, ecx
  0008f	d1 ea		 shr	 edx, 1
  00091	2b c2		 sub	 eax, edx
  00093	3b c8		 cmp	 ecx, eax
  00095	76 1a		 jbe	 SHORT $LN12@Emplace_re

; 1689 :             return _Max; // geometric growth would overflow

  00097	b8 f0 ff ff ff	 mov	 eax, -16		; fffffff0H
  0009c	be aa aa aa 0a	 mov	 esi, 178956970		; 0aaaaaaaH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a1	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1689 :             return _Max; // geometric growth would overflow

  000a2	89 75 ec	 mov	 DWORD PTR __Newcapacity$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a5	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000aa	83 c4 04	 add	 esp, 4
  000ad	8b f8		 mov	 edi, eax
  000af	eb 49		 jmp	 SHORT $LN44@Emplace_re
$LN12@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  000b1	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 64   :         if (_Count > _Max_possible) {

  000b4	8b f7		 mov	 esi, edi
  000b6	3b c7		 cmp	 eax, edi
  000b8	0f 43 f0	 cmovae	 esi, eax
  000bb	81 fe aa aa aa
	0a		 cmp	 esi, 178956970		; 0aaaaaaaH
  000c1	0f 87 d6 00 00
	00		 ja	 $LN48@Emplace_re

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  000c7	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  000ca	89 75 ec	 mov	 DWORD PTR __Newcapacity$[ebp], esi
  000cd	c1 e0 03	 shl	 eax, 3

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000d0	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000d5	72 0d		 jb	 SHORT $LN24@Emplace_re

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000dd	83 c4 04	 add	 esp, 4
  000e0	8b f8		 mov	 edi, eax
  000e2	eb 16		 jmp	 SHORT $LN44@Emplace_re
$LN24@Emplace_re:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  000e4	85 c0		 test	 eax, eax
  000e6	74 0d		 je	 SHORT $LN25@Emplace_re

; 85   :         return ::operator new(_Bytes);

  000e8	50		 push	 eax
  000e9	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000ee	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  000f1	8b f8		 mov	 edi, eax
  000f3	eb 02		 jmp	 SHORT $LN45@Emplace_re
$LN25@Emplace_re:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000f5	33 ff		 xor	 edi, edi
$LN45@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 785  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  000f7	89 75 ec	 mov	 DWORD PTR __Newcapacity$[ebp], esi
$LN44@Emplace_re:
  000fa	8b 45 e4	 mov	 eax, DWORD PTR __Whereoff$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

  000fd	ff 75 0c	 push	 DWORD PTR _<_Val_0>$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 785  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  00100	89 7d e8	 mov	 DWORD PTR $T2[ebp], edi

; 786  :         pointer _Constructed_first      = _Constructed_last;
; 787  : 
; 788  :         _TRY_BEGIN

  00103	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0010a	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0010d	8d 0c c7	 lea	 ecx, DWORD PTR [edi+eax*8]
  00110	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  00113	89 4d dc	 mov	 DWORD PTR tv377[ebp], ecx
  00116	89 45 e4	 mov	 DWORD PTR __Constructed_last$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

  00119	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 792  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  0011e	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00121	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
  00124	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00126	3b d0		 cmp	 edx, eax
  00128	75 04		 jne	 SHORT $LN4@Emplace_re

; 1664 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0012a	8b d7		 mov	 edx, edi

; 793  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 794  :         } else { // provide basic guarantee

  0012c	eb 15		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 1659 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0012e	53		 push	 ebx
  0012f	57		 push	 edi
  00130	52		 push	 edx
  00131	51		 push	 ecx
  00132	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00137	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0013a	83 c4 10	 add	 esp, 16			; 00000010H
  0013d	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00140	8b 55 e4	 mov	 edx, DWORD PTR __Constructed_last$[ebp]
$LN5@Emplace_re:

; 795  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 796  :             _Constructed_first = _Newvec;
; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00143	53		 push	 ebx
  00144	52		 push	 edx
  00145	50		 push	 eax
  00146	51		 push	 ecx
  00147	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 803  :         _CATCH_END
; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  0014c	8b 45 e0	 mov	 eax, DWORD PTR __Oldsize$1$[ebp]
  0014f	83 c4 10	 add	 esp, 16			; 00000010H
  00152	40		 inc	 eax
  00153	8b cb		 mov	 ecx, ebx
  00155	56		 push	 esi
  00156	50		 push	 eax
  00157	57		 push	 edi
  00158	e8 00 00 00 00	 call	 ?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array

; 806  :         return _Newvec + _Whereoff;

  0015d	8b 45 dc	 mov	 eax, DWORD PTR tv377[ebp]

; 807  :     }

  00160	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00163	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0016a	59		 pop	 ecx
  0016b	5f		 pop	 edi
  0016c	5e		 pop	 esi
  0016d	5b		 pop	 ebx
  0016e	8b e5		 mov	 esp, ebp
  00170	5d		 pop	 ebp
  00171	c2 08 00	 ret	 8
__catch$??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z$0:

; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);

  00174	8b 45 e4	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  00177	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0017a	50		 push	 eax
  0017b	50		 push	 eax
  0017c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy

; 801  :         _Al.deallocate(_Newvec, _Newcapacity);

  00181	ff 75 ec	 push	 DWORD PTR __Newcapacity$[ebp]
  00184	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00187	ff 75 e8	 push	 DWORD PTR $T2[ebp]
  0018a	e8 00 00 00 00	 call	 ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate

; 802  :         _RERAISE;

  0018f	6a 00		 push	 0
  00191	6a 00		 push	 0
  00193	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN47@Emplace_re:

; 778  :             _Xlength();

  00198	e8 00 00 00 00	 call	 ?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
$LN48@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  0019d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN43@Emplace_re:
  001a2	cc		 int	 3
  001a3	cc		 int	 3
  001a4	cc		 int	 3
  001a5	cc		 int	 3
  001a6	cc		 int	 3
  001a7	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z
_TEXT	SEGMENT
__Oldsize$1$ = -8					; size = 4
_this$1$ = -4						; size = 4
__Whereoff$1$ = -4					; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 765  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 766  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 767  :         _Alty& _Al        = _Getal();
; 768  :         auto& _My_data    = _Mypair._Myval2;
; 769  :         pointer& _Myfirst = _My_data._Myfirst;
; 770  :         pointer& _Mylast  = _My_data._Mylast;
; 771  : 
; 772  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 773  : 
; 774  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00006	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
  00009	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000e	53		 push	 ebx
  0000f	8b d9		 mov	 ebx, ecx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	8b 33		 mov	 esi, DWORD PTR [ebx]
  00015	2b d6		 sub	 edx, esi

; 775  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00017	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0001a	f7 ea		 imul	 edx
  0001c	2b ce		 sub	 ecx, esi
  0001e	c1 fa 02	 sar	 edx, 2
  00021	8b c2		 mov	 eax, edx
  00023	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00026	03 c2		 add	 eax, edx
  00028	89 45 fc	 mov	 DWORD PTR __Whereoff$1$[ebp], eax
  0002b	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00030	f7 e9		 imul	 ecx
  00032	c1 fa 02	 sar	 edx, 2
  00035	8b c2		 mov	 eax, edx
  00037	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0003a	03 c2		 add	 eax, edx
  0003c	89 45 f8	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 776  : 
; 777  :         if (_Oldsize == max_size()) {

  0003f	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  00044	0f 84 14 01 00
	00		 je	 $LN68@Emplace_re

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0004a	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

  0004d	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00050	2b ce		 sub	 ecx, esi
  00052	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00057	f7 e9		 imul	 ecx

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00059	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0005e	c1 fa 02	 sar	 edx, 2
  00061	8b ca		 mov	 ecx, edx
  00063	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00066	03 ca		 add	 ecx, edx

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00068	8b d1		 mov	 edx, ecx
  0006a	d1 ea		 shr	 edx, 1
  0006c	2b c2		 sub	 eax, edx
  0006e	3b c8		 cmp	 ecx, eax
  00070	76 17		 jbe	 SHORT $LN12@Emplace_re

; 1689 :             return _Max; // geometric growth would overflow

  00072	b8 f0 ff ff ff	 mov	 eax, -16		; fffffff0H
  00077	be aa aa aa 0a	 mov	 esi, 178956970		; 0aaaaaaaH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00082	83 c4 04	 add	 esp, 4
  00085	8b f8		 mov	 edi, eax
  00087	eb 43		 jmp	 SHORT $LN23@Emplace_re
$LN12@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00089	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 64   :         if (_Count > _Max_possible) {

  0008c	8b f7		 mov	 esi, edi
  0008e	3b c7		 cmp	 eax, edi
  00090	0f 43 f0	 cmovae	 esi, eax
  00093	81 fe aa aa aa
	0a		 cmp	 esi, 178956970		; 0aaaaaaaH
  00099	0f 87 c4 00 00
	00		 ja	 $LN69@Emplace_re

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  0009f	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  000a2	c1 e0 03	 shl	 eax, 3

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000a5	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000aa	72 0d		 jb	 SHORT $LN24@Emplace_re

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000b2	83 c4 04	 add	 esp, 4
  000b5	8b f8		 mov	 edi, eax
  000b7	eb 13		 jmp	 SHORT $LN23@Emplace_re
$LN24@Emplace_re:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  000b9	85 c0		 test	 eax, eax
  000bb	74 0d		 je	 SHORT $LN25@Emplace_re

; 85   :         return ::operator new(_Bytes);

  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000c3	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  000c6	8b f8		 mov	 edi, eax
  000c8	eb 02		 jmp	 SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000ca	33 ff		 xor	 edi, edi
$LN23@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 789  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000cc	8b 45 fc	 mov	 eax, DWORD PTR __Whereoff$1$[ebp]
  000cf	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  000d2	8d 0c c7	 lea	 ecx, DWORD PTR [edi+eax*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  000d5	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  000d8	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 2355 :     size_type _Mysize = 0; // current length of string

  000de	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 2356 :     size_type _Myres  = 0; // current storage reserved for string

  000e5	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  000ec	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 789  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000ef	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  000f2	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  000f5	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  000fa	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0

; 4596 :         _My_data._Mysize = 0;

  000ff	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00106	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0010d	c6 00 00	 mov	 BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 792  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00110	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00113	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  00116	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00118	3b c2		 cmp	 eax, edx
  0011a	75 04		 jne	 SHORT $LN4@Emplace_re

; 1664 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0011c	8b c7		 mov	 eax, edi

; 793  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 794  :         } else { // provide basic guarantee

  0011e	eb 18		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 1659 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00120	53		 push	 ebx
  00121	57		 push	 edi
  00122	50		 push	 eax
  00123	51		 push	 ecx
  00124	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 795  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 796  :             _Constructed_first = _Newvec;
; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00129	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]

; 1659 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0012c	83 c4 10	 add	 esp, 16			; 00000010H
  0012f	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]

; 795  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 796  :             _Constructed_first = _Newvec;
; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00132	83 c0 18	 add	 eax, 24			; 00000018H

; 1659 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00135	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
$LN5@Emplace_re:

; 795  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 796  :             _Constructed_first = _Newvec;
; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00138	53		 push	 ebx
  00139	50		 push	 eax
  0013a	52		 push	 edx
  0013b	51		 push	 ecx
  0013c	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);
; 801  :         _Al.deallocate(_Newvec, _Newcapacity);
; 802  :         _RERAISE;
; 803  :         _CATCH_END
; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00141	8b 45 f8	 mov	 eax, DWORD PTR __Oldsize$1$[ebp]
  00144	83 c4 10	 add	 esp, 16			; 00000010H
  00147	40		 inc	 eax
  00148	8b cb		 mov	 ecx, ebx
  0014a	56		 push	 esi
  0014b	50		 push	 eax
  0014c	57		 push	 edi
  0014d	e8 00 00 00 00	 call	 ?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array

; 806  :         return _Newvec + _Whereoff;

  00152	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00155	5f		 pop	 edi
  00156	5e		 pop	 esi
  00157	5b		 pop	 ebx

; 807  :     }

  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c2 08 00	 ret	 8
$LN68@Emplace_re:

; 778  :             _Xlength();

  0015e	e8 00 00 00 00	 call	 ?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
$LN69@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  00163	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN66@Emplace_re:
  00168	cc		 int	 3
??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCDiskFileLoader@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCDiskFileLoader@@UAEPAXI@Z PROC			; CDiskFileLoader::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CDiskFileLoader@@UAE@XZ ; CDiskFileLoader::~CDiskFileLoader
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 0c		 push	 12			; 0000000cH
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GCDiskFileLoader@@UAEPAXI@Z ENDP			; CDiskFileLoader::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
;	COMDAT ?Initialize@CDiskFileLoader@@IAEXXZ
_TEXT	SEGMENT
?Initialize@CDiskFileLoader@@IAEXXZ PROC		; CDiskFileLoader::Initialize, COMDAT
; _this$ = ecx

; 276  : 	m_fp = NULL;

  00000	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 277  : 	m_size = 0;

  00007	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 278  : }

  0000e	c3		 ret	 0
?Initialize@CDiskFileLoader@@IAEXXZ ENDP		; CDiskFileLoader::Initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
;	COMDAT ?GetSize@CDiskFileLoader@@QAEHXZ
_TEXT	SEGMENT
?GetSize@CDiskFileLoader@@QAEHXZ PROC			; CDiskFileLoader::GetSize, COMDAT
; _this$ = ecx

; 233  : 	return m_size;

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 234  : }

  00003	c3		 ret	 0
?GetSize@CDiskFileLoader@@QAEHXZ ENDP			; CDiskFileLoader::GetSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
;	COMDAT ?Read@CDiskFileLoader@@QAE_NHPAX@Z
_TEXT	SEGMENT
_size$ = 8						; size = 4
_pvDst$ = 12						; size = 4
?Read@CDiskFileLoader@@QAE_NHPAX@Z PROC			; CDiskFileLoader::Read, COMDAT
; _this$ = ecx

; 237  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 238  : 	assert(m_fp != NULL);
; 239  : 
; 240  : 	int ret = fread(pvDst, size, 1, m_fp);

  00003	ff 71 04	 push	 DWORD PTR [ecx+4]
  00006	6a 01		 push	 1
  00008	ff 75 08	 push	 DWORD PTR _size$[ebp]
  0000b	ff 75 0c	 push	 DWORD PTR _pvDst$[ebp]
  0000e	e8 00 00 00 00	 call	 _fread
  00013	83 c4 10	 add	 esp, 16			; 00000010H

; 241  : 
; 242  : 	if (ret <= 0)

  00016	85 c0		 test	 eax, eax
  00018	0f 9f c0	 setg	 al

; 243  : 		return false;
; 244  : 
; 245  : 	return true;
; 246  : }

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
?Read@CDiskFileLoader@@QAE_NHPAX@Z ENDP			; CDiskFileLoader::Read
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
;	COMDAT ?Open@CDiskFileLoader@@QAE_NPBD@Z
_TEXT	SEGMENT
_c_szFileName$ = 8					; size = 4
?Open@CDiskFileLoader@@QAE_NPBD@Z PROC			; CDiskFileLoader::Open, COMDAT
; _this$ = ecx

; 249  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 250  : 	Close();

  00006	e8 00 00 00 00	 call	 ?Close@CDiskFileLoader@@QAEXXZ ; CDiskFileLoader::Close

; 251  : 
; 252  : 	if (!c_szFileName[0])

  0000b	8b 45 08	 mov	 eax, DWORD PTR _c_szFileName$[ebp]
  0000e	80 38 00	 cmp	 BYTE PTR [eax], 0
  00011	74 40		 je	 SHORT $LN5@Open

; 253  : 		return false;
; 254  : 
; 255  : 	m_fp = fopen(c_szFileName, "rb");

  00013	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _fopen
  0001e	83 c4 08	 add	 esp, 8
  00021	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 256  : 
; 257  : 	if (!m_fp)

  00024	85 c0		 test	 eax, eax
  00026	74 2b		 je	 SHORT $LN5@Open

; 259  : 
; 260  : 	fseek(m_fp, 0, SEEK_END);

  00028	6a 02		 push	 2
  0002a	6a 00		 push	 0
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 _fseek

; 261  : 	m_size = ftell(m_fp);

  00032	ff 76 04	 push	 DWORD PTR [esi+4]
  00035	e8 00 00 00 00	 call	 _ftell

; 262  : 	fseek(m_fp, 0, SEEK_SET);

  0003a	6a 00		 push	 0
  0003c	6a 00		 push	 0
  0003e	ff 76 04	 push	 DWORD PTR [esi+4]
  00041	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00044	e8 00 00 00 00	 call	 _fseek
  00049	83 c4 1c	 add	 esp, 28			; 0000001cH

; 263  : 	return true;

  0004c	b0 01		 mov	 al, 1
  0004e	5e		 pop	 esi

; 264  : }

  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
$LN5@Open:

; 258  : 		return false;

  00053	32 c0		 xor	 al, al
  00055	5e		 pop	 esi

; 264  : }

  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
?Open@CDiskFileLoader@@QAE_NPBD@Z ENDP			; CDiskFileLoader::Open
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
;	COMDAT ?Close@CDiskFileLoader@@QAEXXZ
_TEXT	SEGMENT
?Close@CDiskFileLoader@@QAEXXZ PROC			; CDiskFileLoader::Close, COMDAT
; _this$ = ecx

; 267  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 268  : 	if (m_fp)

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $LN2@Close

; 269  : 		fclose(m_fp);

  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 _fclose
  00010	83 c4 04	 add	 esp, 4
$LN2@Close:

; 270  : 
; 271  : 	Initialize();

  00013	8b ce		 mov	 ecx, esi
  00015	5e		 pop	 esi
  00016	e9 00 00 00 00	 jmp	 ?Initialize@CDiskFileLoader@@IAEXXZ ; CDiskFileLoader::Initialize
?Close@CDiskFileLoader@@QAEXXZ ENDP			; CDiskFileLoader::Close
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
;	COMDAT ??1CDiskFileLoader@@UAE@XZ
_TEXT	SEGMENT
??1CDiskFileLoader@@UAE@XZ PROC				; CDiskFileLoader::~CDiskFileLoader, COMDAT
; _this$ = ecx

; 286  : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CDiskFileLoader@@6B@

; 287  : 	Close();

  00006	e9 00 00 00 00	 jmp	 ?Close@CDiskFileLoader@@QAEXXZ ; CDiskFileLoader::Close
??1CDiskFileLoader@@UAE@XZ ENDP				; CDiskFileLoader::~CDiskFileLoader
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
;	COMDAT ??0CDiskFileLoader@@QAE@XZ
_TEXT	SEGMENT
??0CDiskFileLoader@@QAE@XZ PROC				; CDiskFileLoader::CDiskFileLoader, COMDAT
; _this$ = ecx

; 281  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CDiskFileLoader@@6B@

; 282  : 	Initialize();

  00009	e8 00 00 00 00	 call	 ?Initialize@CDiskFileLoader@@IAEXXZ ; CDiskFileLoader::Initialize

; 283  : }

  0000e	8b c6		 mov	 eax, esi
  00010	5e		 pop	 esi
  00011	c3		 ret	 0
??0CDiskFileLoader@@QAE@XZ ENDP				; CDiskFileLoader::CDiskFileLoader
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCMemoryFileLoader@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCMemoryFileLoader@@UAEPAXI@Z PROC			; CMemoryFileLoader::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CMemoryFileLoader@@UAE@XZ ; CMemoryFileLoader::~CMemoryFileLoader
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 10		 push	 16			; 00000010H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GCMemoryFileLoader@@UAEPAXI@Z ENDP			; CMemoryFileLoader::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
;	COMDAT ?GetCurrentPositionPointer@CMemoryFileLoader@@IAEPBDXZ
_TEXT	SEGMENT
?GetCurrentPositionPointer@CMemoryFileLoader@@IAEPBDXZ PROC ; CMemoryFileLoader::GetCurrentPositionPointer, COMDAT
; _this$ = ecx

; 213  : 	assert(m_pcBase != NULL);
; 214  : 	return (m_pcBase + m_pos);

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	03 41 04	 add	 eax, DWORD PTR [ecx+4]

; 215  : }

  00006	c3		 ret	 0
?GetCurrentPositionPointer@CMemoryFileLoader@@IAEPBDXZ ENDP ; CMemoryFileLoader::GetCurrentPositionPointer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
;	COMDAT ?IsReadableSize@CMemoryFileLoader@@IAE_NH@Z
_TEXT	SEGMENT
_size$ = 8						; size = 4
?IsReadableSize@CMemoryFileLoader@@IAE_NH@Z PROC	; CMemoryFileLoader::IsReadableSize, COMDAT
; _this$ = ecx

; 194  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 195  : 	if (m_pos + size > m_size)

  00003	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00006	03 45 08	 add	 eax, DWORD PTR _size$[ebp]
  00009	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0000c	0f 9e c0	 setle	 al

; 196  : 		return false;
; 197  : 
; 198  : 	return true;
; 199  : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?IsReadableSize@CMemoryFileLoader@@IAE_NH@Z ENDP	; CMemoryFileLoader::IsReadableSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
;	COMDAT ?GetSize@CMemoryFileLoader@@QAEHXZ
_TEXT	SEGMENT
?GetSize@CMemoryFileLoader@@QAEHXZ PROC			; CMemoryFileLoader::GetSize, COMDAT
; _this$ = ecx

; 185  : 	return m_size;

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 186  : }

  00003	c3		 ret	 0
?GetSize@CMemoryFileLoader@@QAEHXZ ENDP			; CMemoryFileLoader::GetSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
;	COMDAT ?GetPosition@CMemoryFileLoader@@QAEHXZ
_TEXT	SEGMENT
?GetPosition@CMemoryFileLoader@@QAEHXZ PROC		; CMemoryFileLoader::GetPosition, COMDAT
; _this$ = ecx

; 190  : 	return m_pos;

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]

; 191  : }

  00003	c3		 ret	 0
?GetPosition@CMemoryFileLoader@@QAEHXZ ENDP		; CMemoryFileLoader::GetPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
;	COMDAT ?Read@CMemoryFileLoader@@QAE_NHPAX@Z
_TEXT	SEGMENT
_size$ = 8						; size = 4
_pvDst$ = 12						; size = 4
?Read@CMemoryFileLoader@@QAE_NHPAX@Z PROC		; CMemoryFileLoader::Read, COMDAT
; _this$ = ecx

; 202  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 203  : 	if (!IsReadableSize(size))

  00005	8b 7d 08	 mov	 edi, DWORD PTR _size$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi
  0000b	e8 00 00 00 00	 call	 ?IsReadableSize@CMemoryFileLoader@@IAE_NH@Z ; CMemoryFileLoader::IsReadableSize
  00010	84 c0		 test	 al, al
  00012	75 06		 jne	 SHORT $LN2@Read

; 209  : }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
$LN2@Read:

; 204  : 		return false;
; 205  : 
; 206  : 	memcpy(pvDst, GetCurrentPositionPointer(), size);

  0001a	57		 push	 edi
  0001b	8b ce		 mov	 ecx, esi
  0001d	e8 00 00 00 00	 call	 ?GetCurrentPositionPointer@CMemoryFileLoader@@IAEPBDXZ ; CMemoryFileLoader::GetCurrentPositionPointer
  00022	50		 push	 eax
  00023	ff 75 0c	 push	 DWORD PTR _pvDst$[ebp]
  00026	e8 00 00 00 00	 call	 _memcpy
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 207  : 	m_pos += size;
; 208  : 	return true;

  0002e	b0 01		 mov	 al, 1
  00030	01 7e 0c	 add	 DWORD PTR [esi+12], edi
  00033	5f		 pop	 edi

; 209  : }

  00034	5e		 pop	 esi
  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
?Read@CMemoryFileLoader@@QAE_NHPAX@Z ENDP		; CMemoryFileLoader::Read
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
;	COMDAT ??1CMemoryFileLoader@@UAE@XZ
_TEXT	SEGMENT
??1CMemoryFileLoader@@UAE@XZ PROC			; CMemoryFileLoader::~CMemoryFileLoader, COMDAT
; _this$ = ecx

; 227  : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CMemoryFileLoader@@6B@

; 228  : }

  00006	c3		 ret	 0
??1CMemoryFileLoader@@UAE@XZ ENDP			; CMemoryFileLoader::~CMemoryFileLoader
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
;	COMDAT ??0CMemoryFileLoader@@QAE@HPBX@Z
_TEXT	SEGMENT
_size$ = 8						; size = 4
_c_pvMemoryFile$ = 12					; size = 4
??0CMemoryFileLoader@@QAE@HPBX@Z PROC			; CMemoryFileLoader::CMemoryFileLoader, COMDAT
; _this$ = ecx

; 218  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 219  : 	assert(c_pvMemoryFile != NULL);
; 220  : 
; 221  : 	m_pos = 0;
; 222  : 	m_size = size;

  00003	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  00006	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 223  : 	m_pcBase = (const char *) c_pvMemoryFile;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _c_pvMemoryFile$[ebp]
  0000c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 224  : }

  0000f	8b c1		 mov	 eax, ecx
  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CMemoryFileLoader@@6B@
  00017	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
??0CMemoryFileLoader@@QAE@HPBX@Z ENDP			; CMemoryFileLoader::CMemoryFileLoader
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCMemoryTextFileLoader@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCMemoryTextFileLoader@@UAEPAXI@Z PROC		; CMemoryTextFileLoader::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CMemoryTextFileLoader@@UAE@XZ ; CMemoryTextFileLoader::~CMemoryTextFileLoader
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 10		 push	 16			; 00000010H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GCMemoryTextFileLoader@@UAEPAXI@Z ENDP		; CMemoryTextFileLoader::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength, COMDAT

; 1774 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array, COMDAT
; _this$ = ecx

; 1736 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b f9		 mov	 edi, ecx

; 1737 :         // orphan all iterators, discard old array, acquire new array
; 1738 :         auto& _My_data    = _Mypair._Myval2;
; 1739 :         pointer& _Myfirst = _My_data._Myfirst;
; 1740 :         pointer& _Mylast  = _My_data._Mylast;
; 1741 :         pointer& _Myend   = _My_data._Myend;
; 1742 : 
; 1743 :         _My_data._Orphan_all();
; 1744 : 
; 1745 :         if (_Myfirst) { // destroy and deallocate old array

  00006	8b 07		 mov	 eax, DWORD PTR [edi]
  00008	85 c0		 test	 eax, eax
  0000a	74 51		 je	 SHORT $LN10@Change_arr

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	ff 77 04	 push	 DWORD PTR [edi+4]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00017	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0001a	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001f	8b 37		 mov	 esi, DWORD PTR [edi]

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00021	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00024	2b ce		 sub	 ecx, esi
  00026	f7 e9		 imul	 ecx
  00028	c1 fa 02	 sar	 edx, 2
  0002b	8b c2		 mov	 eax, edx
  0002d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00030	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00032	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00035	c1 e1 03	 shl	 ecx, 3

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00038	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0003e	72 12		 jb	 SHORT $LN20@Change_arr

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00040	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  00043	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00046	2b f2		 sub	 esi, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00048	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  0004b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0004e	77 2f		 ja	 SHORT $LN17@Change_arr

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00050	8b f2		 mov	 esi, edx
$LN20@Change_arr:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00052	51		 push	 ecx
  00053	56		 push	 esi
  00054	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00059	83 c4 08	 add	 esp, 8
  0005c	5e		 pop	 esi
$LN10@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         _Myfirst = _Newvec;

  0005d	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]

; 1751 :         _Mylast  = _Newvec + _Newsize;

  00060	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00063	89 0f		 mov	 DWORD PTR [edi], ecx
  00065	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00068	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  0006b	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1752 :         _Myend   = _Newvec + _Newcapacity;

  0006e	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00071	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00074	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  00077	89 47 08	 mov	 DWORD PTR [edi+8], eax
  0007a	5f		 pop	 edi

; 1753 :     }

  0007b	5d		 pop	 ebp
  0007c	c2 0c 00	 ret	 12			; 0000000cH
$LN17@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0007f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@Change_arr:
  00084	cc		 int	 3
?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy, COMDAT
; _this$ = ecx

; 1678 :     _CONSTEXPR20_CONTAINER void _Destroy(pointer _First, pointer _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1679 :         // destroy [_First, _Last) using allocator
; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00003	51		 push	 ecx
  00004	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00007	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000a	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0000f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1681 :     }

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Reallocate_exactly@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXI@Z
_TEXT	SEGMENT
__Size$1$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?_Reallocate_exactly@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXI@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate_exactly, COMDAT
; _this$ = ecx

; 1299 :     _CONSTEXPR20_CONTAINER void _Reallocate_exactly(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 64   :         if (_Count > _Max_possible) {

  00005	8b 5d 08	 mov	 ebx, DWORD PTR __Newcapacity$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1305 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

  00008	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b f9		 mov	 edi, ecx
  00011	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00014	2b 17		 sub	 edx, DWORD PTR [edi]
  00016	f7 ea		 imul	 edx
  00018	c1 fa 02	 sar	 edx, 2
  0001b	8b c2		 mov	 eax, edx
  0001d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00020	03 c2		 add	 eax, edx
  00022	89 45 fc	 mov	 DWORD PTR __Size$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 64   :         if (_Count > _Max_possible) {

  00025	81 fb aa aa aa
	0a		 cmp	 ebx, 178956970		; 0aaaaaaaH
  0002b	77 51		 ja	 SHORT $LN27@Reallocate

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  0002d	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
  00030	c1 e0 03	 shl	 eax, 3

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00033	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00038	72 0d		 jb	 SHORT $LN15@Reallocate

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00040	83 c4 04	 add	 esp, 4
  00043	8b f0		 mov	 esi, eax
  00045	eb 13		 jmp	 SHORT $LN14@Reallocate
$LN15@Reallocate:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  00047	85 c0		 test	 eax, eax
  00049	74 0d		 je	 SHORT $LN16@Reallocate

; 85   :         return ::operator new(_Bytes);

  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00051	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  00054	8b f0		 mov	 esi, eax
  00056	eb 02		 jmp	 SHORT $LN14@Reallocate
$LN16@Reallocate:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  00058	33 f6		 xor	 esi, esi
$LN14@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1664 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0005a	57		 push	 edi
  0005b	56		 push	 esi
  0005c	ff 77 04	 push	 DWORD PTR [edi+4]
  0005f	ff 37		 push	 DWORD PTR [edi]
  00061	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00066	83 c4 10	 add	 esp, 16			; 00000010H

; 1306 : 
; 1307 :         const pointer _Newvec = _Getal().allocate(_Newcapacity);
; 1308 : 
; 1309 :         _TRY_BEGIN
; 1310 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 1311 :         _CATCH_ALL
; 1312 :         _Getal().deallocate(_Newvec, _Newcapacity);
; 1313 :         _RERAISE;
; 1314 :         _CATCH_END
; 1315 : 
; 1316 :         _Change_array(_Newvec, _Size, _Newcapacity);

  00069	8b cf		 mov	 ecx, edi
  0006b	53		 push	 ebx
  0006c	ff 75 fc	 push	 DWORD PTR __Size$1$[ebp]
  0006f	56		 push	 esi
  00070	e8 00 00 00 00	 call	 ?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx

; 1317 :     }

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
$LN27@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  0007e	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN25@Reallocate:
  00083	cc		 int	 3
?_Reallocate_exactly@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXI@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate_exactly
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 65		 je	 SHORT $LN4@vector

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00009	57		 push	 edi
  0000a	56		 push	 esi
  0000b	ff 76 04	 push	 DWORD PTR [esi+4]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00014	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00017	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001c	8b 3e		 mov	 edi, DWORD PTR [esi]

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00021	2b cf		 sub	 ecx, edi
  00023	f7 e9		 imul	 ecx
  00025	c1 fa 02	 sar	 edx, 2
  00028	8b c2		 mov	 eax, edx
  0002a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002d	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0002f	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00032	c1 e1 03	 shl	 ecx, 3

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00035	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0003b	72 12		 jb	 SHORT $LN22@vector

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0003d	8b 57 fc	 mov	 edx, DWORD PTR [edi-4]
  00040	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00043	2b fa		 sub	 edi, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  00048	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0004b	77 23		 ja	 SHORT $LN19@vector

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0004d	8b fa		 mov	 edi, edx
$LN22@vector:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0004f	51		 push	 ecx
  00050	57		 push	 edi
  00051	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00056	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  00059	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1768 :             _Mylast  = nullptr;

  0005f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1769 :             _Myend   = nullptr;

  00066	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0006d	5f		 pop	 edi
$LN4@vector:
  0006e	5e		 pop	 esi

; 717  :     }

  0006f	c3		 ret	 0
$LN19@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00070	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN27@vector:
  00075	cc		 int	 3
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate, COMDAT
; _this$ = ecx

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00009	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000c	c1 e1 03	 shl	 ecx, 3

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000f	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00015	72 12		 jb	 SHORT $LN15@deallocate

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00017	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001a	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001d	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001f	83 c0 fc	 add	 eax, -4			; fffffffcH
  00022	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00025	77 10		 ja	 SHORT $LN12@deallocate

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00027	8b c2		 mov	 eax, edx
$LN15@deallocate:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00029	51		 push	 ecx
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00030	83 c4 08	 add	 esp, 8

; 836  :     }

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
$LN12@deallocate:

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00037	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN18@deallocate:
  0003c	cc		 int	 3
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
;	COMDAT ?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z
_TEXT	SEGMENT
_dwLine$ = 8						; size = 4
?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z PROC ; CMemoryTextFileLoader::GetLineString, COMDAT
; _this$ = ecx

; 141  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwLine$[ebp]
  00006	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00009	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0000c	8d 04 d0	 lea	 eax, DWORD PTR [eax+edx*8]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 144  : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ENDP ; CMemoryTextFileLoader::GetLineString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
;	COMDAT ?SplitLineByTab@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
_c_iLineLength$1$ = -316				; size = 4
_pstTokenVector$GSCopy$1$ = -312			; size = 4
__Hay_size$1$ = -308					; size = 4
_dwLine$GSCopy$1$ = -304				; size = 4
_c_rstLine$1$ = -304					; size = 4
_this$GSCopy$1$ = -300					; size = 4
__Result$1$ = -300					; size = 4
__Matches$2 = -296					; size = 256
$T3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_dwLine$ = 8						; size = 4
_pstTokenVector$ = 12					; size = 4
?SplitLineByTab@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z PROC ; CMemoryTextFileLoader::SplitLineByTab, COMDAT
; _this$ = ecx

; 14   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SplitLineByTab@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	89 8d d4 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  00033	8b 75 0c	 mov	 esi, DWORD PTR _pstTokenVector$[ebp]
  00036	8b 45 08	 mov	 eax, DWORD PTR _dwLine$[ebp]
  00039	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _dwLine$GSCopy$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0003f	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 14   : {

  00044	89 b5 c8 fe ff
	ff		 mov	 DWORD PTR _pstTokenVector$GSCopy$1$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0004a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0004d	8b 3e		 mov	 edi, DWORD PTR [esi]
  0004f	2b cf		 sub	 ecx, edi
  00051	f7 e9		 imul	 ecx
  00053	c1 fa 02	 sar	 edx, 2
  00056	8b c2		 mov	 eax, edx
  00058	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0005b	03 c2		 add	 eax, edx

; 1371 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  0005d	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00060	73 0b		 jae	 SHORT $LN10@SplitLineB

; 1372 :             if (_Newcapacity > max_size()) {
; 1373 :                 _Xlength();
; 1374 :             }
; 1375 : 
; 1376 :             _Reallocate_exactly(_Newcapacity);

  00062	6a 0a		 push	 10			; 0000000aH
  00064	8b ce		 mov	 ecx, esi
  00066	e8 00 00 00 00	 call	 ?_Reallocate_exactly@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate_exactly
  0006b	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN10@SplitLineB:

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  0006d	56		 push	 esi
  0006e	ff 76 04	 push	 DWORD PTR [esi+4]
  00071	57		 push	 edi
  00072	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1456 :         _Mylast = _Myfirst;

  00077	8b 06		 mov	 eax, DWORD PTR [esi]

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00079	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 18   : 	const std::string & c_rstLine = GetLineString(dwLine);

  0007c	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1456 :         _Mylast = _Myfirst;

  00082	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 18   : 	const std::string & c_rstLine = GetLineString(dwLine);

  00085	ff b5 d0 fe ff
	ff		 push	 DWORD PTR _dwLine$GSCopy$1$[ebp]
  0008b	e8 00 00 00 00	 call	 ?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; CMemoryTextFileLoader::GetLineString
  00090	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _c_rstLine$1$[ebp], eax

; 19   : 	const int c_iLineLength = c_rstLine.length();

  00096	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00099	89 8d c4 fe ff
	ff		 mov	 DWORD PTR _c_iLineLength$1$[ebp], ecx

; 20   : 
; 21   : 	if (0 == c_iLineLength)

  0009f	85 c9		 test	 ecx, ecx
  000a1	75 1f		 jne	 SHORT $LN5@SplitLineB

; 22   : 		return false;

  000a3	32 c0		 xor	 al, al
$LN1@SplitLineB:

; 36   : }

  000a5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000af	59		 pop	 ecx
  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b5	33 cd		 xor	 ecx, ebp
  000b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c2 08 00	 ret	 8
$LN5@SplitLineB:

; 23   : 
; 24   : 	int basePos = 0;

  000c2	33 ff		 xor	 edi, edi
$LL4@SplitLineB:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2306 :         if (_Large_string_engaged()) {

  000c4	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  000c8	8b f0		 mov	 esi, eax
  000ca	89 85 d4 fe ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], eax
  000d0	72 08		 jb	 SHORT $LN169@SplitLineB

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  000d2	8b 30		 mov	 esi, DWORD PTR [eax]
  000d4	89 b5 d4 fe ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], esi
$LN169@SplitLineB:

; 4224 :         return static_cast<size_type>(_Traits_find_first_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  000da	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000dd	89 8d cc fe ff
	ff		 mov	 DWORD PTR __Hay_size$1$[ebp], ecx

; 773  :     if (_Needle_size != 0 && _Start_at < _Hay_size) { // room for match, look for it

  000e3	3b f9		 cmp	 edi, ecx
  000e5	73 43		 jae	 SHORT $LN31@SplitLineB
  000e7	68 00 01 00 00	 push	 256			; 00000100H
  000ec	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR __Matches$2[ebp]
  000f2	6a 00		 push	 0
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 _memset

; 774  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 775  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
; 776  :                                                                 // fall back to the serial algorithm
; 777  :             return _Traits_find_first_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
; 778  :         }
; 779  : 
; 780  :         const auto _End = _Haystack + _Hay_size;

  000fa	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR __Hay_size$1$[ebp]
  00100	83 c4 0c	 add	 esp, 12			; 0000000cH

; 705  :             _Matches[static_cast<unsigned char>(*_First)] = true;

  00103	c6 85 e1 fe ff
	ff 01		 mov	 BYTE PTR __Matches$2[ebp+9], 1

; 780  :         const auto _End = _Haystack + _Hay_size;

  0010a	8d 14 31	 lea	 edx, DWORD PTR [ecx+esi]

; 781  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {

  0010d	03 f7		 add	 esi, edi
  0010f	3b f2		 cmp	 esi, edx
  00111	73 17		 jae	 SHORT $LN31@SplitLineB
$LL32@SplitLineB:

; 712  :         return _Matches[static_cast<unsigned char>(_Ch)];

  00113	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00116	8a 84 05 d8 fe
	ff ff		 mov	 al, BYTE PTR __Matches$2[ebp+eax]

; 782  :             if (_Matches._Match(*_Match_try)) {

  0011d	84 c0		 test	 al, al
  0011f	0f 85 86 00 00
	00		 jne	 $LN154@SplitLineB

; 781  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {

  00125	46		 inc	 esi
  00126	3b f2		 cmp	 esi, edx
  00128	72 e9		 jb	 SHORT $LL32@SplitLineB
$LN31@SplitLineB:

; 784  :             }
; 785  :         }
; 786  :     }
; 787  : 
; 788  :     return static_cast<size_t>(-1); // no match

  0012a	83 ce ff	 or	 esi, -1
$LN29@SplitLineB:

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0012d	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0

; 4596 :         _My_data._Mysize = 0;

  00134	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0013b	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T3[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00142	c6 45 d8 00	 mov	 BYTE PTR $T3[ebp], 0

; 2324 :         if (_Mysize < _Off) {

  00146	3b cf		 cmp	 ecx, edi
  00148	0f 82 ca 00 00
	00		 jb	 $LN155@SplitLineB

; 2305 :         const value_type* _Result = _Bx._Buf;

  0014e	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR _c_rstLine$1$[ebp]

; 2342 :         return (_STD min)(_Size, _Mysize - _Off);

  00154	2b cf		 sub	 ecx, edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 30   : 		pstTokenVector->push_back(c_rstLine.substr(basePos, beginPos-basePos));

  00156	8b c6		 mov	 eax, esi
  00158	2b c7		 sub	 eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2342 :         return (_STD min)(_Size, _Mysize - _Off);

  0015a	3b c8		 cmp	 ecx, eax
  0015c	0f 42 c1	 cmovb	 eax, ecx

; 2306 :         if (_Large_string_engaged()) {

  0015f	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  00163	8b ca		 mov	 ecx, edx
  00165	72 02		 jb	 SHORT $LN168@SplitLineB

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  00167	8b 0a		 mov	 ecx, DWORD PTR [edx]
$LN168@SplitLineB:

; 3224 :         return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);

  00169	50		 push	 eax
  0016a	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0016d	50		 push	 eax
  0016e	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00171	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  00176	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR _pstTokenVector$GSCopy$1$[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 30   : 		pstTokenVector->push_back(c_rstLine.substr(basePos, beginPos-basePos));

  0017c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  00183	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00186	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00189	74 2b		 je	 SHORT $LN91@SplitLineB
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0018b	0f 10 45 d8	 movups	 xmm0, XMMWORD PTR $T3[ebp]

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0018f	ba 0f 00 00 00	 mov	 edx, 15			; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00194	c6 45 d8 00	 mov	 BYTE PTR $T3[ebp], 0

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00198	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  0019b	f3 0f 7e 45 e8	 movq	 xmm0, QWORD PTR $T3[ebp+16]
  001a0	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 729  :         ++_Mylast;

  001a5	83 41 04 18	 add	 DWORD PTR [ecx+4], 24	; 00000018H

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  001a9	eb 18		 jmp	 SHORT $LN90@SplitLineB
$LN154@SplitLineB:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 783  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match

  001ab	2b b5 d4 fe ff
	ff		 sub	 esi, DWORD PTR __Result$1$[ebp]
  001b1	e9 77 ff ff ff	 jmp	 $LN29@SplitLineB
$LN91@SplitLineB:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  001b6	8d 55 d8	 lea	 edx, DWORD PTR $T3[ebp]
  001b9	52		 push	 edx
  001ba	50		 push	 eax
  001bb	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  001c0	8b 55 ec	 mov	 edx, DWORD PTR $T3[ebp+20]
$LN90@SplitLineB:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 30   : 		pstTokenVector->push_back(c_rstLine.substr(basePos, beginPos-basePos));

  001c3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  001ca	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  001cd	72 28		 jb	 SHORT $LN134@SplitLineB
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001cf	8b 4d d8	 mov	 ecx, DWORD PTR $T3[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  001d2	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001d3	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  001d5	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001db	72 10		 jb	 SHORT $LN144@SplitLineB

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001dd	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  001e0	83 c2 23	 add	 edx, 35			; 00000023H
  001e3	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001e5	83 c0 fc	 add	 eax, -4			; fffffffcH
  001e8	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001eb	77 30		 ja	 SHORT $LN141@SplitLineB
$LN144@SplitLineB:

; 264  :         ::operator delete(_Ptr, _Bytes);

  001ed	52		 push	 edx
  001ee	51		 push	 ecx
  001ef	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001f4	83 c4 08	 add	 esp, 8
$LN134@SplitLineB:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 32   : 		basePos = beginPos+1;

  001f7	8d 7e 01	 lea	 edi, DWORD PTR [esi+1]

; 33   : 	} while (basePos < c_iLineLength && basePos > 0);

  001fa	3b bd c4 fe ff
	ff		 cmp	 edi, DWORD PTR _c_iLineLength$1$[ebp]
  00200	7d 0f		 jge	 SHORT $LN6@SplitLineB
  00202	85 ff		 test	 edi, edi
  00204	7e 0b		 jle	 SHORT $LN6@SplitLineB
  00206	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _c_rstLine$1$[ebp]
  0020c	e9 b3 fe ff ff	 jmp	 $LL4@SplitLineB
$LN6@SplitLineB:

; 34   : 
; 35   : 	return true;

  00211	b0 01		 mov	 al, 1
  00213	e9 8d fe ff ff	 jmp	 $LN1@SplitLineB
$LN155@SplitLineB:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2325 :             _Xran();

  00218	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN141@SplitLineB:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0021d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN171@SplitLineB:
  00222	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SplitLineByTab@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?SplitLineByTab@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a c4 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-316]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SplitLineByTab@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SplitLineByTab@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ENDP ; CMemoryTextFileLoader::SplitLineByTab
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
;	COMDAT ?SplitLine2@CMemoryTextFileLoader@@QAEHKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z
_TEXT	SEGMENT
_c_rstLine$1$ = -1108					; size = 4
_pstTokenVector$GSCopy$1$ = -1104			; size = 4
_c_szDelimeter$GSCopy$1$ = -1100			; size = 4
__Hay_size$1$ = -1096					; size = 4
__Result$1$ = -1092					; size = 4
_dwLine$GSCopy$1$ = -1092				; size = 4
__Result$1$ = -1092					; size = 4
__Result$1$ = -1092					; size = 4
__Matches$2 = -1088					; size = 256
__Matches$3 = -832					; size = 256
__Matches$4 = -576					; size = 256
__Matches$5 = -320					; size = 256
_stToken$ = -64						; size = 24
$T6 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_dwLine$ = 8						; size = 4
_pstTokenVector$ = 12					; size = 4
_c_szDelimeter$ = 16					; size = 4
?SplitLine2@CMemoryTextFileLoader@@QAEHKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z PROC ; CMemoryTextFileLoader::SplitLine2, COMDAT
; _this$ = ecx

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SplitLine2@CMemoryTextFileLoader@@QAEHKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 48 04 00
	00		 sub	 esp, 1096		; 00000448H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b f9		 mov	 edi, ecx
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _pstTokenVector$[ebp]
  00032	8b 45 08	 mov	 eax, DWORD PTR _dwLine$[ebp]
  00035	89 85 bc fb ff
	ff		 mov	 DWORD PTR _dwLine$GSCopy$1$[ebp], eax
  0003b	8b 45 10	 mov	 eax, DWORD PTR _c_szDelimeter$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0003e	8b 31		 mov	 esi, DWORD PTR [ecx]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 39   : {

  00040	89 85 b4 fb ff
	ff		 mov	 DWORD PTR _c_szDelimeter$GSCopy$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00046	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 39   : {

  0004b	89 8d b0 fb ff
	ff		 mov	 DWORD PTR _pstTokenVector$GSCopy$1$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00051	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00054	2b ce		 sub	 ecx, esi
  00056	f7 e9		 imul	 ecx
  00058	c1 fa 02	 sar	 edx, 2
  0005b	8b c2		 mov	 eax, edx
  0005d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00060	03 c2		 add	 eax, edx

; 1371 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  00062	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00065	73 17		 jae	 SHORT $LN438@SplitLine2

; 1372 :             if (_Newcapacity > max_size()) {
; 1373 :                 _Xlength();
; 1374 :             }
; 1375 : 
; 1376 :             _Reallocate_exactly(_Newcapacity);

  00067	8b 8d b0 fb ff
	ff		 mov	 ecx, DWORD PTR _pstTokenVector$GSCopy$1$[ebp]
  0006d	6a 0a		 push	 10			; 0000000aH
  0006f	e8 00 00 00 00	 call	 ?_Reallocate_exactly@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate_exactly
  00074	8b 85 b0 fb ff
	ff		 mov	 eax, DWORD PTR _pstTokenVector$GSCopy$1$[ebp]
  0007a	8b 30		 mov	 esi, DWORD PTR [eax]
  0007c	eb 06		 jmp	 SHORT $LN16@SplitLine2
$LN438@SplitLine2:

; 748  : #if _HAS_CXX17
; 749  :         return _Result;
; 750  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 751  :         (void) _Result;
; 752  : #endif // _HAS_CXX17
; 753  :     }
; 754  : 
; 755  :     _CONSTEXPR20_CONTAINER void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee
; 756  :         emplace_back(_Val);
; 757  :     }
; 758  : 
; 759  :     _CONSTEXPR20_CONTAINER void push_back(_Ty&& _Val) {
; 760  :         // insert by moving into element at end, provide strong guarantee
; 761  :         emplace_back(_STD move(_Val));
; 762  :     }
; 763  : 
; 764  :     template <class... _Valty>
; 765  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {
; 766  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 767  :         _Alty& _Al        = _Getal();
; 768  :         auto& _My_data    = _Mypair._Myval2;
; 769  :         pointer& _Myfirst = _My_data._Myfirst;
; 770  :         pointer& _Mylast  = _My_data._Mylast;
; 771  : 
; 772  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 773  : 
; 774  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);
; 775  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);
; 776  : 
; 777  :         if (_Oldsize == max_size()) {
; 778  :             _Xlength();
; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;
; 782  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 783  : 
; 784  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);
; 785  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 786  :         pointer _Constructed_first      = _Constructed_last;
; 787  : 
; 788  :         _TRY_BEGIN
; 789  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);
; 790  :         _Constructed_first = _Newvec + _Whereoff;
; 791  : 
; 792  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee
; 793  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 794  :         } else { // provide basic guarantee
; 795  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 796  :             _Constructed_first = _Newvec;
; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);
; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);
; 801  :         _Al.deallocate(_Newvec, _Newcapacity);
; 802  :         _RERAISE;
; 803  :         _CATCH_END
; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 806  :         return _Newvec + _Whereoff;
; 807  :     }
; 808  : 
; 809  :     template <class... _Valty>
; 810  :     _CONSTEXPR20_CONTAINER iterator emplace(const_iterator _Where, _Valty&&... _Val) {
; 811  :         // insert by perfectly forwarding _Val at _Where
; 812  :         const pointer _Whereptr = _Where._Ptr;
; 813  :         auto& _My_data          = _Mypair._Myval2;
; 814  :         const pointer _Oldlast  = _My_data._Mylast;
; 815  : #if _ITERATOR_DEBUG_LEVEL == 2
; 816  :         _STL_VERIFY(
; 817  :             _Where._Getcont() == _STD addressof(_My_data) && _Whereptr >= _My_data._Myfirst && _Oldlast >= _Whereptr,
; 818  :             "vector emplace iterator outside range");
; 819  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 820  : 
; 821  :         if (_Oldlast != _My_data._Myend) {
; 822  :             if (_Whereptr == _Oldlast) { // at back, provide strong guarantee
; 823  :                 _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 824  :             } else {
; 825  :                 auto& _Al = _Getal();
; 826  :                 _Alloc_temporary<_Alty> _Obj(_Al, _STD forward<_Valty>(_Val)...); // handle aliasing
; 827  :                 // after constructing _Obj, provide basic guarantee
; 828  :                 _Orphan_range(_Whereptr, _Oldlast);
; 829  :                 _Alty_traits::construct(_Al, _Unfancy(_Oldlast), _STD move(_Oldlast[-1]));
; 830  :                 ++_My_data._Mylast;
; 831  :                 _Move_backward_unchecked(_Whereptr, _Oldlast - 1, _Oldlast);
; 832  :                 *_Whereptr = _STD move(_Obj._Storage._Value);
; 833  :             }
; 834  : 
; 835  :             return _Make_iterator(_Whereptr);
; 836  :         }
; 837  : 
; 838  :         return _Make_iterator(_Emplace_reallocate(_Whereptr, _STD forward<_Valty>(_Val)...));
; 839  :     }
; 840  : 
; 841  :     _CONSTEXPR20_CONTAINER iterator insert(const_iterator _Where, const _Ty& _Val) { // insert _Val at _Where
; 842  :         return emplace(_Where, _Val);
; 843  :     }
; 844  : 
; 845  :     _CONSTEXPR20_CONTAINER iterator insert(const_iterator _Where, _Ty&& _Val) { // insert by moving _Val at _Where
; 846  :         return emplace(_Where, _STD move(_Val));
; 847  :     }
; 848  : 
; 849  :     _CONSTEXPR20_CONTAINER iterator insert(
; 850  :         const_iterator _Where, _CRT_GUARDOVERFLOW const size_type _Count, const _Ty& _Val) {
; 851  :         // insert _Count * _Val at _Where
; 852  :         const pointer _Whereptr = _Where._Ptr;
; 853  : 
; 854  :         auto& _My_data   = _Mypair._Myval2;
; 855  :         pointer& _Mylast = _My_data._Mylast;
; 856  : 
; 857  :         const pointer _Oldfirst = _My_data._Myfirst;
; 858  :         const pointer _Oldlast  = _Mylast;
; 859  : #if _ITERATOR_DEBUG_LEVEL == 2
; 860  :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_My_data) && _Whereptr >= _Oldfirst && _Oldlast >= _Whereptr,
; 861  :             "vector insert iterator outside range");
; 862  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 863  : 
; 864  :         const auto _Whereoff        = static_cast<size_type>(_Whereptr - _Oldfirst);
; 865  :         const auto _Unused_capacity = static_cast<size_type>(_My_data._Myend - _Oldlast);
; 866  :         const bool _One_at_back     = _Count == 1 && _Whereptr == _Oldlast;
; 867  :         if (_Count == 0) { // nothing to do, avoid invalidating iterators
; 868  :         } else if (_Count > _Unused_capacity) { // reallocate
; 869  :             const auto _Oldsize = static_cast<size_type>(_Oldlast - _Oldfirst);
; 870  : 
; 871  :             if (_Count > max_size() - _Oldsize) {
; 872  :                 _Xlength();
; 873  :             }
; 874  : 
; 875  :             const size_type _Newsize     = _Oldsize + _Count;
; 876  :             const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 877  : 
; 878  :             const pointer _Newvec           = _Getal().allocate(_Newcapacity);
; 879  :             const pointer _Constructed_last = _Newvec + _Whereoff + _Count;
; 880  :             pointer _Constructed_first      = _Constructed_last;
; 881  : 
; 882  :             _TRY_BEGIN
; 883  :             _Ufill(_Newvec + _Whereoff, _Count, _Val);
; 884  :             _Constructed_first = _Newvec + _Whereoff;
; 885  : 
; 886  :             if (_One_at_back) { // provide strong guarantee
; 887  :                 _Umove_if_noexcept(_Oldfirst, _Oldlast, _Newvec);
; 888  :             } else { // provide basic guarantee
; 889  :                 _Umove(_Oldfirst, _Whereptr, _Newvec);
; 890  :                 _Constructed_first = _Newvec;
; 891  :                 _Umove(_Whereptr, _Oldlast, _Newvec + _Whereoff + _Count);
; 892  :             }
; 893  :             _CATCH_ALL
; 894  :             _Destroy(_Constructed_first, _Constructed_last);
; 895  :             _Getal().deallocate(_Newvec, _Newcapacity);
; 896  :             _RERAISE;
; 897  :             _CATCH_END
; 898  : 
; 899  :             _Change_array(_Newvec, _Newsize, _Newcapacity);
; 900  :         } else if (_One_at_back) { // provide strong guarantee
; 901  :             _Emplace_back_with_unused_capacity(_Val);
; 902  :         } else { // provide basic guarantee
; 903  :             const _Alloc_temporary<_Alty> _Tmp_storage(_Getal(), _Val); // handle aliasing
; 904  :             const auto& _Tmp              = _Tmp_storage._Storage._Value;
; 905  :             const auto _Affected_elements = static_cast<size_type>(_Oldlast - _Whereptr);
; 906  :             _Orphan_range(_Whereptr, _Oldlast);
; 907  : 
; 908  :             if (_Count > _Affected_elements) { // new stuff spills off end
; 909  :                 _Mylast = _Ufill(_Oldlast, _Count - _Affected_elements, _Tmp);
; 910  :                 _Mylast = _Umove(_Whereptr, _Oldlast, _Mylast);
; 911  :                 _STD fill(_Whereptr, _Oldlast, _Tmp);
; 912  :             } else { // new stuff can all be assigned
; 913  :                 _Mylast = _Umove(_Oldlast - _Count, _Oldlast, _Oldlast);
; 914  :                 _Move_backward_unchecked(_Whereptr, _Oldlast - _Count, _Oldlast);
; 915  :                 _STD fill(_Whereptr, _Whereptr + _Count, _Tmp);
; 916  :             }
; 917  :         }
; 918  : 
; 919  :         return _Make_iterator_offset(_Whereoff);
; 920  :     }
; 921  : 
; 922  : private:
; 923  :     template <class _Iter>
; 924  :     _CONSTEXPR20_CONTAINER void _Insert_range(const_iterator _Where, _Iter _First, _Iter _Last, input_iterator_tag) {
; 925  :         // insert input range [_First, _Last) at _Where
; 926  :         if (_First == _Last) {
; 927  :             return; // nothing to do, avoid invalidating iterators
; 928  :         }
; 929  : 
; 930  :         auto& _My_data       = _Mypair._Myval2;
; 931  :         pointer& _Myfirst    = _My_data._Myfirst;
; 932  :         pointer& _Mylast     = _My_data._Mylast;
; 933  :         const auto _Whereoff = static_cast<size_type>(_Where._Ptr - _Myfirst);
; 934  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);
; 935  : 
; 936  :         // For one-at-back, provide strong guarantee.
; 937  :         // Otherwise, provide basic guarantee (despite N4659 26.3.11.5 [vector.modifiers]/1).
; 938  :         // Performance note: except for one-at-back, emplace_back()'s strong guarantee is unnecessary here.
; 939  : 
; 940  :         for (; _First != _Last; ++_First) {
; 941  :             emplace_back(*_First);
; 942  :         }
; 943  : 
; 944  :         _Orphan_range(_Myfirst + _Whereoff, _Myfirst + _Oldsize);
; 945  : 
; 946  :         _STD rotate(_Myfirst + _Whereoff, _Myfirst + _Oldsize, _Mylast);
; 947  :     }
; 948  : 
; 949  :     template <class _Iter>
; 950  :     _CONSTEXPR20_CONTAINER void _Insert_range(const_iterator _Where, _Iter _First, _Iter _Last, forward_iterator_tag) {
; 951  :         // insert forward range [_First, _Last) at _Where
; 952  :         const pointer _Whereptr = _Where._Ptr;
; 953  :         const auto _Count       = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
; 954  : 
; 955  :         auto& _My_data   = _Mypair._Myval2;
; 956  :         pointer& _Mylast = _My_data._Mylast;
; 957  : 
; 958  :         const pointer _Oldfirst     = _My_data._Myfirst;
; 959  :         const pointer _Oldlast      = _Mylast;
; 960  :         const auto _Unused_capacity = static_cast<size_type>(_My_data._Myend - _Oldlast);
; 961  : 
; 962  :         if (_Count == 0) { // nothing to do, avoid invalidating iterators
; 963  :         } else if (_Count > _Unused_capacity) { // reallocate
; 964  :             const auto _Oldsize = static_cast<size_type>(_Oldlast - _Oldfirst);
; 965  : 
; 966  :             if (_Count > max_size() - _Oldsize) {
; 967  :                 _Xlength();
; 968  :             }
; 969  : 
; 970  :             const size_type _Newsize     = _Oldsize + _Count;
; 971  :             const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 972  : 
; 973  :             const pointer _Newvec           = _Getal().allocate(_Newcapacity);
; 974  :             const auto _Whereoff            = static_cast<size_type>(_Whereptr - _Oldfirst);
; 975  :             const pointer _Constructed_last = _Newvec + _Whereoff + _Count;
; 976  :             pointer _Constructed_first      = _Constructed_last;
; 977  : 
; 978  :             _TRY_BEGIN
; 979  :             _Ucopy(_First, _Last, _Newvec + _Whereoff);
; 980  :             _Constructed_first = _Newvec + _Whereoff;
; 981  : 
; 982  :             if (_Count == 1 && _Whereptr == _Oldlast) { // one at back, provide strong guarantee
; 983  :                 _Umove_if_noexcept(_Oldfirst, _Oldlast, _Newvec);
; 984  :             } else { // provide basic guarantee
; 985  :                 _Umove(_Oldfirst, _Whereptr, _Newvec);
; 986  :                 _Constructed_first = _Newvec;
; 987  :                 _Umove(_Whereptr, _Oldlast, _Newvec + _Whereoff + _Count);
; 988  :             }
; 989  :             _CATCH_ALL
; 990  :             _Destroy(_Constructed_first, _Constructed_last);
; 991  :             _Getal().deallocate(_Newvec, _Newcapacity);
; 992  :             _RERAISE;
; 993  :             _CATCH_END
; 994  : 
; 995  :             _Change_array(_Newvec, _Newsize, _Newcapacity);
; 996  :         } else { // Attempt to provide the strong guarantee for EmplaceConstructible failure.
; 997  :                  // If we encounter copy/move construction/assignment failure, provide the basic guarantee.
; 998  :                  // (For one-at-back, this provides the strong guarantee.)
; 999  : 
; 1000 :             const auto _Affected_elements = static_cast<size_type>(_Oldlast - _Whereptr);
; 1001 : 
; 1002 :             if (_Count < _Affected_elements) { // some affected elements must be assigned
; 1003 :                 _Mylast = _Umove(_Oldlast - _Count, _Oldlast, _Oldlast);
; 1004 :                 _Move_backward_unchecked(_Whereptr, _Oldlast - _Count, _Oldlast);
; 1005 :                 _Destroy(_Whereptr, _Whereptr + _Count);
; 1006 : 
; 1007 :                 _TRY_BEGIN
; 1008 :                 _Ucopy(_First, _Last, _Whereptr);
; 1009 :                 _CATCH_ALL
; 1010 :                 // glue the broken pieces back together
; 1011 : 
; 1012 :                 _TRY_BEGIN
; 1013 :                 _Umove(_Whereptr + _Count, _Whereptr + 2 * _Count, _Whereptr);
; 1014 :                 _CATCH_ALL
; 1015 :                 // vaporize the detached piece
; 1016 :                 _Orphan_range(_Whereptr, _Oldlast);
; 1017 :                 _Destroy(_Whereptr + _Count, _Mylast);
; 1018 :                 _Mylast = _Whereptr;
; 1019 :                 _RERAISE;
; 1020 :                 _CATCH_END
; 1021 : 
; 1022 :                 _Move_unchecked(_Whereptr + 2 * _Count, _Mylast, _Whereptr + _Count);
; 1023 :                 _Destroy(_Oldlast, _Mylast);
; 1024 :                 _Mylast = _Oldlast;
; 1025 :                 _RERAISE;
; 1026 :                 _CATCH_END
; 1027 :             } else { // affected elements don't overlap before/after
; 1028 :                 const pointer _Relocated = _Whereptr + _Count;
; 1029 :                 _Mylast                  = _Umove(_Whereptr, _Oldlast, _Relocated);
; 1030 :                 _Destroy(_Whereptr, _Oldlast);
; 1031 : 
; 1032 :                 _TRY_BEGIN
; 1033 :                 _Ucopy(_First, _Last, _Whereptr);
; 1034 :                 _CATCH_ALL
; 1035 :                 // glue the broken pieces back together
; 1036 : 
; 1037 :                 _TRY_BEGIN
; 1038 :                 _Umove(_Relocated, _Mylast, _Whereptr);
; 1039 :                 _CATCH_ALL
; 1040 :                 // vaporize the detached piece
; 1041 :                 _Orphan_range(_Whereptr, _Oldlast);
; 1042 :                 _Destroy(_Relocated, _Mylast);
; 1043 :                 _Mylast = _Whereptr;
; 1044 :                 _RERAISE;
; 1045 :                 _CATCH_END
; 1046 : 
; 1047 :                 _Destroy(_Relocated, _Mylast);
; 1048 :                 _Mylast = _Oldlast;
; 1049 :                 _RERAISE;
; 1050 :                 _CATCH_END
; 1051 :             }
; 1052 : 
; 1053 :             _Orphan_range(_Whereptr, _Oldlast);
; 1054 :         }
; 1055 :     }
; 1056 : 
; 1057 : public:
; 1058 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 1059 :     _CONSTEXPR20_CONTAINER iterator insert(const_iterator _Where, _Iter _First, _Iter _Last) {
; 1060 :         const pointer _Whereptr = _Where._Ptr;
; 1061 :         auto& _My_data          = _Mypair._Myval2;
; 1062 :         const pointer _Oldfirst = _My_data._Myfirst;
; 1063 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1064 :         _STL_VERIFY(
; 1065 :             _Where._Getcont() == _STD addressof(_My_data) && _Whereptr >= _Oldfirst && _My_data._Mylast >= _Whereptr,
; 1066 :             "vector insert iterator outside range");
; 1067 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1068 : 
; 1069 :         _Adl_verify_range(_First, _Last);
; 1070 :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Oldfirst);
; 1071 :         _Insert_range(_Where, _Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
; 1072 :         return _Make_iterator_offset(_Whereoff);
; 1073 :     }
; 1074 : 
; 1075 :     _CONSTEXPR20_CONTAINER iterator insert(const_iterator _Where, initializer_list<_Ty> _Ilist) {
; 1076 :         return insert(_Where, _Ilist.begin(), _Ilist.end());
; 1077 :     }
; 1078 : 
; 1079 :     _CONSTEXPR20_CONTAINER void assign(_CRT_GUARDOVERFLOW const size_type _Newsize, const _Ty& _Val) {
; 1080 :         // assign _Newsize * _Val
; 1081 :         auto& _My_data    = _Mypair._Myval2;
; 1082 :         pointer& _Myfirst = _My_data._Myfirst;
; 1083 :         pointer& _Mylast  = _My_data._Mylast;
; 1084 : 
; 1085 :         _My_data._Orphan_all();
; 1086 : 
; 1087 :         auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
; 1088 :         if (_Newsize > _Oldsize) {
; 1089 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);
; 1090 :             if (_Newsize > _Oldcapacity) { // reallocate
; 1091 :                 _Clear_and_reserve_geometric(_Newsize);
; 1092 :                 _Oldsize = 0;
; 1093 :             } else {
; 1094 :                 _STD fill(_Myfirst, _Mylast, _Val);
; 1095 :             }
; 1096 : 
; 1097 :             _Mylast = _Ufill(_Mylast, _Newsize - _Oldsize, _Val);
; 1098 :         } else {
; 1099 :             const pointer _Newlast = _Myfirst + _Newsize;
; 1100 :             _STD fill(_Myfirst, _Newlast, _Val);
; 1101 :             _Destroy(_Newlast, _Mylast);
; 1102 :             _Mylast = _Newlast;
; 1103 :         }
; 1104 :     }
; 1105 : 
; 1106 : private:
; 1107 :     template <class _Iter>
; 1108 :     _CONSTEXPR20_CONTAINER void _Assign_range(_Iter _First, _Iter _Last, input_iterator_tag) {
; 1109 :         // assign input range [_First, _Last)
; 1110 :         auto& _My_data    = _Mypair._Myval2;
; 1111 :         pointer& _Myfirst = _My_data._Myfirst;
; 1112 :         pointer& _Mylast  = _My_data._Mylast;
; 1113 : 
; 1114 :         _My_data._Orphan_all();
; 1115 : 
; 1116 :         pointer _Next = _Myfirst;
; 1117 : 
; 1118 :         for (; _First != _Last && _Next != _Mylast; ++_First, (void) ++_Next) {
; 1119 :             *_Next = *_First;
; 1120 :         }
; 1121 : 
; 1122 :         // Code size optimization: we've exhausted only the source, only the dest, or both.
; 1123 :         // If we've exhausted only the source: we Trim, then Append does nothing.
; 1124 :         // If we've exhausted only the dest: Trim does nothing, then we Append.
; 1125 :         // If we've exhausted both: Trim does nothing, then Append does nothing.
; 1126 : 
; 1127 :         // Trim.
; 1128 :         _Destroy(_Next, _Mylast);
; 1129 :         _Mylast = _Next;
; 1130 : 
; 1131 :         // Append.
; 1132 :         for (; _First != _Last; ++_First) {
; 1133 :             emplace_back(*_First); // performance note: emplace_back()'s strong guarantee is unnecessary here
; 1134 :         }
; 1135 :     }
; 1136 : 
; 1137 :     template <class _Iter>
; 1138 :     _CONSTEXPR20_CONTAINER void _Assign_range(_Iter _First, _Iter _Last, forward_iterator_tag) {
; 1139 :         // assign forward range [_First, _Last)
; 1140 :         const auto _Newsize = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
; 1141 :         auto& _My_data      = _Mypair._Myval2;
; 1142 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1143 :         pointer& _Mylast    = _My_data._Mylast;
; 1144 :         pointer& _Myend     = _My_data._Myend;
; 1145 : 
; 1146 :         _My_data._Orphan_all();
; 1147 : 
; 1148 :         if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<_Iter, _Ty*>::_Trivially_copyable>,
; 1149 :                           _Uses_default_construct<_Alty, _Ty*, decltype(*_First)>,
; 1150 :                           _Uses_default_destroy<_Alty, _Ty*>>) {
; 1151 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1152 :             if (!_STD is_constant_evaluated())
; 1153 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1154 :             {
; 1155 :                 const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);
; 1156 :                 if (_Newsize > _Oldcapacity) {
; 1157 :                     _Clear_and_reserve_geometric(_Newsize);
; 1158 :                 }
; 1159 : 
; 1160 :                 _Mylast = _Refancy<pointer>(_Copy_memmove(_First, _Last, _Unfancy(_Myfirst)));
; 1161 :                 return;
; 1162 :             }
; 1163 :         }
; 1164 :         auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
; 1165 : 
; 1166 :         if (_Newsize > _Oldsize) {
; 1167 :             const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);
; 1168 :             if (_Newsize > _Oldcapacity) { // reallocate
; 1169 :                 _Clear_and_reserve_geometric(_Newsize);
; 1170 :                 _Oldsize = 0;
; 1171 :             }
; 1172 : 
; 1173 :             // performance note: traversing [_First, _Mid) twice
; 1174 :             const _Iter _Mid = _STD next(_First, static_cast<difference_type>(_Oldsize));
; 1175 :             _Copy_unchecked(_First, _Mid, _Myfirst);
; 1176 :             _Mylast = _Ucopy(_Mid, _Last, _Mylast);
; 1177 :         } else {
; 1178 :             const pointer _Newlast = _Myfirst + _Newsize;
; 1179 :             _Copy_unchecked(_First, _Last, _Myfirst);
; 1180 :             _Destroy(_Newlast, _Mylast);
; 1181 :             _Mylast = _Newlast;
; 1182 :         }
; 1183 :     }
; 1184 : 
; 1185 : public:
; 1186 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 1187 :     _CONSTEXPR20_CONTAINER void assign(_Iter _First, _Iter _Last) {
; 1188 :         _Adl_verify_range(_First, _Last);
; 1189 :         _Assign_range(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
; 1190 :     }
; 1191 : 
; 1192 :     _CONSTEXPR20_CONTAINER void assign(initializer_list<_Ty> _Ilist) {
; 1193 :         _Assign_range(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});
; 1194 :     }
; 1195 : 
; 1196 : private:
; 1197 :     _CONSTEXPR20_CONTAINER void _Copy_assign(const vector& _Right, false_type) {
; 1198 :         _Pocca(_Getal(), _Right._Getal());
; 1199 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1200 :         assign(_Right_data._Myfirst, _Right_data._Mylast);
; 1201 :     }
; 1202 : 
; 1203 :     _CONSTEXPR20_CONTAINER void _Copy_assign(const vector& _Right, true_type) {
; 1204 :         if (_Getal() != _Right._Getal()) {
; 1205 :             _Tidy();
; 1206 :             _Mypair._Myval2._Reload_proxy(
; 1207 :                 _GET_PROXY_ALLOCATOR(_Alty, _Getal()), _GET_PROXY_ALLOCATOR(_Alty, _Right._Getal()));
; 1208 :         }
; 1209 : 
; 1210 :         _Copy_assign(_Right, false_type{});
; 1211 :     }
; 1212 : 
; 1213 : public:
; 1214 :     _CONSTEXPR20_CONTAINER vector& operator=(const vector& _Right) {
; 1215 :         if (this != _STD addressof(_Right)) {
; 1216 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});
; 1217 :         }
; 1218 : 
; 1219 :         return *this;
; 1220 :     }
; 1221 : 
; 1222 :     _CONSTEXPR20_CONTAINER vector& operator=(initializer_list<_Ty> _Ilist) {
; 1223 :         _Assign_range(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});
; 1224 :         return *this;
; 1225 :     }
; 1226 : 
; 1227 : private:
; 1228 :     template <class _Ty2>
; 1229 :     _CONSTEXPR20_CONTAINER void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {
; 1230 :         if (_Newsize > max_size()) {
; 1231 :             _Xlength();
; 1232 :         }
; 1233 : 
; 1234 :         auto& _My_data    = _Mypair._Myval2;
; 1235 :         pointer& _Myfirst = _My_data._Myfirst;
; 1236 :         pointer& _Mylast  = _My_data._Mylast;
; 1237 : 
; 1238 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);
; 1239 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1240 : 
; 1241 :         const pointer _Newvec         = _Getal().allocate(_Newcapacity);
; 1242 :         const pointer _Appended_first = _Newvec + _Oldsize;
; 1243 :         pointer _Appended_last        = _Appended_first;
; 1244 : 
; 1245 :         _TRY_BEGIN
; 1246 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);
; 1247 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 1248 :         _CATCH_ALL
; 1249 :         _Destroy(_Appended_first, _Appended_last);
; 1250 :         _Getal().deallocate(_Newvec, _Newcapacity);
; 1251 :         _RERAISE;
; 1252 :         _CATCH_END
; 1253 : 
; 1254 :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 1255 :     }
; 1256 : 
; 1257 :     template <class _Ty2>
; 1258 :     _CONSTEXPR20_CONTAINER void _Resize(const size_type _Newsize, const _Ty2& _Val) {
; 1259 :         // trim or append elements, provide strong guarantee
; 1260 :         auto& _My_data      = _Mypair._Myval2;
; 1261 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1262 :         pointer& _Mylast    = _My_data._Mylast;
; 1263 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
; 1264 :         if (_Newsize < _Oldsize) { // trim
; 1265 :             const pointer _Newlast = _Myfirst + _Newsize;
; 1266 :             _Orphan_range(_Newlast, _Mylast);
; 1267 :             _Destroy(_Newlast, _Mylast);
; 1268 :             _Mylast = _Newlast;
; 1269 :             return;
; 1270 :         }
; 1271 : 
; 1272 :         if (_Newsize > _Oldsize) { // append
; 1273 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);
; 1274 :             if (_Newsize > _Oldcapacity) { // reallocate
; 1275 :                 _Resize_reallocate(_Newsize, _Val);
; 1276 :                 return;
; 1277 :             }
; 1278 : 
; 1279 :             const pointer _Oldlast = _Mylast;
; 1280 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);
; 1281 :             _Orphan_range(_Oldlast, _Oldlast);
; 1282 :         }
; 1283 : 
; 1284 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1285 :     }
; 1286 : 
; 1287 : public:
; 1288 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {
; 1289 :         // trim or append value-initialized elements, provide strong guarantee
; 1290 :         _Resize(_Newsize, _Value_init_tag{});
; 1291 :     }
; 1292 : 
; 1293 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize, const _Ty& _Val) {
; 1294 :         // trim or append copies of _Val, provide strong guarantee
; 1295 :         _Resize(_Newsize, _Val);
; 1296 :     }
; 1297 : 
; 1298 : private:
; 1299 :     _CONSTEXPR20_CONTAINER void _Reallocate_exactly(const size_type _Newcapacity) {
; 1300 :         // set capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1301 :         auto& _My_data    = _Mypair._Myval2;
; 1302 :         pointer& _Myfirst = _My_data._Myfirst;
; 1303 :         pointer& _Mylast  = _My_data._Mylast;
; 1304 : 
; 1305 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);
; 1306 : 
; 1307 :         const pointer _Newvec = _Getal().allocate(_Newcapacity);
; 1308 : 
; 1309 :         _TRY_BEGIN
; 1310 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 1311 :         _CATCH_ALL
; 1312 :         _Getal().deallocate(_Newvec, _Newcapacity);
; 1313 :         _RERAISE;
; 1314 :         _CATCH_END
; 1315 : 
; 1316 :         _Change_array(_Newvec, _Size, _Newcapacity);
; 1317 :     }
; 1318 : 
; 1319 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1320 :     void _Check_all_orphaned_locked() const noexcept {
; 1321 :         _Lockit _Lock(_LOCK_DEBUG);
; 1322 :         auto& _My_data = _Mypair._Myval2;
; 1323 :         _STL_INTERNAL_CHECK(!_My_data._Myproxy->_Myfirstiter);
; 1324 :     }
; 1325 : 
; 1326 :     _CONSTEXPR20_CONTAINER void _Check_all_orphaned() const noexcept {
; 1327 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1328 :         if (_STD is_constant_evaluated()) {
; 1329 :             auto& _My_data = _Mypair._Myval2;
; 1330 :             _STL_INTERNAL_CHECK(!_My_data._Myproxy->_Myfirstiter);
; 1331 :         } else
; 1332 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1333 :         {
; 1334 :             _Check_all_orphaned_locked();
; 1335 :         }
; 1336 :     }
; 1337 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1338 : 
; 1339 :     _CONSTEXPR20_CONTAINER void _Clear_and_reserve_geometric(const size_type _Newsize) {
; 1340 :         auto& _My_data    = _Mypair._Myval2;
; 1341 :         pointer& _Myfirst = _My_data._Myfirst;
; 1342 :         pointer& _Mylast  = _My_data._Mylast;
; 1343 :         pointer& _Myend   = _My_data._Myend;
; 1344 : 
; 1345 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1346 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1347 :         _Check_all_orphaned();
; 1348 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1349 : 
; 1350 :         if (_Newsize > max_size()) {
; 1351 :             _Xlength();
; 1352 :         }
; 1353 : 
; 1354 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1355 : 
; 1356 :         if (_Myfirst) { // destroy and deallocate old array
; 1357 :             _Destroy(_Myfirst, _Mylast);
; 1358 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));
; 1359 : 
; 1360 :             _Myfirst = nullptr;
; 1361 :             _Mylast  = nullptr;
; 1362 :             _Myend   = nullptr;
; 1363 :         }
; 1364 : 
; 1365 :         _Buy_raw(_Newcapacity);
; 1366 :     }
; 1367 : 
; 1368 : public:
; 1369 :     _CONSTEXPR20_CONTAINER void reserve(_CRT_GUARDOVERFLOW const size_type _Newcapacity) {
; 1370 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1371 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  0007e	8b 85 b0 fb ff
	ff		 mov	 eax, DWORD PTR _pstTokenVector$GSCopy$1$[ebp]
$LN16@SplitLine2:

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00084	50		 push	 eax
  00085	ff 70 04	 push	 DWORD PTR [eax+4]
  00088	56		 push	 esi
  00089	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1456 :         _Mylast = _Myfirst;

  0008e	8b 8d b0 fb ff
	ff		 mov	 ecx, DWORD PTR _pstTokenVector$GSCopy$1$[ebp]

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00094	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00097	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _stToken$[ebp], 0

; 4596 :         _My_data._Mysize = 0;

  0009e	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _stToken$[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  000a5	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _stToken$[ebp+20], 15 ; 0000000fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1456 :         _Mylast = _Myfirst;

  000ac	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ae	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  000b1	c6 45 c0 00	 mov	 BYTE PTR _stToken$[ebp], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 44   : 	const std::string & c_rstLine = GetLineString(dwLine);

  000b5	ff b5 bc fb ff
	ff		 push	 DWORD PTR _dwLine$GSCopy$1$[ebp]
  000bb	8b cf		 mov	 ecx, edi
  000bd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000c4	e8 00 00 00 00	 call	 ?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; CMemoryTextFileLoader::GetLineString
  000c9	8b d0		 mov	 edx, eax

; 45   : 
; 46   : 	DWORD basePos = 0;

  000cb	33 ff		 xor	 edi, edi
  000cd	89 95 ac fb ff
	ff		 mov	 DWORD PTR _c_rstLine$1$[ebp], edx
$LL4@SplitLine2:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  000d3	8b b5 b4 fb ff
	ff		 mov	 esi, DWORD PTR _c_szDelimeter$GSCopy$1$[ebp]
  000d9	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  000dc	0f 1f 40 00	 npad	 4
$LL435@SplitLine2:
  000e0	8a 06		 mov	 al, BYTE PTR [esi]
  000e2	46		 inc	 esi
  000e3	84 c0		 test	 al, al
  000e5	75 f9		 jne	 SHORT $LL435@SplitLine2
  000e7	2b f1		 sub	 esi, ecx

; 2305 :         const value_type* _Result = _Bx._Buf;

  000e9	89 95 bc fb ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], edx

; 2306 :         if (_Large_string_engaged()) {

  000ef	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  000f3	72 08		 jb	 SHORT $LN428@SplitLine2

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  000f5	8b 02		 mov	 eax, DWORD PTR [edx]
  000f7	89 85 bc fb ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], eax
$LN428@SplitLine2:

; 4305 :         return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(_Mypair._Myval2._Myptr(),

  000fd	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00100	89 85 b8 fb ff
	ff		 mov	 DWORD PTR __Hay_size$1$[ebp], eax

; 863  :     if (_Start_at < _Hay_size) { // room for match, look for it

  00106	3b f8		 cmp	 edi, eax
  00108	73 69		 jae	 SHORT $LN382@SplitLine2
  0010a	68 00 01 00 00	 push	 256			; 00000100H
  0010f	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR __Matches$5[ebp]
  00115	6a 00		 push	 0
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 _memset

; 864  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 865  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,

  0011d	8b 85 b4 fb ff
	ff		 mov	 eax, DWORD PTR _c_szDelimeter$GSCopy$1$[ebp]
  00123	83 c4 0c	 add	 esp, 12			; 0000000cH
  00126	8b c8		 mov	 ecx, eax
  00128	8d 14 30	 lea	 edx, DWORD PTR [eax+esi]

; 704  :         for (; _First != _Last; ++_First) {

  0012b	3b c2		 cmp	 eax, edx
  0012d	74 11		 je	 SHORT $LN60@SplitLine2
  0012f	90		 npad	 1
$LL61@SplitLine2:

; 705  :             _Matches[static_cast<unsigned char>(*_First)] = true;

  00130	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00133	41		 inc	 ecx
  00134	c6 84 05 c0 fe
	ff ff 01	 mov	 BYTE PTR __Matches$5[ebp+eax], 1
  0013c	3b ca		 cmp	 ecx, edx
  0013e	75 f0		 jne	 SHORT $LL61@SplitLine2
$LN60@SplitLine2:

; 871  :         const auto _End = _Haystack + _Hay_size;

  00140	8b 95 bc fb ff
	ff		 mov	 edx, DWORD PTR __Result$1$[ebp]
  00146	8b 8d b8 fb ff
	ff		 mov	 ecx, DWORD PTR __Hay_size$1$[ebp]
  0014c	03 ca		 add	 ecx, edx

; 872  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {

  0014e	8d 34 3a	 lea	 esi, DWORD PTR [edx+edi]
  00151	3b f1		 cmp	 esi, ecx
  00153	73 1e		 jae	 SHORT $LN382@SplitLine2
  00155	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL51@SplitLine2:

; 712  :         return _Matches[static_cast<unsigned char>(_Ch)];

  00160	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00163	8a 84 05 c0 fe
	ff ff		 mov	 al, BYTE PTR __Matches$5[ebp+eax]

; 873  :             if (!_Matches._Match(*_Match_try)) {

  0016a	84 c0		 test	 al, al
  0016c	74 25		 je	 SHORT $LN375@SplitLine2

; 872  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {

  0016e	46		 inc	 esi
  0016f	3b f1		 cmp	 esi, ecx
  00171	72 ed		 jb	 SHORT $LL51@SplitLine2
$LN382@SplitLine2:
  00173	83 c8 ff	 or	 eax, -1
$LN1@SplitLine2:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 81   : }

  00176	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00179	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00180	59		 pop	 ecx
  00181	5f		 pop	 edi
  00182	5e		 pop	 esi
  00183	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00186	33 cd		 xor	 ecx, ebp
  00188	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018d	8b e5		 mov	 esp, ebp
  0018f	5d		 pop	 ebp
  00190	c2 0c 00	 ret	 12			; 0000000cH
$LN375@SplitLine2:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 874  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match

  00193	2b f2		 sub	 esi, edx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 52   : 		if (beginPos < 0)

  00195	78 dc		 js	 SHORT $LN382@SplitLine2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2305 :         const value_type* _Result = _Bx._Buf;

  00197	8b 95 ac fb ff
	ff		 mov	 edx, DWORD PTR _c_rstLine$1$[ebp]
  0019d	8b c2		 mov	 eax, edx

; 2306 :         if (_Large_string_engaged()) {

  0019f	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  001a2	83 f9 10	 cmp	 ecx, 16			; 00000010H
  001a5	72 02		 jb	 SHORT $LN429@SplitLine2

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  001a7	8b 02		 mov	 eax, DWORD PTR [edx]
$LN429@SplitLine2:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 57   : 		if (c_rstLine[beginPos] == '"')

  001a9	80 3c 06 22	 cmp	 BYTE PTR [esi+eax], 34	; 00000022H
  001ad	75 6a		 jne	 SHORT $LN6@SplitLine2

; 58   : 		{
; 59   : 			++beginPos;

  001af	46		 inc	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2305 :         const value_type* _Result = _Bx._Buf;

  001b0	8b fa		 mov	 edi, edx

; 2306 :         if (_Large_string_engaged()) {

  001b2	83 f9 10	 cmp	 ecx, 16			; 00000010H
  001b5	72 02		 jb	 SHORT $LN430@SplitLine2

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  001b7	8b 3a		 mov	 edi, DWORD PTR [edx]
$LN430@SplitLine2:

; 773  :     if (_Needle_size != 0 && _Start_at < _Hay_size) { // room for match, look for it

  001b9	3b b5 b8 fb ff
	ff		 cmp	 esi, DWORD PTR __Hay_size$1$[ebp]
  001bf	73 42		 jae	 SHORT $LN434@SplitLine2
  001c1	68 00 01 00 00	 push	 256			; 00000100H
  001c6	8d 85 c0 fd ff
	ff		 lea	 eax, DWORD PTR __Matches$4[ebp]
  001cc	6a 00		 push	 0
  001ce	50		 push	 eax
  001cf	e8 00 00 00 00	 call	 _memset

; 776  :                                                                 // fall back to the serial algorithm
; 777  :             return _Traits_find_first_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
; 778  :         }
; 779  : 
; 780  :         const auto _End = _Haystack + _Hay_size;

  001d4	8b 95 b8 fb ff
	ff		 mov	 edx, DWORD PTR __Hay_size$1$[ebp]

; 781  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {

  001da	8d 0c 37	 lea	 ecx, DWORD PTR [edi+esi]
  001dd	03 d7		 add	 edx, edi

; 705  :             _Matches[static_cast<unsigned char>(*_First)] = true;

  001df	c6 85 e2 fd ff
	ff 01		 mov	 BYTE PTR __Matches$4[ebp+34], 1
  001e6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 781  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {

  001e9	3b ca		 cmp	 ecx, edx
  001eb	73 16		 jae	 SHORT $LN434@SplitLine2
  001ed	0f 1f 00	 npad	 3
$LL120@SplitLine2:

; 712  :         return _Matches[static_cast<unsigned char>(_Ch)];

  001f0	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  001f3	8a 84 05 c0 fd
	ff ff		 mov	 al, BYTE PTR __Matches$4[ebp+eax]

; 782  :             if (_Matches._Match(*_Match_try)) {

  001fa	84 c0		 test	 al, al
  001fc	75 0f		 jne	 SHORT $LN377@SplitLine2

; 781  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {

  001fe	41		 inc	 ecx
  001ff	3b ca		 cmp	 ecx, edx
  00201	72 ed		 jb	 SHORT $LL120@SplitLine2
$LN434@SplitLine2:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 63   : 				return -2;

  00203	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00208	e9 69 ff ff ff	 jmp	 $LN1@SplitLine2
$LN377@SplitLine2:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 783  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match

  0020d	2b cf		 sub	 ecx, edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 62   : 			if (endPos < 0)

  0020f	78 f2		 js	 SHORT $LN434@SplitLine2

; 64   : 
; 65   : 			basePos = endPos + 1;

  00211	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]

; 66   : 		}

  00214	e9 a3 00 00 00	 jmp	 $LN7@SplitLine2
$LN6@SplitLine2:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00219	8b bd b4 fb ff
	ff		 mov	 edi, DWORD PTR _c_szDelimeter$GSCopy$1$[ebp]
  0021f	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
$LL436@SplitLine2:
  00222	8a 07		 mov	 al, BYTE PTR [edi]
  00224	47		 inc	 edi
  00225	84 c0		 test	 al, al
  00227	75 f9		 jne	 SHORT $LL436@SplitLine2
  00229	2b f9		 sub	 edi, ecx

; 2305 :         const value_type* _Result = _Bx._Buf;

  0022b	89 95 bc fb ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], edx

; 2306 :         if (_Large_string_engaged()) {

  00231	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  00235	72 08		 jb	 SHORT $LN431@SplitLine2

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  00237	8b 02		 mov	 eax, DWORD PTR [edx]
  00239	89 85 bc fb ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], eax
$LN431@SplitLine2:

; 773  :     if (_Needle_size != 0 && _Start_at < _Hay_size) { // room for match, look for it

  0023f	85 ff		 test	 edi, edi
  00241	74 74		 je	 SHORT $LN181@SplitLine2
  00243	3b b5 b8 fb ff
	ff		 cmp	 esi, DWORD PTR __Hay_size$1$[ebp]
  00249	73 6c		 jae	 SHORT $LN181@SplitLine2
  0024b	68 00 01 00 00	 push	 256			; 00000100H
  00250	8d 85 c0 fc ff
	ff		 lea	 eax, DWORD PTR __Matches$3[ebp]
  00256	6a 00		 push	 0
  00258	50		 push	 eax
  00259	e8 00 00 00 00	 call	 _memset

; 774  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 775  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,

  0025e	8b 85 b4 fb ff
	ff		 mov	 eax, DWORD PTR _c_szDelimeter$GSCopy$1$[ebp]
  00264	83 c4 0c	 add	 esp, 12			; 0000000cH
  00267	8b c8		 mov	 ecx, eax
  00269	8d 14 38	 lea	 edx, DWORD PTR [eax+edi]
  0026c	8b fe		 mov	 edi, esi

; 704  :         for (; _First != _Last; ++_First) {

  0026e	3b c2		 cmp	 eax, edx
  00270	74 10		 je	 SHORT $LN191@SplitLine2
$LL192@SplitLine2:

; 705  :             _Matches[static_cast<unsigned char>(*_First)] = true;

  00272	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00275	41		 inc	 ecx
  00276	c6 84 05 c0 fc
	ff ff 01	 mov	 BYTE PTR __Matches$3[ebp+eax], 1
  0027e	3b ca		 cmp	 ecx, edx
  00280	75 f0		 jne	 SHORT $LL192@SplitLine2
$LN191@SplitLine2:

; 780  :         const auto _End = _Haystack + _Hay_size;

  00282	8b 95 bc fb ff
	ff		 mov	 edx, DWORD PTR __Result$1$[ebp]

; 781  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {

  00288	03 fa		 add	 edi, edx
  0028a	8b 8d b8 fb ff
	ff		 mov	 ecx, DWORD PTR __Hay_size$1$[ebp]
  00290	03 ca		 add	 ecx, edx
  00292	3b f9		 cmp	 edi, ecx
  00294	73 21		 jae	 SHORT $LN181@SplitLine2
  00296	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL182@SplitLine2:

; 712  :         return _Matches[static_cast<unsigned char>(_Ch)];

  002a0	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  002a3	8a 84 05 c0 fc
	ff ff		 mov	 al, BYTE PTR __Matches$3[ebp+eax]

; 782  :             if (_Matches._Match(*_Match_try)) {

  002aa	84 c0		 test	 al, al
  002ac	0f 85 88 00 00
	00		 jne	 $LN379@SplitLine2

; 781  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {

  002b2	47		 inc	 edi
  002b3	3b f9		 cmp	 edi, ecx
  002b5	72 e9		 jb	 SHORT $LL182@SplitLine2
$LN181@SplitLine2:

; 784  :             }
; 785  :         }
; 786  :     }
; 787  : 
; 788  :     return static_cast<size_t>(-1); // no match

  002b7	83 cf ff	 or	 edi, -1
$LN179@SplitLine2:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 69   : 			endPos = c_rstLine.find_first_of(c_szDelimeter, beginPos);

  002ba	8b cf		 mov	 ecx, edi
$LN7@SplitLine2:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2324 :         if (_Mysize < _Off) {

  002bc	8b 85 b8 fb ff
	ff		 mov	 eax, DWORD PTR __Hay_size$1$[ebp]

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  002c2	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T6[ebp], 0

; 4596 :         _My_data._Mysize = 0;

  002c9	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T6[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  002d0	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T6[ebp+20], 15 ; 0000000fH

; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  002d7	c6 45 d8 00	 mov	 BYTE PTR $T6[ebp], 0

; 2324 :         if (_Mysize < _Off) {

  002db	3b c6		 cmp	 eax, esi
  002dd	0f 82 55 01 00
	00		 jb	 $LN384@SplitLine2

; 2305 :         const value_type* _Result = _Bx._Buf;

  002e3	8b 95 ac fb ff
	ff		 mov	 edx, DWORD PTR _c_rstLine$1$[ebp]

; 2342 :         return (_STD min)(_Size, _Mysize - _Off);

  002e9	2b c6		 sub	 eax, esi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 73   : 		pstTokenVector->push_back(c_rstLine.substr(beginPos, endPos - beginPos));

  002eb	2b ce		 sub	 ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2342 :         return (_STD min)(_Size, _Mysize - _Off);

  002ed	3b c1		 cmp	 eax, ecx
  002ef	0f 42 c8	 cmovb	 ecx, eax

; 2306 :         if (_Large_string_engaged()) {

  002f2	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  002f6	8b c2		 mov	 eax, edx
  002f8	72 02		 jb	 SHORT $LN432@SplitLine2

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  002fa	8b 02		 mov	 eax, DWORD PTR [edx]
$LN432@SplitLine2:

; 3224 :         return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);

  002fc	51		 push	 ecx
  002fd	03 c6		 add	 eax, esi
  002ff	8d 4d d8	 lea	 ecx, DWORD PTR $T6[ebp]
  00302	50		 push	 eax
  00303	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  00308	8b 8d b0 fb ff
	ff		 mov	 ecx, DWORD PTR _pstTokenVector$GSCopy$1$[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 73   : 		pstTokenVector->push_back(c_rstLine.substr(beginPos, endPos - beginPos));

  0030e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  00312	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00315	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00318	74 27		 je	 SHORT $LN241@SplitLine2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0031a	0f 10 45 d8	 movups	 xmm0, XMMWORD PTR $T6[ebp]

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0031e	ba 0f 00 00 00	 mov	 edx, 15			; 0000000fH

; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00323	c6 45 d8 00	 mov	 BYTE PTR $T6[ebp], 0

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00327	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  0032a	f3 0f 7e 45 e8	 movq	 xmm0, QWORD PTR $T6[ebp+16]
  0032f	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 729  :         ++_Mylast;

  00334	83 41 04 18	 add	 DWORD PTR [ecx+4], 24	; 00000018H

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00338	eb 14		 jmp	 SHORT $LN240@SplitLine2
$LN379@SplitLine2:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 783  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match

  0033a	2b fa		 sub	 edi, edx
  0033c	e9 79 ff ff ff	 jmp	 $LN179@SplitLine2
$LN241@SplitLine2:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00341	8d 55 d8	 lea	 edx, DWORD PTR $T6[ebp]
  00344	52		 push	 edx
  00345	50		 push	 eax
  00346	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  0034b	8b 55 ec	 mov	 edx, DWORD PTR $T6[ebp+20]
$LN240@SplitLine2:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 73   : 		pstTokenVector->push_back(c_rstLine.substr(beginPos, endPos - beginPos));

  0034e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00352	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00355	72 2c		 jb	 SHORT $LN284@SplitLine2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00357	8b 4d d8	 mov	 ecx, DWORD PTR $T6[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0035a	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0035b	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0035d	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00363	72 14		 jb	 SHORT $LN294@SplitLine2

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00365	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00368	83 c2 23	 add	 edx, 35			; 00000023H
  0036b	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0036d	83 c0 fc	 add	 eax, -4			; fffffffcH
  00370	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00373	0f 87 c4 00 00
	00		 ja	 $LN291@SplitLine2
$LN294@SplitLine2:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00379	52		 push	 edx
  0037a	51		 push	 ecx
  0037b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00380	83 c4 08	 add	 esp, 8
$LN284@SplitLine2:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00383	8b b5 b4 fb ff
	ff		 mov	 esi, DWORD PTR _c_szDelimeter$GSCopy$1$[ebp]
  00389	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  0038c	0f 1f 40 00	 npad	 4
$LL437@SplitLine2:
  00390	8a 06		 mov	 al, BYTE PTR [esi]
  00392	46		 inc	 esi
  00393	84 c0		 test	 al, al
  00395	75 f9		 jne	 SHORT $LL437@SplitLine2
  00397	2b f1		 sub	 esi, ecx

; 2305 :         const value_type* _Result = _Bx._Buf;

  00399	8b 8d ac fb ff
	ff		 mov	 ecx, DWORD PTR _c_rstLine$1$[ebp]
  0039f	89 8d bc fb ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], ecx

; 2319 :         return _BUF_SIZE <= _Myres;

  003a5	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 2306 :         if (_Large_string_engaged()) {

  003a9	72 08		 jb	 SHORT $LN427@SplitLine2

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  003ab	8b 01		 mov	 eax, DWORD PTR [ecx]
  003ad	89 85 bc fb ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], eax
$LN427@SplitLine2:

; 863  :     if (_Start_at < _Hay_size) { // room for match, look for it

  003b3	3b 79 10	 cmp	 edi, DWORD PTR [ecx+16]
  003b6	73 6a		 jae	 SHORT $LN3@SplitLine2
  003b8	68 00 01 00 00	 push	 256			; 00000100H
  003bd	8d 85 c0 fb ff
	ff		 lea	 eax, DWORD PTR __Matches$2[ebp]
  003c3	6a 00		 push	 0
  003c5	50		 push	 eax
  003c6	e8 00 00 00 00	 call	 _memset

; 864  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 865  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,

  003cb	8b 85 b4 fb ff
	ff		 mov	 eax, DWORD PTR _c_szDelimeter$GSCopy$1$[ebp]
  003d1	83 c4 0c	 add	 esp, 12			; 0000000cH
  003d4	8b c8		 mov	 ecx, eax
  003d6	8d 14 30	 lea	 edx, DWORD PTR [eax+esi]

; 704  :         for (; _First != _Last; ++_First) {

  003d9	3b c2		 cmp	 eax, edx
  003db	74 13		 je	 SHORT $LN320@SplitLine2
  003dd	0f 1f 00	 npad	 3
$LL321@SplitLine2:

; 705  :             _Matches[static_cast<unsigned char>(*_First)] = true;

  003e0	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  003e3	41		 inc	 ecx
  003e4	c6 84 05 c0 fb
	ff ff 01	 mov	 BYTE PTR __Matches$2[ebp+eax], 1
  003ec	3b ca		 cmp	 ecx, edx
  003ee	75 f0		 jne	 SHORT $LL321@SplitLine2
$LN320@SplitLine2:

; 871  :         const auto _End = _Haystack + _Hay_size;

  003f0	8b 95 ac fb ff
	ff		 mov	 edx, DWORD PTR _c_rstLine$1$[ebp]
  003f6	8b b5 bc fb ff
	ff		 mov	 esi, DWORD PTR __Result$1$[ebp]
  003fc	8b 52 10	 mov	 edx, DWORD PTR [edx+16]
  003ff	03 d6		 add	 edx, esi

; 872  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {

  00401	8d 0c 3e	 lea	 ecx, DWORD PTR [esi+edi]
  00404	3b ca		 cmp	 ecx, edx
  00406	73 1a		 jae	 SHORT $LN3@SplitLine2
  00408	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL311@SplitLine2:

; 712  :         return _Matches[static_cast<unsigned char>(_Ch)];

  00410	0f b6 01	 movzx	 eax, BYTE PTR [ecx]

; 873  :             if (!_Matches._Match(*_Match_try)) {

  00413	80 bc 05 c0 fb
	ff ff 00	 cmp	 BYTE PTR __Matches$2[ebp+eax], 0
  0041b	74 0c		 je	 SHORT $LN381@SplitLine2

; 872  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {

  0041d	41		 inc	 ecx
  0041e	3b ca		 cmp	 ecx, edx
  00420	72 ee		 jb	 SHORT $LL311@SplitLine2
$LN3@SplitLine2:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 80   : 	return 0;

  00422	33 c0		 xor	 eax, eax
  00424	e9 4d fd ff ff	 jmp	 $LN1@SplitLine2
$LN381@SplitLine2:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 874  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match

  00429	2b ce		 sub	 ecx, esi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 76   : 		if (int(c_rstLine.find_first_not_of(c_szDelimeter, basePos)) < 0)

  0042b	78 f5		 js	 SHORT $LN3@SplitLine2

; 77   : 			break;
; 78   : 	} while (basePos < c_rstLine.length());

  0042d	8b 95 ac fb ff
	ff		 mov	 edx, DWORD PTR _c_rstLine$1$[ebp]
  00433	e9 9b fc ff ff	 jmp	 $LL4@SplitLine2
$LN384@SplitLine2:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2325 :             _Xran();

  00438	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN291@SplitLine2:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0043d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN440@SplitLine2:
  00442	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SplitLine2@CMemoryTextFileLoader@@QAEHKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z$0:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR _stToken$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SplitLine2@CMemoryTextFileLoader@@QAEHKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z$1:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR $T6[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?SplitLine2@CMemoryTextFileLoader@@QAEHKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 8a ac fb ff
	ff		 mov	 ecx, DWORD PTR [edx-1108]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SplitLine2@CMemoryTextFileLoader@@QAEHKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SplitLine2@CMemoryTextFileLoader@@QAEHKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z ENDP ; CMemoryTextFileLoader::SplitLine2
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
;	COMDAT ?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z
_TEXT	SEGMENT
_c_rstLine$1$ = -1108					; size = 4
_pstTokenVector$GSCopy$1$ = -1104			; size = 4
_c_szDelimeter$GSCopy$1$ = -1100			; size = 4
__Hay_size$1$ = -1096					; size = 4
__Result$1$ = -1092					; size = 4
_dwLine$GSCopy$1$ = -1092				; size = 4
__Result$1$ = -1092					; size = 4
__Result$1$ = -1092					; size = 4
__Matches$2 = -1088					; size = 256
__Matches$3 = -832					; size = 256
__Matches$4 = -576					; size = 256
__Matches$5 = -320					; size = 256
_stToken$ = -64						; size = 24
$T6 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_dwLine$ = 8						; size = 4
_pstTokenVector$ = 12					; size = 4
_c_szDelimeter$ = 16					; size = 4
?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z PROC ; CMemoryTextFileLoader::SplitLine, COMDAT
; _this$ = ecx

; 84   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 48 04 00
	00		 sub	 esp, 1096		; 00000448H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b f9		 mov	 edi, ecx
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _pstTokenVector$[ebp]
  00032	8b 45 08	 mov	 eax, DWORD PTR _dwLine$[ebp]
  00035	89 85 bc fb ff
	ff		 mov	 DWORD PTR _dwLine$GSCopy$1$[ebp], eax
  0003b	8b 45 10	 mov	 eax, DWORD PTR _c_szDelimeter$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0003e	8b 31		 mov	 esi, DWORD PTR [ecx]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 84   : {

  00040	89 85 b4 fb ff
	ff		 mov	 DWORD PTR _c_szDelimeter$GSCopy$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00046	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 84   : {

  0004b	89 8d b0 fb ff
	ff		 mov	 DWORD PTR _pstTokenVector$GSCopy$1$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00051	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00054	2b ce		 sub	 ecx, esi
  00056	f7 e9		 imul	 ecx
  00058	c1 fa 02	 sar	 edx, 2
  0005b	8b c2		 mov	 eax, edx
  0005d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00060	03 c2		 add	 eax, edx

; 1371 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  00062	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00065	73 17		 jae	 SHORT $LN438@SplitLine

; 1372 :             if (_Newcapacity > max_size()) {
; 1373 :                 _Xlength();
; 1374 :             }
; 1375 : 
; 1376 :             _Reallocate_exactly(_Newcapacity);

  00067	8b 8d b0 fb ff
	ff		 mov	 ecx, DWORD PTR _pstTokenVector$GSCopy$1$[ebp]
  0006d	6a 0a		 push	 10			; 0000000aH
  0006f	e8 00 00 00 00	 call	 ?_Reallocate_exactly@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate_exactly
  00074	8b 85 b0 fb ff
	ff		 mov	 eax, DWORD PTR _pstTokenVector$GSCopy$1$[ebp]
  0007a	8b 30		 mov	 esi, DWORD PTR [eax]
  0007c	eb 06		 jmp	 SHORT $LN16@SplitLine
$LN438@SplitLine:

; 748  : #if _HAS_CXX17
; 749  :         return _Result;
; 750  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 751  :         (void) _Result;
; 752  : #endif // _HAS_CXX17
; 753  :     }
; 754  : 
; 755  :     _CONSTEXPR20_CONTAINER void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee
; 756  :         emplace_back(_Val);
; 757  :     }
; 758  : 
; 759  :     _CONSTEXPR20_CONTAINER void push_back(_Ty&& _Val) {
; 760  :         // insert by moving into element at end, provide strong guarantee
; 761  :         emplace_back(_STD move(_Val));
; 762  :     }
; 763  : 
; 764  :     template <class... _Valty>
; 765  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {
; 766  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 767  :         _Alty& _Al        = _Getal();
; 768  :         auto& _My_data    = _Mypair._Myval2;
; 769  :         pointer& _Myfirst = _My_data._Myfirst;
; 770  :         pointer& _Mylast  = _My_data._Mylast;
; 771  : 
; 772  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 773  : 
; 774  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);
; 775  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);
; 776  : 
; 777  :         if (_Oldsize == max_size()) {
; 778  :             _Xlength();
; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;
; 782  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 783  : 
; 784  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);
; 785  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 786  :         pointer _Constructed_first      = _Constructed_last;
; 787  : 
; 788  :         _TRY_BEGIN
; 789  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);
; 790  :         _Constructed_first = _Newvec + _Whereoff;
; 791  : 
; 792  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee
; 793  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 794  :         } else { // provide basic guarantee
; 795  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 796  :             _Constructed_first = _Newvec;
; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);
; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);
; 801  :         _Al.deallocate(_Newvec, _Newcapacity);
; 802  :         _RERAISE;
; 803  :         _CATCH_END
; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 806  :         return _Newvec + _Whereoff;
; 807  :     }
; 808  : 
; 809  :     template <class... _Valty>
; 810  :     _CONSTEXPR20_CONTAINER iterator emplace(const_iterator _Where, _Valty&&... _Val) {
; 811  :         // insert by perfectly forwarding _Val at _Where
; 812  :         const pointer _Whereptr = _Where._Ptr;
; 813  :         auto& _My_data          = _Mypair._Myval2;
; 814  :         const pointer _Oldlast  = _My_data._Mylast;
; 815  : #if _ITERATOR_DEBUG_LEVEL == 2
; 816  :         _STL_VERIFY(
; 817  :             _Where._Getcont() == _STD addressof(_My_data) && _Whereptr >= _My_data._Myfirst && _Oldlast >= _Whereptr,
; 818  :             "vector emplace iterator outside range");
; 819  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 820  : 
; 821  :         if (_Oldlast != _My_data._Myend) {
; 822  :             if (_Whereptr == _Oldlast) { // at back, provide strong guarantee
; 823  :                 _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 824  :             } else {
; 825  :                 auto& _Al = _Getal();
; 826  :                 _Alloc_temporary<_Alty> _Obj(_Al, _STD forward<_Valty>(_Val)...); // handle aliasing
; 827  :                 // after constructing _Obj, provide basic guarantee
; 828  :                 _Orphan_range(_Whereptr, _Oldlast);
; 829  :                 _Alty_traits::construct(_Al, _Unfancy(_Oldlast), _STD move(_Oldlast[-1]));
; 830  :                 ++_My_data._Mylast;
; 831  :                 _Move_backward_unchecked(_Whereptr, _Oldlast - 1, _Oldlast);
; 832  :                 *_Whereptr = _STD move(_Obj._Storage._Value);
; 833  :             }
; 834  : 
; 835  :             return _Make_iterator(_Whereptr);
; 836  :         }
; 837  : 
; 838  :         return _Make_iterator(_Emplace_reallocate(_Whereptr, _STD forward<_Valty>(_Val)...));
; 839  :     }
; 840  : 
; 841  :     _CONSTEXPR20_CONTAINER iterator insert(const_iterator _Where, const _Ty& _Val) { // insert _Val at _Where
; 842  :         return emplace(_Where, _Val);
; 843  :     }
; 844  : 
; 845  :     _CONSTEXPR20_CONTAINER iterator insert(const_iterator _Where, _Ty&& _Val) { // insert by moving _Val at _Where
; 846  :         return emplace(_Where, _STD move(_Val));
; 847  :     }
; 848  : 
; 849  :     _CONSTEXPR20_CONTAINER iterator insert(
; 850  :         const_iterator _Where, _CRT_GUARDOVERFLOW const size_type _Count, const _Ty& _Val) {
; 851  :         // insert _Count * _Val at _Where
; 852  :         const pointer _Whereptr = _Where._Ptr;
; 853  : 
; 854  :         auto& _My_data   = _Mypair._Myval2;
; 855  :         pointer& _Mylast = _My_data._Mylast;
; 856  : 
; 857  :         const pointer _Oldfirst = _My_data._Myfirst;
; 858  :         const pointer _Oldlast  = _Mylast;
; 859  : #if _ITERATOR_DEBUG_LEVEL == 2
; 860  :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_My_data) && _Whereptr >= _Oldfirst && _Oldlast >= _Whereptr,
; 861  :             "vector insert iterator outside range");
; 862  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 863  : 
; 864  :         const auto _Whereoff        = static_cast<size_type>(_Whereptr - _Oldfirst);
; 865  :         const auto _Unused_capacity = static_cast<size_type>(_My_data._Myend - _Oldlast);
; 866  :         const bool _One_at_back     = _Count == 1 && _Whereptr == _Oldlast;
; 867  :         if (_Count == 0) { // nothing to do, avoid invalidating iterators
; 868  :         } else if (_Count > _Unused_capacity) { // reallocate
; 869  :             const auto _Oldsize = static_cast<size_type>(_Oldlast - _Oldfirst);
; 870  : 
; 871  :             if (_Count > max_size() - _Oldsize) {
; 872  :                 _Xlength();
; 873  :             }
; 874  : 
; 875  :             const size_type _Newsize     = _Oldsize + _Count;
; 876  :             const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 877  : 
; 878  :             const pointer _Newvec           = _Getal().allocate(_Newcapacity);
; 879  :             const pointer _Constructed_last = _Newvec + _Whereoff + _Count;
; 880  :             pointer _Constructed_first      = _Constructed_last;
; 881  : 
; 882  :             _TRY_BEGIN
; 883  :             _Ufill(_Newvec + _Whereoff, _Count, _Val);
; 884  :             _Constructed_first = _Newvec + _Whereoff;
; 885  : 
; 886  :             if (_One_at_back) { // provide strong guarantee
; 887  :                 _Umove_if_noexcept(_Oldfirst, _Oldlast, _Newvec);
; 888  :             } else { // provide basic guarantee
; 889  :                 _Umove(_Oldfirst, _Whereptr, _Newvec);
; 890  :                 _Constructed_first = _Newvec;
; 891  :                 _Umove(_Whereptr, _Oldlast, _Newvec + _Whereoff + _Count);
; 892  :             }
; 893  :             _CATCH_ALL
; 894  :             _Destroy(_Constructed_first, _Constructed_last);
; 895  :             _Getal().deallocate(_Newvec, _Newcapacity);
; 896  :             _RERAISE;
; 897  :             _CATCH_END
; 898  : 
; 899  :             _Change_array(_Newvec, _Newsize, _Newcapacity);
; 900  :         } else if (_One_at_back) { // provide strong guarantee
; 901  :             _Emplace_back_with_unused_capacity(_Val);
; 902  :         } else { // provide basic guarantee
; 903  :             const _Alloc_temporary<_Alty> _Tmp_storage(_Getal(), _Val); // handle aliasing
; 904  :             const auto& _Tmp              = _Tmp_storage._Storage._Value;
; 905  :             const auto _Affected_elements = static_cast<size_type>(_Oldlast - _Whereptr);
; 906  :             _Orphan_range(_Whereptr, _Oldlast);
; 907  : 
; 908  :             if (_Count > _Affected_elements) { // new stuff spills off end
; 909  :                 _Mylast = _Ufill(_Oldlast, _Count - _Affected_elements, _Tmp);
; 910  :                 _Mylast = _Umove(_Whereptr, _Oldlast, _Mylast);
; 911  :                 _STD fill(_Whereptr, _Oldlast, _Tmp);
; 912  :             } else { // new stuff can all be assigned
; 913  :                 _Mylast = _Umove(_Oldlast - _Count, _Oldlast, _Oldlast);
; 914  :                 _Move_backward_unchecked(_Whereptr, _Oldlast - _Count, _Oldlast);
; 915  :                 _STD fill(_Whereptr, _Whereptr + _Count, _Tmp);
; 916  :             }
; 917  :         }
; 918  : 
; 919  :         return _Make_iterator_offset(_Whereoff);
; 920  :     }
; 921  : 
; 922  : private:
; 923  :     template <class _Iter>
; 924  :     _CONSTEXPR20_CONTAINER void _Insert_range(const_iterator _Where, _Iter _First, _Iter _Last, input_iterator_tag) {
; 925  :         // insert input range [_First, _Last) at _Where
; 926  :         if (_First == _Last) {
; 927  :             return; // nothing to do, avoid invalidating iterators
; 928  :         }
; 929  : 
; 930  :         auto& _My_data       = _Mypair._Myval2;
; 931  :         pointer& _Myfirst    = _My_data._Myfirst;
; 932  :         pointer& _Mylast     = _My_data._Mylast;
; 933  :         const auto _Whereoff = static_cast<size_type>(_Where._Ptr - _Myfirst);
; 934  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);
; 935  : 
; 936  :         // For one-at-back, provide strong guarantee.
; 937  :         // Otherwise, provide basic guarantee (despite N4659 26.3.11.5 [vector.modifiers]/1).
; 938  :         // Performance note: except for one-at-back, emplace_back()'s strong guarantee is unnecessary here.
; 939  : 
; 940  :         for (; _First != _Last; ++_First) {
; 941  :             emplace_back(*_First);
; 942  :         }
; 943  : 
; 944  :         _Orphan_range(_Myfirst + _Whereoff, _Myfirst + _Oldsize);
; 945  : 
; 946  :         _STD rotate(_Myfirst + _Whereoff, _Myfirst + _Oldsize, _Mylast);
; 947  :     }
; 948  : 
; 949  :     template <class _Iter>
; 950  :     _CONSTEXPR20_CONTAINER void _Insert_range(const_iterator _Where, _Iter _First, _Iter _Last, forward_iterator_tag) {
; 951  :         // insert forward range [_First, _Last) at _Where
; 952  :         const pointer _Whereptr = _Where._Ptr;
; 953  :         const auto _Count       = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
; 954  : 
; 955  :         auto& _My_data   = _Mypair._Myval2;
; 956  :         pointer& _Mylast = _My_data._Mylast;
; 957  : 
; 958  :         const pointer _Oldfirst     = _My_data._Myfirst;
; 959  :         const pointer _Oldlast      = _Mylast;
; 960  :         const auto _Unused_capacity = static_cast<size_type>(_My_data._Myend - _Oldlast);
; 961  : 
; 962  :         if (_Count == 0) { // nothing to do, avoid invalidating iterators
; 963  :         } else if (_Count > _Unused_capacity) { // reallocate
; 964  :             const auto _Oldsize = static_cast<size_type>(_Oldlast - _Oldfirst);
; 965  : 
; 966  :             if (_Count > max_size() - _Oldsize) {
; 967  :                 _Xlength();
; 968  :             }
; 969  : 
; 970  :             const size_type _Newsize     = _Oldsize + _Count;
; 971  :             const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 972  : 
; 973  :             const pointer _Newvec           = _Getal().allocate(_Newcapacity);
; 974  :             const auto _Whereoff            = static_cast<size_type>(_Whereptr - _Oldfirst);
; 975  :             const pointer _Constructed_last = _Newvec + _Whereoff + _Count;
; 976  :             pointer _Constructed_first      = _Constructed_last;
; 977  : 
; 978  :             _TRY_BEGIN
; 979  :             _Ucopy(_First, _Last, _Newvec + _Whereoff);
; 980  :             _Constructed_first = _Newvec + _Whereoff;
; 981  : 
; 982  :             if (_Count == 1 && _Whereptr == _Oldlast) { // one at back, provide strong guarantee
; 983  :                 _Umove_if_noexcept(_Oldfirst, _Oldlast, _Newvec);
; 984  :             } else { // provide basic guarantee
; 985  :                 _Umove(_Oldfirst, _Whereptr, _Newvec);
; 986  :                 _Constructed_first = _Newvec;
; 987  :                 _Umove(_Whereptr, _Oldlast, _Newvec + _Whereoff + _Count);
; 988  :             }
; 989  :             _CATCH_ALL
; 990  :             _Destroy(_Constructed_first, _Constructed_last);
; 991  :             _Getal().deallocate(_Newvec, _Newcapacity);
; 992  :             _RERAISE;
; 993  :             _CATCH_END
; 994  : 
; 995  :             _Change_array(_Newvec, _Newsize, _Newcapacity);
; 996  :         } else { // Attempt to provide the strong guarantee for EmplaceConstructible failure.
; 997  :                  // If we encounter copy/move construction/assignment failure, provide the basic guarantee.
; 998  :                  // (For one-at-back, this provides the strong guarantee.)
; 999  : 
; 1000 :             const auto _Affected_elements = static_cast<size_type>(_Oldlast - _Whereptr);
; 1001 : 
; 1002 :             if (_Count < _Affected_elements) { // some affected elements must be assigned
; 1003 :                 _Mylast = _Umove(_Oldlast - _Count, _Oldlast, _Oldlast);
; 1004 :                 _Move_backward_unchecked(_Whereptr, _Oldlast - _Count, _Oldlast);
; 1005 :                 _Destroy(_Whereptr, _Whereptr + _Count);
; 1006 : 
; 1007 :                 _TRY_BEGIN
; 1008 :                 _Ucopy(_First, _Last, _Whereptr);
; 1009 :                 _CATCH_ALL
; 1010 :                 // glue the broken pieces back together
; 1011 : 
; 1012 :                 _TRY_BEGIN
; 1013 :                 _Umove(_Whereptr + _Count, _Whereptr + 2 * _Count, _Whereptr);
; 1014 :                 _CATCH_ALL
; 1015 :                 // vaporize the detached piece
; 1016 :                 _Orphan_range(_Whereptr, _Oldlast);
; 1017 :                 _Destroy(_Whereptr + _Count, _Mylast);
; 1018 :                 _Mylast = _Whereptr;
; 1019 :                 _RERAISE;
; 1020 :                 _CATCH_END
; 1021 : 
; 1022 :                 _Move_unchecked(_Whereptr + 2 * _Count, _Mylast, _Whereptr + _Count);
; 1023 :                 _Destroy(_Oldlast, _Mylast);
; 1024 :                 _Mylast = _Oldlast;
; 1025 :                 _RERAISE;
; 1026 :                 _CATCH_END
; 1027 :             } else { // affected elements don't overlap before/after
; 1028 :                 const pointer _Relocated = _Whereptr + _Count;
; 1029 :                 _Mylast                  = _Umove(_Whereptr, _Oldlast, _Relocated);
; 1030 :                 _Destroy(_Whereptr, _Oldlast);
; 1031 : 
; 1032 :                 _TRY_BEGIN
; 1033 :                 _Ucopy(_First, _Last, _Whereptr);
; 1034 :                 _CATCH_ALL
; 1035 :                 // glue the broken pieces back together
; 1036 : 
; 1037 :                 _TRY_BEGIN
; 1038 :                 _Umove(_Relocated, _Mylast, _Whereptr);
; 1039 :                 _CATCH_ALL
; 1040 :                 // vaporize the detached piece
; 1041 :                 _Orphan_range(_Whereptr, _Oldlast);
; 1042 :                 _Destroy(_Relocated, _Mylast);
; 1043 :                 _Mylast = _Whereptr;
; 1044 :                 _RERAISE;
; 1045 :                 _CATCH_END
; 1046 : 
; 1047 :                 _Destroy(_Relocated, _Mylast);
; 1048 :                 _Mylast = _Oldlast;
; 1049 :                 _RERAISE;
; 1050 :                 _CATCH_END
; 1051 :             }
; 1052 : 
; 1053 :             _Orphan_range(_Whereptr, _Oldlast);
; 1054 :         }
; 1055 :     }
; 1056 : 
; 1057 : public:
; 1058 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 1059 :     _CONSTEXPR20_CONTAINER iterator insert(const_iterator _Where, _Iter _First, _Iter _Last) {
; 1060 :         const pointer _Whereptr = _Where._Ptr;
; 1061 :         auto& _My_data          = _Mypair._Myval2;
; 1062 :         const pointer _Oldfirst = _My_data._Myfirst;
; 1063 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1064 :         _STL_VERIFY(
; 1065 :             _Where._Getcont() == _STD addressof(_My_data) && _Whereptr >= _Oldfirst && _My_data._Mylast >= _Whereptr,
; 1066 :             "vector insert iterator outside range");
; 1067 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1068 : 
; 1069 :         _Adl_verify_range(_First, _Last);
; 1070 :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Oldfirst);
; 1071 :         _Insert_range(_Where, _Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
; 1072 :         return _Make_iterator_offset(_Whereoff);
; 1073 :     }
; 1074 : 
; 1075 :     _CONSTEXPR20_CONTAINER iterator insert(const_iterator _Where, initializer_list<_Ty> _Ilist) {
; 1076 :         return insert(_Where, _Ilist.begin(), _Ilist.end());
; 1077 :     }
; 1078 : 
; 1079 :     _CONSTEXPR20_CONTAINER void assign(_CRT_GUARDOVERFLOW const size_type _Newsize, const _Ty& _Val) {
; 1080 :         // assign _Newsize * _Val
; 1081 :         auto& _My_data    = _Mypair._Myval2;
; 1082 :         pointer& _Myfirst = _My_data._Myfirst;
; 1083 :         pointer& _Mylast  = _My_data._Mylast;
; 1084 : 
; 1085 :         _My_data._Orphan_all();
; 1086 : 
; 1087 :         auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
; 1088 :         if (_Newsize > _Oldsize) {
; 1089 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);
; 1090 :             if (_Newsize > _Oldcapacity) { // reallocate
; 1091 :                 _Clear_and_reserve_geometric(_Newsize);
; 1092 :                 _Oldsize = 0;
; 1093 :             } else {
; 1094 :                 _STD fill(_Myfirst, _Mylast, _Val);
; 1095 :             }
; 1096 : 
; 1097 :             _Mylast = _Ufill(_Mylast, _Newsize - _Oldsize, _Val);
; 1098 :         } else {
; 1099 :             const pointer _Newlast = _Myfirst + _Newsize;
; 1100 :             _STD fill(_Myfirst, _Newlast, _Val);
; 1101 :             _Destroy(_Newlast, _Mylast);
; 1102 :             _Mylast = _Newlast;
; 1103 :         }
; 1104 :     }
; 1105 : 
; 1106 : private:
; 1107 :     template <class _Iter>
; 1108 :     _CONSTEXPR20_CONTAINER void _Assign_range(_Iter _First, _Iter _Last, input_iterator_tag) {
; 1109 :         // assign input range [_First, _Last)
; 1110 :         auto& _My_data    = _Mypair._Myval2;
; 1111 :         pointer& _Myfirst = _My_data._Myfirst;
; 1112 :         pointer& _Mylast  = _My_data._Mylast;
; 1113 : 
; 1114 :         _My_data._Orphan_all();
; 1115 : 
; 1116 :         pointer _Next = _Myfirst;
; 1117 : 
; 1118 :         for (; _First != _Last && _Next != _Mylast; ++_First, (void) ++_Next) {
; 1119 :             *_Next = *_First;
; 1120 :         }
; 1121 : 
; 1122 :         // Code size optimization: we've exhausted only the source, only the dest, or both.
; 1123 :         // If we've exhausted only the source: we Trim, then Append does nothing.
; 1124 :         // If we've exhausted only the dest: Trim does nothing, then we Append.
; 1125 :         // If we've exhausted both: Trim does nothing, then Append does nothing.
; 1126 : 
; 1127 :         // Trim.
; 1128 :         _Destroy(_Next, _Mylast);
; 1129 :         _Mylast = _Next;
; 1130 : 
; 1131 :         // Append.
; 1132 :         for (; _First != _Last; ++_First) {
; 1133 :             emplace_back(*_First); // performance note: emplace_back()'s strong guarantee is unnecessary here
; 1134 :         }
; 1135 :     }
; 1136 : 
; 1137 :     template <class _Iter>
; 1138 :     _CONSTEXPR20_CONTAINER void _Assign_range(_Iter _First, _Iter _Last, forward_iterator_tag) {
; 1139 :         // assign forward range [_First, _Last)
; 1140 :         const auto _Newsize = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
; 1141 :         auto& _My_data      = _Mypair._Myval2;
; 1142 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1143 :         pointer& _Mylast    = _My_data._Mylast;
; 1144 :         pointer& _Myend     = _My_data._Myend;
; 1145 : 
; 1146 :         _My_data._Orphan_all();
; 1147 : 
; 1148 :         if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<_Iter, _Ty*>::_Trivially_copyable>,
; 1149 :                           _Uses_default_construct<_Alty, _Ty*, decltype(*_First)>,
; 1150 :                           _Uses_default_destroy<_Alty, _Ty*>>) {
; 1151 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1152 :             if (!_STD is_constant_evaluated())
; 1153 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1154 :             {
; 1155 :                 const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);
; 1156 :                 if (_Newsize > _Oldcapacity) {
; 1157 :                     _Clear_and_reserve_geometric(_Newsize);
; 1158 :                 }
; 1159 : 
; 1160 :                 _Mylast = _Refancy<pointer>(_Copy_memmove(_First, _Last, _Unfancy(_Myfirst)));
; 1161 :                 return;
; 1162 :             }
; 1163 :         }
; 1164 :         auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
; 1165 : 
; 1166 :         if (_Newsize > _Oldsize) {
; 1167 :             const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);
; 1168 :             if (_Newsize > _Oldcapacity) { // reallocate
; 1169 :                 _Clear_and_reserve_geometric(_Newsize);
; 1170 :                 _Oldsize = 0;
; 1171 :             }
; 1172 : 
; 1173 :             // performance note: traversing [_First, _Mid) twice
; 1174 :             const _Iter _Mid = _STD next(_First, static_cast<difference_type>(_Oldsize));
; 1175 :             _Copy_unchecked(_First, _Mid, _Myfirst);
; 1176 :             _Mylast = _Ucopy(_Mid, _Last, _Mylast);
; 1177 :         } else {
; 1178 :             const pointer _Newlast = _Myfirst + _Newsize;
; 1179 :             _Copy_unchecked(_First, _Last, _Myfirst);
; 1180 :             _Destroy(_Newlast, _Mylast);
; 1181 :             _Mylast = _Newlast;
; 1182 :         }
; 1183 :     }
; 1184 : 
; 1185 : public:
; 1186 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 1187 :     _CONSTEXPR20_CONTAINER void assign(_Iter _First, _Iter _Last) {
; 1188 :         _Adl_verify_range(_First, _Last);
; 1189 :         _Assign_range(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
; 1190 :     }
; 1191 : 
; 1192 :     _CONSTEXPR20_CONTAINER void assign(initializer_list<_Ty> _Ilist) {
; 1193 :         _Assign_range(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});
; 1194 :     }
; 1195 : 
; 1196 : private:
; 1197 :     _CONSTEXPR20_CONTAINER void _Copy_assign(const vector& _Right, false_type) {
; 1198 :         _Pocca(_Getal(), _Right._Getal());
; 1199 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1200 :         assign(_Right_data._Myfirst, _Right_data._Mylast);
; 1201 :     }
; 1202 : 
; 1203 :     _CONSTEXPR20_CONTAINER void _Copy_assign(const vector& _Right, true_type) {
; 1204 :         if (_Getal() != _Right._Getal()) {
; 1205 :             _Tidy();
; 1206 :             _Mypair._Myval2._Reload_proxy(
; 1207 :                 _GET_PROXY_ALLOCATOR(_Alty, _Getal()), _GET_PROXY_ALLOCATOR(_Alty, _Right._Getal()));
; 1208 :         }
; 1209 : 
; 1210 :         _Copy_assign(_Right, false_type{});
; 1211 :     }
; 1212 : 
; 1213 : public:
; 1214 :     _CONSTEXPR20_CONTAINER vector& operator=(const vector& _Right) {
; 1215 :         if (this != _STD addressof(_Right)) {
; 1216 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});
; 1217 :         }
; 1218 : 
; 1219 :         return *this;
; 1220 :     }
; 1221 : 
; 1222 :     _CONSTEXPR20_CONTAINER vector& operator=(initializer_list<_Ty> _Ilist) {
; 1223 :         _Assign_range(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});
; 1224 :         return *this;
; 1225 :     }
; 1226 : 
; 1227 : private:
; 1228 :     template <class _Ty2>
; 1229 :     _CONSTEXPR20_CONTAINER void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {
; 1230 :         if (_Newsize > max_size()) {
; 1231 :             _Xlength();
; 1232 :         }
; 1233 : 
; 1234 :         auto& _My_data    = _Mypair._Myval2;
; 1235 :         pointer& _Myfirst = _My_data._Myfirst;
; 1236 :         pointer& _Mylast  = _My_data._Mylast;
; 1237 : 
; 1238 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);
; 1239 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1240 : 
; 1241 :         const pointer _Newvec         = _Getal().allocate(_Newcapacity);
; 1242 :         const pointer _Appended_first = _Newvec + _Oldsize;
; 1243 :         pointer _Appended_last        = _Appended_first;
; 1244 : 
; 1245 :         _TRY_BEGIN
; 1246 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);
; 1247 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 1248 :         _CATCH_ALL
; 1249 :         _Destroy(_Appended_first, _Appended_last);
; 1250 :         _Getal().deallocate(_Newvec, _Newcapacity);
; 1251 :         _RERAISE;
; 1252 :         _CATCH_END
; 1253 : 
; 1254 :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 1255 :     }
; 1256 : 
; 1257 :     template <class _Ty2>
; 1258 :     _CONSTEXPR20_CONTAINER void _Resize(const size_type _Newsize, const _Ty2& _Val) {
; 1259 :         // trim or append elements, provide strong guarantee
; 1260 :         auto& _My_data      = _Mypair._Myval2;
; 1261 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1262 :         pointer& _Mylast    = _My_data._Mylast;
; 1263 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
; 1264 :         if (_Newsize < _Oldsize) { // trim
; 1265 :             const pointer _Newlast = _Myfirst + _Newsize;
; 1266 :             _Orphan_range(_Newlast, _Mylast);
; 1267 :             _Destroy(_Newlast, _Mylast);
; 1268 :             _Mylast = _Newlast;
; 1269 :             return;
; 1270 :         }
; 1271 : 
; 1272 :         if (_Newsize > _Oldsize) { // append
; 1273 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);
; 1274 :             if (_Newsize > _Oldcapacity) { // reallocate
; 1275 :                 _Resize_reallocate(_Newsize, _Val);
; 1276 :                 return;
; 1277 :             }
; 1278 : 
; 1279 :             const pointer _Oldlast = _Mylast;
; 1280 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);
; 1281 :             _Orphan_range(_Oldlast, _Oldlast);
; 1282 :         }
; 1283 : 
; 1284 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1285 :     }
; 1286 : 
; 1287 : public:
; 1288 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {
; 1289 :         // trim or append value-initialized elements, provide strong guarantee
; 1290 :         _Resize(_Newsize, _Value_init_tag{});
; 1291 :     }
; 1292 : 
; 1293 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize, const _Ty& _Val) {
; 1294 :         // trim or append copies of _Val, provide strong guarantee
; 1295 :         _Resize(_Newsize, _Val);
; 1296 :     }
; 1297 : 
; 1298 : private:
; 1299 :     _CONSTEXPR20_CONTAINER void _Reallocate_exactly(const size_type _Newcapacity) {
; 1300 :         // set capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1301 :         auto& _My_data    = _Mypair._Myval2;
; 1302 :         pointer& _Myfirst = _My_data._Myfirst;
; 1303 :         pointer& _Mylast  = _My_data._Mylast;
; 1304 : 
; 1305 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);
; 1306 : 
; 1307 :         const pointer _Newvec = _Getal().allocate(_Newcapacity);
; 1308 : 
; 1309 :         _TRY_BEGIN
; 1310 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 1311 :         _CATCH_ALL
; 1312 :         _Getal().deallocate(_Newvec, _Newcapacity);
; 1313 :         _RERAISE;
; 1314 :         _CATCH_END
; 1315 : 
; 1316 :         _Change_array(_Newvec, _Size, _Newcapacity);
; 1317 :     }
; 1318 : 
; 1319 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1320 :     void _Check_all_orphaned_locked() const noexcept {
; 1321 :         _Lockit _Lock(_LOCK_DEBUG);
; 1322 :         auto& _My_data = _Mypair._Myval2;
; 1323 :         _STL_INTERNAL_CHECK(!_My_data._Myproxy->_Myfirstiter);
; 1324 :     }
; 1325 : 
; 1326 :     _CONSTEXPR20_CONTAINER void _Check_all_orphaned() const noexcept {
; 1327 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1328 :         if (_STD is_constant_evaluated()) {
; 1329 :             auto& _My_data = _Mypair._Myval2;
; 1330 :             _STL_INTERNAL_CHECK(!_My_data._Myproxy->_Myfirstiter);
; 1331 :         } else
; 1332 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1333 :         {
; 1334 :             _Check_all_orphaned_locked();
; 1335 :         }
; 1336 :     }
; 1337 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1338 : 
; 1339 :     _CONSTEXPR20_CONTAINER void _Clear_and_reserve_geometric(const size_type _Newsize) {
; 1340 :         auto& _My_data    = _Mypair._Myval2;
; 1341 :         pointer& _Myfirst = _My_data._Myfirst;
; 1342 :         pointer& _Mylast  = _My_data._Mylast;
; 1343 :         pointer& _Myend   = _My_data._Myend;
; 1344 : 
; 1345 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1346 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1347 :         _Check_all_orphaned();
; 1348 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1349 : 
; 1350 :         if (_Newsize > max_size()) {
; 1351 :             _Xlength();
; 1352 :         }
; 1353 : 
; 1354 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1355 : 
; 1356 :         if (_Myfirst) { // destroy and deallocate old array
; 1357 :             _Destroy(_Myfirst, _Mylast);
; 1358 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));
; 1359 : 
; 1360 :             _Myfirst = nullptr;
; 1361 :             _Mylast  = nullptr;
; 1362 :             _Myend   = nullptr;
; 1363 :         }
; 1364 : 
; 1365 :         _Buy_raw(_Newcapacity);
; 1366 :     }
; 1367 : 
; 1368 : public:
; 1369 :     _CONSTEXPR20_CONTAINER void reserve(_CRT_GUARDOVERFLOW const size_type _Newcapacity) {
; 1370 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1371 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  0007e	8b 85 b0 fb ff
	ff		 mov	 eax, DWORD PTR _pstTokenVector$GSCopy$1$[ebp]
$LN16@SplitLine:

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00084	50		 push	 eax
  00085	ff 70 04	 push	 DWORD PTR [eax+4]
  00088	56		 push	 esi
  00089	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1456 :         _Mylast = _Myfirst;

  0008e	8b 8d b0 fb ff
	ff		 mov	 ecx, DWORD PTR _pstTokenVector$GSCopy$1$[ebp]

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00094	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00097	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _stToken$[ebp], 0

; 4596 :         _My_data._Mysize = 0;

  0009e	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _stToken$[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  000a5	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _stToken$[ebp+20], 15 ; 0000000fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1456 :         _Mylast = _Myfirst;

  000ac	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ae	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  000b1	c6 45 c0 00	 mov	 BYTE PTR _stToken$[ebp], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 89   : 	const std::string & c_rstLine = GetLineString(dwLine);

  000b5	ff b5 bc fb ff
	ff		 push	 DWORD PTR _dwLine$GSCopy$1$[ebp]
  000bb	8b cf		 mov	 ecx, edi
  000bd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000c4	e8 00 00 00 00	 call	 ?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; CMemoryTextFileLoader::GetLineString
  000c9	8b d0		 mov	 edx, eax

; 90   : 
; 91   : 	DWORD basePos = 0;

  000cb	33 ff		 xor	 edi, edi
  000cd	89 95 ac fb ff
	ff		 mov	 DWORD PTR _c_rstLine$1$[ebp], edx
$LL4@SplitLine:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  000d3	8b b5 b4 fb ff
	ff		 mov	 esi, DWORD PTR _c_szDelimeter$GSCopy$1$[ebp]
  000d9	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  000dc	0f 1f 40 00	 npad	 4
$LL435@SplitLine:
  000e0	8a 06		 mov	 al, BYTE PTR [esi]
  000e2	46		 inc	 esi
  000e3	84 c0		 test	 al, al
  000e5	75 f9		 jne	 SHORT $LL435@SplitLine
  000e7	2b f1		 sub	 esi, ecx

; 2305 :         const value_type* _Result = _Bx._Buf;

  000e9	89 95 bc fb ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], edx

; 2306 :         if (_Large_string_engaged()) {

  000ef	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  000f3	72 08		 jb	 SHORT $LN428@SplitLine

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  000f5	8b 02		 mov	 eax, DWORD PTR [edx]
  000f7	89 85 bc fb ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], eax
$LN428@SplitLine:

; 4305 :         return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(_Mypair._Myval2._Myptr(),

  000fd	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00100	89 85 b8 fb ff
	ff		 mov	 DWORD PTR __Hay_size$1$[ebp], eax

; 863  :     if (_Start_at < _Hay_size) { // room for match, look for it

  00106	3b f8		 cmp	 edi, eax
  00108	73 69		 jae	 SHORT $LN382@SplitLine
  0010a	68 00 01 00 00	 push	 256			; 00000100H
  0010f	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR __Matches$5[ebp]
  00115	6a 00		 push	 0
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 _memset

; 864  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 865  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,

  0011d	8b 85 b4 fb ff
	ff		 mov	 eax, DWORD PTR _c_szDelimeter$GSCopy$1$[ebp]
  00123	83 c4 0c	 add	 esp, 12			; 0000000cH
  00126	8b c8		 mov	 ecx, eax
  00128	8d 14 30	 lea	 edx, DWORD PTR [eax+esi]

; 704  :         for (; _First != _Last; ++_First) {

  0012b	3b c2		 cmp	 eax, edx
  0012d	74 11		 je	 SHORT $LN60@SplitLine
  0012f	90		 npad	 1
$LL61@SplitLine:

; 705  :             _Matches[static_cast<unsigned char>(*_First)] = true;

  00130	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00133	41		 inc	 ecx
  00134	c6 84 05 c0 fe
	ff ff 01	 mov	 BYTE PTR __Matches$5[ebp+eax], 1
  0013c	3b ca		 cmp	 ecx, edx
  0013e	75 f0		 jne	 SHORT $LL61@SplitLine
$LN60@SplitLine:

; 871  :         const auto _End = _Haystack + _Hay_size;

  00140	8b 95 bc fb ff
	ff		 mov	 edx, DWORD PTR __Result$1$[ebp]
  00146	8b 85 b8 fb ff
	ff		 mov	 eax, DWORD PTR __Hay_size$1$[ebp]

; 872  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {

  0014c	8d 34 3a	 lea	 esi, DWORD PTR [edx+edi]
  0014f	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]
  00152	3b f1		 cmp	 esi, ecx
  00154	73 1d		 jae	 SHORT $LN382@SplitLine
  00156	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL51@SplitLine:

; 712  :         return _Matches[static_cast<unsigned char>(_Ch)];

  00160	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00163	8a 84 05 c0 fe
	ff ff		 mov	 al, BYTE PTR __Matches$5[ebp+eax]

; 873  :             if (!_Matches._Match(*_Match_try)) {

  0016a	84 c0		 test	 al, al
  0016c	74 24		 je	 SHORT $LN375@SplitLine

; 872  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {

  0016e	46		 inc	 esi
  0016f	3b f1		 cmp	 esi, ecx
  00171	72 ed		 jb	 SHORT $LL51@SplitLine
$LN382@SplitLine:
  00173	32 c0		 xor	 al, al
$LN1@SplitLine:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 125  : }

  00175	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00178	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0017f	59		 pop	 ecx
  00180	5f		 pop	 edi
  00181	5e		 pop	 esi
  00182	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00185	33 cd		 xor	 ecx, ebp
  00187	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018c	8b e5		 mov	 esp, ebp
  0018e	5d		 pop	 ebp
  0018f	c2 0c 00	 ret	 12			; 0000000cH
$LN375@SplitLine:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 874  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match

  00192	2b f2		 sub	 esi, edx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 96   : 		if (beginPos < 0)

  00194	78 dd		 js	 SHORT $LN382@SplitLine
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2305 :         const value_type* _Result = _Bx._Buf;

  00196	8b 95 ac fb ff
	ff		 mov	 edx, DWORD PTR _c_rstLine$1$[ebp]
  0019c	8b c2		 mov	 eax, edx

; 2306 :         if (_Large_string_engaged()) {

  0019e	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  001a1	83 f9 10	 cmp	 ecx, 16			; 00000010H
  001a4	72 02		 jb	 SHORT $LN429@SplitLine

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  001a6	8b 02		 mov	 eax, DWORD PTR [edx]
$LN429@SplitLine:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 101  : 		if (c_rstLine[beginPos] == '"')

  001a8	80 3c 06 22	 cmp	 BYTE PTR [esi+eax], 34	; 00000022H
  001ac	75 6a		 jne	 SHORT $LN6@SplitLine

; 102  : 		{
; 103  : 			++beginPos;

  001ae	46		 inc	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2305 :         const value_type* _Result = _Bx._Buf;

  001af	8b fa		 mov	 edi, edx

; 2306 :         if (_Large_string_engaged()) {

  001b1	83 f9 10	 cmp	 ecx, 16			; 00000010H
  001b4	72 02		 jb	 SHORT $LN430@SplitLine

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  001b6	8b 3a		 mov	 edi, DWORD PTR [edx]
$LN430@SplitLine:

; 773  :     if (_Needle_size != 0 && _Start_at < _Hay_size) { // room for match, look for it

  001b8	3b b5 b8 fb ff
	ff		 cmp	 esi, DWORD PTR __Hay_size$1$[ebp]
  001be	73 b3		 jae	 SHORT $LN382@SplitLine
  001c0	68 00 01 00 00	 push	 256			; 00000100H
  001c5	8d 85 c0 fd ff
	ff		 lea	 eax, DWORD PTR __Matches$4[ebp]
  001cb	6a 00		 push	 0
  001cd	50		 push	 eax
  001ce	e8 00 00 00 00	 call	 _memset

; 776  :                                                                 // fall back to the serial algorithm
; 777  :             return _Traits_find_first_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
; 778  :         }
; 779  : 
; 780  :         const auto _End = _Haystack + _Hay_size;

  001d3	8b 85 b8 fb ff
	ff		 mov	 eax, DWORD PTR __Hay_size$1$[ebp]

; 781  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {

  001d9	8d 0c 37	 lea	 ecx, DWORD PTR [edi+esi]
  001dc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 705  :             _Matches[static_cast<unsigned char>(*_First)] = true;

  001df	c6 85 e2 fd ff
	ff 01		 mov	 BYTE PTR __Matches$4[ebp+34], 1

; 780  :         const auto _End = _Haystack + _Hay_size;

  001e6	8d 14 38	 lea	 edx, DWORD PTR [eax+edi]

; 781  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {

  001e9	3b ca		 cmp	 ecx, edx
  001eb	73 86		 jae	 SHORT $LN382@SplitLine
  001ed	0f 1f 00	 npad	 3
$LL120@SplitLine:

; 712  :         return _Matches[static_cast<unsigned char>(_Ch)];

  001f0	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  001f3	8a 84 05 c0 fd
	ff ff		 mov	 al, BYTE PTR __Matches$4[ebp+eax]

; 782  :             if (_Matches._Match(*_Match_try)) {

  001fa	84 c0		 test	 al, al
  001fc	75 0a		 jne	 SHORT $LN377@SplitLine

; 781  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {

  001fe	41		 inc	 ecx
  001ff	3b ca		 cmp	 ecx, edx
  00201	72 ed		 jb	 SHORT $LL120@SplitLine
  00203	e9 6b ff ff ff	 jmp	 $LN382@SplitLine
$LN377@SplitLine:

; 783  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match

  00208	2b cf		 sub	 ecx, edi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 106  : 			if (endPos < 0)

  0020a	0f 88 63 ff ff
	ff		 js	 $LN382@SplitLine

; 107  : 				return false;
; 108  : 
; 109  : 			basePos = endPos + 1;

  00210	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]

; 110  : 		}

  00213	e9 a4 00 00 00	 jmp	 $LN7@SplitLine
$LN6@SplitLine:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00218	8b bd b4 fb ff
	ff		 mov	 edi, DWORD PTR _c_szDelimeter$GSCopy$1$[ebp]
  0021e	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
$LL436@SplitLine:
  00221	8a 07		 mov	 al, BYTE PTR [edi]
  00223	47		 inc	 edi
  00224	84 c0		 test	 al, al
  00226	75 f9		 jne	 SHORT $LL436@SplitLine
  00228	2b f9		 sub	 edi, ecx

; 2305 :         const value_type* _Result = _Bx._Buf;

  0022a	89 95 bc fb ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], edx

; 2306 :         if (_Large_string_engaged()) {

  00230	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  00234	72 08		 jb	 SHORT $LN431@SplitLine

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  00236	8b 02		 mov	 eax, DWORD PTR [edx]
  00238	89 85 bc fb ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], eax
$LN431@SplitLine:

; 773  :     if (_Needle_size != 0 && _Start_at < _Hay_size) { // room for match, look for it

  0023e	85 ff		 test	 edi, edi
  00240	74 75		 je	 SHORT $LN181@SplitLine
  00242	3b b5 b8 fb ff
	ff		 cmp	 esi, DWORD PTR __Hay_size$1$[ebp]
  00248	73 6d		 jae	 SHORT $LN181@SplitLine
  0024a	68 00 01 00 00	 push	 256			; 00000100H
  0024f	8d 85 c0 fc ff
	ff		 lea	 eax, DWORD PTR __Matches$3[ebp]
  00255	6a 00		 push	 0
  00257	50		 push	 eax
  00258	e8 00 00 00 00	 call	 _memset

; 774  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 775  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,

  0025d	8b 85 b4 fb ff
	ff		 mov	 eax, DWORD PTR _c_szDelimeter$GSCopy$1$[ebp]
  00263	83 c4 0c	 add	 esp, 12			; 0000000cH
  00266	8b c8		 mov	 ecx, eax
  00268	8d 14 38	 lea	 edx, DWORD PTR [eax+edi]
  0026b	8b fe		 mov	 edi, esi

; 704  :         for (; _First != _Last; ++_First) {

  0026d	3b c2		 cmp	 eax, edx
  0026f	74 10		 je	 SHORT $LN191@SplitLine
$LL192@SplitLine:

; 705  :             _Matches[static_cast<unsigned char>(*_First)] = true;

  00271	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00274	41		 inc	 ecx
  00275	c6 84 05 c0 fc
	ff ff 01	 mov	 BYTE PTR __Matches$3[ebp+eax], 1
  0027d	3b ca		 cmp	 ecx, edx
  0027f	75 f0		 jne	 SHORT $LL192@SplitLine
$LN191@SplitLine:

; 780  :         const auto _End = _Haystack + _Hay_size;

  00281	8b 95 bc fb ff
	ff		 mov	 edx, DWORD PTR __Result$1$[ebp]

; 781  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {

  00287	03 fa		 add	 edi, edx
  00289	8b 8d b8 fb ff
	ff		 mov	 ecx, DWORD PTR __Hay_size$1$[ebp]
  0028f	03 ca		 add	 ecx, edx
  00291	3b f9		 cmp	 edi, ecx
  00293	73 22		 jae	 SHORT $LN181@SplitLine
  00295	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL182@SplitLine:

; 712  :         return _Matches[static_cast<unsigned char>(_Ch)];

  002a0	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  002a3	8a 84 05 c0 fc
	ff ff		 mov	 al, BYTE PTR __Matches$3[ebp+eax]

; 782  :             if (_Matches._Match(*_Match_try)) {

  002aa	84 c0		 test	 al, al
  002ac	0f 85 88 00 00
	00		 jne	 $LN379@SplitLine

; 781  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {

  002b2	47		 inc	 edi
  002b3	3b f9		 cmp	 edi, ecx
  002b5	72 e9		 jb	 SHORT $LL182@SplitLine
$LN181@SplitLine:

; 784  :             }
; 785  :         }
; 786  :     }
; 787  : 
; 788  :     return static_cast<size_t>(-1); // no match

  002b7	83 cf ff	 or	 edi, -1
$LN179@SplitLine:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 113  : 			endPos = c_rstLine.find_first_of(c_szDelimeter, beginPos);

  002ba	8b cf		 mov	 ecx, edi
$LN7@SplitLine:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2324 :         if (_Mysize < _Off) {

  002bc	8b 85 b8 fb ff
	ff		 mov	 eax, DWORD PTR __Hay_size$1$[ebp]

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  002c2	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T6[ebp], 0

; 4596 :         _My_data._Mysize = 0;

  002c9	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T6[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  002d0	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T6[ebp+20], 15 ; 0000000fH

; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  002d7	c6 45 d8 00	 mov	 BYTE PTR $T6[ebp], 0

; 2324 :         if (_Mysize < _Off) {

  002db	3b c6		 cmp	 eax, esi
  002dd	0f 82 55 01 00
	00		 jb	 $LN384@SplitLine

; 2305 :         const value_type* _Result = _Bx._Buf;

  002e3	8b 95 ac fb ff
	ff		 mov	 edx, DWORD PTR _c_rstLine$1$[ebp]

; 2342 :         return (_STD min)(_Size, _Mysize - _Off);

  002e9	2b c6		 sub	 eax, esi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 117  : 		pstTokenVector->push_back(c_rstLine.substr(beginPos, endPos - beginPos));

  002eb	2b ce		 sub	 ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2342 :         return (_STD min)(_Size, _Mysize - _Off);

  002ed	3b c1		 cmp	 eax, ecx
  002ef	0f 42 c8	 cmovb	 ecx, eax

; 2306 :         if (_Large_string_engaged()) {

  002f2	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  002f6	8b c2		 mov	 eax, edx
  002f8	72 02		 jb	 SHORT $LN432@SplitLine

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  002fa	8b 02		 mov	 eax, DWORD PTR [edx]
$LN432@SplitLine:

; 3224 :         return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);

  002fc	51		 push	 ecx
  002fd	03 c6		 add	 eax, esi
  002ff	8d 4d d8	 lea	 ecx, DWORD PTR $T6[ebp]
  00302	50		 push	 eax
  00303	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  00308	8b 8d b0 fb ff
	ff		 mov	 ecx, DWORD PTR _pstTokenVector$GSCopy$1$[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 117  : 		pstTokenVector->push_back(c_rstLine.substr(beginPos, endPos - beginPos));

  0030e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  00312	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00315	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00318	74 27		 je	 SHORT $LN241@SplitLine
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0031a	0f 10 45 d8	 movups	 xmm0, XMMWORD PTR $T6[ebp]

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0031e	ba 0f 00 00 00	 mov	 edx, 15			; 0000000fH

; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00323	c6 45 d8 00	 mov	 BYTE PTR $T6[ebp], 0

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00327	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  0032a	f3 0f 7e 45 e8	 movq	 xmm0, QWORD PTR $T6[ebp+16]
  0032f	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 729  :         ++_Mylast;

  00334	83 41 04 18	 add	 DWORD PTR [ecx+4], 24	; 00000018H

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00338	eb 14		 jmp	 SHORT $LN240@SplitLine
$LN379@SplitLine:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 783  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match

  0033a	2b fa		 sub	 edi, edx
  0033c	e9 79 ff ff ff	 jmp	 $LN179@SplitLine
$LN241@SplitLine:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00341	8d 55 d8	 lea	 edx, DWORD PTR $T6[ebp]
  00344	52		 push	 edx
  00345	50		 push	 eax
  00346	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  0034b	8b 55 ec	 mov	 edx, DWORD PTR $T6[ebp+20]
$LN240@SplitLine:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 117  : 		pstTokenVector->push_back(c_rstLine.substr(beginPos, endPos - beginPos));

  0034e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00352	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00355	72 2c		 jb	 SHORT $LN284@SplitLine
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00357	8b 4d d8	 mov	 ecx, DWORD PTR $T6[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0035a	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0035b	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0035d	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00363	72 14		 jb	 SHORT $LN294@SplitLine

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00365	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00368	83 c2 23	 add	 edx, 35			; 00000023H
  0036b	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0036d	83 c0 fc	 add	 eax, -4			; fffffffcH
  00370	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00373	0f 87 c4 00 00
	00		 ja	 $LN291@SplitLine
$LN294@SplitLine:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00379	52		 push	 edx
  0037a	51		 push	 ecx
  0037b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00380	83 c4 08	 add	 esp, 8
$LN284@SplitLine:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00383	8b b5 b4 fb ff
	ff		 mov	 esi, DWORD PTR _c_szDelimeter$GSCopy$1$[ebp]
  00389	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  0038c	0f 1f 40 00	 npad	 4
$LL437@SplitLine:
  00390	8a 06		 mov	 al, BYTE PTR [esi]
  00392	46		 inc	 esi
  00393	84 c0		 test	 al, al
  00395	75 f9		 jne	 SHORT $LL437@SplitLine
  00397	2b f1		 sub	 esi, ecx

; 2305 :         const value_type* _Result = _Bx._Buf;

  00399	8b 8d ac fb ff
	ff		 mov	 ecx, DWORD PTR _c_rstLine$1$[ebp]
  0039f	89 8d bc fb ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], ecx

; 2319 :         return _BUF_SIZE <= _Myres;

  003a5	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 2306 :         if (_Large_string_engaged()) {

  003a9	72 08		 jb	 SHORT $LN427@SplitLine

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  003ab	8b 01		 mov	 eax, DWORD PTR [ecx]
  003ad	89 85 bc fb ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], eax
$LN427@SplitLine:

; 863  :     if (_Start_at < _Hay_size) { // room for match, look for it

  003b3	3b 79 10	 cmp	 edi, DWORD PTR [ecx+16]
  003b6	73 6a		 jae	 SHORT $LN3@SplitLine
  003b8	68 00 01 00 00	 push	 256			; 00000100H
  003bd	8d 85 c0 fb ff
	ff		 lea	 eax, DWORD PTR __Matches$2[ebp]
  003c3	6a 00		 push	 0
  003c5	50		 push	 eax
  003c6	e8 00 00 00 00	 call	 _memset

; 864  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 865  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,

  003cb	8b 85 b4 fb ff
	ff		 mov	 eax, DWORD PTR _c_szDelimeter$GSCopy$1$[ebp]
  003d1	83 c4 0c	 add	 esp, 12			; 0000000cH
  003d4	8b c8		 mov	 ecx, eax
  003d6	8d 14 30	 lea	 edx, DWORD PTR [eax+esi]

; 704  :         for (; _First != _Last; ++_First) {

  003d9	3b c2		 cmp	 eax, edx
  003db	74 13		 je	 SHORT $LN320@SplitLine
  003dd	0f 1f 00	 npad	 3
$LL321@SplitLine:

; 705  :             _Matches[static_cast<unsigned char>(*_First)] = true;

  003e0	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  003e3	41		 inc	 ecx
  003e4	c6 84 05 c0 fb
	ff ff 01	 mov	 BYTE PTR __Matches$2[ebp+eax], 1
  003ec	3b ca		 cmp	 ecx, edx
  003ee	75 f0		 jne	 SHORT $LL321@SplitLine
$LN320@SplitLine:

; 871  :         const auto _End = _Haystack + _Hay_size;

  003f0	8b 95 ac fb ff
	ff		 mov	 edx, DWORD PTR _c_rstLine$1$[ebp]
  003f6	8b b5 bc fb ff
	ff		 mov	 esi, DWORD PTR __Result$1$[ebp]
  003fc	8b 52 10	 mov	 edx, DWORD PTR [edx+16]
  003ff	03 d6		 add	 edx, esi

; 872  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {

  00401	8d 0c 3e	 lea	 ecx, DWORD PTR [esi+edi]
  00404	3b ca		 cmp	 ecx, edx
  00406	73 1a		 jae	 SHORT $LN3@SplitLine
  00408	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL311@SplitLine:

; 712  :         return _Matches[static_cast<unsigned char>(_Ch)];

  00410	0f b6 01	 movzx	 eax, BYTE PTR [ecx]

; 873  :             if (!_Matches._Match(*_Match_try)) {

  00413	80 bc 05 c0 fb
	ff ff 00	 cmp	 BYTE PTR __Matches$2[ebp+eax], 0
  0041b	74 0c		 je	 SHORT $LN381@SplitLine

; 872  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {

  0041d	41		 inc	 ecx
  0041e	3b ca		 cmp	 ecx, edx
  00420	72 ee		 jb	 SHORT $LL311@SplitLine
$LN3@SplitLine:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 124  : 	return true;

  00422	b0 01		 mov	 al, 1
  00424	e9 4c fd ff ff	 jmp	 $LN1@SplitLine
$LN381@SplitLine:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 874  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match

  00429	2b ce		 sub	 ecx, esi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 120  : 		if (int(c_rstLine.find_first_not_of(c_szDelimeter, basePos)) < 0)

  0042b	78 f5		 js	 SHORT $LN3@SplitLine

; 121  : 			break;
; 122  : 	} while (basePos < c_rstLine.length());

  0042d	8b 95 ac fb ff
	ff		 mov	 edx, DWORD PTR _c_rstLine$1$[ebp]
  00433	e9 9b fc ff ff	 jmp	 $LL4@SplitLine
$LN384@SplitLine:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2325 :             _Xran();

  00438	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN291@SplitLine:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0043d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN440@SplitLine:
  00442	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z$0:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR _stToken$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z$1:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR $T6[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 8a ac fb ff
	ff		 mov	 ecx, DWORD PTR [edx-1108]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z ENDP ; CMemoryTextFileLoader::SplitLine
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
;	COMDAT ?CheckLineIndex@CMemoryTextFileLoader@@QAE_NK@Z
_TEXT	SEGMENT
_dwLine$ = 8						; size = 4
?CheckLineIndex@CMemoryTextFileLoader@@QAE_NK@Z PROC	; CMemoryTextFileLoader::CheckLineIndex, COMDAT
; _this$ = ecx

; 133  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000b	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  0000e	f7 ea		 imul	 edx
  00010	c1 fa 02	 sar	 edx, 2
  00013	8b c2		 mov	 eax, edx
  00015	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00018	03 c2		 add	 eax, edx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 134  : 	if (dwLine >= m_stLineVector.size())

  0001a	39 45 08	 cmp	 DWORD PTR _dwLine$[ebp], eax
  0001d	0f 92 c0	 setb	 al

; 135  : 		return false;
; 136  : 
; 137  : 	return true;
; 138  : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
?CheckLineIndex@CMemoryTextFileLoader@@QAE_NK@Z ENDP	; CMemoryTextFileLoader::CheckLineIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
;	COMDAT ?GetLineCount@CMemoryTextFileLoader@@QAEKXZ
_TEXT	SEGMENT
?GetLineCount@CMemoryTextFileLoader@@QAEKXZ PROC	; CMemoryTextFileLoader::GetLineCount, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  0000b	f7 ea		 imul	 edx
  0000d	c1 fa 02	 sar	 edx, 2
  00010	8b c2		 mov	 eax, edx
  00012	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00015	03 c2		 add	 eax, edx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 130  : }

  00017	c3		 ret	 0
?GetLineCount@CMemoryTextFileLoader@@QAEKXZ ENDP	; CMemoryTextFileLoader::GetLineCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
;	COMDAT ?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z
_TEXT	SEGMENT
_this$1$ = -68						; size = 4
_c_pvBuf$GSCopy$1$ = -64				; size = 4
tv1628 = -60						; size = 4
tv1626 = -60						; size = 4
__Old_size$1$ = -60					; size = 4
tv1629 = -56						; size = 4
tv1625 = -56						; size = 4
__Old_size$1$ = -56					; size = 4
__Old_capacity$1$ = -52					; size = 4
$T2 = -52						; size = 4
$T3 = -48						; size = 4
__Old_capacity$1$ = -48					; size = 4
_c$1$ = -41						; size = 1
_stLine$ = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_bufSize$ = 8						; size = 4
_c_pvBuf$ = 12						; size = 4
?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z PROC		; CMemoryTextFileLoader::Bind, COMDAT
; _this$ = ecx

; 147  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 45 0c	 mov	 eax, DWORD PTR _c_pvBuf$[ebp]

; 148  : 	m_stLineVector.reserve(128);

  0002e	8d 79 04	 lea	 edi, DWORD PTR [ecx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00031	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00034	2b 0f		 sub	 ecx, DWORD PTR [edi]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 147  : {

  00036	89 45 c0	 mov	 DWORD PTR _c_pvBuf$GSCopy$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00039	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0003e	f7 e9		 imul	 ecx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 148  : 	m_stLineVector.reserve(128);

  00040	89 7d bc	 mov	 DWORD PTR _this$1$[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00043	c1 fa 02	 sar	 edx, 2
  00046	8b c2		 mov	 eax, edx
  00048	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0004b	03 c2		 add	 eax, edx

; 1371 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  0004d	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00052	73 0c		 jae	 SHORT $LN15@Bind

; 1372 :             if (_Newcapacity > max_size()) {
; 1373 :                 _Xlength();
; 1374 :             }
; 1375 : 
; 1376 :             _Reallocate_exactly(_Newcapacity);

  00054	68 80 00 00 00	 push	 128			; 00000080H
  00059	8b cf		 mov	 ecx, edi
  0005b	e8 00 00 00 00	 call	 ?_Reallocate_exactly@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate_exactly
$LN15@Bind:

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00060	57		 push	 edi
  00061	ff 77 04	 push	 DWORD PTR [edi+4]
  00064	ff 37		 push	 DWORD PTR [edi]
  00066	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1456 :         _Mylast = _Myfirst;

  0006b	8b 07		 mov	 eax, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0006d	be 0f 00 00 00	 mov	 esi, 15			; 0000000fH

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00072	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _stLine$[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00079	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1456 :         _Mylast = _Myfirst;

  0007c	89 47 04	 mov	 DWORD PTR [edi+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4596 :         _My_data._Mysize = 0;

  0007f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _stLine$[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00086	89 75 ec	 mov	 DWORD PTR _stLine$[ebp+20], esi

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00089	c6 45 d8 00	 mov	 BYTE PTR _stLine$[ebp], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 155  : 	while (pos < bufSize)

  0008d	8b 4d 08	 mov	 ecx, DWORD PTR _bufSize$[ebp]
  00090	33 db		 xor	 ebx, ebx
  00092	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00099	85 c9		 test	 ecx, ecx
  0009b	0f 8e 4e 03 00
	00		 jle	 $LN3@Bind
  000a1	8b 7d d8	 mov	 edi, DWORD PTR _stLine$[ebp]
$LL2@Bind:

; 156  : 	{
; 157  : 		const char c = c_pcBuf[pos++];

  000a4	8b 45 c0	 mov	 eax, DWORD PTR _c_pvBuf$GSCopy$1$[ebp]
  000a7	8a 14 18	 mov	 dl, BYTE PTR [eax+ebx]
  000aa	43		 inc	 ebx
  000ab	88 55 d7	 mov	 BYTE PTR _c$1$[ebp], dl

; 158  : 
; 159  : 		if ('\n' == c || '\r' == c)

  000ae	80 fa 0a	 cmp	 dl, 10			; 0000000aH
  000b1	0f 84 d8 02 00
	00		 je	 $LN6@Bind
  000b7	80 fa 0d	 cmp	 dl, 13			; 0000000dH
  000ba	0f 84 cf 02 00
	00		 je	 $LN6@Bind

; 164  : 
; 165  : 			m_stLineVector.push_back(stLine);
; 166  : 			stLine = "";
; 167  : 		}
; 168  : 		else if (c < 0)

  000c0	84 d2		 test	 dl, dl
  000c2	0f 89 78 01 00
	00		 jns	 $LN10@Bind
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3154 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  000c8	8b 55 e8	 mov	 edx, DWORD PTR _stLine$[ebp+16]
  000cb	8b c6		 mov	 eax, esi
  000cd	2b c2		 sub	 eax, edx
  000cf	89 55 c8	 mov	 DWORD PTR __Old_size$1$[ebp], edx

; 3155 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  000d2	83 f8 02	 cmp	 eax, 2
  000d5	72 2c		 jb	 SHORT $LN110@Bind

; 3156 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  000d7	8d 42 02	 lea	 eax, DWORD PTR [edx+2]

; 2319 :         return _BUF_SIZE <= _Myres;

  000da	83 fe 10	 cmp	 esi, 16			; 00000010H

; 3156 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  000dd	89 45 e8	 mov	 DWORD PTR _stLine$[ebp+16], eax

; 2296 :         value_type* _Result = _Bx._Buf;

  000e0	8d 4d d8	 lea	 ecx, DWORD PTR _stLine$[ebp]

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  000e3	8b 45 c0	 mov	 eax, DWORD PTR _c_pvBuf$GSCopy$1$[ebp]

; 2297 :         if (_Large_string_engaged()) {

  000e6	0f 43 cf	 cmovae	 ecx, edi

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  000e9	66 8b 44 18 ff	 mov	 ax, WORD PTR [eax+ebx-1]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 171  : 			++pos;

  000ee	43		 inc	 ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  000ef	66 89 04 11	 mov	 WORD PTR [ecx+edx], ax

; 3159 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  000f3	c6 44 11 02 00	 mov	 BYTE PTR [ecx+edx+2], 0

; 3160 :             return *this;

  000f8	8b 75 ec	 mov	 esi, DWORD PTR _stLine$[ebp+20]
  000fb	8b 7d d8	 mov	 edi, DWORD PTR _stLine$[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 172  : 		}

  000fe	e9 db 02 00 00	 jmp	 $LN66@Bind
$LN110@Bind:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4542 :         const size_type _Old_size = _My_data._Mysize;

  00103	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00108	2b c2		 sub	 eax, edx

; 4543 :         if (max_size() - _Old_size < _Size_increase) {

  0010a	83 f8 02	 cmp	 eax, 2
  0010d	0f 82 48 03 00
	00		 jb	 $LN268@Bind

; 4545 :         }
; 4546 : 
; 4547 :         const size_type _New_size     = _Old_size + _Size_increase;
; 4548 :         const size_type _Old_capacity = _My_data._Myres;

  00113	8b c6		 mov	 eax, esi

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00115	8d 72 02	 lea	 esi, DWORD PTR [edx+2]
  00118	83 ce 0f	 or	 esi, 15			; 0000000fH

; 4548 :         const size_type _Old_capacity = _My_data._Myres;

  0011b	89 45 d0	 mov	 DWORD PTR __Old_capacity$1$[ebp], eax

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0011e	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 4489 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00124	76 18		 jbe	 SHORT $LN127@Bind

; 4490 :             return _Max;

  00126	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0012b	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00130	50		 push	 eax
  00131	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00136	8b 55 c8	 mov	 edx, DWORD PTR __Old_size$1$[ebp]
  00139	83 c4 04	 add	 esp, 4
  0013c	eb 5e		 jmp	 SHORT $LN277@Bind
$LN127@Bind:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4493 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0013e	8b c8		 mov	 ecx, eax
  00140	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00145	d1 e9		 shr	 ecx, 1
  00147	2b c1		 sub	 eax, ecx
  00149	39 45 d0	 cmp	 DWORD PTR __Old_capacity$1$[ebp], eax
  0014c	76 18		 jbe	 SHORT $LN128@Bind

; 4494 :             return _Max;

  0014e	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00153	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00158	50		 push	 eax
  00159	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0015e	8b 55 c8	 mov	 edx, DWORD PTR __Old_size$1$[ebp]
  00161	83 c4 04	 add	 esp, 4
  00164	eb 36		 jmp	 SHORT $LN277@Bind
$LN128@Bind:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4497 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00166	8b 45 d0	 mov	 eax, DWORD PTR __Old_capacity$1$[ebp]
  00169	03 c1		 add	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  0016b	3b f0		 cmp	 esi, eax
  0016d	0f 42 f0	 cmovb	 esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4551 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00170	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00173	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00178	72 0e		 jb	 SHORT $LN135@Bind

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0017a	50		 push	 eax
  0017b	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00180	8b 55 c8	 mov	 edx, DWORD PTR __Old_size$1$[ebp]
  00183	83 c4 04	 add	 esp, 4
  00186	eb 14		 jmp	 SHORT $LN277@Bind
$LN135@Bind:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  00188	85 c0		 test	 eax, eax
  0018a	74 0e		 je	 SHORT $LN136@Bind

; 85   :         return ::operator new(_Bytes);

  0018c	50		 push	 eax
  0018d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 244  :         return _Traits::_Allocate(_Bytes);

  00192	8b 55 c8	 mov	 edx, DWORD PTR __Old_size$1$[ebp]

; 85   :         return ::operator new(_Bytes);

  00195	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  00198	eb 02		 jmp	 SHORT $LN277@Bind
$LN136@Bind:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  0019a	33 c0		 xor	 eax, eax
$LN277@Bind:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4559 :         _My_data._Mysize      = _New_size;

  0019c	8d 4a 02	 lea	 ecx, DWORD PTR [edx+2]
  0019f	89 45 cc	 mov	 DWORD PTR $T2[ebp], eax
  001a2	89 4d e8	 mov	 DWORD PTR _stLine$[ebp+16], ecx

; 4560 :         _My_data._Myres       = _New_capacity;
; 4561 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  001a5	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]
  001a8	89 4d c8	 mov	 DWORD PTR tv1629[ebp], ecx
  001ab	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
  001ae	03 ca		 add	 ecx, edx
  001b0	89 75 ec	 mov	 DWORD PTR _stLine$[ebp+20], esi

; 4562 :         if (_BUF_SIZE <= _Old_capacity) {

  001b3	83 7d d0 10	 cmp	 DWORD PTR __Old_capacity$1$[ebp], 16 ; 00000010H
  001b7	89 4d c4	 mov	 DWORD PTR tv1628[ebp], ecx
  001ba	52		 push	 edx
  001bb	72 56		 jb	 SHORT $LN121@Bind

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  001bd	57		 push	 edi
  001be	50		 push	 eax
  001bf	e8 00 00 00 00	 call	 _memcpy
  001c4	8b 45 c0	 mov	 eax, DWORD PTR _c_pvBuf$GSCopy$1$[ebp]
  001c7	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ca	8b 4d c8	 mov	 ecx, DWORD PTR tv1629[ebp]
  001cd	66 8b 44 18 ff	 mov	 ax, WORD PTR [eax+ebx-1]
  001d2	66 89 01	 mov	 WORD PTR [ecx], ax

; 3169 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  001d5	8b 45 c4	 mov	 eax, DWORD PTR tv1628[ebp]

; 4565 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  001d8	8b 4d d0	 mov	 ecx, DWORD PTR __Old_capacity$1$[ebp]
  001db	41		 inc	 ecx

; 3169 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  001dc	c6 00 00	 mov	 BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001df	8b c7		 mov	 eax, edi

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  001e1	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  001e7	72 14		 jb	 SHORT $LN160@Bind

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001e9	8b 7f fc	 mov	 edi, DWORD PTR [edi-4]
  001ec	83 c1 23	 add	 ecx, 35			; 00000023H
  001ef	2b c7		 sub	 eax, edi

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001f1	83 c0 fc	 add	 eax, -4			; fffffffcH
  001f4	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001f7	0f 87 63 02 00
	00		 ja	 $LN258@Bind
$LN160@Bind:

; 264  :         ::operator delete(_Ptr, _Bytes);

  001fd	51		 push	 ecx
  001fe	57		 push	 edi
  001ff	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 171  : 			++pos;

  00204	8b 7d cc	 mov	 edi, DWORD PTR $T2[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00207	83 c4 08	 add	 esp, 8
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 171  : 			++pos;

  0020a	89 7d d8	 mov	 DWORD PTR _stLine$[ebp], edi
  0020d	43		 inc	 ebx

; 172  : 		}

  0020e	e9 cb 01 00 00	 jmp	 $LN66@Bind
$LN121@Bind:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00213	8d 4d d8	 lea	 ecx, DWORD PTR _stLine$[ebp]
  00216	51		 push	 ecx
  00217	50		 push	 eax
  00218	e8 00 00 00 00	 call	 _memcpy
  0021d	8b 45 c0	 mov	 eax, DWORD PTR _c_pvBuf$GSCopy$1$[ebp]
  00220	83 c4 0c	 add	 esp, 12			; 0000000cH
  00223	8b 4d c8	 mov	 ecx, DWORD PTR tv1629[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 171  : 			++pos;

  00226	8b 7d cc	 mov	 edi, DWORD PTR $T2[ebp]
  00229	89 7d d8	 mov	 DWORD PTR _stLine$[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0022c	66 8b 44 18 ff	 mov	 ax, WORD PTR [eax+ebx-1]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 171  : 			++pos;

  00231	43		 inc	 ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00232	66 89 01	 mov	 WORD PTR [ecx], ax

; 3169 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00235	8b 45 c4	 mov	 eax, DWORD PTR tv1628[ebp]
  00238	c6 00 00	 mov	 BYTE PTR [eax], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 172  : 		}

  0023b	e9 9e 01 00 00	 jmp	 $LN66@Bind
$LN10@Bind:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3862 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00240	8b 4d e8	 mov	 ecx, DWORD PTR _stLine$[ebp+16]
  00243	89 4d c4	 mov	 DWORD PTR __Old_size$1$[ebp], ecx
  00246	3b ce		 cmp	 ecx, esi

; 3863 :         if (_Old_size < _Mypair._Myval2._Myres) {

  00248	73 1c		 jae	 SHORT $LN174@Bind

; 3864 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  0024a	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 2319 :         return _BUF_SIZE <= _Myres;

  0024d	83 fe 10	 cmp	 esi, 16			; 00000010H

; 3864 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  00250	89 45 e8	 mov	 DWORD PTR _stLine$[ebp+16], eax

; 2296 :         value_type* _Result = _Bx._Buf;

  00253	8d 45 d8	 lea	 eax, DWORD PTR _stLine$[ebp]

; 2297 :         if (_Large_string_engaged()) {

  00256	0f 43 c7	 cmovae	 eax, edi

; 3866 :             _Traits::assign(_Ptr[_Old_size], _Ch);

  00259	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 3867 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

  0025c	c6 44 08 01 00	 mov	 BYTE PTR [eax+ecx+1], 0

; 3868 :             return;

  00261	e9 72 01 00 00	 jmp	 $LN279@Bind
$LN174@Bind:

; 4542 :         const size_type _Old_size = _My_data._Mysize;

  00266	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0026b	2b c1		 sub	 eax, ecx

; 4543 :         if (max_size() - _Old_size < _Size_increase) {

  0026d	83 f8 01	 cmp	 eax, 1
  00270	0f 82 e5 01 00
	00		 jb	 $LN268@Bind

; 4545 :         }
; 4546 : 
; 4547 :         const size_type _New_size     = _Old_size + _Size_increase;
; 4548 :         const size_type _Old_capacity = _My_data._Myres;

  00276	8b c6		 mov	 eax, esi

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00278	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  0027b	83 ce 0f	 or	 esi, 15			; 0000000fH

; 4548 :         const size_type _Old_capacity = _My_data._Myres;

  0027e	89 45 cc	 mov	 DWORD PTR __Old_capacity$1$[ebp], eax

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00281	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 4489 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00287	76 18		 jbe	 SHORT $LN189@Bind

; 4490 :             return _Max;

  00289	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0028e	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00293	50		 push	 eax
  00294	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00299	8b 4d c4	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  0029c	83 c4 04	 add	 esp, 4
  0029f	eb 5e		 jmp	 SHORT $LN280@Bind
$LN189@Bind:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4493 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  002a1	8b d0		 mov	 edx, eax
  002a3	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  002a8	d1 ea		 shr	 edx, 1
  002aa	2b c2		 sub	 eax, edx
  002ac	39 45 cc	 cmp	 DWORD PTR __Old_capacity$1$[ebp], eax
  002af	76 18		 jbe	 SHORT $LN190@Bind

; 4494 :             return _Max;

  002b1	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  002b6	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  002bb	50		 push	 eax
  002bc	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  002c1	8b 4d c4	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  002c4	83 c4 04	 add	 esp, 4
  002c7	eb 36		 jmp	 SHORT $LN280@Bind
$LN190@Bind:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4497 :         return (_STD max)(_Masked, _Old + _Old / 2);

  002c9	8b 45 cc	 mov	 eax, DWORD PTR __Old_capacity$1$[ebp]
  002cc	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  002ce	3b f0		 cmp	 esi, eax
  002d0	0f 42 f0	 cmovb	 esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4551 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  002d3	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  002d6	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  002db	72 0e		 jb	 SHORT $LN197@Bind

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  002dd	50		 push	 eax
  002de	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  002e3	8b 4d c4	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  002e6	83 c4 04	 add	 esp, 4
  002e9	eb 14		 jmp	 SHORT $LN280@Bind
$LN197@Bind:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  002eb	85 c0		 test	 eax, eax
  002ed	74 0e		 je	 SHORT $LN198@Bind

; 85   :         return ::operator new(_Bytes);

  002ef	50		 push	 eax
  002f0	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 244  :         return _Traits::_Allocate(_Bytes);

  002f5	8b 4d c4	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]

; 85   :         return ::operator new(_Bytes);

  002f8	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  002fb	eb 02		 jmp	 SHORT $LN280@Bind
$LN198@Bind:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  002fd	33 c0		 xor	 eax, eax
$LN280@Bind:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4559 :         _My_data._Mysize      = _New_size;

  002ff	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  00302	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
  00305	89 55 e8	 mov	 DWORD PTR _stLine$[ebp+16], edx

; 4560 :         _My_data._Myres       = _New_capacity;
; 4561 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  00308	8d 14 08	 lea	 edx, DWORD PTR [eax+ecx]
  0030b	89 55 c4	 mov	 DWORD PTR tv1626[ebp], edx
  0030e	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00311	03 d1		 add	 edx, ecx
  00313	89 75 ec	 mov	 DWORD PTR _stLine$[ebp+20], esi

; 4562 :         if (_BUF_SIZE <= _Old_capacity) {

  00316	83 7d cc 10	 cmp	 DWORD PTR __Old_capacity$1$[ebp], 16 ; 00000010H
  0031a	89 55 c8	 mov	 DWORD PTR tv1625[ebp], edx
  0031d	51		 push	 ecx
  0031e	72 4c		 jb	 SHORT $LN183@Bind

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00320	57		 push	 edi
  00321	50		 push	 eax
  00322	e8 00 00 00 00	 call	 _memcpy

; 3875 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

  00327	8b 4d c4	 mov	 ecx, DWORD PTR tv1626[ebp]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0032a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3875 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

  0032d	8a 45 d7	 mov	 al, BYTE PTR _c$1$[ebp]
  00330	88 01		 mov	 BYTE PTR [ecx], al

; 3876 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  00332	8b 45 c8	 mov	 eax, DWORD PTR tv1625[ebp]

; 4565 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  00335	8b 4d cc	 mov	 ecx, DWORD PTR __Old_capacity$1$[ebp]
  00338	41		 inc	 ecx

; 3876 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  00339	c6 00 00	 mov	 BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0033c	8b c7		 mov	 eax, edi

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0033e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00344	72 14		 jb	 SHORT $LN220@Bind

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00346	8b 7f fc	 mov	 edi, DWORD PTR [edi-4]
  00349	83 c1 23	 add	 ecx, 35			; 00000023H
  0034c	2b c7		 sub	 eax, edi

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0034e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00351	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00354	0f 87 06 01 00
	00		 ja	 $LN258@Bind
$LN220@Bind:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0035a	51		 push	 ecx
  0035b	57		 push	 edi
  0035c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4566 :             _My_data._Bx._Ptr = _New_ptr;

  00361	8b 7d d0	 mov	 edi, DWORD PTR $T3[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00364	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4566 :             _My_data._Bx._Ptr = _New_ptr;

  00367	89 7d d8	 mov	 DWORD PTR _stLine$[ebp], edi

; 4567 :         } else {

  0036a	eb 72		 jmp	 SHORT $LN66@Bind
$LN183@Bind:

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0036c	8d 4d d8	 lea	 ecx, DWORD PTR _stLine$[ebp]
  0036f	51		 push	 ecx
  00370	50		 push	 eax
  00371	e8 00 00 00 00	 call	 _memcpy

; 3875 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

  00376	8b 4d c4	 mov	 ecx, DWORD PTR tv1626[ebp]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00379	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3875 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

  0037c	8a 45 d7	 mov	 al, BYTE PTR _c$1$[ebp]

; 4569 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  0037f	8b 7d d0	 mov	 edi, DWORD PTR $T3[ebp]
  00382	89 7d d8	 mov	 DWORD PTR _stLine$[ebp], edi

; 3875 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

  00385	88 01		 mov	 BYTE PTR [ecx], al

; 3876 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  00387	8b 45 c8	 mov	 eax, DWORD PTR tv1625[ebp]
  0038a	c6 00 00	 mov	 BYTE PTR [eax], 0

; 4569 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  0038d	eb 4f		 jmp	 SHORT $LN66@Bind
$LN6@Bind:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 161  : 			if (pos < bufSize)

  0038f	3b d9		 cmp	 ebx, ecx
  00391	7d 0c		 jge	 SHORT $LN8@Bind

; 162  : 				if ('\n' == c_pcBuf[pos] || '\r' == c_pcBuf[pos])

  00393	8a 04 18	 mov	 al, BYTE PTR [eax+ebx]
  00396	3c 0a		 cmp	 al, 10			; 0000000aH
  00398	74 04		 je	 SHORT $LN9@Bind
  0039a	3c 0d		 cmp	 al, 13			; 0000000dH
  0039c	75 01		 jne	 SHORT $LN8@Bind
$LN9@Bind:

; 163  : 					++pos;

  0039e	43		 inc	 ebx
$LN8@Bind:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  0039f	8b 75 bc	 mov	 esi, DWORD PTR _this$1$[ebp]
  003a2	8d 4d d8	 lea	 ecx, DWORD PTR _stLine$[ebp]
  003a5	51		 push	 ecx
  003a6	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  003a9	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  003ac	74 0d		 je	 SHORT $LN41@Bind
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

  003ae	8b c8		 mov	 ecx, eax
  003b0	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 729  :         ++_Mylast;

  003b5	83 46 04 18	 add	 DWORD PTR [esi+4], 24	; 00000018H

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  003b9	eb 08		 jmp	 SHORT $LN40@Bind
$LN41@Bind:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  003bb	50		 push	 eax
  003bc	8b ce		 mov	 ecx, esi
  003be	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
$LN40@Bind:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  003c3	83 7d ec 10	 cmp	 DWORD PTR _stLine$[ebp+20], 16 ; 00000010H

; 2296 :         value_type* _Result = _Bx._Buf;

  003c7	8d 45 d8	 lea	 eax, DWORD PTR _stLine$[ebp]

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  003ca	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _stLine$[ebp+16], 0

; 2297 :         if (_Large_string_engaged()) {

  003d1	0f 43 45 d8	 cmovae	 eax, DWORD PTR _stLine$[ebp]

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  003d5	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN279@Bind:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 155  : 	while (pos < bufSize)

  003d8	8b 7d d8	 mov	 edi, DWORD PTR _stLine$[ebp]
  003db	8b 75 ec	 mov	 esi, DWORD PTR _stLine$[ebp+20]
$LN66@Bind:
  003de	8b 4d 08	 mov	 ecx, DWORD PTR _bufSize$[ebp]
  003e1	3b d9		 cmp	 ebx, ecx
  003e3	0f 8c bb fc ff
	ff		 jl	 $LL2@Bind
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4508 :         if (_New_size > max_size()) {

  003e9	8b 7d bc	 mov	 edi, DWORD PTR _this$1$[ebp]
  003ec	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
$LN3@Bind:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  003ef	8d 4d d8	 lea	 ecx, DWORD PTR _stLine$[ebp]
  003f2	51		 push	 ecx
  003f3	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  003f6	74 0d		 je	 SHORT $LN233@Bind
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

  003f8	8b c8		 mov	 ecx, eax
  003fa	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 729  :         ++_Mylast;

  003ff	83 47 04 18	 add	 DWORD PTR [edi+4], 24	; 00000018H

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00403	eb 08		 jmp	 SHORT $LN232@Bind
$LN233@Bind:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00405	50		 push	 eax
  00406	8b cf		 mov	 ecx, edi
  00408	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
$LN232@Bind:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  0040d	8b 55 ec	 mov	 edx, DWORD PTR _stLine$[ebp+20]
  00410	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00413	72 28		 jb	 SHORT $LN251@Bind
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00415	8b 4d d8	 mov	 ecx, DWORD PTR _stLine$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00418	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00419	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0041b	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00421	72 10		 jb	 SHORT $LN261@Bind

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00423	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00426	83 c2 23	 add	 edx, 35			; 00000023H
  00429	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0042b	83 c0 fc	 add	 eax, -4			; fffffffcH
  0042e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00431	77 2d		 ja	 SHORT $LN258@Bind
$LN261@Bind:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00433	52		 push	 edx
  00434	51		 push	 ecx
  00435	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0043a	83 c4 08	 add	 esp, 8
$LN251@Bind:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 180  : }

  0043d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00440	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00447	59		 pop	 ecx
  00448	5f		 pop	 edi
  00449	5e		 pop	 esi
  0044a	5b		 pop	 ebx
  0044b	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0044e	33 cd		 xor	 ecx, ebp
  00450	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00455	8b e5		 mov	 esp, ebp
  00457	5d		 pop	 ebp
  00458	c2 08 00	 ret	 8
$LN268@Bind:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4544 :             _Xlen_string(); // result too long

  0045b	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN258@Bind:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00460	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN276@Bind:
  00465	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _stLine$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z ENDP		; CMemoryTextFileLoader::Bind
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
;	COMDAT ??1CMemoryTextFileLoader@@UAE@XZ
_TEXT	SEGMENT
??1CMemoryTextFileLoader@@UAE@XZ PROC			; CMemoryTextFileLoader::~CMemoryTextFileLoader, COMDAT
; _this$ = ecx

; 10   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CMemoryTextFileLoader@@6B@

; 11   : }

  00006	83 c1 04	 add	 ecx, 4
  00009	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
??1CMemoryTextFileLoader@@UAE@XZ ENDP			; CMemoryTextFileLoader::~CMemoryTextFileLoader
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp
;	COMDAT ??0CMemoryTextFileLoader@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CMemoryTextFileLoader@@QAE@XZ PROC			; CMemoryTextFileLoader::CMemoryTextFileLoader, COMDAT
; _this$ = ecx

; 6    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CMemoryTextFileLoader@@6B@

; 7    : }

  0000a	8b c1		 mov	 eax, ecx
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0000f	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00016	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0001d	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileLoader.cpp

; 7    : }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??0CMemoryTextFileLoader@@QAE@XZ ENDP			; CMemoryTextFileLoader::CMemoryTextFileLoader
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Old$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
$T1 = 12						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3244 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 3245 :         // assign [_Ptr, _Ptr + _Count)
; 3246 :         if (_Count <= _Mypair._Myval2._Myres) {

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	57		 push	 edi
  0000c	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0000f	89 4d fc	 mov	 DWORD PTR __Old$1$[ebp], ecx
  00012	3b d9		 cmp	 ebx, ecx
  00014	77 28		 ja	 SHORT $LN2@assign

; 2296 :         value_type* _Result = _Bx._Buf;

  00016	8b fe		 mov	 edi, esi

; 2319 :         return _BUF_SIZE <= _Myres;

  00018	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 2297 :         if (_Large_string_engaged()) {

  0001b	72 02		 jb	 SHORT $LN5@assign

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  0001d	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN5@assign:

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0001f	53		 push	 ebx
  00020	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 3247 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3248 :             _Mypair._Myval2._Mysize = _Count;

  00023	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00026	57		 push	 edi
  00027	e8 00 00 00 00	 call	 _memmove
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3249 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0002f	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 3259 :             },
; 3260 :             _Ptr);
; 3261 :     }

  00033	8b c6		 mov	 eax, esi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
$LN2@assign:

; 4508 :         if (_New_size > max_size()) {

  0003e	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  00044	0f 87 d4 00 00
	00		 ja	 $LN60@assign

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0004a	8b fb		 mov	 edi, ebx
  0004c	83 cf 0f	 or	 edi, 15			; 0000000fH
  0004f	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH

; 4489 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00055	76 15		 jbe	 SHORT $LN19@assign

; 4490 :             return _Max;

  00057	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0005c	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00067	83 c4 04	 add	 esp, 4
  0006a	eb 52		 jmp	 SHORT $LN58@assign
$LN19@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4493 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0006c	8b d1		 mov	 edx, ecx
  0006e	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00073	d1 ea		 shr	 edx, 1
  00075	2b c2		 sub	 eax, edx
  00077	3b c8		 cmp	 ecx, eax
  00079	76 15		 jbe	 SHORT $LN20@assign

; 4494 :             return _Max;

  0007b	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00080	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0008b	83 c4 04	 add	 esp, 4
  0008e	eb 2e		 jmp	 SHORT $LN58@assign
$LN20@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4497 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00090	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00093	3b f8		 cmp	 edi, eax
  00095	0f 42 f8	 cmovb	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4515 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00098	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0009b	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000a0	72 0b		 jb	 SHORT $LN27@assign

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a8	83 c4 04	 add	 esp, 4
  000ab	eb 11		 jmp	 SHORT $LN58@assign
$LN27@assign:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  000ad	85 c0		 test	 eax, eax
  000af	74 0b		 je	 SHORT $LN28@assign

; 85   :         return ::operator new(_Bytes);

  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000b7	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  000ba	eb 02		 jmp	 SHORT $LN58@assign
$LN28@assign:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000bc	33 c0		 xor	 eax, eax
$LN58@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000be	53		 push	 ebx
  000bf	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 4523 :         _Mypair._Myval2._Mysize = _New_size;

  000c2	89 45 0c	 mov	 DWORD PTR $T1[ebp], eax

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c5	50		 push	 eax

; 4523 :         _Mypair._Myval2._Mysize = _New_size;

  000c6	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 4524 :         _Mypair._Myval2._Myres  = _New_capacity;

  000c9	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000cc	e8 00 00 00 00	 call	 _memcpy

; 3258 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000d1	8b 7d 0c	 mov	 edi, DWORD PTR $T1[ebp]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4526 :         if (_BUF_SIZE <= _Old_capacity) {

  000d7	8b 45 fc	 mov	 eax, DWORD PTR __Old$1$[ebp]

; 3258 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000da	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 4526 :         if (_BUF_SIZE <= _Old_capacity) {

  000de	83 f8 10	 cmp	 eax, 16			; 00000010H
  000e1	72 29		 jb	 SHORT $LN13@assign

; 4527 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  000e3	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e6	8b 06		 mov	 eax, DWORD PTR [esi]

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000e8	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000ee	72 12		 jb	 SHORT $LN50@assign

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f0	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000f3	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000f6	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000f8	83 c0 fc	 add	 eax, -4			; fffffffcH
  000fb	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000fe	77 19		 ja	 SHORT $LN47@assign

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00100	8b c2		 mov	 eax, edx
$LN50@assign:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00102	51		 push	 ecx
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00109	83 c4 08	 add	 esp, 8
$LN13@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3254 :         return _Reallocate_for(

  0010c	89 3e		 mov	 DWORD PTR [esi], edi

; 3259 :             },
; 3260 :             _Ptr);
; 3261 :     }

  0010e	8b c6		 mov	 eax, esi
  00110	5f		 pop	 edi
  00111	5e		 pop	 esi
  00112	5b		 pop	 ebx
  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c2 08 00	 ret	 8
$LN47@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00119	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN60@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4509 :             _Xlen_string(); // result too long

  0011e	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN56@assign:
  00123	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 3002 :     _CONSTEXPR20_CONTAINER ~basic_string() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2319 :         return _BUF_SIZE <= _Myres;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 27		 jb	 SHORT $LN12@basic_stri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0000d	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN22@basic_stri

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN19@basic_stri

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN22@basic_stri:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN12@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi

; 3010 :     }

  00044	c3		 ret	 0
$LN19@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN27@basic_stri:
  0004a	cc		 int	 3
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right_size$1$ = 8					; size = 4
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2451 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	57		 push	 edi

; 2921 :         const size_type _Right_size   = _Right_data._Mysize;

  00008	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0000b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 2355 :     size_type _Mysize = 0; // current length of string

  00011	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 2356 :     size_type _Myres  = 0; // current storage reserved for string

  00018	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 2319 :         return _BUF_SIZE <= _Myres;

  0001f	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H

; 2921 :         const size_type _Right_size   = _Right_data._Mysize;

  00023	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00026	89 4d 08	 mov	 DWORD PTR __Right_size$1$[ebp], ecx

; 2306 :         if (_Large_string_engaged()) {

  00029	72 02		 jb	 SHORT $LN15@basic_stri

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  0002b	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN15@basic_stri:

; 2928 :         const bool _Stay_small = _Right_size < _BUF_SIZE;

  0002d	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 2929 : #endif // __cpp_lib_constexpr_string
; 2930 : 
; 2931 :         // NOTE: even if _Right is in large mode, we only go into large mode ourselves if the actual size of _Right
; 2932 :         // requires it
; 2933 :         if (_Stay_small) { // stay small, don't allocate

  00030	73 1a		 jae	 SHORT $LN12@basic_stri

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00032	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]

; 2936 :             _My_data._Myres  = _BUF_SIZE - 1;

  00035	bb 0f 00 00 00	 mov	 ebx, 15			; 0000000fH

; 2452 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2453 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2454 :         _Construct_lv_contents(_Right);
; 2455 :         _Proxy._Release();
; 2456 :     }

  0003a	8b c6		 mov	 eax, esi
  0003c	5f		 pop	 edi

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0003d	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0

; 2452 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2453 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2454 :         _Construct_lv_contents(_Right);
; 2455 :         _Proxy._Release();
; 2456 :     }

  00040	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  00043	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
$LN12@basic_stri:

; 2941 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  0004c	8b d9		 mov	 ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0004e	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2941 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  00053	83 cb 0f	 or	 ebx, 15			; 0000000fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00056	3b d8		 cmp	 ebx, eax
  00058	0f 47 d8	 cmova	 ebx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2942 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  0005b	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0005e	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00063	72 0d		 jb	 SHORT $LN26@basic_stri

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0006b	83 c4 04	 add	 esp, 4
  0006e	8b c8		 mov	 ecx, eax
  00070	eb 13		 jmp	 SHORT $LN25@basic_stri
$LN26@basic_stri:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  00072	85 c0		 test	 eax, eax
  00074	74 0d		 je	 SHORT $LN27@basic_stri

; 85   :         return ::operator new(_Bytes);

  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0007c	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  0007f	8b c8		 mov	 ecx, eax
  00081	eb 02		 jmp	 SHORT $LN25@basic_stri
$LN27@basic_stri:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  00083	33 c9		 xor	 ecx, ecx
$LN25@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2950 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  00085	8b 45 08	 mov	 eax, DWORD PTR __Right_size$1$[ebp]
  00088	40		 inc	 eax
  00089	89 0e		 mov	 DWORD PTR [esi], ecx

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0008b	50		 push	 eax
  0008c	57		 push	 edi
  0008d	51		 push	 ecx
  0008e	e8 00 00 00 00	 call	 _memcpy
  00093	8b 4d 08	 mov	 ecx, DWORD PTR __Right_size$1$[ebp]
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2452 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2453 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2454 :         _Construct_lv_contents(_Right);
; 2455 :         _Proxy._Release();
; 2456 :     }

  00099	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0009c	8b c6		 mov	 eax, esi
  0009e	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx
  000a4	5d		 pop	 ebp
  000a5	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 2337 :         _Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2374 :     _Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlen_strin:
  0000a	cc		 int	 3
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN12@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 142  :     }

  00003	8b c1		 mov	 eax, ecx

; 65   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 66   :     {
; 67   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 141  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN6@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 96   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 91   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 74   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
END
