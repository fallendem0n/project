; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30137.0 

	TITLE	C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\Distribute\Poly.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??0CPoly@@QAE@XZ				; CPoly::CPoly
PUBLIC	??1CPoly@@UAE@XZ				; CPoly::~CPoly
PUBLIC	?Analyze@CPoly@@QAEHPBD@Z			; CPoly::Analyze
PUBLIC	?Eval@CPoly@@QAEMXZ				; CPoly::Eval
PUBLIC	?SetRandom@CPoly@@QAEXH@Z			; CPoly::SetRandom
PUBLIC	?SetStr@CPoly@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CPoly::SetStr
PUBLIC	?SetVar@CPoly@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z ; CPoly::SetVar
PUBLIC	?GetVarCount@CPoly@@QAEHXZ			; CPoly::GetVarCount
PUBLIC	?GetVarName@CPoly@@QAEPBDI@Z			; CPoly::GetVarName
PUBLIC	?Clear@CPoly@@QAEXXZ				; CPoly::Clear
PUBLIC	?my_irandom@CPoly@@IAEHNN@Z			; CPoly::my_irandom
PUBLIC	?my_frandom@CPoly@@IAENNN@Z			; CPoly::my_frandom
PUBLIC	?init@CPoly@@IAEXXZ				; CPoly::init
PUBLIC	?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPoly::insert
PUBLIC	?find@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CPoly::find
PUBLIC	?emit@CPoly@@IAEXHH@Z				; CPoly::emit
PUBLIC	?match@CPoly@@IAEXH@Z				; CPoly::match
PUBLIC	?expo@CPoly@@IAEXXZ				; CPoly::expo
PUBLIC	?factor@CPoly@@IAEXXZ				; CPoly::factor
PUBLIC	?term@CPoly@@IAEXXZ				; CPoly::term
PUBLIC	?lexan@CPoly@@IAEHXZ				; CPoly::lexan
PUBLIC	?error@CPoly@@IAEXXZ				; CPoly::error
PUBLIC	?expr@CPoly@@IAEXXZ				; CPoly::expr
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEX$$QAH@Z ; std::vector<int,std::allocator<int> >::push_back
PUBLIC	?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z ; std::vector<int,std::allocator<int> >::_Change_array
PUBLIC	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
PUBLIC	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ	; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
PUBLIC	?_Xlength@?$vector@NV?$allocator@N@std@@@std@@CAXXZ ; std::vector<double,std::allocator<double> >::_Xlength
PUBLIC	??1?$vector@PAVCSymTable@@V?$allocator@PAVCSymTable@@@std@@@std@@QAE@XZ ; std::vector<CSymTable *,std::allocator<CSymTable *> >::~vector<CSymTable *,std::allocator<CSymTable *> >
PUBLIC	?_Reallocate_exactly@?$vector@PAVCSymTable@@V?$allocator@PAVCSymTable@@@std@@@std@@AAEXI@Z ; std::vector<CSymTable *,std::allocator<CSymTable *> >::_Reallocate_exactly
PUBLIC	?_Change_array@?$vector@PAVCSymTable@@V?$allocator@PAVCSymTable@@@std@@@std@@AAEXQAPAVCSymTable@@II@Z ; std::vector<CSymTable *,std::allocator<CSymTable *> >::_Change_array
PUBLIC	?_Xlength@?$vector@PAVCSymTable@@V?$allocator@PAVCSymTable@@@std@@@std@@CAXXZ ; std::vector<CSymTable *,std::allocator<CSymTable *> >::_Xlength
PUBLIC	??_GCPoly@@UAEPAXI@Z				; CPoly::`scalar deleting destructor'
PUBLIC	?_random@@YANXZ					; _random
PUBLIC	??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$_Emplace_reallocate@PAVCSymTable@@@?$vector@PAVCSymTable@@V?$allocator@PAVCSymTable@@@std@@@std@@QAEPAPAVCSymTable@@QAPAV2@$$QAPAV2@@Z ; std::vector<CSymTable *,std::allocator<CSymTable *> >::_Emplace_reallocate<CSymTable *>
PUBLIC	??$_Emplace_reallocate@ABN@?$vector@NV?$allocator@N@std@@@std@@QAEPANQANABN@Z ; std::vector<double,std::allocator<double> >::_Emplace_reallocate<double const &>
PUBLIC	??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAH$$QAH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int>
PUBLIC	??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>
PUBLIC	??$_Traits_compare@U?$char_traits@D@std@@@std@@YAHQBDI0I@Z ; std::_Traits_compare<std::char_traits<char> >
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Copy_memmove@PAPAVCSymTable@@PAPAV1@@std@@YAPAPAVCSymTable@@PAPAV1@00@Z ; std::_Copy_memmove<CSymTable * *,CSymTable * *>
PUBLIC	??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z ; std::_Copy_backward_memmove<int *,int *>
PUBLIC	??$_Copy_memmove@PANPAN@std@@YAPANPAN00@Z	; std::_Copy_memmove<double *,double *>
PUBLIC	??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z	; std::_Copy_memmove<int *,int *>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_7CPoly@@6B@					; CPoly::`vftable'
PUBLIC	??_C@_03KLIPLJLL@min@				; `string'
PUBLIC	??_C@_03LJAEFNNE@max@				; `string'
PUBLIC	??_C@_06EBGNBFIA@number@			; `string'
PUBLIC	??_C@_07OMLILGHE@irandom@			; `string'
PUBLIC	??_C@_05CCJGGLIO@irand@				; `string'
PUBLIC	??_C@_07DFJIKENI@frandom@			; `string'
PUBLIC	??_C@_05NDMANJFL@frand@				; `string'
PUBLIC	??_C@_03LALBNOCG@cos@				; `string'
PUBLIC	??_C@_03BLEJJJBH@sin@				; `string'
PUBLIC	??_C@_03IIINPABG@tan@				; `string'
PUBLIC	??_C@_03PPPAEIOB@cot@				; `string'
PUBLIC	??_C@_03OPEPJGGD@csc@				; `string'
PUBLIC	??_C@_05KCHJPNOJ@cosec@				; `string'
PUBLIC	??_C@_03KHPNBODO@sec@				; `string'
PUBLIC	??_C@_02OAHAJOFD@pi@				; `string'
PUBLIC	??_C@_01KGKMHCOC@e@				; `string'
PUBLIC	??_C@_03MGHMBJCF@log@				; `string'
PUBLIC	??_C@_02LKANFCIA@ln@				; `string'
PUBLIC	??_C@_05HGHHAHAP@log10@				; `string'
PUBLIC	??_C@_03BCGAIFPO@abs@				; `string'
PUBLIC	??_C@_03FFONCNID@mod@				; `string'
PUBLIC	??_C@_05PBJFFIGL@floor@				; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CPoly@@6B@					; CPoly::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCPoly@@@8				; CPoly `RTTI Type Descriptor'
PUBLIC	??_R3CPoly@@8					; CPoly::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CPoly@@8					; CPoly::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CPoly@@8				; CPoly::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3f00000000000000
PUBLIC	__real@3fb999999999999a
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4005bf0a8b145769
PUBLIC	__real@400921fb54442d18
PUBLIC	__xmm@7fffffffffffffff7fffffffffffffff
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_isalpha:PROC
EXTRN	_isdigit:PROC
EXTRN	_rand:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	??0CSymTable@@QAE@HV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; CSymTable::CSymTable
EXTRN	??_ECPoly@@UAEPAXI@Z:PROC			; CPoly::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CIfmod:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__libm_sse2_cos_precise:PROC
EXTRN	__libm_sse2_log10_precise:PROC
EXTRN	__libm_sse2_log_precise:PROC
EXTRN	__libm_sse2_pow_precise:PROC
EXTRN	__libm_sse2_sin_precise:PROC
EXTRN	__libm_sse2_sqrt_precise:PROC
EXTRN	__libm_sse2_tan_precise:PROC
EXTRN	_floor:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@7fffffffffffffff7fffffffffffffff
CONST	SEGMENT
__xmm@7fffffffffffffff7fffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT __real@4005bf0a8b145769
CONST	SEGMENT
__real@4005bf0a8b145769 DQ 04005bf0a8b145769r	; 2.71828
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3fb999999999999a
CONST	SEGMENT
__real@3fb999999999999a DQ 03fb999999999999ar	; 0.1
CONST	ENDS
;	COMDAT __real@3f00000000000000
CONST	SEGMENT
__real@3f00000000000000 DQ 03f00000000000000r	; 3.05176e-05
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CPoly@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CPoly@@8 DD FLAT:??_R0?AVCPoly@@@8	; CPoly::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CPoly@@8
rdata$r	ENDS
;	COMDAT ??_R2CPoly@@8
rdata$r	SEGMENT
??_R2CPoly@@8 DD FLAT:??_R1A@?0A@EA@CPoly@@8		; CPoly::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CPoly@@8
rdata$r	SEGMENT
??_R3CPoly@@8 DD 00H					; CPoly::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CPoly@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCPoly@@@8
data$rs	SEGMENT
??_R0?AVCPoly@@@8 DD FLAT:??_7type_info@@6B@		; CPoly `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCPoly@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CPoly@@6B@
rdata$r	SEGMENT
??_R4CPoly@@6B@ DD 00H					; CPoly::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCPoly@@@8
	DD	FLAT:??_R3CPoly@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05PBJFFIGL@floor@
CONST	SEGMENT
??_C@_05PBJFFIGL@floor@ DB 'floor', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FFONCNID@mod@
CONST	SEGMENT
??_C@_03FFONCNID@mod@ DB 'mod', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BCGAIFPO@abs@
CONST	SEGMENT
??_C@_03BCGAIFPO@abs@ DB 'abs', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05HGHHAHAP@log10@
CONST	SEGMENT
??_C@_05HGHHAHAP@log10@ DB 'log10', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LKANFCIA@ln@
CONST	SEGMENT
??_C@_02LKANFCIA@ln@ DB 'ln', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MGHMBJCF@log@
CONST	SEGMENT
??_C@_03MGHMBJCF@log@ DB 'log', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KGKMHCOC@e@
CONST	SEGMENT
??_C@_01KGKMHCOC@e@ DB 'e', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02OAHAJOFD@pi@
CONST	SEGMENT
??_C@_02OAHAJOFD@pi@ DB 'pi', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KHPNBODO@sec@
CONST	SEGMENT
??_C@_03KHPNBODO@sec@ DB 'sec', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05KCHJPNOJ@cosec@
CONST	SEGMENT
??_C@_05KCHJPNOJ@cosec@ DB 'cosec', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OPEPJGGD@csc@
CONST	SEGMENT
??_C@_03OPEPJGGD@csc@ DB 'csc', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PPPAEIOB@cot@
CONST	SEGMENT
??_C@_03PPPAEIOB@cot@ DB 'cot', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IIINPABG@tan@
CONST	SEGMENT
??_C@_03IIINPABG@tan@ DB 'tan', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BLEJJJBH@sin@
CONST	SEGMENT
??_C@_03BLEJJJBH@sin@ DB 'sin', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LALBNOCG@cos@
CONST	SEGMENT
??_C@_03LALBNOCG@cos@ DB 'cos', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05NDMANJFL@frand@
CONST	SEGMENT
??_C@_05NDMANJFL@frand@ DB 'frand', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DFJIKENI@frandom@
CONST	SEGMENT
??_C@_07DFJIKENI@frandom@ DB 'frandom', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CCJGGLIO@irand@
CONST	SEGMENT
??_C@_05CCJGGLIO@irand@ DB 'irand', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07OMLILGHE@irandom@
CONST	SEGMENT
??_C@_07OMLILGHE@irandom@ DB 'irandom', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EBGNBFIA@number@
CONST	SEGMENT
??_C@_06EBGNBFIA@number@ DB 'number', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LJAEFNNE@max@
CONST	SEGMENT
??_C@_03LJAEFNNE@max@ DB 'max', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KLIPLJLL@min@
CONST	SEGMENT
??_C@_03KLIPLJLL@min@ DB 'min', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7CPoly@@6B@
CONST	SEGMENT
??_7CPoly@@6B@ DD FLAT:??_R4CPoly@@6B@			; CPoly::`vftable'
	DD	FLAT:??_ECPoly@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?lexan@CPoly@@IAEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?lexan@CPoly@@IAEHXZ$0
__ehfuncinfo$?lexan@CPoly@@IAEHXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?lexan@CPoly@@IAEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z$0
__ehfuncinfo$?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?init@CPoly@@IAEXXZ DD 019930522H
	DD	018H
	DD	FLAT:__unwindtable$?init@CPoly@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?init@CPoly@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CPoly@@IAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CPoly@@IAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CPoly@@IAEXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CPoly@@IAEXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CPoly@@IAEXXZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CPoly@@IAEXXZ$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CPoly@@IAEXXZ$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CPoly@@IAEXXZ$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CPoly@@IAEXXZ$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CPoly@@IAEXXZ$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CPoly@@IAEXXZ$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CPoly@@IAEXXZ$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CPoly@@IAEXXZ$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CPoly@@IAEXXZ$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CPoly@@IAEXXZ$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CPoly@@IAEXXZ$15
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CPoly@@IAEXXZ$16
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CPoly@@IAEXXZ$18
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CPoly@@IAEXXZ$20
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CPoly@@IAEXXZ$21
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CPoly@@IAEXXZ$22
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CPoly@@IAEXXZ$23
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CPoly@@IAEXXZ$24
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CPoly@@IAEXXZ$25
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Analyze@CPoly@@QAEHPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Analyze@CPoly@@QAEHPBD@Z$0
__ehfuncinfo$?Analyze@CPoly@@QAEHPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Analyze@CPoly@@QAEHPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CPoly@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0CPoly@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CPoly@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CPoly@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CPoly@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CPoly@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CPoly@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CPoly@@QAE@XZ$4
xdata$x	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z PROC		; std::_Copy_memmove<int *,int *>, COMDAT

; 4159 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4160 :     auto _FirstPtr              = _To_address(_First);
; 4161 :     auto _LastPtr               = _To_address(_Last);
; 4162 :     auto _DestPtr               = _To_address(_Dest);
; 4163 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4164 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4165 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4168 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4169 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 4170 :     } else {
; 4171 :         return _Dest + (_LastPtr - _FirstPtr);
; 4172 :     }
; 4173 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ENDP		; std::_Copy_memmove<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PANPAN@std@@YAPANPAN00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PANPAN@std@@YAPANPAN00@Z PROC		; std::_Copy_memmove<double *,double *>, COMDAT

; 4159 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4160 :     auto _FirstPtr              = _To_address(_First);
; 4161 :     auto _LastPtr               = _To_address(_Last);
; 4162 :     auto _DestPtr               = _To_address(_Dest);
; 4163 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4164 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4165 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4168 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4169 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 4170 :     } else {
; 4171 :         return _Dest + (_LastPtr - _FirstPtr);
; 4172 :     }
; 4173 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PANPAN@std@@YAPANPAN00@Z ENDP		; std::_Copy_memmove<double *,double *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z PROC	; std::_Copy_backward_memmove<int *,int *>, COMDAT

; 4354 : _CtgIt2 _Copy_backward_memmove(_CtgIt1 _First, _CtgIt1 _Last, _CtgIt2 _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4355 :     // implement copy_backward-like function as memmove
; 4356 :     auto _FirstPtr              = _To_address(_First);
; 4357 :     auto _LastPtr               = _To_address(_Last);
; 4358 :     auto _DestPtr               = _To_address(_Dest);
; 4359 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4360 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4361 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4362 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b c8		 sub	 ecx, eax

; 4363 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

  0000b	51		 push	 ecx
  0000c	50		 push	 eax
  0000d	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00010	2b c1		 sub	 eax, ecx
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4364 :     if constexpr (is_pointer_v<_CtgIt2>) {
; 4365 :         return static_cast<_CtgIt2>(_Result);
; 4366 :     } else {
; 4367 :         return _Dest - (_LastPtr - _FirstPtr);
; 4368 :     }
; 4369 : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z ENDP	; std::_Copy_backward_memmove<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCSymTable@@PAPAV1@@std@@YAPAPAVCSymTable@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCSymTable@@PAPAV1@@std@@YAPAPAVCSymTable@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CSymTable * *,CSymTable * *>, COMDAT

; 4159 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4160 :     auto _FirstPtr              = _To_address(_First);
; 4161 :     auto _LastPtr               = _To_address(_Last);
; 4162 :     auto _DestPtr               = _To_address(_Dest);
; 4163 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4164 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4165 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4168 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4169 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 4170 :     } else {
; 4171 :         return _Dest + (_LastPtr - _FirstPtr);
; 4172 :     }
; 4173 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PAPAVCSymTable@@PAPAV1@@std@@YAPAPAVCSymTable@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CSymTable * *,CSymTable * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 134  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 135  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 137  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 85   :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 138  :         _Throw_bad_array_new_length(); // add overflow
; 139  :     }
; 140  : 
; 141  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 85   :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 145  : 
; 146  : #ifdef _DEBUG
; 147  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 148  : #endif // _DEBUG
; 149  :     return _Ptr;
; 150  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$_Traits_compare@U?$char_traits@D@std@@@std@@YAHQBDI0I@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Left_size$ = 12					; size = 4
__Right$ = 16						; size = 4
__Right_size$ = 20					; size = 4
??$_Traits_compare@U?$char_traits@D@std@@@std@@YAHQBDI0I@Z PROC ; std::_Traits_compare<std::char_traits<char> >, COMDAT

; 588  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 392  :         return _CSTD memcmp(_First1, _First2, _Count);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 588  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {

  00006	53		 push	 ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00007	8b 5d 14	 mov	 ebx, DWORD PTR __Right_size$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 588  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {

  0000a	56		 push	 esi

; 392  :         return _CSTD memcmp(_First1, _First2, _Count);

  0000b	8b 75 10	 mov	 esi, DWORD PTR __Right$[ebp]

; 588  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {

  0000e	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0000f	8b 7d 0c	 mov	 edi, DWORD PTR __Left_size$[ebp]
  00012	3b df		 cmp	 ebx, edi
  00014	8b cf		 mov	 ecx, edi
  00016	0f 42 cb	 cmovb	 ecx, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 392  :         return _CSTD memcmp(_First1, _First2, _Count);

  00019	83 e9 04	 sub	 ecx, 4
  0001c	72 13		 jb	 SHORT $LN12@Traits_com
  0001e	66 90		 npad	 2
$LL13@Traits_com:
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	3b 06		 cmp	 eax, DWORD PTR [esi]
  00024	75 10		 jne	 SHORT $LN11@Traits_com
  00026	83 c2 04	 add	 edx, 4
  00029	83 c6 04	 add	 esi, 4
  0002c	83 e9 04	 sub	 ecx, 4
  0002f	73 ef		 jae	 SHORT $LL13@Traits_com
$LN12@Traits_com:
  00031	83 f9 fc	 cmp	 ecx, -4			; fffffffcH
  00034	74 34		 je	 SHORT $LN10@Traits_com
$LN11@Traits_com:
  00036	8a 02		 mov	 al, BYTE PTR [edx]
  00038	3a 06		 cmp	 al, BYTE PTR [esi]
  0003a	75 27		 jne	 SHORT $LN14@Traits_com
  0003c	83 f9 fd	 cmp	 ecx, -3			; fffffffdH
  0003f	74 29		 je	 SHORT $LN10@Traits_com
  00041	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  00044	3a 46 01	 cmp	 al, BYTE PTR [esi+1]
  00047	75 1a		 jne	 SHORT $LN14@Traits_com
  00049	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  0004c	74 1c		 je	 SHORT $LN10@Traits_com
  0004e	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  00051	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  00054	75 0d		 jne	 SHORT $LN14@Traits_com
  00056	83 f9 ff	 cmp	 ecx, -1
  00059	74 0f		 je	 SHORT $LN10@Traits_com
  0005b	8a 42 03	 mov	 al, BYTE PTR [edx+3]
  0005e	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  00061	74 07		 je	 SHORT $LN10@Traits_com
$LN14@Traits_com:
  00063	1b c0		 sbb	 eax, eax
  00065	83 c8 01	 or	 eax, 1
  00068	eb 02		 jmp	 SHORT $LN15@Traits_com
$LN10@Traits_com:
  0006a	33 c0		 xor	 eax, eax
$LN15@Traits_com:

; 589  :     // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) using _Traits
; 590  :     const int _Ans = _Traits::compare(_Left, _Right, (_STD min)(_Left_size, _Right_size));
; 591  : 
; 592  :     if (_Ans != 0) {

  0006c	85 c0		 test	 eax, eax
  0006e	75 10		 jne	 SHORT $LN4@Traits_com

; 593  :         return _Ans;
; 594  :     }
; 595  : 
; 596  :     if (_Left_size < _Right_size) {

  00070	3b df		 cmp	 ebx, edi
  00072	76 08		 jbe	 SHORT $LN16@Traits_com

; 601  :         return 1;
; 602  :     }
; 603  : 
; 604  :     return 0;
; 605  : }

  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	83 c8 ff	 or	 eax, -1
  00079	5b		 pop	 ebx
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
$LN16@Traits_com:

; 597  :         return -1;
; 598  :     }
; 599  : 
; 600  :     if (_Left_size > _Right_size) {

  0007c	1b c0		 sbb	 eax, eax
  0007e	f7 d8		 neg	 eax
$LN4@Traits_com:

; 601  :         return 1;
; 602  :     }
; 603  : 
; 604  :     return 0;
; 605  : }

  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
??$_Traits_compare@U?$char_traits@D@std@@@std@@YAHQBDI0I@Z ENDP ; std::_Traits_compare<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z
_TEXT	SEGMENT
__Newsize$1$ = -8					; size = 4
__Whereoff$1$ = -4					; size = 4
tv505 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z PROC ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>, COMDAT
; _this$ = ecx

; 765  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 766  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 767  :         _Alty& _Al        = _Getal();
; 768  :         auto& _My_data    = _Mypair._Myval2;
; 769  :         pointer& _Myfirst = _My_data._Myfirst;
; 770  :         pointer& _Mylast  = _My_data._Mylast;
; 771  : 
; 772  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 773  : 
; 774  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  00009	53		 push	 ebx
  0000a	8b d9		 mov	 ebx, ecx
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	8b 13		 mov	 edx, DWORD PTR [ebx]
  00010	2b c2		 sub	 eax, edx
  00012	c1 f8 02	 sar	 eax, 2
  00015	89 45 fc	 mov	 DWORD PTR __Whereoff$1$[ebp], eax

; 775  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00018	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0001b	2b c2		 sub	 eax, edx
  0001d	c1 f8 02	 sar	 eax, 2

; 776  : 
; 777  :         if (_Oldsize == max_size()) {

  00020	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00025	0f 84 d2 00 00
	00		 je	 $LN74@Emplace_re

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002b	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

  0002e	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00031	2b ca		 sub	 ecx, edx

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

  00033	89 7d f8	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00036	c1 f9 02	 sar	 ecx, 2

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00039	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0003e	8b d1		 mov	 edx, ecx
  00040	d1 ea		 shr	 edx, 1
  00042	2b c2		 sub	 eax, edx
  00044	3b c8		 cmp	 ecx, eax
  00046	76 17		 jbe	 SHORT $LN12@Emplace_re

; 1689 :             return _Max; // geometric growth would overflow

  00048	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0004d	be ff ff ff 3f	 mov	 esi, 1073741823		; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00058	83 c4 04	 add	 esp, 4
  0005b	8b f8		 mov	 edi, eax
  0005d	eb 44		 jmp	 SHORT $LN23@Emplace_re
$LN12@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0005f	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 64   :         if (_Count > _Max_possible) {

  00062	8b f7		 mov	 esi, edi
  00064	3b c7		 cmp	 eax, edi
  00066	0f 43 f0	 cmovae	 esi, eax
  00069	81 fe ff ff ff
	3f		 cmp	 esi, 1073741823		; 3fffffffH
  0006f	0f 87 8d 00 00
	00		 ja	 $LN75@Emplace_re

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  00075	8d 04 b5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*4]

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0007c	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00081	72 0d		 jb	 SHORT $LN24@Emplace_re

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00089	83 c4 04	 add	 esp, 4
  0008c	8b f8		 mov	 edi, eax
  0008e	eb 13		 jmp	 SHORT $LN23@Emplace_re
$LN24@Emplace_re:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  00090	85 c0		 test	 eax, eax
  00092	74 0d		 je	 SHORT $LN25@Emplace_re

; 85   :         return ::operator new(_Bytes);

  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0009a	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  0009d	8b f8		 mov	 edi, eax
  0009f	eb 02		 jmp	 SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000a1	33 ff		 xor	 edi, edi
$LN23@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 789  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000a3	8b 45 fc	 mov	 eax, DWORD PTR __Whereoff$1$[ebp]
  000a6	8d 0c 87	 lea	 ecx, DWORD PTR [edi+eax*4]
  000a9	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  000ac	89 4d fc	 mov	 DWORD PTR tv505[ebp], ecx
  000af	8b 00		 mov	 eax, DWORD PTR [eax]
  000b1	89 01		 mov	 DWORD PTR [ecx], eax

; 790  :         _Constructed_first = _Newvec + _Whereoff;
; 791  : 
; 792  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000b3	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000b6	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  000b9	8b 13		 mov	 edx, DWORD PTR [ebx]
  000bb	3b c1		 cmp	 eax, ecx
  000bd	75 04		 jne	 SHORT $LN4@Emplace_re
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000bf	8b c7		 mov	 eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 794  :         } else { // provide basic guarantee

  000c1	eb 17		 jmp	 SHORT $LN60@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000c3	57		 push	 edi
  000c4	50		 push	 eax
  000c5	52		 push	 edx
  000c6	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ; std::_Copy_memmove<int *,int *>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000cb	8b 45 fc	 mov	 eax, DWORD PTR tv505[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d1	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000d4	83 c0 04	 add	 eax, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000d7	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
$LN60@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000da	50		 push	 eax
  000db	51		 push	 ecx
  000dc	52		 push	 edx
  000dd	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ; std::_Copy_memmove<int *,int *>
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);
; 801  :         _Al.deallocate(_Newvec, _Newcapacity);
; 802  :         _RERAISE;
; 803  :         _CATCH_END
; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  000e5	8b cb		 mov	 ecx, ebx
  000e7	56		 push	 esi
  000e8	ff 75 f8	 push	 DWORD PTR __Newsize$1$[ebp]
  000eb	57		 push	 edi
  000ec	e8 00 00 00 00	 call	 ?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z ; std::vector<int,std::allocator<int> >::_Change_array

; 806  :         return _Newvec + _Whereoff;

  000f1	8b 45 fc	 mov	 eax, DWORD PTR tv505[ebp]
  000f4	5f		 pop	 edi
  000f5	5e		 pop	 esi
  000f6	5b		 pop	 ebx

; 807  :     }

  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 08 00	 ret	 8
$LN74@Emplace_re:

; 778  :             _Xlength();

  000fd	e8 00 00 00 00	 call	 ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
$LN75@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  00102	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN72@Emplace_re:
  00107	cc		 int	 3
??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAH$$QAH@Z
_TEXT	SEGMENT
__Newsize$1$ = -8					; size = 4
__Whereoff$1$ = -4					; size = 4
tv505 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAH$$QAH@Z PROC ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int>, COMDAT
; _this$ = ecx

; 765  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 766  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 767  :         _Alty& _Al        = _Getal();
; 768  :         auto& _My_data    = _Mypair._Myval2;
; 769  :         pointer& _Myfirst = _My_data._Myfirst;
; 770  :         pointer& _Mylast  = _My_data._Mylast;
; 771  : 
; 772  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 773  : 
; 774  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  00009	53		 push	 ebx
  0000a	8b d9		 mov	 ebx, ecx
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	8b 13		 mov	 edx, DWORD PTR [ebx]
  00010	2b c2		 sub	 eax, edx
  00012	c1 f8 02	 sar	 eax, 2
  00015	89 45 fc	 mov	 DWORD PTR __Whereoff$1$[ebp], eax

; 775  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00018	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0001b	2b c2		 sub	 eax, edx
  0001d	c1 f8 02	 sar	 eax, 2

; 776  : 
; 777  :         if (_Oldsize == max_size()) {

  00020	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00025	0f 84 d2 00 00
	00		 je	 $LN74@Emplace_re

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002b	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

  0002e	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00031	2b ca		 sub	 ecx, edx

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

  00033	89 7d f8	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00036	c1 f9 02	 sar	 ecx, 2

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00039	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0003e	8b d1		 mov	 edx, ecx
  00040	d1 ea		 shr	 edx, 1
  00042	2b c2		 sub	 eax, edx
  00044	3b c8		 cmp	 ecx, eax
  00046	76 17		 jbe	 SHORT $LN12@Emplace_re

; 1689 :             return _Max; // geometric growth would overflow

  00048	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0004d	be ff ff ff 3f	 mov	 esi, 1073741823		; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00058	83 c4 04	 add	 esp, 4
  0005b	8b f8		 mov	 edi, eax
  0005d	eb 44		 jmp	 SHORT $LN23@Emplace_re
$LN12@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0005f	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 64   :         if (_Count > _Max_possible) {

  00062	8b f7		 mov	 esi, edi
  00064	3b c7		 cmp	 eax, edi
  00066	0f 43 f0	 cmovae	 esi, eax
  00069	81 fe ff ff ff
	3f		 cmp	 esi, 1073741823		; 3fffffffH
  0006f	0f 87 8d 00 00
	00		 ja	 $LN75@Emplace_re

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  00075	8d 04 b5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*4]

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0007c	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00081	72 0d		 jb	 SHORT $LN24@Emplace_re

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00089	83 c4 04	 add	 esp, 4
  0008c	8b f8		 mov	 edi, eax
  0008e	eb 13		 jmp	 SHORT $LN23@Emplace_re
$LN24@Emplace_re:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  00090	85 c0		 test	 eax, eax
  00092	74 0d		 je	 SHORT $LN25@Emplace_re

; 85   :         return ::operator new(_Bytes);

  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0009a	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  0009d	8b f8		 mov	 edi, eax
  0009f	eb 02		 jmp	 SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000a1	33 ff		 xor	 edi, edi
$LN23@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 789  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000a3	8b 45 fc	 mov	 eax, DWORD PTR __Whereoff$1$[ebp]
  000a6	8d 0c 87	 lea	 ecx, DWORD PTR [edi+eax*4]
  000a9	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  000ac	89 4d fc	 mov	 DWORD PTR tv505[ebp], ecx
  000af	8b 00		 mov	 eax, DWORD PTR [eax]
  000b1	89 01		 mov	 DWORD PTR [ecx], eax

; 790  :         _Constructed_first = _Newvec + _Whereoff;
; 791  : 
; 792  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000b3	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000b6	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  000b9	8b 13		 mov	 edx, DWORD PTR [ebx]
  000bb	3b c1		 cmp	 eax, ecx
  000bd	75 04		 jne	 SHORT $LN4@Emplace_re
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000bf	8b c7		 mov	 eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 794  :         } else { // provide basic guarantee

  000c1	eb 17		 jmp	 SHORT $LN60@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000c3	57		 push	 edi
  000c4	50		 push	 eax
  000c5	52		 push	 edx
  000c6	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ; std::_Copy_memmove<int *,int *>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000cb	8b 45 fc	 mov	 eax, DWORD PTR tv505[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d1	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000d4	83 c0 04	 add	 eax, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000d7	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
$LN60@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000da	50		 push	 eax
  000db	51		 push	 ecx
  000dc	52		 push	 edx
  000dd	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ; std::_Copy_memmove<int *,int *>
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);
; 801  :         _Al.deallocate(_Newvec, _Newcapacity);
; 802  :         _RERAISE;
; 803  :         _CATCH_END
; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  000e5	8b cb		 mov	 ecx, ebx
  000e7	56		 push	 esi
  000e8	ff 75 f8	 push	 DWORD PTR __Newsize$1$[ebp]
  000eb	57		 push	 edi
  000ec	e8 00 00 00 00	 call	 ?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z ; std::vector<int,std::allocator<int> >::_Change_array

; 806  :         return _Newvec + _Whereoff;

  000f1	8b 45 fc	 mov	 eax, DWORD PTR tv505[ebp]
  000f4	5f		 pop	 edi
  000f5	5e		 pop	 esi
  000f6	5b		 pop	 ebx

; 807  :     }

  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 08 00	 ret	 8
$LN74@Emplace_re:

; 778  :             _Xlength();

  000fd	e8 00 00 00 00	 call	 ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
$LN75@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  00102	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN72@Emplace_re:
  00107	cc		 int	 3
??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAH$$QAH@Z ENDP ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABN@?$vector@NV?$allocator@N@std@@@std@@QAEPANQANABN@Z
_TEXT	SEGMENT
__Newsize$1$ = -8					; size = 4
tv673 = -4						; size = 4
__Whereoff$1$ = -4					; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABN@?$vector@NV?$allocator@N@std@@@std@@QAEPANQANABN@Z PROC ; std::vector<double,std::allocator<double> >::_Emplace_reallocate<double const &>, COMDAT
; _this$ = ecx

; 765  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 766  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 767  :         _Alty& _Al        = _Getal();
; 768  :         auto& _My_data    = _Mypair._Myval2;
; 769  :         pointer& _Myfirst = _My_data._Myfirst;
; 770  :         pointer& _Mylast  = _My_data._Mylast;
; 771  : 
; 772  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 773  : 
; 774  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00010	2b c1		 sub	 eax, ecx
  00012	c1 f8 03	 sar	 eax, 3
  00015	89 45 fc	 mov	 DWORD PTR __Whereoff$1$[ebp], eax

; 775  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00018	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001b	2b c1		 sub	 eax, ecx
  0001d	c1 f8 03	 sar	 eax, 3

; 776  : 
; 777  :         if (_Oldsize == max_size()) {

  00020	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  00025	0f 84 0a 01 00
	00		 je	 $LN104@Emplace_re

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

  0002e	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00031	2b d1		 sub	 edx, ecx

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

  00033	89 7d f8	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00036	c1 fa 03	 sar	 edx, 3

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00039	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH
  0003e	8b ca		 mov	 ecx, edx
  00040	d1 e9		 shr	 ecx, 1
  00042	2b c1		 sub	 eax, ecx
  00044	3b d0		 cmp	 edx, eax
  00046	76 12		 jbe	 SHORT $LN12@Emplace_re

; 1689 :             return _Max; // geometric growth would overflow

  00048	bb f8 ff ff ff	 mov	 ebx, -8			; fffffff8H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0004d	53		 push	 ebx
  0004e	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00053	83 c4 04	 add	 esp, 4
  00056	8b f8		 mov	 edi, eax
  00058	eb 41		 jmp	 SHORT $LN23@Emplace_re
$LN12@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0005a	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 64   :         if (_Count > _Max_possible) {

  0005d	8b df		 mov	 ebx, edi
  0005f	3b c7		 cmp	 eax, edi
  00061	0f 43 d8	 cmovae	 ebx, eax
  00064	81 fb ff ff ff
	1f		 cmp	 ebx, 536870911		; 1fffffffH
  0006a	0f 87 ca 00 00
	00		 ja	 $LN105@Emplace_re

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  00070	c1 e3 03	 shl	 ebx, 3

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00073	81 fb 00 10 00
	00		 cmp	 ebx, 4096		; 00001000H
  00079	72 0d		 jb	 SHORT $LN24@Emplace_re

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0007b	53		 push	 ebx
  0007c	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00081	83 c4 04	 add	 esp, 4
  00084	8b f8		 mov	 edi, eax
  00086	eb 13		 jmp	 SHORT $LN23@Emplace_re
$LN24@Emplace_re:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  00088	85 db		 test	 ebx, ebx
  0008a	74 0d		 je	 SHORT $LN25@Emplace_re

; 85   :         return ::operator new(_Bytes);

  0008c	53		 push	 ebx
  0008d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00092	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  00095	8b f8		 mov	 edi, eax
  00097	eb 02		 jmp	 SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  00099	33 ff		 xor	 edi, edi
$LN23@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 789  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0009b	8b 45 fc	 mov	 eax, DWORD PTR __Whereoff$1$[ebp]
  0009e	8d 0c c7	 lea	 ecx, DWORD PTR [edi+eax*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

  000a1	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 789  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000a4	89 4d fc	 mov	 DWORD PTR tv673[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

  000a7	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 792  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000ab	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

  000ae	f2 0f 11 01	 movsd	 QWORD PTR [ecx], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 792  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000b2	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000b5	8b 16		 mov	 edx, DWORD PTR [esi]
  000b7	3b c1		 cmp	 eax, ecx
  000b9	75 04		 jne	 SHORT $LN4@Emplace_re
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000bb	8b c7		 mov	 eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 794  :         } else { // provide basic guarantee

  000bd	eb 17		 jmp	 SHORT $LN66@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000bf	57		 push	 edi
  000c0	50		 push	 eax
  000c1	52		 push	 edx
  000c2	e8 00 00 00 00	 call	 ??$_Copy_memmove@PANPAN@std@@YAPANPAN00@Z ; std::_Copy_memmove<double *,double *>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000c7	8b 45 fc	 mov	 eax, DWORD PTR tv673[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000ca	83 c4 0c	 add	 esp, 12			; 0000000cH
  000cd	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000d0	83 c0 08	 add	 eax, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000d3	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
$LN66@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000d6	50		 push	 eax
  000d7	51		 push	 ecx
  000d8	52		 push	 edx
  000d9	e8 00 00 00 00	 call	 ??$_Copy_memmove@PANPAN@std@@YAPANPAN00@Z ; std::_Copy_memmove<double *,double *>

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

  000de	8b 06		 mov	 eax, DWORD PTR [esi]

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000e0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

  000e3	85 c0		 test	 eax, eax
  000e5	74 2c		 je	 SHORT $LN86@Emplace_re

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000e7	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000ea	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000ec	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000ef	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000f5	72 12		 jb	 SHORT $LN96@Emplace_re

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f7	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000fa	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000fd	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000ff	83 c0 fc	 add	 eax, -4			; fffffffcH
  00102	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00105	77 29		 ja	 SHORT $LN93@Emplace_re

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00107	8b c2		 mov	 eax, edx
$LN96@Emplace_re:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00109	51		 push	 ecx
  0010a	50		 push	 eax
  0010b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00110	83 c4 08	 add	 esp, 8
$LN86@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1751 :         _Mylast  = _Newvec + _Newsize;

  00113	8b 45 f8	 mov	 eax, DWORD PTR __Newsize$1$[ebp]
  00116	89 3e		 mov	 DWORD PTR [esi], edi
  00118	8d 0c c7	 lea	 ecx, DWORD PTR [edi+eax*8]

; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);
; 801  :         _Al.deallocate(_Newvec, _Newcapacity);
; 802  :         _RERAISE;
; 803  :         _CATCH_END
; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 806  :         return _Newvec + _Whereoff;

  0011b	8b 45 fc	 mov	 eax, DWORD PTR tv673[ebp]

; 1751 :         _Mylast  = _Newvec + _Newsize;

  0011e	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 1752 :         _Myend   = _Newvec + _Newcapacity;

  00121	8d 0c 3b	 lea	 ecx, DWORD PTR [ebx+edi]

; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);
; 801  :         _Al.deallocate(_Newvec, _Newcapacity);
; 802  :         _RERAISE;
; 803  :         _CATCH_END
; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 806  :         return _Newvec + _Whereoff;

  00124	5f		 pop	 edi

; 1752 :         _Myend   = _Newvec + _Newcapacity;

  00125	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);
; 801  :         _Al.deallocate(_Newvec, _Newcapacity);
; 802  :         _RERAISE;
; 803  :         _CATCH_END
; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 806  :         return _Newvec + _Whereoff;

  00128	5e		 pop	 esi
  00129	5b		 pop	 ebx

; 807  :     }

  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c2 08 00	 ret	 8
$LN93@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00130	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN104@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 778  :             _Xlength();

  00135	e8 00 00 00 00	 call	 ?_Xlength@?$vector@NV?$allocator@N@std@@@std@@CAXXZ ; std::vector<double,std::allocator<double> >::_Xlength
$LN105@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  0013a	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN102@Emplace_re:
  0013f	cc		 int	 3
??$_Emplace_reallocate@ABN@?$vector@NV?$allocator@N@std@@@std@@QAEPANQANABN@Z ENDP ; std::vector<double,std::allocator<double> >::_Emplace_reallocate<double const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@PAVCSymTable@@@?$vector@PAVCSymTable@@V?$allocator@PAVCSymTable@@@std@@@std@@QAEPAPAVCSymTable@@QAPAV2@$$QAPAV2@@Z
_TEXT	SEGMENT
__Newsize$1$ = -8					; size = 4
__Whereoff$1$ = -4					; size = 4
tv505 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@PAVCSymTable@@@?$vector@PAVCSymTable@@V?$allocator@PAVCSymTable@@@std@@@std@@QAEPAPAVCSymTable@@QAPAV2@$$QAPAV2@@Z PROC ; std::vector<CSymTable *,std::allocator<CSymTable *> >::_Emplace_reallocate<CSymTable *>, COMDAT
; _this$ = ecx

; 765  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 766  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 767  :         _Alty& _Al        = _Getal();
; 768  :         auto& _My_data    = _Mypair._Myval2;
; 769  :         pointer& _Myfirst = _My_data._Myfirst;
; 770  :         pointer& _Mylast  = _My_data._Mylast;
; 771  : 
; 772  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 773  : 
; 774  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  00009	53		 push	 ebx
  0000a	8b d9		 mov	 ebx, ecx
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	8b 13		 mov	 edx, DWORD PTR [ebx]
  00010	2b c2		 sub	 eax, edx
  00012	c1 f8 02	 sar	 eax, 2
  00015	89 45 fc	 mov	 DWORD PTR __Whereoff$1$[ebp], eax

; 775  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00018	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0001b	2b c2		 sub	 eax, edx
  0001d	c1 f8 02	 sar	 eax, 2

; 776  : 
; 777  :         if (_Oldsize == max_size()) {

  00020	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00025	0f 84 d2 00 00
	00		 je	 $LN74@Emplace_re

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002b	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

  0002e	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00031	2b ca		 sub	 ecx, edx

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

  00033	89 7d f8	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00036	c1 f9 02	 sar	 ecx, 2

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00039	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0003e	8b d1		 mov	 edx, ecx
  00040	d1 ea		 shr	 edx, 1
  00042	2b c2		 sub	 eax, edx
  00044	3b c8		 cmp	 ecx, eax
  00046	76 17		 jbe	 SHORT $LN12@Emplace_re

; 1689 :             return _Max; // geometric growth would overflow

  00048	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0004d	be ff ff ff 3f	 mov	 esi, 1073741823		; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00058	83 c4 04	 add	 esp, 4
  0005b	8b f8		 mov	 edi, eax
  0005d	eb 44		 jmp	 SHORT $LN23@Emplace_re
$LN12@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0005f	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 64   :         if (_Count > _Max_possible) {

  00062	8b f7		 mov	 esi, edi
  00064	3b c7		 cmp	 eax, edi
  00066	0f 43 f0	 cmovae	 esi, eax
  00069	81 fe ff ff ff
	3f		 cmp	 esi, 1073741823		; 3fffffffH
  0006f	0f 87 8d 00 00
	00		 ja	 $LN75@Emplace_re

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  00075	8d 04 b5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*4]

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0007c	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00081	72 0d		 jb	 SHORT $LN24@Emplace_re

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00089	83 c4 04	 add	 esp, 4
  0008c	8b f8		 mov	 edi, eax
  0008e	eb 13		 jmp	 SHORT $LN23@Emplace_re
$LN24@Emplace_re:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  00090	85 c0		 test	 eax, eax
  00092	74 0d		 je	 SHORT $LN25@Emplace_re

; 85   :         return ::operator new(_Bytes);

  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0009a	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  0009d	8b f8		 mov	 edi, eax
  0009f	eb 02		 jmp	 SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000a1	33 ff		 xor	 edi, edi
$LN23@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 789  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000a3	8b 45 fc	 mov	 eax, DWORD PTR __Whereoff$1$[ebp]
  000a6	8d 0c 87	 lea	 ecx, DWORD PTR [edi+eax*4]
  000a9	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  000ac	89 4d fc	 mov	 DWORD PTR tv505[ebp], ecx
  000af	8b 00		 mov	 eax, DWORD PTR [eax]
  000b1	89 01		 mov	 DWORD PTR [ecx], eax

; 790  :         _Constructed_first = _Newvec + _Whereoff;
; 791  : 
; 792  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000b3	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000b6	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  000b9	8b 13		 mov	 edx, DWORD PTR [ebx]
  000bb	3b c1		 cmp	 eax, ecx
  000bd	75 04		 jne	 SHORT $LN4@Emplace_re
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000bf	8b c7		 mov	 eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 794  :         } else { // provide basic guarantee

  000c1	eb 17		 jmp	 SHORT $LN60@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000c3	57		 push	 edi
  000c4	50		 push	 eax
  000c5	52		 push	 edx
  000c6	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCSymTable@@PAPAV1@@std@@YAPAPAVCSymTable@@PAPAV1@00@Z ; std::_Copy_memmove<CSymTable * *,CSymTable * *>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000cb	8b 45 fc	 mov	 eax, DWORD PTR tv505[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d1	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000d4	83 c0 04	 add	 eax, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000d7	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
$LN60@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000da	50		 push	 eax
  000db	51		 push	 ecx
  000dc	52		 push	 edx
  000dd	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCSymTable@@PAPAV1@@std@@YAPAPAVCSymTable@@PAPAV1@00@Z ; std::_Copy_memmove<CSymTable * *,CSymTable * *>
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);
; 801  :         _Al.deallocate(_Newvec, _Newcapacity);
; 802  :         _RERAISE;
; 803  :         _CATCH_END
; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  000e5	8b cb		 mov	 ecx, ebx
  000e7	56		 push	 esi
  000e8	ff 75 f8	 push	 DWORD PTR __Newsize$1$[ebp]
  000eb	57		 push	 edi
  000ec	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCSymTable@@V?$allocator@PAVCSymTable@@@std@@@std@@AAEXQAPAVCSymTable@@II@Z ; std::vector<CSymTable *,std::allocator<CSymTable *> >::_Change_array

; 806  :         return _Newvec + _Whereoff;

  000f1	8b 45 fc	 mov	 eax, DWORD PTR tv505[ebp]
  000f4	5f		 pop	 edi
  000f5	5e		 pop	 esi
  000f6	5b		 pop	 ebx

; 807  :     }

  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 08 00	 ret	 8
$LN74@Emplace_re:

; 778  :             _Xlength();

  000fd	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCSymTable@@V?$allocator@PAVCSymTable@@@std@@@std@@CAXXZ ; std::vector<CSymTable *,std::allocator<CSymTable *> >::_Xlength
$LN75@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  00102	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN72@Emplace_re:
  00107	cc		 int	 3
??$_Emplace_reallocate@PAVCSymTable@@@?$vector@PAVCSymTable@@V?$allocator@PAVCSymTable@@@std@@@std@@QAEPAPAVCSymTable@@QAPAV2@$$QAPAV2@@Z ENDP ; std::vector<CSymTable *,std::allocator<CSymTable *> >::_Emplace_reallocate<CSymTable *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::operator<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4842 :     const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2305 :         const value_type* _Result = _Bx._Buf;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b d0		 mov	 edx, eax

; 2319 :         return _BUF_SIZE <= _Myres;

  00008	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 2306 :         if (_Large_string_engaged()) {

  0000c	72 02		 jb	 SHORT $LN6@operator

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  0000e	8b 10		 mov	 edx, DWORD PTR [eax]
$LN6@operator:

; 2305 :         const value_type* _Result = _Bx._Buf;

  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00013	56		 push	 esi
  00014	8b f1		 mov	 esi, ecx

; 2319 :         return _BUF_SIZE <= _Myres;

  00016	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 2306 :         if (_Large_string_engaged()) {

  0001a	72 02		 jb	 SHORT $LN11@operator

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  0001c	8b 31		 mov	 esi, DWORD PTR [ecx]
$LN11@operator:

; 4414 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  0001e	ff 70 10	 push	 DWORD PTR [eax+16]
  00021	52		 push	 edx
  00022	ff 71 10	 push	 DWORD PTR [ecx+16]
  00025	56		 push	 esi
  00026	e8 00 00 00 00	 call	 ??$_Traits_compare@U?$char_traits@D@std@@@std@@YAHQBDI0I@Z ; std::_Traits_compare<std::char_traits<char> >
  0002b	83 c4 10	 add	 esp, 16			; 00000010H

; 4843 :     return _Left.compare(_Right) < 0;

  0002e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00031	5e		 pop	 esi

; 4844 : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
;	COMDAT ?_random@@YANXZ
_TEXT	SEGMENT
tv68 = -8						; size = 8
?_random@@YANXZ PROC					; _random, COMDAT

; 13   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 14   :     return rand() / (RAND_MAX + 1.0);

  00006	e8 00 00 00 00	 call	 _rand
  0000b	66 0f 6e c0	 movd	 xmm0, eax
  0000f	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00013	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3f00000000000000
  0001b	f2 0f 11 45 f8	 movsd	 QWORD PTR tv68[ebp], xmm0
  00020	dd 45 f8	 fld	 QWORD PTR tv68[ebp]

; 15   : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?_random@@YANXZ ENDP					; _random
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCPoly@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCPoly@@UAEPAXI@Z PROC				; CPoly::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CPoly@@UAE@XZ	; CPoly::~CPoly
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN4@scalar
  00011	68 80 00 00 00	 push	 128			; 00000080H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GCPoly@@UAEPAXI@Z ENDP				; CPoly::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCSymTable@@V?$allocator@PAVCSymTable@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCSymTable@@V?$allocator@PAVCSymTable@@@std@@@std@@CAXXZ PROC ; std::vector<CSymTable *,std::allocator<CSymTable *> >::_Xlength, COMDAT

; 1774 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@PAVCSymTable@@V?$allocator@PAVCSymTable@@@std@@@std@@CAXXZ ENDP ; std::vector<CSymTable *,std::allocator<CSymTable *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCSymTable@@V?$allocator@PAVCSymTable@@@std@@@std@@AAEXQAPAVCSymTable@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCSymTable@@V?$allocator@PAVCSymTable@@@std@@@std@@AAEXQAPAVCSymTable@@II@Z PROC ; std::vector<CSymTable *,std::allocator<CSymTable *> >::_Change_array, COMDAT
; _this$ = ecx

; 1736 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1737 :         // orphan all iterators, discard old array, acquire new array
; 1738 :         auto& _My_data    = _Mypair._Myval2;
; 1739 :         pointer& _Myfirst = _My_data._Myfirst;
; 1740 :         pointer& _Mylast  = _My_data._Mylast;
; 1741 :         pointer& _Myend   = _My_data._Myend;
; 1742 : 
; 1743 :         _My_data._Orphan_all();
; 1744 : 
; 1745 :         if (_Myfirst) { // destroy and deallocate old array

  00006	8b 06		 mov	 eax, DWORD PTR [esi]
  00008	85 c0		 test	 eax, eax
  0000a	74 2c		 je	 SHORT $LN8@Change_arr

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0000c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000f	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00014	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001a	72 12		 jb	 SHORT $LN18@Change_arr

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001c	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001f	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00022	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00024	83 c0 fc	 add	 eax, -4			; fffffffcH
  00027	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002a	77 28		 ja	 SHORT $LN15@Change_arr

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002c	8b c2		 mov	 eax, edx
$LN18@Change_arr:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0002e	51		 push	 ecx
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00035	83 c4 08	 add	 esp, 8
$LN8@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         _Myfirst = _Newvec;

  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]

; 1751 :         _Mylast  = _Newvec + _Newsize;

  0003b	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0003e	89 0e		 mov	 DWORD PTR [esi], ecx
  00040	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00043	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1752 :         _Myend   = _Newvec + _Newcapacity;

  00046	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00049	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0004c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004f	5e		 pop	 esi

; 1753 :     }

  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
$LN15@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00054	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@Change_arr:
  00059	cc		 int	 3
?_Change_array@?$vector@PAVCSymTable@@V?$allocator@PAVCSymTable@@@std@@@std@@AAEXQAPAVCSymTable@@II@Z ENDP ; std::vector<CSymTable *,std::allocator<CSymTable *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Reallocate_exactly@?$vector@PAVCSymTable@@V?$allocator@PAVCSymTable@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Size$1$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?_Reallocate_exactly@?$vector@PAVCSymTable@@V?$allocator@PAVCSymTable@@@std@@@std@@AAEXI@Z PROC ; std::vector<CSymTable *,std::allocator<CSymTable *> >::_Reallocate_exactly, COMDAT
; _this$ = ecx

; 1299 :     _CONSTEXPR20_CONTAINER void _Reallocate_exactly(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 64   :         if (_Count > _Max_possible) {

  00005	8b 5d 08	 mov	 ebx, DWORD PTR __Newcapacity$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1299 :     _CONSTEXPR20_CONTAINER void _Reallocate_exactly(const size_type _Newcapacity) {

  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	57		 push	 edi

; 1300 :         // set capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1301 :         auto& _My_data    = _Mypair._Myval2;
; 1302 :         pointer& _Myfirst = _My_data._Myfirst;
; 1303 :         pointer& _Mylast  = _My_data._Mylast;
; 1304 : 
; 1305 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

  0000c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000f	2b 06		 sub	 eax, DWORD PTR [esi]
  00011	c1 f8 02	 sar	 eax, 2
  00014	89 45 fc	 mov	 DWORD PTR __Size$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 64   :         if (_Count > _Max_possible) {

  00017	81 fb ff ff ff
	3f		 cmp	 ebx, 1073741823		; 3fffffffH
  0001d	0f 87 8a 00 00
	00		 ja	 $LN59@Reallocate

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  00023	c1 e3 02	 shl	 ebx, 2

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00026	81 fb 00 10 00
	00		 cmp	 ebx, 4096		; 00001000H
  0002c	72 0d		 jb	 SHORT $LN15@Reallocate

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0002e	53		 push	 ebx
  0002f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00034	83 c4 04	 add	 esp, 4
  00037	8b f8		 mov	 edi, eax
  00039	eb 13		 jmp	 SHORT $LN14@Reallocate
$LN15@Reallocate:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  0003b	85 db		 test	 ebx, ebx
  0003d	74 0d		 je	 SHORT $LN16@Reallocate

; 85   :         return ::operator new(_Bytes);

  0003f	53		 push	 ebx
  00040	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00045	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  00048	8b f8		 mov	 edi, eax
  0004a	eb 02		 jmp	 SHORT $LN14@Reallocate
$LN16@Reallocate:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  0004c	33 ff		 xor	 edi, edi
$LN14@Reallocate:

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  0004e	57		 push	 edi
  0004f	ff 76 04	 push	 DWORD PTR [esi+4]
  00052	ff 36		 push	 DWORD PTR [esi]
  00054	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCSymTable@@PAPAV1@@std@@YAPAPAVCSymTable@@PAPAV1@00@Z ; std::_Copy_memmove<CSymTable * *,CSymTable * *>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

  00059	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

  0005e	85 c0		 test	 eax, eax
  00060	74 2c		 je	 SHORT $LN43@Reallocate

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00062	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00065	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00067	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0006a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00070	72 12		 jb	 SHORT $LN53@Reallocate

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00072	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00075	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00078	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0007a	83 c0 fc	 add	 eax, -4			; fffffffcH
  0007d	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00080	77 26		 ja	 SHORT $LN50@Reallocate

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00082	8b c2		 mov	 eax, edx
$LN53@Reallocate:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00084	51		 push	 ecx
  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0008b	83 c4 08	 add	 esp, 8
$LN43@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1751 :         _Mylast  = _Newvec + _Newsize;

  0008e	8b 45 fc	 mov	 eax, DWORD PTR __Size$1$[ebp]
  00091	89 3e		 mov	 DWORD PTR [esi], edi
  00093	8d 04 87	 lea	 eax, DWORD PTR [edi+eax*4]
  00096	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1752 :         _Myend   = _Newvec + _Newcapacity;

  00099	8d 04 3b	 lea	 eax, DWORD PTR [ebx+edi]
  0009c	5f		 pop	 edi
  0009d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000a0	5e		 pop	 esi
  000a1	5b		 pop	 ebx

; 1317 :     }

  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 04 00	 ret	 4
$LN50@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000a8	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN59@Reallocate:

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  000ad	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN57@Reallocate:
  000b2	cc		 int	 3
?_Reallocate_exactly@?$vector@PAVCSymTable@@V?$allocator@PAVCSymTable@@@std@@@std@@AAEXI@Z ENDP ; std::vector<CSymTable *,std::allocator<CSymTable *> >::_Reallocate_exactly
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAVCSymTable@@V?$allocator@PAVCSymTable@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCSymTable@@V?$allocator@PAVCSymTable@@@std@@@std@@QAE@XZ PROC ; std::vector<CSymTable *,std::allocator<CSymTable *> >::~vector<CSymTable *,std::allocator<CSymTable *> >, COMDAT
; _this$ = ecx

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 40		 je	 SHORT $LN4@vector

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000c	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00011	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN20@vector

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00019	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001c	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 22		 ja	 SHORT $LN17@vector

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00029	8b c2		 mov	 eax, edx
$LN20@vector:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0002b	51		 push	 ecx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00038	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  0003b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1769 :             _Myend   = nullptr;

  00042	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:
  00049	5e		 pop	 esi

; 717  :     }

  0004a	c3		 ret	 0
$LN17@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@vector:
  00050	cc		 int	 3
??1?$vector@PAVCSymTable@@V?$allocator@PAVCSymTable@@@std@@@std@@QAE@XZ ENDP ; std::vector<CSymTable *,std::allocator<CSymTable *> >::~vector<CSymTable *,std::allocator<CSymTable *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@NV?$allocator@N@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@NV?$allocator@N@std@@@std@@CAXXZ PROC ; std::vector<double,std::allocator<double> >::_Xlength, COMDAT

; 1774 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@NV?$allocator@N@std@@@std@@CAXXZ ENDP ; std::vector<double,std::allocator<double> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ PROC	; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >, COMDAT
; _this$ = ecx

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 40		 je	 SHORT $LN4@vector

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000c	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00011	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN20@vector

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00019	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001c	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 22		 ja	 SHORT $LN17@vector

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00029	8b c2		 mov	 eax, edx
$LN20@vector:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0002b	51		 push	 ecx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00038	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  0003b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1769 :             _Myend   = nullptr;

  00042	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:
  00049	5e		 pop	 esi

; 717  :     }

  0004a	c3		 ret	 0
$LN17@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@vector:
  00050	cc		 int	 3
??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ENDP	; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ PROC ; std::vector<int,std::allocator<int> >::_Xlength, COMDAT

; 1774 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ENDP ; std::vector<int,std::allocator<int> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z PROC ; std::vector<int,std::allocator<int> >::_Change_array, COMDAT
; _this$ = ecx

; 1736 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1737 :         // orphan all iterators, discard old array, acquire new array
; 1738 :         auto& _My_data    = _Mypair._Myval2;
; 1739 :         pointer& _Myfirst = _My_data._Myfirst;
; 1740 :         pointer& _Mylast  = _My_data._Mylast;
; 1741 :         pointer& _Myend   = _My_data._Myend;
; 1742 : 
; 1743 :         _My_data._Orphan_all();
; 1744 : 
; 1745 :         if (_Myfirst) { // destroy and deallocate old array

  00006	8b 06		 mov	 eax, DWORD PTR [esi]
  00008	85 c0		 test	 eax, eax
  0000a	74 2c		 je	 SHORT $LN8@Change_arr

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0000c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000f	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00014	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001a	72 12		 jb	 SHORT $LN18@Change_arr

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001c	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001f	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00022	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00024	83 c0 fc	 add	 eax, -4			; fffffffcH
  00027	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002a	77 28		 ja	 SHORT $LN15@Change_arr

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002c	8b c2		 mov	 eax, edx
$LN18@Change_arr:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0002e	51		 push	 ecx
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00035	83 c4 08	 add	 esp, 8
$LN8@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         _Myfirst = _Newvec;

  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]

; 1751 :         _Mylast  = _Newvec + _Newsize;

  0003b	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0003e	89 0e		 mov	 DWORD PTR [esi], ecx
  00040	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00043	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1752 :         _Myend   = _Newvec + _Newcapacity;

  00046	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00049	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0004c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004f	5e		 pop	 esi

; 1753 :     }

  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
$LN15@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00054	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@Change_arr:
  00059	cc		 int	 3
?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z ENDP ; std::vector<int,std::allocator<int> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEX$$QAH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEX$$QAH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 759  :     _CONSTEXPR20_CONTAINER void push_back(_Ty&& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 743  :         if (_Mylast != _My_data._Myend) {

  00003	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00006	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00009	74 0f		 je	 SHORT $LN4@push_back

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0000b	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000e	8b 00		 mov	 eax, DWORD PTR [eax]
  00010	89 02		 mov	 DWORD PTR [edx], eax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

  00012	83 41 04 04	 add	 DWORD PTR [ecx+4], 4

; 760  :         // insert by moving into element at end, provide strong guarantee
; 761  :         emplace_back(_STD move(_Val));
; 762  :     }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN4@push_back:

; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0001a	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAH$$QAH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int>

; 760  :         // insert by moving into element at end, provide strong guarantee
; 761  :         emplace_back(_STD move(_Val));
; 762  :     }

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEX$$QAH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 755  :     _CONSTEXPR20_CONTAINER void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 743  :         if (_Mylast != _My_data._Myend) {

  00003	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00006	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00009	74 0f		 je	 SHORT $LN4@push_back

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0000b	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000e	8b 00		 mov	 eax, DWORD PTR [eax]
  00010	89 02		 mov	 DWORD PTR [edx], eax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

  00012	83 41 04 04	 add	 DWORD PTR [ecx+4], 4

; 756  :         emplace_back(_Val);
; 757  :     }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN4@push_back:

; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0001a	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>

; 756  :         emplace_back(_Val);
; 757  :     }

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 40		 je	 SHORT $LN4@vector

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000c	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00011	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN20@vector

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00019	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001c	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 22		 ja	 SHORT $LN17@vector

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00029	8b c2		 mov	 eax, edx
$LN20@vector:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0002b	51		 push	 ecx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00038	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  0003b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1769 :             _Myend   = nullptr;

  00042	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:
  00049	5e		 pop	 esi

; 717  :     }

  0004a	c3		 ret	 0
$LN17@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@vector:
  00050	cc		 int	 3
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
;	COMDAT ?expr@CPoly@@IAEXXZ
_TEXT	SEGMENT
?expr@CPoly@@IAEXXZ PROC				; CPoly::expr, COMDAT
; _this$ = ecx

; 279  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 280  :     int t;
; 281  : 
; 282  :     switch (iLookAhead)

  00003	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00006	83 e8 2b	 sub	 eax, 43			; 0000002bH
  00009	74 05		 je	 SHORT $LN8@expr
  0000b	83 e8 02	 sub	 eax, 2
  0000e	75 19		 jne	 SHORT $LN2@expr
$LN8@expr:

; 283  :     {
; 284  : 	case '+':
; 285  : 	case '-':
; 286  : 	    uiLookPos--;

  00010	ff 4e 24	 dec	 DWORD PTR [esi+36]
  00013	0f 57 c0	 xorps	 xmm0, xmm0

; 287  : 	    iLookAhead = POLY_NUM;

  00016	c7 46 18 09 00
	00 00		 mov	 DWORD PTR [esi+24], 9

; 288  : 	    iNumToken = iToken = 0;

  0001d	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00024	f2 0f 11 46 10	 movsd	 QWORD PTR [esi+16], xmm0
$LN2@expr:

; 289  : 
; 290  :     }
; 291  : 
; 292  :     term();

  00029	e8 00 00 00 00	 call	 ?term@CPoly@@IAEXXZ	; CPoly::term

; 293  : 
; 294  :     while (!ErrorOccur)

  0002e	80 7e 20 00	 cmp	 BYTE PTR [esi+32], 0
  00032	75 3a		 jne	 SHORT $LN5@expr
  00034	57		 push	 edi
$LL4@expr:

; 295  :     {
; 296  : 	switch (iLookAhead)

  00035	8b 7e 18	 mov	 edi, DWORD PTR [esi+24]
  00038	8d 47 f5	 lea	 eax, DWORD PTR [edi-11]
  0003b	83 f8 22	 cmp	 eax, 34			; 00000022H
  0003e	77 30		 ja	 SHORT $LN15@expr
  00040	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN21@expr[eax]
  00047	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN22@expr[eax*4]
$LN10@expr:

; 297  : 	{
; 298  : 	    case '+':
; 299  : 	    case '-':
; 300  : 		t=iLookAhead;
; 301  : 		match(t);

  0004e	57		 push	 edi
  0004f	8b ce		 mov	 ecx, esi
  00051	e8 00 00 00 00	 call	 ?match@CPoly@@IAEXH@Z	; CPoly::match

; 302  : 		term();

  00056	8b ce		 mov	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?term@CPoly@@IAEXXZ	; CPoly::term

; 303  : 		emit(t,POLY_NONE);

  0005d	6a 00		 push	 0
  0005f	57		 push	 edi
  00060	8b ce		 mov	 ecx, esi
  00062	e8 00 00 00 00	 call	 ?emit@CPoly@@IAEXHH@Z	; CPoly::emit
  00067	80 7e 20 00	 cmp	 BYTE PTR [esi+32], 0
  0006b	74 c8		 je	 SHORT $LL4@expr
$LN23@expr:
  0006d	5f		 pop	 edi
$LN5@expr:
  0006e	5e		 pop	 esi

; 308  : 					  //THROW( new CParseException("Error Parsing"));
; 309  : 					  return;
; 310  : 	}
; 311  :     }
; 312  : }

  0006f	c3		 ret	 0
$LN15@expr:
  00070	5f		 pop	 edi

; 304  : 		continue;
; 305  : 	    case POLY_EOS: case ')': case ',': return;
; 306  : 	    default:
; 307  : 					  error();

  00071	8b ce		 mov	 ecx, esi
  00073	5e		 pop	 esi
  00074	e9 00 00 00 00	 jmp	 ?error@CPoly@@IAEXXZ	; CPoly::error
  00079	0f 1f 00	 npad	 3
$LN22@expr:

; 308  : 					  //THROW( new CParseException("Error Parsing"));
; 309  : 					  return;
; 310  : 	}
; 311  :     }
; 312  : }

  0007c	00 00 00 00	 DD	 $LN23@expr
  00080	00 00 00 00	 DD	 $LN10@expr
  00084	00 00 00 00	 DD	 $LN15@expr
$LN21@expr:
  00088	00		 DB	 0
  00089	02		 DB	 2
  0008a	02		 DB	 2
  0008b	02		 DB	 2
  0008c	02		 DB	 2
  0008d	02		 DB	 2
  0008e	02		 DB	 2
  0008f	02		 DB	 2
  00090	02		 DB	 2
  00091	02		 DB	 2
  00092	02		 DB	 2
  00093	02		 DB	 2
  00094	02		 DB	 2
  00095	02		 DB	 2
  00096	02		 DB	 2
  00097	02		 DB	 2
  00098	02		 DB	 2
  00099	02		 DB	 2
  0009a	02		 DB	 2
  0009b	02		 DB	 2
  0009c	02		 DB	 2
  0009d	02		 DB	 2
  0009e	02		 DB	 2
  0009f	02		 DB	 2
  000a0	02		 DB	 2
  000a1	02		 DB	 2
  000a2	02		 DB	 2
  000a3	02		 DB	 2
  000a4	02		 DB	 2
  000a5	02		 DB	 2
  000a6	00		 DB	 0
  000a7	02		 DB	 2
  000a8	01		 DB	 1
  000a9	00		 DB	 0
  000aa	01		 DB	 1
?expr@CPoly@@IAEXXZ ENDP				; CPoly::expr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
;	COMDAT ?error@CPoly@@IAEXXZ
_TEXT	SEGMENT
?error@CPoly@@IAEXXZ PROC				; CPoly::error, COMDAT
; _this$ = ecx

; 316  :     iErrorPos=uiLookPos;

  00000	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00003	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 317  :     ErrorOccur=true;

  00006	c6 41 20 01	 mov	 BYTE PTR [ecx+32], 1

; 318  : }

  0000a	c3		 ret	 0
?error@CPoly@@IAEXXZ ENDP				; CPoly::error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
;	COMDAT ?lexan@CPoly@@IAEHXZ
_TEXT	SEGMENT
_tt$1$ = -68						; size = 8
tv1874 = -64						; size = 4
__Old_capacity$1$ = -60					; size = 4
__Old_size$1$ = -56					; size = 4
$T2 = -52						; size = 4
__Ptr$1$ = -48						; size = 4
__Ch$1$ = -41						; size = 1
_localSymbol$3 = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?lexan@CPoly@@IAEHXZ PROC				; CPoly::lexan, COMDAT
; _this$ = ecx

; 321  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?lexan@CPoly@@IAEHXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f9		 mov	 edi, ecx

; 322  :     int t;
; 323  :     double tt;
; 324  : 
; 325  :     while (uiLookPos < strData.size())

  0002d	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  00030	8b 5f 70	 mov	 ebx, DWORD PTR [edi+112]
  00033	3b c3		 cmp	 eax, ebx
  00035	73 32		 jae	 SHORT $LN313@lexan
  00037	8d 77 60	 lea	 esi, DWORD PTR [edi+96]
  0003a	66 0f 1f 44 00
	00		 npad	 6
$LL2@lexan:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00040	8b 56 14	 mov	 edx, DWORD PTR [esi+20]

; 2296 :         value_type* _Result = _Bx._Buf;

  00043	8b ce		 mov	 ecx, esi

; 2297 :         if (_Large_string_engaged()) {

  00045	83 fa 10	 cmp	 edx, 16			; 00000010H
  00048	72 02		 jb	 SHORT $LN302@lexan

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  0004a	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN302@lexan:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 327  : 	if (strData[uiLookPos] == ' ' || strData[uiLookPos] == '\t')

  0004c	80 3c 08 20	 cmp	 BYTE PTR [eax+ecx], 32	; 00000020H
  00050	74 0f		 je	 SHORT $LN285@lexan
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2296 :         value_type* _Result = _Bx._Buf;

  00052	8b ce		 mov	 ecx, esi

; 2297 :         if (_Large_string_engaged()) {

  00054	83 fa 10	 cmp	 edx, 16			; 00000010H
  00057	72 02		 jb	 SHORT $LN301@lexan

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  00059	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN301@lexan:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 327  : 	if (strData[uiLookPos] == ' ' || strData[uiLookPos] == '\t')

  0005b	80 3c 08 09	 cmp	 BYTE PTR [eax+ecx], 9
  0005f	75 29		 jne	 SHORT $LN12@lexan
$LN285@lexan:

; 375  : 	}
; 376  : 	uiLookPos++;

  00061	40		 inc	 eax
  00062	89 47 24	 mov	 DWORD PTR [edi+36], eax
  00065	3b c3		 cmp	 eax, ebx
  00067	72 d7		 jb	 SHORT $LL2@lexan
$LN313@lexan:

; 377  :     }
; 378  :     return POLY_EOS;

  00069	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
$LN1@lexan:

; 379  : }

  0006e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00071	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00078	59		 pop	 ecx
  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007f	33 cd		 xor	 ecx, ebp
  00081	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
$LN12@lexan:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2296 :         value_type* _Result = _Bx._Buf;

  0008a	8b ce		 mov	 ecx, esi

; 2297 :         if (_Large_string_engaged()) {

  0008c	83 fa 10	 cmp	 edx, 16			; 00000010H
  0008f	72 02		 jb	 SHORT $LN303@lexan

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  00091	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN303@lexan:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 329  : 	else if (isdigit(strData[uiLookPos]))

  00093	0f be 04 08	 movsx	 eax, BYTE PTR [eax+ecx]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 _isdigit
  0009d	83 c4 04	 add	 esp, 4
  000a0	85 c0		 test	 eax, eax
  000a2	0f 84 05 01 00
	00		 je	 $LN15@lexan

; 330  : 	{
; 331  : 	    t = 0;
; 332  : 	    for (;uiLookPos<strData.size();uiLookPos++)

  000a8	8b 57 24	 mov	 edx, DWORD PTR [edi+36]
  000ab	33 db		 xor	 ebx, ebx
  000ad	3b 57 70	 cmp	 edx, DWORD PTR [edi+112]
  000b0	73 3e		 jae	 SHORT $LN315@lexan
$LL6@lexan:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  000b2	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2296 :         value_type* _Result = _Bx._Buf;

  000b6	8b c6		 mov	 eax, esi

; 2297 :         if (_Large_string_engaged()) {

  000b8	72 02		 jb	 SHORT $LN305@lexan

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  000ba	8b 06		 mov	 eax, DWORD PTR [esi]
$LN305@lexan:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 334  : 		if (isdigit(strData[uiLookPos]))

  000bc	0f be 04 02	 movsx	 eax, BYTE PTR [edx+eax]
  000c0	50		 push	 eax
  000c1	e8 00 00 00 00	 call	 _isdigit
  000c6	83 c4 04	 add	 esp, 4
  000c9	85 c0		 test	 eax, eax
  000cb	74 23		 je	 SHORT $LN315@lexan
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  000cd	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2296 :         value_type* _Result = _Bx._Buf;

  000d1	8b c6		 mov	 eax, esi

; 2297 :         if (_Large_string_engaged()) {

  000d3	72 02		 jb	 SHORT $LN304@lexan

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  000d5	8b 06		 mov	 eax, DWORD PTR [esi]
$LN304@lexan:

; 3843 :         return _Mypair._Myval2._Myptr()[_Off];

  000d7	8b 57 24	 mov	 edx, DWORD PTR [edi+36]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 335  : 		    t = t * 10 + strData[uiLookPos] - '0';

  000da	8d 1c 9b	 lea	 ebx, DWORD PTR [ebx+ebx*4]
  000dd	8d 5b e8	 lea	 ebx, DWORD PTR [ebx-24]
  000e0	0f be 0c 02	 movsx	 ecx, BYTE PTR [edx+eax]
  000e4	42		 inc	 edx
  000e5	89 57 24	 mov	 DWORD PTR [edi+36], edx
  000e8	8d 1c 59	 lea	 ebx, DWORD PTR [ecx+ebx*2]
  000eb	3b 57 70	 cmp	 edx, DWORD PTR [edi+112]
  000ee	72 c2		 jb	 SHORT $LL6@lexan
$LN315@lexan:

; 336  : 		else
; 337  : 		    break;
; 338  : 	    }
; 339  : 	    iToken=t;
; 340  : 	    tt=0.1;

  000f0	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3fb999999999999a

; 342  : 	    if (uiLookPos<strData.size() && strData[uiLookPos]=='.')

  000f8	8b 4f 24	 mov	 ecx, DWORD PTR [edi+36]
  000fb	8b 57 70	 mov	 edx, DWORD PTR [edi+112]
  000fe	f2 0f 11 45 bc	 movsd	 QWORD PTR _tt$1$[ebp], xmm0
  00103	0f 57 c0	 xorps	 xmm0, xmm0
  00106	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  00109	f2 0f 11 47 10	 movsd	 QWORD PTR [edi+16], xmm0
  0010e	3b ca		 cmp	 ecx, edx
  00110	73 7e		 jae	 SHORT $LN316@lexan
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00112	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2296 :         value_type* _Result = _Bx._Buf;

  00116	8b c6		 mov	 eax, esi

; 2297 :         if (_Large_string_engaged()) {

  00118	72 02		 jb	 SHORT $LN306@lexan

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  0011a	8b 06		 mov	 eax, DWORD PTR [esi]
$LN306@lexan:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 342  : 	    if (uiLookPos<strData.size() && strData[uiLookPos]=='.')

  0011c	80 3c 08 2e	 cmp	 BYTE PTR [eax+ecx], 46	; 0000002eH
  00120	75 6e		 jne	 SHORT $LN316@lexan

; 343  : 	    {
; 344  : 		uiLookPos++;

  00122	41		 inc	 ecx
  00123	89 4f 24	 mov	 DWORD PTR [edi+36], ecx

; 345  : 		for (;uiLookPos<strData.size();uiLookPos++,tt*=0.1)

  00126	3b ca		 cmp	 ecx, edx
  00128	73 66		 jae	 SHORT $LN316@lexan
  0012a	66 0f 1f 44 00
	00		 npad	 6
$LL9@lexan:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00130	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2296 :         value_type* _Result = _Bx._Buf;

  00134	8b c6		 mov	 eax, esi

; 2297 :         if (_Large_string_engaged()) {

  00136	72 02		 jb	 SHORT $LN308@lexan

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  00138	8b 06		 mov	 eax, DWORD PTR [esi]
$LN308@lexan:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 347  : 		    if (isdigit(strData[uiLookPos]))

  0013a	0f be 04 01	 movsx	 eax, BYTE PTR [ecx+eax]
  0013e	50		 push	 eax
  0013f	e8 00 00 00 00	 call	 _isdigit
  00144	83 c4 04	 add	 esp, 4
  00147	85 c0		 test	 eax, eax
  00149	74 45		 je	 SHORT $LN316@lexan
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  0014b	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2296 :         value_type* _Result = _Bx._Buf;

  0014f	8b c6		 mov	 eax, esi

; 2297 :         if (_Large_string_engaged()) {

  00151	72 02		 jb	 SHORT $LN307@lexan

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  00153	8b 06		 mov	 eax, DWORD PTR [esi]
$LN307@lexan:

; 3843 :         return _Mypair._Myval2._Myptr()[_Off];

  00155	8b 4f 24	 mov	 ecx, DWORD PTR [edi+36]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 348  : 			iNumToken+=tt*(strData[uiLookPos]-'0');

  00158	f2 0f 10 4d bc	 movsd	 xmm1, QWORD PTR _tt$1$[ebp]
  0015d	0f be 04 08	 movsx	 eax, BYTE PTR [eax+ecx]
  00161	41		 inc	 ecx
  00162	83 e8 30	 sub	 eax, 48			; 00000030H
  00165	89 4f 24	 mov	 DWORD PTR [edi+36], ecx
  00168	66 0f 6e c0	 movd	 xmm0, eax
  0016c	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00170	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00174	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fb999999999999a
  0017c	f2 0f 58 47 10	 addsd	 xmm0, QWORD PTR [edi+16]
  00181	f2 0f 11 4d bc	 movsd	 QWORD PTR _tt$1$[ebp], xmm1
  00186	f2 0f 11 47 10	 movsd	 QWORD PTR [edi+16], xmm0
  0018b	3b 4f 70	 cmp	 ecx, DWORD PTR [edi+112]
  0018e	72 a0		 jb	 SHORT $LL9@lexan
$LN316@lexan:
  00190	66 0f 6e 47 08	 movd	 xmm0, DWORD PTR [edi+8]

; 349  : 		    else
; 350  : 			break;
; 351  : 		}
; 352  : 	    }
; 353  : 	    iNumToken+=iToken;
; 354  : 	    return POLY_NUM;

  00195	b8 09 00 00 00	 mov	 eax, 9
  0019a	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0019e	f2 0f 58 47 10	 addsd	 xmm0, QWORD PTR [edi+16]
  001a3	f2 0f 11 47 10	 movsd	 QWORD PTR [edi+16], xmm0
  001a8	e9 c1 fe ff ff	 jmp	 $LN1@lexan
$LN15@lexan:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2297 :         if (_Large_string_engaged()) {

  001ad	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  001b1	8b ce		 mov	 ecx, esi
  001b3	72 02		 jb	 SHORT $LN309@lexan

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  001b5	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN309@lexan:

; 3843 :         return _Mypair._Myval2._Myptr()[_Off];

  001b7	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 356  : 	else if (isalpha(strData[uiLookPos]))

  001ba	0f be 04 08	 movsx	 eax, BYTE PTR [eax+ecx]
  001be	50		 push	 eax
  001bf	e8 00 00 00 00	 call	 _isalpha
  001c4	8b 4f 24	 mov	 ecx, DWORD PTR [edi+36]
  001c7	83 c4 04	 add	 esp, 4
  001ca	85 c0		 test	 eax, eax
  001cc	0f 84 3a 02 00
	00		 je	 $LN22@lexan
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  001d2	33 d2		 xor	 edx, edx

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  001d4	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _localSymbol$3[ebp], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  001db	bb 0f 00 00 00	 mov	 ebx, 15			; 0000000fH

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  001e0	89 55 c8	 mov	 DWORD PTR __Old_size$1$[ebp], edx

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  001e3	89 5d ec	 mov	 DWORD PTR _localSymbol$3[ebp+20], ebx

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  001e6	89 55 e8	 mov	 DWORD PTR _localSymbol$3[ebp+16], edx

; 3249 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  001e9	88 55 d8	 mov	 BYTE PTR _localSymbol$3[ebp], dl
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 358  : 	    string localSymbol("");

  001ec	89 55 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edx

; 359  : 	    while (uiLookPos<strData.size() && isalpha(strData[uiLookPos]))

  001ef	3b 4f 70	 cmp	 ecx, DWORD PTR [edi+112]
  001f2	0f 83 fe 01 00
	00		 jae	 $LN314@lexan
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  001f8	8b 45 d8	 mov	 eax, DWORD PTR _localSymbol$3[ebp]
  001fb	89 45 d0	 mov	 DWORD PTR __Ptr$1$[ebp], eax
  001fe	66 90		 npad	 2
$LL10@lexan:

; 2319 :         return _BUF_SIZE <= _Myres;

  00200	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2296 :         value_type* _Result = _Bx._Buf;

  00204	8b c6		 mov	 eax, esi

; 2297 :         if (_Large_string_engaged()) {

  00206	72 02		 jb	 SHORT $LN311@lexan

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  00208	8b 06		 mov	 eax, DWORD PTR [esi]
$LN311@lexan:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 359  : 	    while (uiLookPos<strData.size() && isalpha(strData[uiLookPos]))

  0020a	0f be 04 01	 movsx	 eax, BYTE PTR [ecx+eax]
  0020e	50		 push	 eax
  0020f	e8 00 00 00 00	 call	 _isalpha
  00214	83 c4 04	 add	 esp, 4
  00217	85 c0		 test	 eax, eax
  00219	0f 84 7c 01 00
	00		 je	 $LN317@lexan
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  0021f	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2296 :         value_type* _Result = _Bx._Buf;

  00223	8b ce		 mov	 ecx, esi

; 2297 :         if (_Large_string_engaged()) {

  00225	72 02		 jb	 SHORT $LN310@lexan

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  00227	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN310@lexan:

; 3119 :         push_back(_Ch);

  00229	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  0022c	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]

; 3862 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  0022f	8b 4d c8	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]

; 3119 :         push_back(_Ch);

  00232	88 55 d7	 mov	 BYTE PTR __Ch$1$[ebp], dl

; 3862 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00235	3b cb		 cmp	 ecx, ebx

; 3863 :         if (_Old_size < _Mypair._Myval2._Myres) {

  00237	73 29		 jae	 SHORT $LN180@lexan

; 3864 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  00239	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 2319 :         return _BUF_SIZE <= _Myres;

  0023c	83 fb 10	 cmp	 ebx, 16			; 00000010H

; 3864 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  0023f	89 45 e8	 mov	 DWORD PTR _localSymbol$3[ebp+16], eax

; 2296 :         value_type* _Result = _Bx._Buf;

  00242	8d 45 d8	 lea	 eax, DWORD PTR _localSymbol$3[ebp]

; 2297 :         if (_Large_string_engaged()) {

  00245	0f 43 45 d0	 cmovae	 eax, DWORD PTR __Ptr$1$[ebp]

; 3866 :             _Traits::assign(_Ptr[_Old_size], _Ch);

  00249	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 3867 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

  0024c	c6 44 08 01 00	 mov	 BYTE PTR [eax+ecx+1], 0

; 3868 :             return;

  00251	8b 55 e8	 mov	 edx, DWORD PTR _localSymbol$3[ebp+16]
  00254	8b 5d ec	 mov	 ebx, DWORD PTR _localSymbol$3[ebp+20]
  00257	8b 4d d8	 mov	 ecx, DWORD PTR _localSymbol$3[ebp]
  0025a	89 55 c8	 mov	 DWORD PTR __Old_size$1$[ebp], edx
  0025d	e9 26 01 00 00	 jmp	 $LN320@lexan
$LN180@lexan:

; 4542 :         const size_type _Old_size = _My_data._Mysize;

  00262	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 3871 :         _Reallocate_grow_by(

  00267	89 4d c0	 mov	 DWORD PTR tv1874[ebp], ecx

; 4542 :         const size_type _Old_size = _My_data._Mysize;

  0026a	2b c1		 sub	 eax, ecx

; 4543 :         if (max_size() - _Old_size < _Size_increase) {

  0026c	83 f8 01	 cmp	 eax, 1
  0026f	0f 82 ba 01 00
	00		 jb	 $LN276@lexan

; 4545 :         }
; 4546 : 
; 4547 :         const size_type _New_size     = _Old_size + _Size_increase;

  00275	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 4548 :         const size_type _Old_capacity = _My_data._Myres;

  00278	8b d3		 mov	 edx, ebx

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0027a	8b d8		 mov	 ebx, eax

; 4547 :         const size_type _New_size     = _Old_size + _Size_increase;

  0027c	89 45 c8	 mov	 DWORD PTR __Old_size$1$[ebp], eax

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0027f	83 cb 0f	 or	 ebx, 15			; 0000000fH

; 4548 :         const size_type _Old_capacity = _My_data._Myres;

  00282	89 55 c4	 mov	 DWORD PTR __Old_capacity$1$[ebp], edx

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00285	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH

; 4489 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0028b	76 18		 jbe	 SHORT $LN195@lexan

; 4490 :             return _Max;

  0028d	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00292	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00297	50		 push	 eax
  00298	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0029d	8b 4d c0	 mov	 ecx, DWORD PTR tv1874[ebp]
  002a0	83 c4 04	 add	 esp, 4
  002a3	eb 5c		 jmp	 SHORT $LN321@lexan
$LN195@lexan:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4493 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  002a5	d1 ea		 shr	 edx, 1
  002a7	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  002ac	2b c2		 sub	 eax, edx
  002ae	39 45 c4	 cmp	 DWORD PTR __Old_capacity$1$[ebp], eax
  002b1	76 18		 jbe	 SHORT $LN196@lexan

; 4494 :             return _Max;

  002b3	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  002b8	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  002bd	50		 push	 eax
  002be	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  002c3	8b 4d c0	 mov	 ecx, DWORD PTR tv1874[ebp]
  002c6	83 c4 04	 add	 esp, 4
  002c9	eb 36		 jmp	 SHORT $LN321@lexan
$LN196@lexan:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4497 :         return (_STD max)(_Masked, _Old + _Old / 2);

  002cb	8b 45 c4	 mov	 eax, DWORD PTR __Old_capacity$1$[ebp]
  002ce	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  002d0	3b d8		 cmp	 ebx, eax
  002d2	0f 42 d8	 cmovb	 ebx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4551 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  002d5	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  002d8	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  002dd	72 0e		 jb	 SHORT $LN203@lexan

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  002df	50		 push	 eax
  002e0	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  002e5	8b 4d c0	 mov	 ecx, DWORD PTR tv1874[ebp]
  002e8	83 c4 04	 add	 esp, 4
  002eb	eb 14		 jmp	 SHORT $LN321@lexan
$LN203@lexan:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  002ed	85 c0		 test	 eax, eax
  002ef	74 0e		 je	 SHORT $LN204@lexan

; 85   :         return ::operator new(_Bytes);

  002f1	50		 push	 eax
  002f2	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 244  :         return _Traits::_Allocate(_Bytes);

  002f7	8b 4d c0	 mov	 ecx, DWORD PTR tv1874[ebp]

; 85   :         return ::operator new(_Bytes);

  002fa	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  002fd	eb 02		 jmp	 SHORT $LN321@lexan
$LN204@lexan:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  002ff	33 c0		 xor	 eax, eax
$LN321@lexan:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4562 :         if (_BUF_SIZE <= _Old_capacity) {

  00301	83 7d c4 10	 cmp	 DWORD PTR __Old_capacity$1$[ebp], 16 ; 00000010H
  00305	8b 55 c8	 mov	 edx, DWORD PTR __Old_size$1$[ebp]
  00308	89 45 cc	 mov	 DWORD PTR $T2[ebp], eax
  0030b	89 55 e8	 mov	 DWORD PTR _localSymbol$3[ebp+16], edx
  0030e	89 5d ec	 mov	 DWORD PTR _localSymbol$3[ebp+20], ebx
  00311	51		 push	 ecx
  00312	72 51		 jb	 SHORT $LN189@lexan

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00314	ff 75 d0	 push	 DWORD PTR __Ptr$1$[ebp]
  00317	50		 push	 eax
  00318	e8 00 00 00 00	 call	 _memcpy

; 3875 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

  0031d	8b 45 cc	 mov	 eax, DWORD PTR $T2[ebp]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00320	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3875 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

  00323	8b 4d c0	 mov	 ecx, DWORD PTR tv1874[ebp]
  00326	8a 55 d7	 mov	 dl, BYTE PTR __Ch$1$[ebp]
  00329	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 4565 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  0032c	8b 55 c4	 mov	 edx, DWORD PTR __Old_capacity$1$[ebp]

; 3876 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  0032f	c6 44 01 01 00	 mov	 BYTE PTR [ecx+eax+1], 0

; 4565 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  00334	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00335	8b 4d d0	 mov	 ecx, DWORD PTR __Ptr$1$[ebp]
  00338	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0033a	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00340	72 14		 jb	 SHORT $LN226@lexan

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00342	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00345	83 c2 23	 add	 edx, 35			; 00000023H
  00348	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0034a	83 c0 fc	 add	 eax, -4			; fffffffcH
  0034d	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00350	0f 87 d4 00 00
	00		 ja	 $LN257@lexan
$LN226@lexan:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00356	52		 push	 edx
  00357	51		 push	 ecx
  00358	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4566 :             _My_data._Bx._Ptr = _New_ptr;

  0035d	8b 4d cc	 mov	 ecx, DWORD PTR $T2[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00360	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4567 :         } else {

  00363	eb 20		 jmp	 SHORT $LN322@lexan
$LN189@lexan:

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00365	8d 4d d8	 lea	 ecx, DWORD PTR _localSymbol$3[ebp]
  00368	51		 push	 ecx
  00369	50		 push	 eax
  0036a	e8 00 00 00 00	 call	 _memcpy

; 3875 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

  0036f	8b 45 cc	 mov	 eax, DWORD PTR $T2[ebp]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00372	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3875 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

  00375	8b 4d c0	 mov	 ecx, DWORD PTR tv1874[ebp]
  00378	8a 55 d7	 mov	 dl, BYTE PTR __Ch$1$[ebp]
  0037b	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 3876 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  0037e	c6 44 01 01 00	 mov	 BYTE PTR [ecx+eax+1], 0

; 4569 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00383	8b c8		 mov	 ecx, eax
$LN322@lexan:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 362  : 		uiLookPos++;

  00385	89 4d d8	 mov	 DWORD PTR _localSymbol$3[ebp], ecx
$LN320@lexan:
  00388	89 4d d0	 mov	 DWORD PTR __Ptr$1$[ebp], ecx
  0038b	8b 4f 24	 mov	 ecx, DWORD PTR [edi+36]
  0038e	41		 inc	 ecx
  0038f	89 4f 24	 mov	 DWORD PTR [edi+36], ecx
  00392	3b 4f 70	 cmp	 ecx, DWORD PTR [edi+112]
  00395	0f 82 65 fe ff
	ff		 jb	 $LL10@lexan
$LN317@lexan:

; 363  : 	    }
; 364  : 	    iToken= find(localSymbol);

  0039b	8b 75 d0	 mov	 esi, DWORD PTR __Ptr$1$[ebp]
$LN11@lexan:
  0039e	8d 45 d8	 lea	 eax, DWORD PTR _localSymbol$3[ebp]
  003a1	8b cf		 mov	 ecx, edi
  003a3	50		 push	 eax
  003a4	e8 00 00 00 00	 call	 ?find@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CPoly::find
  003a9	8b c8		 mov	 ecx, eax
  003ab	89 4f 08	 mov	 DWORD PTR [edi+8], ecx

; 365  : 	    if (iToken==-1)

  003ae	83 f9 ff	 cmp	 ecx, -1
  003b1	75 18		 jne	 SHORT $LN24@lexan

; 366  : 	    {
; 367  : 		iToken=insert(localSymbol,POLY_ID);

  003b3	6a 0a		 push	 10			; 0000000aH
  003b5	8d 45 d8	 lea	 eax, DWORD PTR _localSymbol$3[ebp]
  003b8	8b cf		 mov	 ecx, edi
  003ba	50		 push	 eax
  003bb	e8 00 00 00 00	 call	 ?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPoly::insert
  003c0	8b 5d ec	 mov	 ebx, DWORD PTR _localSymbol$3[ebp+20]
  003c3	8b c8		 mov	 ecx, eax
  003c5	8b 75 d8	 mov	 esi, DWORD PTR _localSymbol$3[ebp]
  003c8	89 47 08	 mov	 DWORD PTR [edi+8], eax
$LN24@lexan:

; 369  : 	    return lSymbol[(/*FindIndex*/(iToken))]->token;

  003cb	8b 47 40	 mov	 eax, DWORD PTR [edi+64]
  003ce	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  003d1	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  003d4	83 fb 10	 cmp	 ebx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  003d7	72 2c		 jb	 SHORT $LN250@lexan

; 4619 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4620 :             auto& _Al          = _Getal();
; 4621 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  003d9	43		 inc	 ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003da	8b c6		 mov	 eax, esi

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  003dc	81 fb 00 10 00
	00		 cmp	 ebx, 4096		; 00001000H
  003e2	72 17		 jb	 SHORT $LN260@lexan

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  003e4	8b 76 fc	 mov	 esi, DWORD PTR [esi-4]
  003e7	83 c3 23	 add	 ebx, 35			; 00000023H
  003ea	2b c6		 sub	 eax, esi

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003ec	83 c0 fc	 add	 eax, -4			; fffffffcH
  003ef	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  003f2	77 36		 ja	 SHORT $LN257@lexan
  003f4	eb 05		 jmp	 SHORT $LN260@lexan
$LN314@lexan:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 359  : 	    while (uiLookPos<strData.size() && isalpha(strData[uiLookPos]))

  003f6	8b 75 d8	 mov	 esi, DWORD PTR _localSymbol$3[ebp]
  003f9	eb a3		 jmp	 SHORT $LN11@lexan
$LN260@lexan:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  003fb	53		 push	 ebx
  003fc	56		 push	 esi
  003fd	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00402	83 c4 08	 add	 esp, 8
$LN250@lexan:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 369  : 	    return lSymbol[(/*FindIndex*/(iToken))]->token;

  00405	8b c7		 mov	 eax, edi
  00407	e9 62 fc ff ff	 jmp	 $LN1@lexan
$LN22@lexan:

; 374  : 	    return strData[uiLookPos++];

  0040c	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0040f	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  00416	89 47 24	 mov	 DWORD PTR [edi+36], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00419	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2297 :         if (_Large_string_engaged()) {

  0041d	72 02		 jb	 SHORT $LN268@lexan

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  0041f	8b 36		 mov	 esi, DWORD PTR [esi]
$LN268@lexan:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 374  : 	    return strData[uiLookPos++];

  00421	0f be 04 0e	 movsx	 eax, BYTE PTR [esi+ecx]
  00425	e9 44 fc ff ff	 jmp	 $LN1@lexan
$LN257@lexan:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0042a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN276@lexan:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4544 :             _Xlen_string(); // result too long

  0042f	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN319@lexan:
  00434	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?lexan@CPoly@@IAEHXZ$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _localSymbol$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?lexan@CPoly@@IAEHXZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?lexan@CPoly@@IAEHXZ
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?lexan@CPoly@@IAEHXZ ENDP				; CPoly::lexan
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
;	COMDAT ?term@CPoly@@IAEXXZ
_TEXT	SEGMENT
?term@CPoly@@IAEXXZ PROC				; CPoly::term, COMDAT
; _this$ = ecx

; 382  : {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 383  :     int t;
; 384  :     factor();

  00003	e8 00 00 00 00	 call	 ?factor@CPoly@@IAEXXZ	; CPoly::factor

; 385  :     while (!ErrorOccur)

  00008	80 7f 20 00	 cmp	 BYTE PTR [edi+32], 0
  0000c	75 34		 jne	 SHORT $LN16@term
  0000e	56		 push	 esi
  0000f	90		 npad	 1
$LL2@term:

; 386  :     {
; 387  : 	switch (iLookAhead)

  00010	8b 77 18	 mov	 esi, DWORD PTR [edi+24]
  00013	83 fe 25	 cmp	 esi, 37			; 00000025H
  00016	74 0a		 je	 SHORT $LN6@term
  00018	83 fe 2a	 cmp	 esi, 42			; 0000002aH
  0001b	74 05		 je	 SHORT $LN6@term
  0001d	83 fe 2f	 cmp	 esi, 47			; 0000002fH
  00020	75 1f		 jne	 SHORT $LN17@term
$LN6@term:

; 388  : 	{
; 389  : 	    case '*':
; 390  : 	    case '/':
; 391  : 	    case '%':
; 392  : 		t=iLookAhead;
; 393  : 		match(t);

  00022	56		 push	 esi
  00023	8b cf		 mov	 ecx, edi
  00025	e8 00 00 00 00	 call	 ?match@CPoly@@IAEXH@Z	; CPoly::match

; 394  : 		factor();

  0002a	8b cf		 mov	 ecx, edi
  0002c	e8 00 00 00 00	 call	 ?factor@CPoly@@IAEXXZ	; CPoly::factor

; 395  : 		emit(t,POLY_NONE);

  00031	6a 00		 push	 0
  00033	56		 push	 esi
  00034	8b cf		 mov	 ecx, edi
  00036	e8 00 00 00 00	 call	 ?emit@CPoly@@IAEXHH@Z	; CPoly::emit
  0003b	80 7f 20 00	 cmp	 BYTE PTR [edi+32], 0
  0003f	74 cf		 je	 SHORT $LL2@term
$LN17@term:
  00041	5e		 pop	 esi
$LN16@term:
  00042	5f		 pop	 edi

; 396  : 		continue;
; 397  : 	    default:
; 398  : 		return;
; 399  : 	}
; 400  :     }
; 401  : }

  00043	c3		 ret	 0
?term@CPoly@@IAEXXZ ENDP				; CPoly::term
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
;	COMDAT ?factor@CPoly@@IAEXXZ
_TEXT	SEGMENT
?factor@CPoly@@IAEXXZ PROC				; CPoly::factor, COMDAT
; _this$ = ecx

; 404  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 405  :     int t;
; 406  :     expo();

  00003	e8 00 00 00 00	 call	 ?expo@CPoly@@IAEXXZ	; CPoly::expo

; 407  :     while (!ErrorOccur)

  00008	80 7e 20 00	 cmp	 BYTE PTR [esi+32], 0
  0000c	75 29		 jne	 SHORT $LN14@factor
  0000e	66 90		 npad	 2
$LL2@factor:

; 408  :     {
; 409  : 	switch (iLookAhead)

  00010	83 7e 18 5e	 cmp	 DWORD PTR [esi+24], 94	; 0000005eH
  00014	75 21		 jne	 SHORT $LN14@factor

; 410  : 	{
; 411  : 	    case '^':
; 412  : 		t=iLookAhead;
; 413  : 		match(t);

  00016	6a 5e		 push	 94			; 0000005eH
  00018	8b ce		 mov	 ecx, esi
  0001a	e8 00 00 00 00	 call	 ?match@CPoly@@IAEXH@Z	; CPoly::match

; 414  : 		expo();

  0001f	8b ce		 mov	 ecx, esi
  00021	e8 00 00 00 00	 call	 ?expo@CPoly@@IAEXXZ	; CPoly::expo

; 415  : 		emit(t,POLY_NONE);

  00026	6a 00		 push	 0
  00028	6a 5e		 push	 94			; 0000005eH
  0002a	8b ce		 mov	 ecx, esi
  0002c	e8 00 00 00 00	 call	 ?emit@CPoly@@IAEXHH@Z	; CPoly::emit
  00031	80 7e 20 00	 cmp	 BYTE PTR [esi+32], 0
  00035	74 d9		 je	 SHORT $LL2@factor
$LN14@factor:
  00037	5e		 pop	 esi

; 416  : 		continue;
; 417  : 	    default:
; 418  : 		return;
; 419  : 	}
; 420  :     }
; 421  : }

  00038	c3		 ret	 0
?factor@CPoly@@IAEXXZ ENDP				; CPoly::factor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
;	COMDAT ?expo@CPoly@@IAEXXZ
_TEXT	SEGMENT
?expo@CPoly@@IAEXXZ PROC				; CPoly::expo, COMDAT
; _this$ = ecx

; 424  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 425  :     int t;
; 426  :     switch (iLookAhead)

  00004	8b 7e 18	 mov	 edi, DWORD PTR [esi+24]
  00007	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  0000a	83 f8 27	 cmp	 eax, 39			; 00000027H
  0000d	0f 87 9b 00 00
	00		 ja	 $LN25@expo
  00013	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN27@expo[eax]
  0001a	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN28@expo[eax*4]
$LN4@expo:

; 427  :     {
; 428  : 	case '(':
; 429  : 	    match('('); expr(); match(')'); break;

  00021	6a 28		 push	 40			; 00000028H
  00023	e8 00 00 00 00	 call	 ?match@CPoly@@IAEXH@Z	; CPoly::match
  00028	8b ce		 mov	 ecx, esi
  0002a	e8 00 00 00 00	 call	 ?expr@CPoly@@IAEXXZ	; CPoly::expr
  0002f	6a 29		 push	 41			; 00000029H

; 457  : 	case POLY_EOS:
; 458  : 	    break;
; 459  : 	default:
; 460  : 	    error();
; 461  : 	    //THROW( new CParseException("Error Parsing"));
; 462  :     }
; 463  : }

  00031	8b ce		 mov	 ecx, esi
  00033	e8 00 00 00 00	 call	 ?match@CPoly@@IAEXH@Z	; CPoly::match
$LN2@expo:
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	c3		 ret	 0
$LN5@expo:

; 430  : 	case POLY_NUM:
; 431  : 	    emit(POLY_NUM, iToken); match(POLY_NUM); break;

  0003b	ff 76 08	 push	 DWORD PTR [esi+8]
  0003e	6a 09		 push	 9
  00040	e8 00 00 00 00	 call	 ?emit@CPoly@@IAEXHH@Z	; CPoly::emit
  00045	6a 09		 push	 9

; 457  : 	case POLY_EOS:
; 458  : 	    break;
; 459  : 	default:
; 460  : 	    error();
; 461  : 	    //THROW( new CParseException("Error Parsing"));
; 462  :     }
; 463  : }

  00047	8b ce		 mov	 ecx, esi
  00049	e8 00 00 00 00	 call	 ?match@CPoly@@IAEXH@Z	; CPoly::match
  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	c3		 ret	 0
$LN6@expo:

; 432  : 	case POLY_ID:
; 433  : 	    emit(POLY_ID,(int)/*FindIndex*/(iToken)); match(POLY_ID); break;

  00051	ff 76 08	 push	 DWORD PTR [esi+8]
  00054	6a 0a		 push	 10			; 0000000aH
  00056	e8 00 00 00 00	 call	 ?emit@CPoly@@IAEXHH@Z	; CPoly::emit
  0005b	6a 0a		 push	 10			; 0000000aH

; 457  : 	case POLY_EOS:
; 458  : 	    break;
; 459  : 	default:
; 460  : 	    error();
; 461  : 	    //THROW( new CParseException("Error Parsing"));
; 462  :     }
; 463  : }

  0005d	8b ce		 mov	 ecx, esi
  0005f	e8 00 00 00 00	 call	 ?match@CPoly@@IAEXH@Z	; CPoly::match
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	c3		 ret	 0
$LN7@expo:

; 434  : 	case POLY_ROOT:
; 435  : 	case POLY_SIN:
; 436  : 	case POLY_COT:
; 437  : 	case POLY_TAN:
; 438  : 	case POLY_CSC:
; 439  : 	case POLY_SEC:
; 440  : 	case POLY_LN:
; 441  : 	case POLY_LOG10:
; 442  : 	case POLY_COS:
; 443  : 	case POLY_ABS:
; 444  : 	case POLY_FLOOR:
; 445  : 	    t=iLookAhead;
; 446  : 	    match(iLookAhead); match('('); expr(); match(')'); emit(t,iToken);

  00067	57		 push	 edi
  00068	e8 00 00 00 00	 call	 ?match@CPoly@@IAEXH@Z	; CPoly::match
  0006d	6a 28		 push	 40			; 00000028H
$LN31@expo:

; 457  : 	case POLY_EOS:
; 458  : 	    break;
; 459  : 	default:
; 460  : 	    error();
; 461  : 	    //THROW( new CParseException("Error Parsing"));
; 462  :     }
; 463  : }

  0006f	8b ce		 mov	 ecx, esi
  00071	e8 00 00 00 00	 call	 ?match@CPoly@@IAEXH@Z	; CPoly::match
  00076	8b ce		 mov	 ecx, esi
  00078	e8 00 00 00 00	 call	 ?expr@CPoly@@IAEXXZ	; CPoly::expr
  0007d	6a 29		 push	 41			; 00000029H
  0007f	8b ce		 mov	 ecx, esi
  00081	e8 00 00 00 00	 call	 ?match@CPoly@@IAEXH@Z	; CPoly::match
  00086	ff 76 08	 push	 DWORD PTR [esi+8]
  00089	8b ce		 mov	 ecx, esi
  0008b	57		 push	 edi
  0008c	e8 00 00 00 00	 call	 ?emit@CPoly@@IAEXHH@Z	; CPoly::emit
  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	c3		 ret	 0
$LN18@expo:

; 447  : 	    break;
; 448  : 	case POLY_LOG:
; 449  : 	case POLY_MINF:
; 450  : 	case POLY_MAXF:
; 451  : 	case POLY_IRAND:
; 452  : 	case POLY_FRAND:
; 453  : 	case POLY_MOD:
; 454  : 	    t=iLookAhead;
; 455  : 	    match(iLookAhead); match('('); expr(); match(','); expr(); match(')'); emit(t,iToken);

  00094	57		 push	 edi
  00095	e8 00 00 00 00	 call	 ?match@CPoly@@IAEXH@Z	; CPoly::match
  0009a	6a 28		 push	 40			; 00000028H
  0009c	8b ce		 mov	 ecx, esi
  0009e	e8 00 00 00 00	 call	 ?match@CPoly@@IAEXH@Z	; CPoly::match
  000a3	8b ce		 mov	 ecx, esi
  000a5	e8 00 00 00 00	 call	 ?expr@CPoly@@IAEXXZ	; CPoly::expr
  000aa	6a 2c		 push	 44			; 0000002cH

; 456  : 	    break;

  000ac	eb c1		 jmp	 SHORT $LN31@expo
$LN25@expo:
  000ae	5f		 pop	 edi

; 457  : 	case POLY_EOS:
; 458  : 	    break;
; 459  : 	default:
; 460  : 	    error();
; 461  : 	    //THROW( new CParseException("Error Parsing"));
; 462  :     }
; 463  : }

  000af	5e		 pop	 esi
  000b0	e9 00 00 00 00	 jmp	 ?error@CPoly@@IAEXXZ	; CPoly::error
  000b5	0f 1f 00	 npad	 3
$LN28@expo:
  000b8	00 00 00 00	 DD	 $LN7@expo
  000bc	00 00 00 00	 DD	 $LN5@expo
  000c0	00 00 00 00	 DD	 $LN6@expo
  000c4	00 00 00 00	 DD	 $LN2@expo
  000c8	00 00 00 00	 DD	 $LN18@expo
  000cc	00 00 00 00	 DD	 $LN4@expo
  000d0	00 00 00 00	 DD	 $LN25@expo
$LN27@expo:
  000d4	00		 DB	 0
  000d5	06		 DB	 6
  000d6	06		 DB	 6
  000d7	06		 DB	 6
  000d8	06		 DB	 6
  000d9	06		 DB	 6
  000da	06		 DB	 6
  000db	06		 DB	 6
  000dc	01		 DB	 1
  000dd	02		 DB	 2
  000de	03		 DB	 3
  000df	00		 DB	 0
  000e0	00		 DB	 0
  000e1	00		 DB	 0
  000e2	00		 DB	 0
  000e3	00		 DB	 0
  000e4	00		 DB	 0
  000e5	04		 DB	 4
  000e6	00		 DB	 0
  000e7	00		 DB	 0
  000e8	00		 DB	 0
  000e9	04		 DB	 4
  000ea	04		 DB	 4
  000eb	04		 DB	 4
  000ec	04		 DB	 4
  000ed	04		 DB	 4
  000ee	00		 DB	 0
  000ef	06		 DB	 6
  000f0	06		 DB	 6
  000f1	06		 DB	 6
  000f2	06		 DB	 6
  000f3	06		 DB	 6
  000f4	06		 DB	 6
  000f5	06		 DB	 6
  000f6	06		 DB	 6
  000f7	06		 DB	 6
  000f8	06		 DB	 6
  000f9	06		 DB	 6
  000fa	06		 DB	 6
  000fb	05		 DB	 5
?expo@CPoly@@IAEXXZ ENDP				; CPoly::expo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
;	COMDAT ?match@CPoly@@IAEXH@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
?match@CPoly@@IAEXH@Z PROC				; CPoly::match, COMDAT
; _this$ = ecx

; 466  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 467  :     if (iLookAhead==t) iLookAhead=lexan(); else error();

  00006	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00009	3b 45 08	 cmp	 eax, DWORD PTR _t$[ebp]
  0000c	75 0d		 jne	 SHORT $LN2@match
  0000e	e8 00 00 00 00	 call	 ?lexan@CPoly@@IAEHXZ	; CPoly::lexan
  00013	89 46 18	 mov	 DWORD PTR [esi+24], eax
  00016	5e		 pop	 esi

; 468  : }

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
$LN2@match:

; 467  :     if (iLookAhead==t) iLookAhead=lexan(); else error();

  0001b	e8 00 00 00 00	 call	 ?error@CPoly@@IAEXXZ	; CPoly::error
  00020	5e		 pop	 esi

; 468  : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?match@CPoly@@IAEXH@Z ENDP				; CPoly::match
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
;	COMDAT ?emit@CPoly@@IAEXHH@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
$T2 = 8							; size = 4
$T3 = 8							; size = 4
$T4 = 8							; size = 4
$T5 = 8							; size = 4
$T6 = 8							; size = 4
_t$ = 8							; size = 4
_tval$ = 12						; size = 4
?emit@CPoly@@IAEXHH@Z PROC				; CPoly::emit, COMDAT
; _this$ = ecx

; 471  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  :     switch (t)

  00003	8b 55 08	 mov	 edx, DWORD PTR _t$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  0000c	83 f8 5d	 cmp	 eax, 93			; 0000005dH
  0000f	0f 87 1a 01 00
	00		 ja	 $LN29@emit
  00015	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN47@emit[eax]
  0001c	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN48@emit[eax*4]
$LN4@emit:

; 473  :     {
; 474  : 	case '+':
; 475  : 	    tokenBase.push_back(POLY_PLU);

  00023	8d 45 08	 lea	 eax, DWORD PTR $T6[ebp]
  00026	c7 45 08 03 00
	00 00		 mov	 DWORD PTR $T6[ebp], 3
  0002d	50		 push	 eax
  0002e	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  00031	e8 00 00 00 00	 call	 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEX$$QAH@Z ; std::vector<int,std::allocator<int> >::push_back
  00036	5e		 pop	 esi

; 524  : }

  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
$LN5@emit:

; 476  : 	    break;
; 477  : 	case '-':
; 478  : 	    tokenBase.push_back(POLY_MIN);

  0003b	8d 45 08	 lea	 eax, DWORD PTR $T5[ebp]
  0003e	c7 45 08 05 00
	00 00		 mov	 DWORD PTR $T5[ebp], 5
  00045	50		 push	 eax
  00046	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  00049	e8 00 00 00 00	 call	 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEX$$QAH@Z ; std::vector<int,std::allocator<int> >::push_back
  0004e	5e		 pop	 esi

; 524  : }

  0004f	5d		 pop	 ebp
  00050	c2 08 00	 ret	 8
$LN6@emit:

; 479  : 	    break;
; 480  : 	case '*':
; 481  : 	    tokenBase.push_back(POLY_MUL);

  00053	8d 45 08	 lea	 eax, DWORD PTR $T4[ebp]
  00056	c7 45 08 02 00
	00 00		 mov	 DWORD PTR $T4[ebp], 2
  0005d	50		 push	 eax
  0005e	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  00061	e8 00 00 00 00	 call	 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEX$$QAH@Z ; std::vector<int,std::allocator<int> >::push_back
  00066	5e		 pop	 esi

; 524  : }

  00067	5d		 pop	 ebp
  00068	c2 08 00	 ret	 8
$LN7@emit:

; 482  : 	    break;
; 483  : 	case '/':
; 484  : 	    tokenBase.push_back(POLY_DIV);

  0006b	8d 45 08	 lea	 eax, DWORD PTR $T3[ebp]
  0006e	c7 45 08 06 00
	00 00		 mov	 DWORD PTR $T3[ebp], 6
  00075	50		 push	 eax
  00076	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  00079	e8 00 00 00 00	 call	 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEX$$QAH@Z ; std::vector<int,std::allocator<int> >::push_back
  0007e	5e		 pop	 esi

; 524  : }

  0007f	5d		 pop	 ebp
  00080	c2 08 00	 ret	 8
$LN8@emit:

; 485  : 	    break;
; 486  : 	case '%':
; 487  : 	    tokenBase.push_back(POLY_MOD);

  00083	8d 45 08	 lea	 eax, DWORD PTR $T2[ebp]
  00086	c7 45 08 1a 00
	00 00		 mov	 DWORD PTR $T2[ebp], 26	; 0000001aH
  0008d	50		 push	 eax
  0008e	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  00091	e8 00 00 00 00	 call	 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEX$$QAH@Z ; std::vector<int,std::allocator<int> >::push_back
  00096	5e		 pop	 esi

; 524  : }

  00097	5d		 pop	 ebp
  00098	c2 08 00	 ret	 8
$LN9@emit:

; 488  : 	    break;
; 489  : 	case '^':
; 490  : 	    tokenBase.push_back(POLY_POW);

  0009b	8d 45 08	 lea	 eax, DWORD PTR $T1[ebp]
  0009e	c7 45 08 04 00
	00 00		 mov	 DWORD PTR $T1[ebp], 4
  000a5	50		 push	 eax
  000a6	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  000a9	e8 00 00 00 00	 call	 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEX$$QAH@Z ; std::vector<int,std::allocator<int> >::push_back
  000ae	5e		 pop	 esi

; 524  : }

  000af	5d		 pop	 ebp
  000b0	c2 08 00	 ret	 8
$LN10@emit:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  000b3	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 509  : 	    tokenBase.push_back(t);

  000b6	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  000b9	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  000bc	74 0b		 je	 SHORT $LN34@emit

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  000be	89 10		 mov	 DWORD PTR [eax], edx

; 729  :         ++_Mylast;

  000c0	83 41 04 04	 add	 DWORD PTR [ecx+4], 4
  000c4	5e		 pop	 esi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 524  : }

  000c5	5d		 pop	 ebp
  000c6	c2 08 00	 ret	 8
$LN34@emit:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  000c9	8d 55 08	 lea	 edx, DWORD PTR _t$[ebp]
  000cc	52		 push	 edx
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>
  000d3	5e		 pop	 esi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 524  : }

  000d4	5d		 pop	 ebp
  000d5	c2 08 00	 ret	 8
$LN27@emit:

; 510  : 	    break;
; 511  : 	case POLY_NUM:
; 512  : 	    tokenBase.push_back(t);

  000d8	8d 45 08	 lea	 eax, DWORD PTR _t$[ebp]
  000db	50		 push	 eax
  000dc	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  000df	e8 00 00 00 00	 call	 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  000e4	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 513  : 	    numBase.push_back(iNumToken);

  000e7	8d 4e 34	 lea	 ecx, DWORD PTR [esi+52]
  000ea	8d 56 10	 lea	 edx, DWORD PTR [esi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  000ed	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  000f0	74 13		 je	 SHORT $LN41@emit
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

  000f2	f2 0f 10 02	 movsd	 xmm0, QWORD PTR [edx]
  000f6	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 729  :         ++_Mylast;

  000fa	83 c0 08	 add	 eax, 8
  000fd	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00100	5e		 pop	 esi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 524  : }

  00101	5d		 pop	 ebp
  00102	c2 08 00	 ret	 8
$LN41@emit:
  00105	5e		 pop	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00106	89 55 0c	 mov	 DWORD PTR _tval$[ebp], edx
  00109	89 45 08	 mov	 DWORD PTR _t$[ebp], eax
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 524  : }

  0010c	5d		 pop	 ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0010d	e9 00 00 00 00	 jmp	 ??$_Emplace_reallocate@ABN@?$vector@NV?$allocator@N@std@@@std@@QAEPANQANABN@Z ; std::vector<double,std::allocator<double> >::_Emplace_reallocate<double const &>
$LN28@emit:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 516  : 	    tokenBase.push_back(t);

  00112	8d 45 08	 lea	 eax, DWORD PTR _t$[ebp]
  00115	50		 push	 eax
  00116	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  00119	e8 00 00 00 00	 call	 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 517  : 	    tokenBase.push_back(tval); break;

  0011e	8d 45 0c	 lea	 eax, DWORD PTR _tval$[ebp]
  00121	50		 push	 eax
  00122	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  00125	e8 00 00 00 00	 call	 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
  0012a	5e		 pop	 esi

; 524  : }

  0012b	5d		 pop	 ebp
  0012c	c2 08 00	 ret	 8
$LN29@emit:

; 518  : 	default:
; 519  : 	    error();

  0012f	e8 00 00 00 00	 call	 ?error@CPoly@@IAEXXZ	; CPoly::error

; 520  : 	    Clear();

  00134	8b ce		 mov	 ecx, esi
  00136	e8 00 00 00 00	 call	 ?Clear@CPoly@@QAEXXZ	; CPoly::Clear
  0013b	5e		 pop	 esi

; 524  : }

  0013c	5d		 pop	 ebp
  0013d	c2 08 00	 ret	 8
$LN48@emit:
  00140	00 00 00 00	 DD	 $LN10@emit
  00144	00 00 00 00	 DD	 $LN27@emit
  00148	00 00 00 00	 DD	 $LN28@emit
  0014c	00 00 00 00	 DD	 $LN8@emit
  00150	00 00 00 00	 DD	 $LN6@emit
  00154	00 00 00 00	 DD	 $LN4@emit
  00158	00 00 00 00	 DD	 $LN5@emit
  0015c	00 00 00 00	 DD	 $LN7@emit
  00160	00 00 00 00	 DD	 $LN9@emit
  00164	00 00 00 00	 DD	 $LN29@emit
$LN47@emit:
  00168	00		 DB	 0
  00169	09		 DB	 9
  0016a	09		 DB	 9
  0016b	09		 DB	 9
  0016c	09		 DB	 9
  0016d	09		 DB	 9
  0016e	09		 DB	 9
  0016f	09		 DB	 9
  00170	01		 DB	 1
  00171	02		 DB	 2
  00172	09		 DB	 9
  00173	00		 DB	 0
  00174	00		 DB	 0
  00175	00		 DB	 0
  00176	00		 DB	 0
  00177	00		 DB	 0
  00178	00		 DB	 0
  00179	00		 DB	 0
  0017a	00		 DB	 0
  0017b	00		 DB	 0
  0017c	00		 DB	 0
  0017d	00		 DB	 0
  0017e	00		 DB	 0
  0017f	00		 DB	 0
  00180	00		 DB	 0
  00181	00		 DB	 0
  00182	00		 DB	 0
  00183	09		 DB	 9
  00184	09		 DB	 9
  00185	09		 DB	 9
  00186	09		 DB	 9
  00187	09		 DB	 9
  00188	09		 DB	 9
  00189	09		 DB	 9
  0018a	09		 DB	 9
  0018b	09		 DB	 9
  0018c	03		 DB	 3
  0018d	09		 DB	 9
  0018e	09		 DB	 9
  0018f	09		 DB	 9
  00190	09		 DB	 9
  00191	04		 DB	 4
  00192	05		 DB	 5
  00193	09		 DB	 9
  00194	06		 DB	 6
  00195	09		 DB	 9
  00196	07		 DB	 7
  00197	09		 DB	 9
  00198	09		 DB	 9
  00199	09		 DB	 9
  0019a	09		 DB	 9
  0019b	09		 DB	 9
  0019c	09		 DB	 9
  0019d	09		 DB	 9
  0019e	09		 DB	 9
  0019f	09		 DB	 9
  001a0	09		 DB	 9
  001a1	09		 DB	 9
  001a2	09		 DB	 9
  001a3	09		 DB	 9
  001a4	09		 DB	 9
  001a5	09		 DB	 9
  001a6	09		 DB	 9
  001a7	09		 DB	 9
  001a8	09		 DB	 9
  001a9	09		 DB	 9
  001aa	09		 DB	 9
  001ab	09		 DB	 9
  001ac	09		 DB	 9
  001ad	09		 DB	 9
  001ae	09		 DB	 9
  001af	09		 DB	 9
  001b0	09		 DB	 9
  001b1	09		 DB	 9
  001b2	09		 DB	 9
  001b3	09		 DB	 9
  001b4	09		 DB	 9
  001b5	09		 DB	 9
  001b6	09		 DB	 9
  001b7	09		 DB	 9
  001b8	09		 DB	 9
  001b9	09		 DB	 9
  001ba	09		 DB	 9
  001bb	09		 DB	 9
  001bc	09		 DB	 9
  001bd	09		 DB	 9
  001be	09		 DB	 9
  001bf	09		 DB	 9
  001c0	09		 DB	 9
  001c1	09		 DB	 9
  001c2	09		 DB	 9
  001c3	09		 DB	 9
  001c4	09		 DB	 9
  001c5	08		 DB	 8
?emit@CPoly@@IAEXHH@Z ENDP				; CPoly::emit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
;	COMDAT ?find@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
tv433 = -20						; size = 4
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_m$1$ = -8						; size = 4
_l$1$ = -4						; size = 4
_s$ = 8							; size = 4
?find@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CPoly::find, COMDAT
; _this$ = ecx

; 527  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx

; 528  :     int l, m, r;
; 529  : 
; 530  :     l = 0;
; 531  :     r = STSize - 1;

  00007	8b 59 58	 mov	 ebx, DWORD PTR [ecx+88]
  0000a	33 c0		 xor	 eax, eax
  0000c	83 eb 01	 sub	 ebx, 1
  0000f	89 45 fc	 mov	 DWORD PTR _l$1$[ebp], eax
  00012	56		 push	 esi
  00013	57		 push	 edi

; 532  : 
; 533  :     while (l <= r)

  00014	0f 88 d5 00 00
	00		 js	 $LN3@find
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  0001a	8b 71 4c	 mov	 esi, DWORD PTR [ecx+76]
  0001d	8b 79 40	 mov	 edi, DWORD PTR [ecx+64]
  00020	89 75 f4	 mov	 DWORD PTR $T2[ebp], esi
  00023	89 7d f0	 mov	 DWORD PTR $T1[ebp], edi
$LN52@find:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 535  : 	m = (l + r) >> 1;

  00026	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00029	03 c3		 add	 eax, ebx
  0002b	d1 f8		 sar	 eax, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2305 :         const value_type* _Result = _Bx._Buf;

  0002d	8b d1		 mov	 edx, ecx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 535  : 	m = (l + r) >> 1;

  0002f	89 45 f8	 mov	 DWORD PTR _m$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  00032	8b 04 86	 mov	 eax, DWORD PTR [esi+eax*4]
  00035	89 45 ec	 mov	 DWORD PTR tv433[ebp], eax
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 537  : 	if (lSymbol[SymbolIndex[m]]->strlex == s)

  00038	8b 3c 87	 mov	 edi, DWORD PTR [edi+eax*4]
  0003b	83 c7 14	 add	 edi, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  0003e	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 2306 :         if (_Large_string_engaged()) {

  00042	72 02		 jb	 SHORT $LN18@find

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  00044	8b 11		 mov	 edx, DWORD PTR [ecx]
$LN18@find:

; 2319 :         return _BUF_SIZE <= _Myres;

  00046	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H

; 2305 :         const value_type* _Result = _Bx._Buf;

  0004a	8b c7		 mov	 eax, edi

; 2306 :         if (_Large_string_engaged()) {

  0004c	72 02		 jb	 SHORT $LN23@find

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  0004e	8b 07		 mov	 eax, DWORD PTR [edi]
$LN23@find:

; 4372 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00050	8b 77 10	 mov	 esi, DWORD PTR [edi+16]

; 583  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  00053	3b 71 10	 cmp	 esi, DWORD PTR [ecx+16]
  00056	75 5b		 jne	 SHORT $LN29@find

; 392  :         return _CSTD memcmp(_First1, _First2, _Count);

  00058	83 ee 04	 sub	 esi, 4
  0005b	72 14		 jb	 SHORT $LN48@find
  0005d	0f 1f 00	 npad	 3
$LL49@find:
  00060	8b 08		 mov	 ecx, DWORD PTR [eax]
  00062	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00064	75 10		 jne	 SHORT $LN47@find
  00066	83 c0 04	 add	 eax, 4
  00069	83 c2 04	 add	 edx, 4
  0006c	83 ee 04	 sub	 esi, 4
  0006f	73 ef		 jae	 SHORT $LL49@find
$LN48@find:
  00071	83 fe fc	 cmp	 esi, -4			; fffffffcH
  00074	74 34		 je	 SHORT $LN46@find
$LN47@find:
  00076	8a 08		 mov	 cl, BYTE PTR [eax]
  00078	3a 0a		 cmp	 cl, BYTE PTR [edx]
  0007a	75 27		 jne	 SHORT $LN50@find
  0007c	83 fe fd	 cmp	 esi, -3			; fffffffdH
  0007f	74 29		 je	 SHORT $LN46@find
  00081	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00084	3a 4a 01	 cmp	 cl, BYTE PTR [edx+1]
  00087	75 1a		 jne	 SHORT $LN50@find
  00089	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0008c	74 1c		 je	 SHORT $LN46@find
  0008e	8a 48 02	 mov	 cl, BYTE PTR [eax+2]
  00091	3a 4a 02	 cmp	 cl, BYTE PTR [edx+2]
  00094	75 0d		 jne	 SHORT $LN50@find
  00096	83 fe ff	 cmp	 esi, -1
  00099	74 0f		 je	 SHORT $LN46@find
  0009b	8a 40 03	 mov	 al, BYTE PTR [eax+3]
  0009e	3a 42 03	 cmp	 al, BYTE PTR [edx+3]
  000a1	74 07		 je	 SHORT $LN46@find
$LN50@find:
  000a3	1b c0		 sbb	 eax, eax
  000a5	83 c8 01	 or	 eax, 1
  000a8	eb 02		 jmp	 SHORT $LN51@find
$LN46@find:
  000aa	33 c0		 xor	 eax, eax
$LN51@find:

; 583  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  000ac	85 c0		 test	 eax, eax
  000ae	74 33		 je	 SHORT $LN40@find
  000b0	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
$LN29@find:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 539  : 	else if (lSymbol[SymbolIndex[m]]->strlex < s)

  000b3	51		 push	 ecx
  000b4	57		 push	 edi
  000b5	e8 00 00 00 00	 call	 ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
  000ba	8b 55 f8	 mov	 edx, DWORD PTR _m$1$[ebp]
  000bd	8a c8		 mov	 cl, al
  000bf	83 c4 08	 add	 esp, 8
  000c2	84 c9		 test	 cl, cl
  000c4	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  000c7	0f 44 d8	 cmove	 ebx, eax
  000ca	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  000cd	0f 44 45 fc	 cmove	 eax, DWORD PTR _l$1$[ebp]
  000d1	89 45 fc	 mov	 DWORD PTR _l$1$[ebp], eax
  000d4	3b c3		 cmp	 eax, ebx
  000d6	7f 17		 jg	 SHORT $LN3@find

; 532  : 
; 533  :     while (l <= r)

  000d8	8b 75 f4	 mov	 esi, DWORD PTR $T2[ebp]
  000db	8b 7d f0	 mov	 edi, DWORD PTR $T1[ebp]
  000de	e9 43 ff ff ff	 jmp	 $LN52@find
$LN40@find:

; 538  : 	    return SymbolIndex[m];

  000e3	8b 45 ec	 mov	 eax, DWORD PTR tv433[ebp]
  000e6	5f		 pop	 edi

; 540  : 	    l = m + 1;
; 541  : 	else
; 542  : 	    r = m - 1;
; 543  :     }
; 544  :     return -1;
; 545  : }

  000e7	5e		 pop	 esi
  000e8	5b		 pop	 ebx
  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c2 04 00	 ret	 4
$LN3@find:
  000ef	5f		 pop	 edi
  000f0	5e		 pop	 esi
  000f1	83 c8 ff	 or	 eax, -1
  000f4	5b		 pop	 ebx
  000f5	8b e5		 mov	 esp, ebp
  000f7	5d		 pop	 ebp
  000f8	c2 04 00	 ret	 4
?find@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CPoly::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
;	COMDAT ?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
_TEXT	SEGMENT
$T3 = -32						; size = 4
tv1030 = -28						; size = 4
$T4 = -28						; size = 4
tv1037 = -24						; size = 4
__Right_size$1$ = -24					; size = 4
tv1045 = -20						; size = 4
__Result$1$ = -20					; size = 4
_this$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_s$ = 8							; size = 4
__Val$1$ = 12						; size = 4
$T5 = 12						; size = 4
_tok$ = 12						; size = 4
?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z PROC ; CPoly::insert, COMDAT
; _this$ = ecx

; 548  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	89 4d f0	 mov	 DWORD PTR _this$1$[ebp], ecx

; 552  :     lSymbol.push_back(new CSymTable(tok,s));

  0002a	6a 30		 push	 48			; 00000030H
  0002c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00031	83 c4 04	 add	 esp, 4
  00034	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
  00037	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
  0003a	85 c0		 test	 eax, eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00046	0f 84 a5 00 00
	00		 je	 $LN8@insert
  0004c	83 ec 18	 sub	 esp, 24			; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2305 :         const value_type* _Result = _Bx._Buf;

  0004f	89 45 ec	 mov	 DWORD PTR __Result$1$[ebp], eax
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 552  :     lSymbol.push_back(new CSymTable(tok,s));

  00052	8b f4		 mov	 esi, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2305 :         const value_type* _Result = _Bx._Buf;

  00054	8b d0		 mov	 edx, eax

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00056	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 2355 :     size_type _Mysize = 0; // current length of string

  0005c	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 2356 :     size_type _Myres  = 0; // current storage reserved for string

  00063	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 2306 :         if (_Large_string_engaged()) {

  0006a	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 2921 :         const size_type _Right_size   = _Right_data._Mysize;

  0006e	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00071	89 4d e8	 mov	 DWORD PTR __Right_size$1$[ebp], ecx

; 2306 :         if (_Large_string_engaged()) {

  00074	72 05		 jb	 SHORT $LN26@insert

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  00076	8b 10		 mov	 edx, DWORD PTR [eax]
  00078	89 55 ec	 mov	 DWORD PTR __Result$1$[ebp], edx
$LN26@insert:

; 2933 :         if (_Stay_small) { // stay small, don't allocate

  0007b	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0007e	73 0d		 jae	 SHORT $LN23@insert

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00080	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]

; 2936 :             _My_data._Myres  = _BUF_SIZE - 1;

  00083	bf 0f 00 00 00	 mov	 edi, 15			; 0000000fH

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00088	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0

; 2937 :             return;

  0008b	eb 4f		 jmp	 SHORT $LN22@insert
$LN23@insert:

; 2938 :         }
; 2939 : 
; 2940 :         auto& _Al                     = _Getal();
; 2941 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  0008d	8b f9		 mov	 edi, ecx
  0008f	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00094	83 cf 0f	 or	 edi, 15			; 0000000fH
  00097	3b f8		 cmp	 edi, eax
  00099	0f 47 f8	 cmova	 edi, eax

; 2942 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  0009c	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0009f	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000a4	72 0d		 jb	 SHORT $LN37@insert

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000ac	83 c4 04	 add	 esp, 4
  000af	8b c8		 mov	 ecx, eax
  000b1	eb 13		 jmp	 SHORT $LN36@insert
$LN37@insert:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  000b3	85 c0		 test	 eax, eax
  000b5	74 0d		 je	 SHORT $LN38@insert

; 85   :         return ::operator new(_Bytes);

  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000bd	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  000c0	8b c8		 mov	 ecx, eax
  000c2	eb 02		 jmp	 SHORT $LN36@insert
$LN38@insert:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000c4	33 c9		 xor	 ecx, ecx
$LN36@insert:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2950 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  000c6	8b 45 e8	 mov	 eax, DWORD PTR __Right_size$1$[ebp]
  000c9	40		 inc	 eax
  000ca	89 0e		 mov	 DWORD PTR [esi], ecx

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000cc	50		 push	 eax
  000cd	ff 75 ec	 push	 DWORD PTR __Result$1$[ebp]
  000d0	51		 push	 ecx
  000d1	e8 00 00 00 00	 call	 _memcpy
  000d6	8b 4d e8	 mov	 ecx, DWORD PTR __Right_size$1$[ebp]
  000d9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN22@insert:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 552  :     lSymbol.push_back(new CSymTable(tok,s));

  000dc	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  000df	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  000e2	ff 75 0c	 push	 DWORD PTR _tok$[ebp]
  000e5	8b 4d e4	 mov	 ecx, DWORD PTR $T4[ebp]
  000e8	e8 00 00 00 00	 call	 ??0CSymTable@@QAE@HV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CSymTable::CSymTable
  000ed	8b c8		 mov	 ecx, eax
  000ef	eb 02		 jmp	 SHORT $LN9@insert
$LN8@insert:
  000f1	33 c9		 xor	 ecx, ecx
$LN9@insert:
  000f3	8b 55 f0	 mov	 edx, DWORD PTR _this$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  000f6	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 552  :     lSymbol.push_back(new CSymTable(tok,s));

  000f9	8d 7a 40	 lea	 edi, DWORD PTR [edx+64]
  000fc	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00103	89 4d 0c	 mov	 DWORD PTR $T5[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  00106	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  00109	74 08		 je	 SHORT $LN47@insert

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0010b	89 08		 mov	 DWORD PTR [eax], ecx

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

  0010d	83 47 04 04	 add	 DWORD PTR [edi+4], 4

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00111	eb 0f		 jmp	 SHORT $LN46@insert
$LN47@insert:

; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00113	8d 4d 0c	 lea	 ecx, DWORD PTR $T5[ebp]
  00116	51		 push	 ecx
  00117	50		 push	 eax
  00118	8b cf		 mov	 ecx, edi
  0011a	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@PAVCSymTable@@@?$vector@PAVCSymTable@@V?$allocator@PAVCSymTable@@@std@@@std@@QAEPAPAVCSymTable@@QAPAV2@$$QAPAV2@@Z ; std::vector<CSymTable *,std::allocator<CSymTable *> >::_Emplace_reallocate<CSymTable *>
  0011f	8b 55 f0	 mov	 edx, DWORD PTR _this$1$[ebp]
$LN46@insert:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 553  :     for (i=0;i<STSize;i++)

  00122	8b 4a 58	 mov	 ecx, DWORD PTR [edx+88]
  00125	8d 42 58	 lea	 eax, DWORD PTR [edx+88]
  00128	33 f6		 xor	 esi, esi
  0012a	89 45 0c	 mov	 DWORD PTR __Val$1$[ebp], eax
  0012d	89 4d ec	 mov	 DWORD PTR tv1045[ebp], ecx
  00130	85 c9		 test	 ecx, ecx
  00132	7e 37		 jle	 SHORT $LN106@insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  00134	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  00137	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00139	8b f8		 mov	 edi, eax
  0013b	89 45 e8	 mov	 DWORD PTR tv1037[ebp], eax
  0013e	89 4d e4	 mov	 DWORD PTR tv1030[ebp], ecx
$LL4@insert:
  00141	8b 07		 mov	 eax, DWORD PTR [edi]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 555  : 	if (s<lSymbol[SymbolIndex[i]]->strlex)

  00143	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00146	83 c0 14	 add	 eax, 20			; 00000014H
  00149	50		 push	 eax
  0014a	ff 75 08	 push	 DWORD PTR _s$[ebp]
  0014d	e8 00 00 00 00	 call	 ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
  00152	83 c4 08	 add	 esp, 8
  00155	84 c0		 test	 al, al
  00157	75 27		 jne	 SHORT $LN102@insert

; 553  :     for (i=0;i<STSize;i++)

  00159	8b 4d e4	 mov	 ecx, DWORD PTR tv1030[ebp]
  0015c	46		 inc	 esi
  0015d	83 c7 04	 add	 edi, 4
  00160	3b 75 ec	 cmp	 esi, DWORD PTR tv1045[ebp]
  00163	7c dc		 jl	 SHORT $LL4@insert

; 555  : 	if (s<lSymbol[SymbolIndex[i]]->strlex)

  00165	8b 45 0c	 mov	 eax, DWORD PTR __Val$1$[ebp]
  00168	8b 55 f0	 mov	 edx, DWORD PTR _this$1$[ebp]
$LN106@insert:

; 563  :     {
; 564  : 	//SymbolIndex.SetAtGrow(STSize,STSize);
; 565  : 	SymbolIndex.push_back(STSize);

  0016b	8d 4a 4c	 lea	 ecx, DWORD PTR [edx+76]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

  0016e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00171	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00174	74 57		 je	 SHORT $LN97@insert

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00176	8b 00		 mov	 eax, DWORD PTR [eax]
  00178	89 02		 mov	 DWORD PTR [edx], eax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

  0017a	83 41 04 04	 add	 DWORD PTR [ecx+4], 4

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0017e	eb 54		 jmp	 SHORT $LN108@insert
$LN102@insert:

; 123  :         _Ptr += _Off;

  00180	8b 45 e8	 mov	 eax, DWORD PTR tv1037[ebp]

; 814  :         const pointer _Oldlast  = _My_data._Mylast;

  00183	8b 55 f0	 mov	 edx, DWORD PTR _this$1$[ebp]

; 123  :         _Ptr += _Off;

  00186	8d 3c b0	 lea	 edi, DWORD PTR [eax+esi*4]

; 814  :         const pointer _Oldlast  = _My_data._Mylast;

  00189	8b 72 50	 mov	 esi, DWORD PTR [edx+80]

; 815  : #if _ITERATOR_DEBUG_LEVEL == 2
; 816  :         _STL_VERIFY(
; 817  :             _Where._Getcont() == _STD addressof(_My_data) && _Whereptr >= _My_data._Myfirst && _Oldlast >= _Whereptr,
; 818  :             "vector emplace iterator outside range");
; 819  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 820  : 
; 821  :         if (_Oldlast != _My_data._Myend) {

  0018c	3b 72 54	 cmp	 esi, DWORD PTR [edx+84]
  0018f	74 2d		 je	 SHORT $LN70@insert

; 822  :             if (_Whereptr == _Oldlast) { // at back, provide strong guarantee

  00191	3b fe		 cmp	 edi, esi
  00193	75 0b		 jne	 SHORT $LN71@insert

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00195	8b 45 ec	 mov	 eax, DWORD PTR tv1045[ebp]
  00198	89 06		 mov	 DWORD PTR [esi], eax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

  0019a	83 42 50 04	 add	 DWORD PTR [edx+80], 4

; 824  :             } else {

  0019e	eb 34		 jmp	 SHORT $LN108@insert
$LN71@insert:

; 829  :                 _Alty_traits::construct(_Al, _Unfancy(_Oldlast), _STD move(_Oldlast[-1]));

  001a0	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  001a3	8d 4e fc	 lea	 ecx, DWORD PTR [esi-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xutility

; 4468 :             return _Copy_backward_memmove(_First, _Last, _Dest);

  001a6	56		 push	 esi
  001a7	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 829  :                 _Alty_traits::construct(_Al, _Unfancy(_Oldlast), _STD move(_Oldlast[-1]));

  001a8	89 06		 mov	 DWORD PTR [esi], eax

; 830  :                 ++_My_data._Mylast;

  001aa	83 42 50 04	 add	 DWORD PTR [edx+80], 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xutility

; 4468 :             return _Copy_backward_memmove(_First, _Last, _Dest);

  001ae	57		 push	 edi
  001af	e8 00 00 00 00	 call	 ??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z ; std::_Copy_backward_memmove<int *,int *>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 832  :                 *_Whereptr = _STD move(_Obj._Storage._Value);

  001b4	8b 45 ec	 mov	 eax, DWORD PTR tv1045[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xutility

; 4468 :             return _Copy_backward_memmove(_First, _Last, _Dest);

  001b7	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 832  :                 *_Whereptr = _STD move(_Obj._Storage._Value);

  001ba	89 07		 mov	 DWORD PTR [edi], eax

; 833  :             }
; 834  : 
; 835  :             return _Make_iterator(_Whereptr);

  001bc	eb 16		 jmp	 SHORT $LN108@insert
$LN70@insert:

; 836  :         }
; 837  : 
; 838  :         return _Make_iterator(_Emplace_reallocate(_Whereptr, _STD forward<_Valty>(_Val)...));

  001be	8b 75 0c	 mov	 esi, DWORD PTR __Val$1$[ebp]
  001c1	8d 4a 4c	 lea	 ecx, DWORD PTR [edx+76]
  001c4	56		 push	 esi
  001c5	57		 push	 edi
  001c6	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 562  :     if (!bAdded)

  001cb	eb 0a		 jmp	 SHORT $LN96@insert
$LN97@insert:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  001cd	50		 push	 eax
  001ce	52		 push	 edx
  001cf	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>
$LN108@insert:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 567  :     STSize++;

  001d4	8b 75 0c	 mov	 esi, DWORD PTR __Val$1$[ebp]
$LN96@insert:
  001d7	8b 06		 mov	 eax, DWORD PTR [esi]
  001d9	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  001dc	89 0e		 mov	 DWORD PTR [esi], ecx

; 568  :     return STSize-1;
; 569  : }

  001de	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001e1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e8	59		 pop	 ecx
  001e9	5f		 pop	 edi
  001ea	5e		 pop	 esi
  001eb	8b e5		 mov	 esp, ebp
  001ed	5d		 pop	 ebp
  001ee	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z$0:
  00000	6a 30		 push	 48			; 00000030H
  00002	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
__ehhandler$?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z:
  00014	90		 npad	 1
  00015	90		 npad	 1
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ENDP ; CPoly::insert
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
;	COMDAT ?init@CPoly@@IAEXXZ
_TEXT	SEGMENT
$T2 = -40						; size = 24
$T3 = -40						; size = 24
$T4 = -40						; size = 24
$T5 = -40						; size = 24
$T6 = -40						; size = 24
$T7 = -40						; size = 24
$T8 = -40						; size = 24
$T9 = -40						; size = 24
$T10 = -40						; size = 24
$T11 = -40						; size = 24
$T12 = -40						; size = 24
$T13 = -40						; size = 24
$T14 = -40						; size = 24
$T15 = -40						; size = 24
$T16 = -40						; size = 24
$T17 = -40						; size = 24
$T18 = -40						; size = 24
$T19 = -40						; size = 24
$T20 = -40						; size = 24
$T21 = -40						; size = 24
$T22 = -40						; size = 24
$T23 = -40						; size = 24
$T24 = -40						; size = 24
$T25 = -40						; size = 24
$T26 = -40						; size = 24
$T27 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?init@CPoly@@IAEXXZ PROC				; CPoly::init, COMDAT
; _this$ = ecx

; 594  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?init@CPoly@@IAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0002b	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_03KLIPLJLL@min@

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00031	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T27[ebp], 0

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00038	66 89 45 d8	 mov	 WORD PTR $T27[ebp], ax
  0003c	a0 02 00 00 00	 mov	 al, BYTE PTR ??_C@_03KLIPLJLL@min@+2

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00041	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T27[ebp+20], 15 ; 0000000fH

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  00048	c7 45 e8 03 00
	00 00		 mov	 DWORD PTR $T27[ebp+16], 3

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0004f	88 45 da	 mov	 BYTE PTR $T27[ebp+2], al

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00052	c6 45 db 00	 mov	 BYTE PTR $T27[ebp+3], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 595  :     insert("min",POLY_MINF);

  00056	6a 16		 push	 22			; 00000016H
  00058	8d 45 d8	 lea	 eax, DWORD PTR $T27[ebp]
  0005b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 ?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPoly::insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00068	8b 55 ec	 mov	 edx, DWORD PTR $T27[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 595  :     insert("min",POLY_MINF);

  0006b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00072	83 fa 10	 cmp	 edx, 16			; 00000010H
  00075	72 2c		 jb	 SHORT $LN114@init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00077	8b 4d d8	 mov	 ecx, DWORD PTR $T27[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0007a	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0007b	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0007d	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00083	72 14		 jb	 SHORT $LN124@init

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00085	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00088	83 c2 23	 add	 edx, 35			; 00000023H
  0008b	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0008d	83 c0 fc	 add	 eax, -4			; fffffffcH
  00090	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00093	0f 87 9c 0b 00
	00		 ja	 $LN1644@init
$LN124@init:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00099	52		 push	 edx
  0009a	51		 push	 ecx
  0009b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000a0	83 c4 08	 add	 esp, 8
$LN114@init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  000a3	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_03LJAEFNNE@max@

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  000a9	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T26[ebp], 0

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  000b0	66 89 45 d8	 mov	 WORD PTR $T26[ebp], ax
  000b4	a0 02 00 00 00	 mov	 al, BYTE PTR ??_C@_03LJAEFNNE@max@+2

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  000b9	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T26[ebp+20], 15 ; 0000000fH

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  000c0	c7 45 e8 03 00
	00 00		 mov	 DWORD PTR $T26[ebp+16], 3

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  000c7	88 45 da	 mov	 BYTE PTR $T26[ebp+2], al

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  000ca	c6 45 db 00	 mov	 BYTE PTR $T26[ebp+3], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 596  :     insert("max",POLY_MAXF);

  000ce	6a 17		 push	 23			; 00000017H
  000d0	8d 45 d8	 lea	 eax, DWORD PTR $T26[ebp]
  000d3	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000da	50		 push	 eax
  000db	8b ce		 mov	 ecx, esi
  000dd	e8 00 00 00 00	 call	 ?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPoly::insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  000e2	8b 55 ec	 mov	 edx, DWORD PTR $T26[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 596  :     insert("max",POLY_MAXF);

  000e5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  000ec	83 fa 10	 cmp	 edx, 16			; 00000010H
  000ef	72 2c		 jb	 SHORT $LN213@init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000f1	8b 4d d8	 mov	 ecx, DWORD PTR $T26[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  000f4	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000f5	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000f7	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  000fd	72 14		 jb	 SHORT $LN223@init

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000ff	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00102	83 c2 23	 add	 edx, 35			; 00000023H
  00105	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00107	83 c0 fc	 add	 eax, -4			; fffffffcH
  0010a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0010d	0f 87 22 0b 00
	00		 ja	 $LN1644@init
$LN223@init:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00113	52		 push	 edx
  00114	51		 push	 ecx
  00115	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0011a	83 c4 08	 add	 esp, 8
$LN213@init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0011d	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_06EBGNBFIA@number@
  00122	89 45 d8	 mov	 DWORD PTR $T25[ebp], eax
  00125	66 a1 04 00 00
	00		 mov	 ax, WORD PTR ??_C@_06EBGNBFIA@number@+4

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0012b	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T25[ebp+20], 15 ; 0000000fH

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  00132	c7 45 e8 06 00
	00 00		 mov	 DWORD PTR $T25[ebp+16], 6

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00139	66 89 45 dc	 mov	 WORD PTR $T25[ebp+4], ax

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0013d	c6 45 de 00	 mov	 BYTE PTR $T25[ebp+6], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 597  :     insert("number", POLY_IRAND);

  00141	6a 18		 push	 24			; 00000018H
  00143	8d 45 d8	 lea	 eax, DWORD PTR $T25[ebp]
  00146	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  0014d	50		 push	 eax
  0014e	8b ce		 mov	 ecx, esi
  00150	e8 00 00 00 00	 call	 ?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPoly::insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00155	8b 55 ec	 mov	 edx, DWORD PTR $T25[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 597  :     insert("number", POLY_IRAND);

  00158	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0015f	83 fa 10	 cmp	 edx, 16			; 00000010H
  00162	72 2c		 jb	 SHORT $LN312@init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00164	8b 4d d8	 mov	 ecx, DWORD PTR $T25[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00167	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00168	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0016a	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00170	72 14		 jb	 SHORT $LN322@init

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00172	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00175	83 c2 23	 add	 edx, 35			; 00000023H
  00178	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0017a	83 c0 fc	 add	 eax, -4			; fffffffcH
  0017d	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00180	0f 87 af 0a 00
	00		 ja	 $LN1644@init
$LN322@init:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00186	52		 push	 edx
  00187	51		 push	 ecx
  00188	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0018d	83 c4 08	 add	 esp, 8
$LN312@init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00190	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_07OMLILGHE@irandom@
  00195	89 45 d8	 mov	 DWORD PTR $T24[ebp], eax
  00198	66 a1 04 00 00
	00		 mov	 ax, WORD PTR ??_C@_07OMLILGHE@irandom@+4
  0019e	66 89 45 dc	 mov	 WORD PTR $T24[ebp+4], ax
  001a2	a0 06 00 00 00	 mov	 al, BYTE PTR ??_C@_07OMLILGHE@irandom@+6

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  001a7	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T24[ebp+20], 15 ; 0000000fH

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  001ae	c7 45 e8 07 00
	00 00		 mov	 DWORD PTR $T24[ebp+16], 7

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  001b5	88 45 de	 mov	 BYTE PTR $T24[ebp+6], al

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  001b8	c6 45 df 00	 mov	 BYTE PTR $T24[ebp+7], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 598  :     insert("irandom", POLY_IRAND);

  001bc	6a 18		 push	 24			; 00000018H
  001be	8d 45 d8	 lea	 eax, DWORD PTR $T24[ebp]
  001c1	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  001c8	50		 push	 eax
  001c9	8b ce		 mov	 ecx, esi
  001cb	e8 00 00 00 00	 call	 ?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPoly::insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  001d0	8b 55 ec	 mov	 edx, DWORD PTR $T24[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 598  :     insert("irandom", POLY_IRAND);

  001d3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  001da	83 fa 10	 cmp	 edx, 16			; 00000010H
  001dd	72 2c		 jb	 SHORT $LN411@init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001df	8b 4d d8	 mov	 ecx, DWORD PTR $T24[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  001e2	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001e3	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  001e5	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001eb	72 14		 jb	 SHORT $LN421@init

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001ed	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  001f0	83 c2 23	 add	 edx, 35			; 00000023H
  001f3	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001f5	83 c0 fc	 add	 eax, -4			; fffffffcH
  001f8	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001fb	0f 87 34 0a 00
	00		 ja	 $LN1644@init
$LN421@init:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00201	52		 push	 edx
  00202	51		 push	 ecx
  00203	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00208	83 c4 08	 add	 esp, 8
$LN411@init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0020b	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_05CCJGGLIO@irand@
  00210	89 45 d8	 mov	 DWORD PTR $T23[ebp], eax
  00213	a0 04 00 00 00	 mov	 al, BYTE PTR ??_C@_05CCJGGLIO@irand@+4

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00218	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T23[ebp+20], 15 ; 0000000fH

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  0021f	c7 45 e8 05 00
	00 00		 mov	 DWORD PTR $T23[ebp+16], 5

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00226	88 45 dc	 mov	 BYTE PTR $T23[ebp+4], al

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00229	c6 45 dd 00	 mov	 BYTE PTR $T23[ebp+5], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 599  :     insert("irand", POLY_IRAND);

  0022d	6a 18		 push	 24			; 00000018H
  0022f	8d 45 d8	 lea	 eax, DWORD PTR $T23[ebp]
  00232	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4
  00239	50		 push	 eax
  0023a	8b ce		 mov	 ecx, esi
  0023c	e8 00 00 00 00	 call	 ?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPoly::insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00241	8b 55 ec	 mov	 edx, DWORD PTR $T23[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 599  :     insert("irand", POLY_IRAND);

  00244	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0024b	83 fa 10	 cmp	 edx, 16			; 00000010H
  0024e	72 2c		 jb	 SHORT $LN510@init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00250	8b 4d d8	 mov	 ecx, DWORD PTR $T23[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00253	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00254	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00256	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0025c	72 14		 jb	 SHORT $LN520@init

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0025e	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00261	83 c2 23	 add	 edx, 35			; 00000023H
  00264	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00266	83 c0 fc	 add	 eax, -4			; fffffffcH
  00269	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0026c	0f 87 c3 09 00
	00		 ja	 $LN1644@init
$LN520@init:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00272	52		 push	 edx
  00273	51		 push	 ecx
  00274	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00279	83 c4 08	 add	 esp, 8
$LN510@init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0027c	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_07DFJIKENI@frandom@
  00281	89 45 d8	 mov	 DWORD PTR $T22[ebp], eax
  00284	66 a1 04 00 00
	00		 mov	 ax, WORD PTR ??_C@_07DFJIKENI@frandom@+4
  0028a	66 89 45 dc	 mov	 WORD PTR $T22[ebp+4], ax
  0028e	a0 06 00 00 00	 mov	 al, BYTE PTR ??_C@_07DFJIKENI@frandom@+6

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00293	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T22[ebp+20], 15 ; 0000000fH

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  0029a	c7 45 e8 07 00
	00 00		 mov	 DWORD PTR $T22[ebp+16], 7

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  002a1	88 45 de	 mov	 BYTE PTR $T22[ebp+6], al

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  002a4	c6 45 df 00	 mov	 BYTE PTR $T22[ebp+7], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 600  :     insert("frandom",POLY_FRAND);

  002a8	6a 19		 push	 25			; 00000019H
  002aa	8d 45 d8	 lea	 eax, DWORD PTR $T22[ebp]
  002ad	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5
  002b4	50		 push	 eax
  002b5	8b ce		 mov	 ecx, esi
  002b7	e8 00 00 00 00	 call	 ?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPoly::insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  002bc	8b 55 ec	 mov	 edx, DWORD PTR $T22[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 600  :     insert("frandom",POLY_FRAND);

  002bf	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  002c6	83 fa 10	 cmp	 edx, 16			; 00000010H
  002c9	72 2c		 jb	 SHORT $LN609@init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002cb	8b 4d d8	 mov	 ecx, DWORD PTR $T22[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  002ce	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002cf	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  002d1	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  002d7	72 14		 jb	 SHORT $LN619@init

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  002d9	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  002dc	83 c2 23	 add	 edx, 35			; 00000023H
  002df	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  002e1	83 c0 fc	 add	 eax, -4			; fffffffcH
  002e4	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  002e7	0f 87 48 09 00
	00		 ja	 $LN1644@init
$LN619@init:

; 264  :         ::operator delete(_Ptr, _Bytes);

  002ed	52		 push	 edx
  002ee	51		 push	 ecx
  002ef	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  002f4	83 c4 08	 add	 esp, 8
$LN609@init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  002f7	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_05NDMANJFL@frand@
  002fc	89 45 d8	 mov	 DWORD PTR $T21[ebp], eax
  002ff	a0 04 00 00 00	 mov	 al, BYTE PTR ??_C@_05NDMANJFL@frand@+4

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00304	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T21[ebp+20], 15 ; 0000000fH

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  0030b	c7 45 e8 05 00
	00 00		 mov	 DWORD PTR $T21[ebp+16], 5

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00312	88 45 dc	 mov	 BYTE PTR $T21[ebp+4], al

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00315	c6 45 dd 00	 mov	 BYTE PTR $T21[ebp+5], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 601  :     insert("frand",POLY_FRAND);

  00319	6a 19		 push	 25			; 00000019H
  0031b	8d 45 d8	 lea	 eax, DWORD PTR $T21[ebp]
  0031e	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 6
  00325	50		 push	 eax
  00326	8b ce		 mov	 ecx, esi
  00328	e8 00 00 00 00	 call	 ?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPoly::insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0032d	8b 55 ec	 mov	 edx, DWORD PTR $T21[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 601  :     insert("frand",POLY_FRAND);

  00330	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00337	83 fa 10	 cmp	 edx, 16			; 00000010H
  0033a	72 2c		 jb	 SHORT $LN708@init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0033c	8b 4d d8	 mov	 ecx, DWORD PTR $T21[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0033f	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00340	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00342	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00348	72 14		 jb	 SHORT $LN718@init

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0034a	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0034d	83 c2 23	 add	 edx, 35			; 00000023H
  00350	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00352	83 c0 fc	 add	 eax, -4			; fffffffcH
  00355	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00358	0f 87 d7 08 00
	00		 ja	 $LN1644@init
$LN718@init:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0035e	52		 push	 edx
  0035f	51		 push	 ecx
  00360	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00365	83 c4 08	 add	 esp, 8
$LN708@init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00368	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T20[ebp], 0

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0036f	b8 72 74 00 00	 mov	 eax, 29810		; 00007472H

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00374	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T20[ebp+20], 15 ; 0000000fH

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  0037b	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR $T20[ebp+16], 2

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00382	66 89 45 d8	 mov	 WORD PTR $T20[ebp], ax

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00386	c6 45 da 00	 mov	 BYTE PTR $T20[ebp+2], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 602  :     insert("rt",POLY_ROOT);

  0038a	6a 01		 push	 1
  0038c	8d 45 d8	 lea	 eax, DWORD PTR $T20[ebp]
  0038f	c7 45 fc 07 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 7
  00396	50		 push	 eax
  00397	8b ce		 mov	 ecx, esi
  00399	e8 00 00 00 00	 call	 ?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPoly::insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0039e	8b 55 ec	 mov	 edx, DWORD PTR $T20[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 602  :     insert("rt",POLY_ROOT);

  003a1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  003a8	83 fa 10	 cmp	 edx, 16			; 00000010H
  003ab	72 2c		 jb	 SHORT $LN807@init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003ad	8b 4d d8	 mov	 ecx, DWORD PTR $T20[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  003b0	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003b1	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  003b3	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  003b9	72 14		 jb	 SHORT $LN817@init

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  003bb	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  003be	83 c2 23	 add	 edx, 35			; 00000023H
  003c1	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003c3	83 c0 fc	 add	 eax, -4			; fffffffcH
  003c6	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  003c9	0f 87 66 08 00
	00		 ja	 $LN1644@init
$LN817@init:

; 264  :         ::operator delete(_Ptr, _Bytes);

  003cf	52		 push	 edx
  003d0	51		 push	 ecx
  003d1	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  003d6	83 c4 08	 add	 esp, 8
$LN807@init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  003d9	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T19[ebp+20], 15 ; 0000000fH

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  003e0	c7 45 e8 04 00
	00 00		 mov	 DWORD PTR $T19[ebp+16], 4

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  003e7	c7 45 d8 73 71
	72 74		 mov	 DWORD PTR $T19[ebp], 1953657203 ; 74727173H

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  003ee	c6 45 dc 00	 mov	 BYTE PTR $T19[ebp+4], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 603  :     insert("sqrt",POLY_ROOT);

  003f2	6a 01		 push	 1
  003f4	8d 45 d8	 lea	 eax, DWORD PTR $T19[ebp]
  003f7	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 8
  003fe	50		 push	 eax
  003ff	8b ce		 mov	 ecx, esi
  00401	e8 00 00 00 00	 call	 ?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPoly::insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00406	8b 55 ec	 mov	 edx, DWORD PTR $T19[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 603  :     insert("sqrt",POLY_ROOT);

  00409	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00410	83 fa 10	 cmp	 edx, 16			; 00000010H
  00413	72 2c		 jb	 SHORT $LN906@init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00415	8b 4d d8	 mov	 ecx, DWORD PTR $T19[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00418	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00419	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0041b	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00421	72 14		 jb	 SHORT $LN916@init

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00423	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00426	83 c2 23	 add	 edx, 35			; 00000023H
  00429	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0042b	83 c0 fc	 add	 eax, -4			; fffffffcH
  0042e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00431	0f 87 fe 07 00
	00		 ja	 $LN1644@init
$LN916@init:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00437	52		 push	 edx
  00438	51		 push	 ecx
  00439	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0043e	83 c4 08	 add	 esp, 8
$LN906@init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00441	6a 03		 push	 3

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00443	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T18[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0044a	8d 4d d8	 lea	 ecx, DWORD PTR $T18[ebp]
  0044d	68 00 00 00 00	 push	 OFFSET ??_C@_03LALBNOCG@cos@

; 4596 :         _My_data._Mysize = 0;

  00452	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T18[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00459	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T18[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00460	c6 45 d8 00	 mov	 BYTE PTR $T18[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00464	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 604  :     insert("cos",POLY_COS);

  00469	6a 0c		 push	 12			; 0000000cH
  0046b	8d 45 d8	 lea	 eax, DWORD PTR $T18[ebp]
  0046e	c7 45 fc 09 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 9
  00475	50		 push	 eax
  00476	8b ce		 mov	 ecx, esi
  00478	e8 00 00 00 00	 call	 ?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPoly::insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0047d	8b 55 ec	 mov	 edx, DWORD PTR $T18[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 604  :     insert("cos",POLY_COS);

  00480	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00487	83 fa 10	 cmp	 edx, 16			; 00000010H
  0048a	72 2c		 jb	 SHORT $LN949@init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0048c	8b 4d d8	 mov	 ecx, DWORD PTR $T18[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0048f	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00490	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00492	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00498	72 14		 jb	 SHORT $LN959@init

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0049a	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0049d	83 c2 23	 add	 edx, 35			; 00000023H
  004a0	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  004a2	83 c0 fc	 add	 eax, -4			; fffffffcH
  004a5	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  004a8	0f 87 87 07 00
	00		 ja	 $LN1644@init
$LN959@init:

; 264  :         ::operator delete(_Ptr, _Bytes);

  004ae	52		 push	 edx
  004af	51		 push	 ecx
  004b0	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  004b5	83 c4 08	 add	 esp, 8
$LN949@init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  004b8	6a 03		 push	 3

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  004ba	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T17[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  004c1	8d 4d d8	 lea	 ecx, DWORD PTR $T17[ebp]
  004c4	68 00 00 00 00	 push	 OFFSET ??_C@_03BLEJJJBH@sin@

; 4596 :         _My_data._Mysize = 0;

  004c9	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T17[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  004d0	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T17[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  004d7	c6 45 d8 00	 mov	 BYTE PTR $T17[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  004db	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 605  :     insert("sin",POLY_SIN);

  004e0	6a 0d		 push	 13			; 0000000dH
  004e2	8d 45 d8	 lea	 eax, DWORD PTR $T17[ebp]
  004e5	c7 45 fc 0a 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  004ec	50		 push	 eax
  004ed	8b ce		 mov	 ecx, esi
  004ef	e8 00 00 00 00	 call	 ?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPoly::insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  004f4	8b 55 ec	 mov	 edx, DWORD PTR $T17[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 605  :     insert("sin",POLY_SIN);

  004f7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  004fe	83 fa 10	 cmp	 edx, 16			; 00000010H
  00501	72 2c		 jb	 SHORT $LN992@init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00503	8b 4d d8	 mov	 ecx, DWORD PTR $T17[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00506	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00507	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00509	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0050f	72 14		 jb	 SHORT $LN1002@init

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00511	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00514	83 c2 23	 add	 edx, 35			; 00000023H
  00517	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00519	83 c0 fc	 add	 eax, -4			; fffffffcH
  0051c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0051f	0f 87 10 07 00
	00		 ja	 $LN1644@init
$LN1002@init:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00525	52		 push	 edx
  00526	51		 push	 ecx
  00527	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0052c	83 c4 08	 add	 esp, 8
$LN992@init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0052f	6a 03		 push	 3

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00531	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T16[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00538	8d 4d d8	 lea	 ecx, DWORD PTR $T16[ebp]
  0053b	68 00 00 00 00	 push	 OFFSET ??_C@_03IIINPABG@tan@

; 4596 :         _My_data._Mysize = 0;

  00540	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T16[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00547	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T16[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0054e	c6 45 d8 00	 mov	 BYTE PTR $T16[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00552	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 606  :     insert("tan",POLY_TAN);

  00557	6a 0e		 push	 14			; 0000000eH
  00559	8d 45 d8	 lea	 eax, DWORD PTR $T16[ebp]
  0055c	c7 45 fc 0b 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  00563	50		 push	 eax
  00564	8b ce		 mov	 ecx, esi
  00566	e8 00 00 00 00	 call	 ?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPoly::insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0056b	8b 55 ec	 mov	 edx, DWORD PTR $T16[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 606  :     insert("tan",POLY_TAN);

  0056e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00575	83 fa 10	 cmp	 edx, 16			; 00000010H
  00578	72 2c		 jb	 SHORT $LN1035@init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0057a	8b 4d d8	 mov	 ecx, DWORD PTR $T16[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0057d	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0057e	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00580	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00586	72 14		 jb	 SHORT $LN1045@init

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00588	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0058b	83 c2 23	 add	 edx, 35			; 00000023H
  0058e	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00590	83 c0 fc	 add	 eax, -4			; fffffffcH
  00593	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00596	0f 87 99 06 00
	00		 ja	 $LN1644@init
$LN1045@init:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0059c	52		 push	 edx
  0059d	51		 push	 ecx
  0059e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  005a3	83 c4 08	 add	 esp, 8
$LN1035@init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  005a6	6a 03		 push	 3

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  005a8	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T15[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  005af	8d 4d d8	 lea	 ecx, DWORD PTR $T15[ebp]
  005b2	68 00 00 00 00	 push	 OFFSET ??_C@_03PPPAEIOB@cot@

; 4596 :         _My_data._Mysize = 0;

  005b7	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T15[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  005be	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T15[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  005c5	c6 45 d8 00	 mov	 BYTE PTR $T15[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  005c9	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 607  :     insert("cot",POLY_COT);

  005ce	6a 11		 push	 17			; 00000011H
  005d0	8d 45 d8	 lea	 eax, DWORD PTR $T15[ebp]
  005d3	c7 45 fc 0c 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  005da	50		 push	 eax
  005db	8b ce		 mov	 ecx, esi
  005dd	e8 00 00 00 00	 call	 ?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPoly::insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  005e2	8b 55 ec	 mov	 edx, DWORD PTR $T15[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 607  :     insert("cot",POLY_COT);

  005e5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  005ec	83 fa 10	 cmp	 edx, 16			; 00000010H
  005ef	72 2c		 jb	 SHORT $LN1078@init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  005f1	8b 4d d8	 mov	 ecx, DWORD PTR $T15[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  005f4	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  005f5	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  005f7	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  005fd	72 14		 jb	 SHORT $LN1088@init

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  005ff	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00602	83 c2 23	 add	 edx, 35			; 00000023H
  00605	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00607	83 c0 fc	 add	 eax, -4			; fffffffcH
  0060a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0060d	0f 87 22 06 00
	00		 ja	 $LN1644@init
$LN1088@init:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00613	52		 push	 edx
  00614	51		 push	 ecx
  00615	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0061a	83 c4 08	 add	 esp, 8
$LN1078@init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0061d	6a 03		 push	 3

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0061f	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T14[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00626	8d 4d d8	 lea	 ecx, DWORD PTR $T14[ebp]
  00629	68 00 00 00 00	 push	 OFFSET ??_C@_03OPEPJGGD@csc@

; 4596 :         _My_data._Mysize = 0;

  0062e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T14[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00635	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T14[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0063c	c6 45 d8 00	 mov	 BYTE PTR $T14[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00640	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 608  :     insert("csc",POLY_CSC);

  00645	6a 0f		 push	 15			; 0000000fH
  00647	8d 45 d8	 lea	 eax, DWORD PTR $T14[ebp]
  0064a	c7 45 fc 0d 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  00651	50		 push	 eax
  00652	8b ce		 mov	 ecx, esi
  00654	e8 00 00 00 00	 call	 ?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPoly::insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00659	8b 55 ec	 mov	 edx, DWORD PTR $T14[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 608  :     insert("csc",POLY_CSC);

  0065c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00663	83 fa 10	 cmp	 edx, 16			; 00000010H
  00666	72 2c		 jb	 SHORT $LN1121@init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00668	8b 4d d8	 mov	 ecx, DWORD PTR $T14[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0066b	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0066c	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0066e	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00674	72 14		 jb	 SHORT $LN1131@init

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00676	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00679	83 c2 23	 add	 edx, 35			; 00000023H
  0067c	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0067e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00681	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00684	0f 87 ab 05 00
	00		 ja	 $LN1644@init
$LN1131@init:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0068a	52		 push	 edx
  0068b	51		 push	 ecx
  0068c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00691	83 c4 08	 add	 esp, 8
$LN1121@init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00694	6a 05		 push	 5

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00696	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T13[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0069d	8d 4d d8	 lea	 ecx, DWORD PTR $T13[ebp]
  006a0	68 00 00 00 00	 push	 OFFSET ??_C@_05KCHJPNOJ@cosec@

; 4596 :         _My_data._Mysize = 0;

  006a5	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T13[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  006ac	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T13[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  006b3	c6 45 d8 00	 mov	 BYTE PTR $T13[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  006b7	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 609  :     insert("cosec",POLY_COSEC);

  006bc	6a 0f		 push	 15			; 0000000fH
  006be	8d 45 d8	 lea	 eax, DWORD PTR $T13[ebp]
  006c1	c7 45 fc 0e 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  006c8	50		 push	 eax
  006c9	8b ce		 mov	 ecx, esi
  006cb	e8 00 00 00 00	 call	 ?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPoly::insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  006d0	8b 55 ec	 mov	 edx, DWORD PTR $T13[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 609  :     insert("cosec",POLY_COSEC);

  006d3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  006da	83 fa 10	 cmp	 edx, 16			; 00000010H
  006dd	72 2c		 jb	 SHORT $LN1164@init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  006df	8b 4d d8	 mov	 ecx, DWORD PTR $T13[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  006e2	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  006e3	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  006e5	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  006eb	72 14		 jb	 SHORT $LN1174@init

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  006ed	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  006f0	83 c2 23	 add	 edx, 35			; 00000023H
  006f3	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  006f5	83 c0 fc	 add	 eax, -4			; fffffffcH
  006f8	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  006fb	0f 87 34 05 00
	00		 ja	 $LN1644@init
$LN1174@init:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00701	52		 push	 edx
  00702	51		 push	 ecx
  00703	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00708	83 c4 08	 add	 esp, 8
$LN1164@init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0070b	6a 03		 push	 3

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0070d	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T12[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00714	8d 4d d8	 lea	 ecx, DWORD PTR $T12[ebp]
  00717	68 00 00 00 00	 push	 OFFSET ??_C@_03KHPNBODO@sec@

; 4596 :         _My_data._Mysize = 0;

  0071c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T12[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00723	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T12[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0072a	c6 45 d8 00	 mov	 BYTE PTR $T12[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0072e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 610  :     insert("sec",POLY_SEC);

  00733	6a 10		 push	 16			; 00000010H
  00735	8d 45 d8	 lea	 eax, DWORD PTR $T12[ebp]
  00738	c7 45 fc 0f 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  0073f	50		 push	 eax
  00740	8b ce		 mov	 ecx, esi
  00742	e8 00 00 00 00	 call	 ?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPoly::insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00747	8b 55 ec	 mov	 edx, DWORD PTR $T12[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 610  :     insert("sec",POLY_SEC);

  0074a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00751	83 fa 10	 cmp	 edx, 16			; 00000010H
  00754	72 2c		 jb	 SHORT $LN1207@init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00756	8b 4d d8	 mov	 ecx, DWORD PTR $T12[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00759	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0075a	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0075c	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00762	72 14		 jb	 SHORT $LN1217@init

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00764	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00767	83 c2 23	 add	 edx, 35			; 00000023H
  0076a	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0076c	83 c0 fc	 add	 eax, -4			; fffffffcH
  0076f	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00772	0f 87 bd 04 00
	00		 ja	 $LN1644@init
$LN1217@init:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00778	52		 push	 edx
  00779	51		 push	 ecx
  0077a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0077f	83 c4 08	 add	 esp, 8
$LN1207@init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00782	6a 02		 push	 2

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00784	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T11[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0078b	8d 4d d8	 lea	 ecx, DWORD PTR $T11[ebp]
  0078e	68 00 00 00 00	 push	 OFFSET ??_C@_02OAHAJOFD@pi@

; 4596 :         _My_data._Mysize = 0;

  00793	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T11[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0079a	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T11[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  007a1	c6 45 d8 00	 mov	 BYTE PTR $T11[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  007a5	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 611  :     insert("pi",POLY_PI);

  007aa	6a 0a		 push	 10			; 0000000aH
  007ac	8d 45 d8	 lea	 eax, DWORD PTR $T11[ebp]
  007af	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 16 ; 00000010H
  007b6	50		 push	 eax
  007b7	8b ce		 mov	 ecx, esi
  007b9	e8 00 00 00 00	 call	 ?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPoly::insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  007be	8b 55 ec	 mov	 edx, DWORD PTR $T11[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 611  :     insert("pi",POLY_PI);

  007c1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  007c8	83 fa 10	 cmp	 edx, 16			; 00000010H
  007cb	72 2c		 jb	 SHORT $LN1250@init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  007cd	8b 4d d8	 mov	 ecx, DWORD PTR $T11[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  007d0	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  007d1	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  007d3	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  007d9	72 14		 jb	 SHORT $LN1260@init

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  007db	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  007de	83 c2 23	 add	 edx, 35			; 00000023H
  007e1	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  007e3	83 c0 fc	 add	 eax, -4			; fffffffcH
  007e6	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  007e9	0f 87 46 04 00
	00		 ja	 $LN1644@init
$LN1260@init:

; 264  :         ::operator delete(_Ptr, _Bytes);

  007ef	52		 push	 edx
  007f0	51		 push	 ecx
  007f1	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  007f6	83 c4 08	 add	 esp, 8
$LN1250@init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  007f9	6a 02		 push	 2
  007fb	68 00 00 00 00	 push	 OFFSET ??_C@_02OAHAJOFD@pi@
  00800	8d 4d d8	 lea	 ecx, DWORD PTR $T10[ebp]

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00803	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T10[ebp], 0

; 4596 :         _My_data._Mysize = 0;

  0080a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T10[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00811	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T10[ebp+20], 15 ; 0000000fH

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00818	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 612  :     SetVar("pi",3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068);

  0081d	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@400921fb54442d18
  00825	8d 45 d8	 lea	 eax, DWORD PTR $T10[ebp]
  00828	83 ec 08	 sub	 esp, 8
  0082b	8b ce		 mov	 ecx, esi
  0082d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00832	50		 push	 eax
  00833	e8 00 00 00 00	 call	 ?SetVar@CPoly@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z ; CPoly::SetVar
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00838	8b 55 ec	 mov	 edx, DWORD PTR $T10[ebp+20]
  0083b	83 fa 10	 cmp	 edx, 16			; 00000010H
  0083e	72 2c		 jb	 SHORT $LN1293@init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00840	8b 4d d8	 mov	 ecx, DWORD PTR $T10[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00843	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00844	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00846	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0084c	72 14		 jb	 SHORT $LN1303@init

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0084e	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00851	83 c2 23	 add	 edx, 35			; 00000023H
  00854	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00856	83 c0 fc	 add	 eax, -4			; fffffffcH
  00859	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0085c	0f 87 d3 03 00
	00		 ja	 $LN1644@init
$LN1303@init:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00862	52		 push	 edx
  00863	51		 push	 ecx
  00864	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00869	83 c4 08	 add	 esp, 8
$LN1293@init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0086c	6a 01		 push	 1

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0086e	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T9[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00875	8d 4d d8	 lea	 ecx, DWORD PTR $T9[ebp]
  00878	68 00 00 00 00	 push	 OFFSET ??_C@_01KGKMHCOC@e@

; 4596 :         _My_data._Mysize = 0;

  0087d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T9[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00884	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T9[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0088b	c6 45 d8 00	 mov	 BYTE PTR $T9[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0088f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 613  :     insert("e",POLY_EXP);

  00894	6a 0a		 push	 10			; 0000000aH
  00896	8d 45 d8	 lea	 eax, DWORD PTR $T9[ebp]
  00899	c7 45 fc 11 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 17 ; 00000011H
  008a0	50		 push	 eax
  008a1	8b ce		 mov	 ecx, esi
  008a3	e8 00 00 00 00	 call	 ?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPoly::insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  008a8	8b 55 ec	 mov	 edx, DWORD PTR $T9[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 613  :     insert("e",POLY_EXP);

  008ab	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  008b2	83 fa 10	 cmp	 edx, 16			; 00000010H
  008b5	72 2c		 jb	 SHORT $LN1336@init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  008b7	8b 4d d8	 mov	 ecx, DWORD PTR $T9[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  008ba	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  008bb	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  008bd	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  008c3	72 14		 jb	 SHORT $LN1346@init

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  008c5	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  008c8	83 c2 23	 add	 edx, 35			; 00000023H
  008cb	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  008cd	83 c0 fc	 add	 eax, -4			; fffffffcH
  008d0	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  008d3	0f 87 5c 03 00
	00		 ja	 $LN1644@init
$LN1346@init:

; 264  :         ::operator delete(_Ptr, _Bytes);

  008d9	52		 push	 edx
  008da	51		 push	 ecx
  008db	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  008e0	83 c4 08	 add	 esp, 8
$LN1336@init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  008e3	6a 01		 push	 1
  008e5	68 00 00 00 00	 push	 OFFSET ??_C@_01KGKMHCOC@e@
  008ea	8d 4d d8	 lea	 ecx, DWORD PTR $T8[ebp]

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  008ed	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T8[ebp], 0

; 4596 :         _My_data._Mysize = 0;

  008f4	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T8[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  008fb	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T8[ebp+20], 15 ; 0000000fH

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00902	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 614  :     SetVar("e",2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427);

  00907	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4005bf0a8b145769
  0090f	8d 45 d8	 lea	 eax, DWORD PTR $T8[ebp]
  00912	83 ec 08	 sub	 esp, 8
  00915	8b ce		 mov	 ecx, esi
  00917	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0091c	50		 push	 eax
  0091d	e8 00 00 00 00	 call	 ?SetVar@CPoly@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z ; CPoly::SetVar
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00922	8b 55 ec	 mov	 edx, DWORD PTR $T8[ebp+20]
  00925	83 fa 10	 cmp	 edx, 16			; 00000010H
  00928	72 2c		 jb	 SHORT $LN1379@init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0092a	8b 4d d8	 mov	 ecx, DWORD PTR $T8[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0092d	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0092e	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00930	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00936	72 14		 jb	 SHORT $LN1389@init

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00938	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0093b	83 c2 23	 add	 edx, 35			; 00000023H
  0093e	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00940	83 c0 fc	 add	 eax, -4			; fffffffcH
  00943	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00946	0f 87 e9 02 00
	00		 ja	 $LN1644@init
$LN1389@init:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0094c	52		 push	 edx
  0094d	51		 push	 ecx
  0094e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00953	83 c4 08	 add	 esp, 8
$LN1379@init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00956	6a 03		 push	 3

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00958	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T7[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0095f	8d 4d d8	 lea	 ecx, DWORD PTR $T7[ebp]
  00962	68 00 00 00 00	 push	 OFFSET ??_C@_03MGHMBJCF@log@

; 4596 :         _My_data._Mysize = 0;

  00967	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T7[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0096e	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T7[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00975	c6 45 d8 00	 mov	 BYTE PTR $T7[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00979	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 615  :     insert("log",POLY_LOG);

  0097e	6a 12		 push	 18			; 00000012H
  00980	8d 45 d8	 lea	 eax, DWORD PTR $T7[ebp]
  00983	c7 45 fc 12 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 18 ; 00000012H
  0098a	50		 push	 eax
  0098b	8b ce		 mov	 ecx, esi
  0098d	e8 00 00 00 00	 call	 ?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPoly::insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00992	8b 55 ec	 mov	 edx, DWORD PTR $T7[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 615  :     insert("log",POLY_LOG);

  00995	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0099c	83 fa 10	 cmp	 edx, 16			; 00000010H
  0099f	72 2c		 jb	 SHORT $LN1422@init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  009a1	8b 4d d8	 mov	 ecx, DWORD PTR $T7[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  009a4	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  009a5	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  009a7	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  009ad	72 14		 jb	 SHORT $LN1432@init

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  009af	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  009b2	83 c2 23	 add	 edx, 35			; 00000023H
  009b5	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  009b7	83 c0 fc	 add	 eax, -4			; fffffffcH
  009ba	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  009bd	0f 87 72 02 00
	00		 ja	 $LN1644@init
$LN1432@init:

; 264  :         ::operator delete(_Ptr, _Bytes);

  009c3	52		 push	 edx
  009c4	51		 push	 ecx
  009c5	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  009ca	83 c4 08	 add	 esp, 8
$LN1422@init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  009cd	6a 02		 push	 2

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  009cf	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T6[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  009d6	8d 4d d8	 lea	 ecx, DWORD PTR $T6[ebp]
  009d9	68 00 00 00 00	 push	 OFFSET ??_C@_02LKANFCIA@ln@

; 4596 :         _My_data._Mysize = 0;

  009de	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T6[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  009e5	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T6[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  009ec	c6 45 d8 00	 mov	 BYTE PTR $T6[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  009f0	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 616  :     insert("ln",POLY_LN);

  009f5	6a 13		 push	 19			; 00000013H
  009f7	8d 45 d8	 lea	 eax, DWORD PTR $T6[ebp]
  009fa	c7 45 fc 13 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 19 ; 00000013H
  00a01	50		 push	 eax
  00a02	8b ce		 mov	 ecx, esi
  00a04	e8 00 00 00 00	 call	 ?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPoly::insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00a09	8b 55 ec	 mov	 edx, DWORD PTR $T6[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 616  :     insert("ln",POLY_LN);

  00a0c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00a13	83 fa 10	 cmp	 edx, 16			; 00000010H
  00a16	72 2c		 jb	 SHORT $LN1465@init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00a18	8b 4d d8	 mov	 ecx, DWORD PTR $T6[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00a1b	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00a1c	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00a1e	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00a24	72 14		 jb	 SHORT $LN1475@init

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00a26	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00a29	83 c2 23	 add	 edx, 35			; 00000023H
  00a2c	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00a2e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00a31	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00a34	0f 87 fb 01 00
	00		 ja	 $LN1644@init
$LN1475@init:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00a3a	52		 push	 edx
  00a3b	51		 push	 ecx
  00a3c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00a41	83 c4 08	 add	 esp, 8
$LN1465@init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00a44	6a 05		 push	 5

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00a46	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T5[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00a4d	8d 4d d8	 lea	 ecx, DWORD PTR $T5[ebp]
  00a50	68 00 00 00 00	 push	 OFFSET ??_C@_05HGHHAHAP@log10@

; 4596 :         _My_data._Mysize = 0;

  00a55	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T5[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00a5c	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T5[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00a63	c6 45 d8 00	 mov	 BYTE PTR $T5[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00a67	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 617  :     insert("log10",POLY_LOG10);

  00a6c	6a 14		 push	 20			; 00000014H
  00a6e	8d 45 d8	 lea	 eax, DWORD PTR $T5[ebp]
  00a71	c7 45 fc 14 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 20 ; 00000014H
  00a78	50		 push	 eax
  00a79	8b ce		 mov	 ecx, esi
  00a7b	e8 00 00 00 00	 call	 ?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPoly::insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00a80	8b 55 ec	 mov	 edx, DWORD PTR $T5[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 617  :     insert("log10",POLY_LOG10);

  00a83	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00a8a	83 fa 10	 cmp	 edx, 16			; 00000010H
  00a8d	72 2c		 jb	 SHORT $LN1508@init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00a8f	8b 4d d8	 mov	 ecx, DWORD PTR $T5[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00a92	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00a93	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00a95	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00a9b	72 14		 jb	 SHORT $LN1518@init

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00a9d	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00aa0	83 c2 23	 add	 edx, 35			; 00000023H
  00aa3	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00aa5	83 c0 fc	 add	 eax, -4			; fffffffcH
  00aa8	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00aab	0f 87 84 01 00
	00		 ja	 $LN1644@init
$LN1518@init:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00ab1	52		 push	 edx
  00ab2	51		 push	 ecx
  00ab3	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00ab8	83 c4 08	 add	 esp, 8
$LN1508@init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00abb	6a 03		 push	 3

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00abd	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00ac4	8d 4d d8	 lea	 ecx, DWORD PTR $T4[ebp]
  00ac7	68 00 00 00 00	 push	 OFFSET ??_C@_03BCGAIFPO@abs@

; 4596 :         _My_data._Mysize = 0;

  00acc	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00ad3	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T4[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00ada	c6 45 d8 00	 mov	 BYTE PTR $T4[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00ade	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 618  :     insert("abs",POLY_ABS);

  00ae3	6a 15		 push	 21			; 00000015H
  00ae5	8d 45 d8	 lea	 eax, DWORD PTR $T4[ebp]
  00ae8	c7 45 fc 15 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 21 ; 00000015H
  00aef	50		 push	 eax
  00af0	8b ce		 mov	 ecx, esi
  00af2	e8 00 00 00 00	 call	 ?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPoly::insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00af7	8b 55 ec	 mov	 edx, DWORD PTR $T4[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 618  :     insert("abs",POLY_ABS);

  00afa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00b01	83 fa 10	 cmp	 edx, 16			; 00000010H
  00b04	72 2c		 jb	 SHORT $LN1551@init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00b06	8b 4d d8	 mov	 ecx, DWORD PTR $T4[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00b09	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00b0a	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00b0c	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00b12	72 14		 jb	 SHORT $LN1561@init

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00b14	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00b17	83 c2 23	 add	 edx, 35			; 00000023H
  00b1a	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00b1c	83 c0 fc	 add	 eax, -4			; fffffffcH
  00b1f	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00b22	0f 87 0d 01 00
	00		 ja	 $LN1644@init
$LN1561@init:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00b28	52		 push	 edx
  00b29	51		 push	 ecx
  00b2a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00b2f	83 c4 08	 add	 esp, 8
$LN1551@init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00b32	6a 03		 push	 3

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00b34	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00b3b	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00b3e	68 00 00 00 00	 push	 OFFSET ??_C@_03FFONCNID@mod@

; 4596 :         _My_data._Mysize = 0;

  00b43	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00b4a	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T3[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00b51	c6 45 d8 00	 mov	 BYTE PTR $T3[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00b55	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 619  :     insert("mod",POLY_MOD);

  00b5a	6a 1a		 push	 26			; 0000001aH
  00b5c	8d 45 d8	 lea	 eax, DWORD PTR $T3[ebp]
  00b5f	c7 45 fc 16 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 22 ; 00000016H
  00b66	50		 push	 eax
  00b67	8b ce		 mov	 ecx, esi
  00b69	e8 00 00 00 00	 call	 ?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPoly::insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00b6e	8b 55 ec	 mov	 edx, DWORD PTR $T3[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 619  :     insert("mod",POLY_MOD);

  00b71	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00b78	83 fa 10	 cmp	 edx, 16			; 00000010H
  00b7b	72 2c		 jb	 SHORT $LN1594@init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00b7d	8b 4d d8	 mov	 ecx, DWORD PTR $T3[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00b80	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00b81	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00b83	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00b89	72 14		 jb	 SHORT $LN1604@init

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00b8b	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00b8e	83 c2 23	 add	 edx, 35			; 00000023H
  00b91	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00b93	83 c0 fc	 add	 eax, -4			; fffffffcH
  00b96	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00b99	0f 87 96 00 00
	00		 ja	 $LN1644@init
$LN1604@init:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00b9f	52		 push	 edx
  00ba0	51		 push	 ecx
  00ba1	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00ba6	83 c4 08	 add	 esp, 8
$LN1594@init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00ba9	6a 05		 push	 5

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00bab	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00bb2	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  00bb5	68 00 00 00 00	 push	 OFFSET ??_C@_05PBJFFIGL@floor@

; 4596 :         _My_data._Mysize = 0;

  00bba	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00bc1	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00bc8	c6 45 d8 00	 mov	 BYTE PTR $T2[ebp], 0

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00bcc	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 620  :     insert("floor",POLY_FLOOR);

  00bd1	6a 1b		 push	 27			; 0000001bH
  00bd3	8d 45 d8	 lea	 eax, DWORD PTR $T2[ebp]
  00bd6	c7 45 fc 17 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 23 ; 00000017H
  00bdd	50		 push	 eax
  00bde	8b ce		 mov	 ecx, esi
  00be0	e8 00 00 00 00	 call	 ?insert@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPoly::insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00be5	8b 55 ec	 mov	 edx, DWORD PTR $T2[ebp+20]
  00be8	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00beb	72 28		 jb	 SHORT $LN1637@init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00bed	8b 4d d8	 mov	 ecx, DWORD PTR $T2[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00bf0	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00bf1	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00bf3	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00bf9	72 10		 jb	 SHORT $LN1647@init

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00bfb	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00bfe	83 c2 23	 add	 edx, 35			; 00000023H
  00c01	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00c03	83 c0 fc	 add	 eax, -4			; fffffffcH
  00c06	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00c09	77 2a		 ja	 SHORT $LN1644@init
$LN1647@init:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00c0b	52		 push	 edx
  00c0c	51		 push	 ecx
  00c0d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00c12	83 c4 08	 add	 esp, 8
$LN1637@init:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 621  : 	MathSymbolCount = STSize;

  00c15	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  00c18	89 46 5c	 mov	 DWORD PTR [esi+92], eax

; 622  : }

  00c1b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00c1e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00c25	59		 pop	 ecx
  00c26	5e		 pop	 esi
  00c27	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c2a	33 cd		 xor	 ecx, ebp
  00c2c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c31	8b e5		 mov	 esp, ebp
  00c33	5d		 pop	 ebp
  00c34	c3		 ret	 0
$LN1644@init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00c35	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1653@init:
  00c3a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?init@CPoly@@IAEXXZ$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T27[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPoly@@IAEXXZ$1:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR $T26[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPoly@@IAEXXZ$2:
  00010	8d 4d d8	 lea	 ecx, DWORD PTR $T25[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPoly@@IAEXXZ$3:
  00018	8d 4d d8	 lea	 ecx, DWORD PTR $T24[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPoly@@IAEXXZ$4:
  00020	8d 4d d8	 lea	 ecx, DWORD PTR $T23[ebp]
  00023	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPoly@@IAEXXZ$5:
  00028	8d 4d d8	 lea	 ecx, DWORD PTR $T22[ebp]
  0002b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPoly@@IAEXXZ$6:
  00030	8d 4d d8	 lea	 ecx, DWORD PTR $T21[ebp]
  00033	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPoly@@IAEXXZ$7:
  00038	8d 4d d8	 lea	 ecx, DWORD PTR $T20[ebp]
  0003b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPoly@@IAEXXZ$8:
  00040	8d 4d d8	 lea	 ecx, DWORD PTR $T19[ebp]
  00043	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPoly@@IAEXXZ$9:
  00048	8d 4d d8	 lea	 ecx, DWORD PTR $T18[ebp]
  0004b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPoly@@IAEXXZ$10:
  00050	8d 4d d8	 lea	 ecx, DWORD PTR $T17[ebp]
  00053	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPoly@@IAEXXZ$11:
  00058	8d 4d d8	 lea	 ecx, DWORD PTR $T16[ebp]
  0005b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPoly@@IAEXXZ$12:
  00060	8d 4d d8	 lea	 ecx, DWORD PTR $T15[ebp]
  00063	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPoly@@IAEXXZ$13:
  00068	8d 4d d8	 lea	 ecx, DWORD PTR $T14[ebp]
  0006b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPoly@@IAEXXZ$14:
  00070	8d 4d d8	 lea	 ecx, DWORD PTR $T13[ebp]
  00073	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPoly@@IAEXXZ$15:
  00078	8d 4d d8	 lea	 ecx, DWORD PTR $T12[ebp]
  0007b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPoly@@IAEXXZ$16:
  00080	8d 4d d8	 lea	 ecx, DWORD PTR $T11[ebp]
  00083	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPoly@@IAEXXZ$18:
  00088	8d 4d d8	 lea	 ecx, DWORD PTR $T9[ebp]
  0008b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPoly@@IAEXXZ$20:
  00090	8d 4d d8	 lea	 ecx, DWORD PTR $T7[ebp]
  00093	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPoly@@IAEXXZ$21:
  00098	8d 4d d8	 lea	 ecx, DWORD PTR $T6[ebp]
  0009b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPoly@@IAEXXZ$22:
  000a0	8d 4d d8	 lea	 ecx, DWORD PTR $T5[ebp]
  000a3	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPoly@@IAEXXZ$23:
  000a8	8d 4d d8	 lea	 ecx, DWORD PTR $T4[ebp]
  000ab	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPoly@@IAEXXZ$24:
  000b0	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  000b3	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPoly@@IAEXXZ$25:
  000b8	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  000bb	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  000c0	cc		 int	 3
  000c1	cc		 int	 3
  000c2	cc		 int	 3
  000c3	cc		 int	 3
  000c4	cc		 int	 3
__ehhandler$?init@CPoly@@IAEXXZ:
  000c5	90		 npad	 1
  000c6	90		 npad	 1
  000c7	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000cb	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000ce	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  000d1	33 c8		 xor	 ecx, eax
  000d3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d8	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  000db	33 c8		 xor	 ecx, eax
  000dd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e2	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?init@CPoly@@IAEXXZ
  000e7	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?init@CPoly@@IAEXXZ ENDP				; CPoly::init
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
;	COMDAT ?my_frandom@CPoly@@IAENNN@Z
_TEXT	SEGMENT
_start$ = 8						; size = 8
_end$ = 16						; size = 8
?my_frandom@CPoly@@IAENNN@Z PROC			; CPoly::my_frandom, COMDAT
; _this$ = ecx

; 42   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 43   :     return _random() * (end - start) + start;

  00003	e8 00 00 00 00	 call	 ?_random@@YANXZ		; _random
  00008	dd 45 10	 fld	 QWORD PTR _end$[ebp]
  0000b	dd 45 08	 fld	 QWORD PTR _start$[ebp]
  0000e	dc e9		 fsub	 ST(1), ST(0)
  00010	d9 ca		 fxch	 ST(2)
  00012	de c9		 fmulp	 ST(1), ST(0)
  00014	de c1		 faddp	 ST(1), ST(0)

; 44   : }

  00016	5d		 pop	 ebp
  00017	c2 10 00	 ret	 16			; 00000010H
?my_frandom@CPoly@@IAENNN@Z ENDP			; CPoly::my_frandom
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
;	COMDAT ?my_irandom@CPoly@@IAEHNN@Z
_TEXT	SEGMENT
_start$ = 8						; size = 8
tv129 = 16						; size = 8
tv90 = 16						; size = 8
tv88 = 16						; size = 8
_end$ = 16						; size = 8
?my_irandom@CPoly@@IAEHNN@Z PROC			; CPoly::my_irandom, COMDAT
; _this$ = ecx

; 23   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 24   : 	switch (m_iRandomType)

  00003	8b 41 78	 mov	 eax, DWORD PTR [ecx+120]
  00006	83 e8 01	 sub	 eax, 1
  00009	74 66		 je	 SHORT $LN4@my_irandom
  0000b	83 e8 01	 sub	 eax, 1
  0000e	74 58		 je	 SHORT $LN5@my_irandom

; 31   : 			break;
; 32   : 	}
; 33   : 
; 34   :     // Make range as inclusive-exclusive
; 35   :     int is = int(start + 0.5);
; 36   :     int ie = int(end - start + 0.5) + 1;
; 37   : 
; 38   :     return int(_random() * ie + is);

  00010	e8 00 00 00 00	 call	 ?_random@@YANXZ		; _random
  00015	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _end$[ebp]
  0001a	f2 0f 10 55 08	 movsd	 xmm2, QWORD PTR _start$[ebp]
  0001f	f2 0f 5c c2	 subsd	 xmm0, xmm2
  00023	f2 0f 58 15 00
	00 00 00	 addsd	 xmm2, QWORD PTR __real@3fe0000000000000
  0002b	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  00033	f2 0f 2c c0	 cvttsd2si eax, xmm0
  00037	40		 inc	 eax
  00038	66 0f 6e c0	 movd	 xmm0, eax
  0003c	f2 0f 2c c2	 cvttsd2si eax, xmm2
  00040	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00044	f2 0f 11 45 10	 movsd	 QWORD PTR tv129[ebp], xmm0
  00049	dc 4d 10	 fmul	 QWORD PTR tv129[ebp]
  0004c	66 0f 6e c0	 movd	 xmm0, eax
  00050	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00054	f2 0f 11 45 10	 movsd	 QWORD PTR tv90[ebp], xmm0
  00059	dc 45 10	 fadd	 QWORD PTR tv90[ebp]
  0005c	dd 5d 10	 fstp	 QWORD PTR tv88[ebp]
  0005f	f2 0f 2c 45 10	 cvttsd2si eax, QWORD PTR tv88[ebp]

; 39   : }

  00064	5d		 pop	 ebp
  00065	c2 10 00	 ret	 16			; 00000010H
$LN5@my_irandom:

; 28   : 			break;
; 29   : 		case RANDOM_TYPE_FORCE_MAX:
; 30   : 			return int(end);

  00068	f2 0f 2c 45 10	 cvttsd2si eax, QWORD PTR _end$[ebp]

; 39   : }

  0006d	5d		 pop	 ebp
  0006e	c2 10 00	 ret	 16			; 00000010H
$LN4@my_irandom:

; 25   : 	{
; 26   : 		case RANDOM_TYPE_FORCE_MIN:
; 27   : 			return int(start);

  00071	f2 0f 2c 45 08	 cvttsd2si eax, QWORD PTR _start$[ebp]

; 39   : }

  00076	5d		 pop	 ebp
  00077	c2 10 00	 ret	 16			; 00000010H
?my_irandom@CPoly@@IAEHNN@Z ENDP			; CPoly::my_irandom
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
;	COMDAT ?Clear@CPoly@@QAEXXZ
_TEXT	SEGMENT
?Clear@CPoly@@QAEXXZ PROC				; CPoly::Clear, COMDAT
; _this$ = ecx

; 259  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 260  :     int i;
; 261  :     //while (!tokenBase.IsEmpty()) listBase.RemoveTail();
; 262  :     //while (!numBase.IsEmpty()) numBase.RemoveTail();
; 263  :     tokenBase.clear();
; 264  :     numBase.clear();
; 265  : 
; 266  :     for (i = 0;i < STSize; ++i)

  00004	33 ff		 xor	 edi, edi
  00006	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00009	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  0000c	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0000f	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00012	39 7e 58	 cmp	 DWORD PTR [esi+88], edi
  00015	7e 20		 jle	 SHORT $LN3@Clear
$LL4@Clear:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  00017	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 268  : 	if (lSymbol[i]) delete lSymbol[i];

  0001a	8b 0c b8	 mov	 ecx, DWORD PTR [eax+edi*4]
  0001d	85 c9		 test	 ecx, ecx
  0001f	74 09		 je	 SHORT $LN19@Clear
  00021	8b 01		 mov	 eax, DWORD PTR [ecx]
  00023	6a 01		 push	 1
  00025	ff 10		 call	 DWORD PTR [eax]
  00027	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
$LN19@Clear:

; 269  : 	lSymbol[i]=NULL;

  0002a	c7 04 b8 00 00
	00 00		 mov	 DWORD PTR [eax+edi*4], 0
  00031	47		 inc	 edi
  00032	3b 7e 58	 cmp	 edi, DWORD PTR [esi+88]
  00035	7c e0		 jl	 SHORT $LL4@Clear
$LN3@Clear:

; 270  :     }
; 271  :     //lSymbol.FreeExtra();
; 272  :     lSymbol.clear();

  00037	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  0003a	89 46 44	 mov	 DWORD PTR [esi+68], eax

; 273  :     SymbolIndex.clear();

  0003d	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]

; 274  :     STSize=0;
; 275  : 	MathSymbolCount=0;

  00040	5f		 pop	 edi
  00041	89 46 50	 mov	 DWORD PTR [esi+80], eax
  00044	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
  0004b	c7 46 5c 00 00
	00 00		 mov	 DWORD PTR [esi+92], 0
  00052	5e		 pop	 esi

; 276  : }

  00053	c3		 ret	 0
?Clear@CPoly@@QAEXXZ ENDP				; CPoly::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
;	COMDAT ?GetVarName@CPoly@@QAEPBDI@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
?GetVarName@CPoly@@QAEPBDI@Z PROC			; CPoly::GetVarName, COMDAT
; _this$ = ecx

; 588  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  00003	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  00006	03 55 08	 add	 edx, DWORD PTR _dwIndex$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3922 :         return _Mypair._Myval2._Myptr();

  00009	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]
  0000c	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  0000f	83 c0 14	 add	 eax, 20			; 00000014H

; 2319 :         return _BUF_SIZE <= _Myres;

  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 2306 :         if (_Large_string_engaged()) {

  00016	72 02		 jb	 SHORT $LN8@GetVarName
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 590  : 	return lSymbol[dwIndex + MathSymbolCount]->strlex.c_str();

  00018	8b 00		 mov	 eax, DWORD PTR [eax]
$LN8@GetVarName:

; 591  : }

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?GetVarName@CPoly@@QAEPBDI@Z ENDP			; CPoly::GetVarName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
;	COMDAT ?GetVarCount@CPoly@@QAEHXZ
_TEXT	SEGMENT
?GetVarCount@CPoly@@QAEHXZ PROC				; CPoly::GetVarCount, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00000	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  00003	2b 41 40	 sub	 eax, DWORD PTR [ecx+64]
  00006	c1 f8 02	 sar	 eax, 2
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 584  : 	return lSymbol.size() - MathSymbolCount;

  00009	2b 41 5c	 sub	 eax, DWORD PTR [ecx+92]

; 585  : }

  0000c	c3		 ret	 0
?GetVarCount@CPoly@@QAEHXZ ENDP				; CPoly::GetVarCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
;	COMDAT ?SetVar@CPoly@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z
_TEXT	SEGMENT
_strName$ = 8						; size = 4
_dVar$ = 12						; size = 8
?SetVar@CPoly@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z PROC ; CPoly::SetVar, COMDAT
; _this$ = ecx

; 572  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 573  : 
; 574  :     if (ErrorOccur) return false;

  00006	80 7e 20 00	 cmp	 BYTE PTR [esi+32], 0
  0000a	75 27		 jne	 SHORT $LN7@SetVar

; 575  :     int index=find(strName);

  0000c	ff 75 08	 push	 DWORD PTR _strName$[ebp]
  0000f	e8 00 00 00 00	 call	 ?find@CPoly@@IAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CPoly::find

; 576  :     if (index==-1) return false;

  00014	83 f8 ff	 cmp	 eax, -1
  00017	74 1a		 je	 SHORT $LN7@SetVar

; 577  :     CSymTable* stVar = lSymbol[(/*FindIndex*/(index))];
; 578  :     stVar->dVal=dVar;

  00019	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  0001c	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _dVar$[ebp]
  00021	5e		 pop	 esi
  00022	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00025	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0

; 579  :     return true;

  0002a	b8 01 00 00 00	 mov	 eax, 1

; 580  : }

  0002f	5d		 pop	 ebp
  00030	c2 0c 00	 ret	 12			; 0000000cH
$LN7@SetVar:

; 576  :     if (index==-1) return false;

  00033	33 c0		 xor	 eax, eax
  00035	5e		 pop	 esi

; 580  : }

  00036	5d		 pop	 ebp
  00037	c2 0c 00	 ret	 12			; 0000000cH
?SetVar@CPoly@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z ENDP ; CPoly::SetVar
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
;	COMDAT ?SetStr@CPoly@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
?SetStr@CPoly@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CPoly::SetStr, COMDAT
; _this$ = ecx

; 64   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3077 :         if (this != _STD addressof(_Right)) {

  00003	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 65   :     strData = str;

  00006	83 c1 60	 add	 ecx, 96			; 00000060H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3077 :         if (this != _STD addressof(_Right)) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	74 13		 je	 SHORT $LN4@SetStr

; 2319 :         return _BUF_SIZE <= _Myres;

  0000d	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 2305 :         const value_type* _Result = _Bx._Buf;

  00011	8b d0		 mov	 edx, eax

; 2306 :         if (_Large_string_engaged()) {

  00013	72 02		 jb	 SHORT $LN9@SetStr

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  00015	8b 10		 mov	 edx, DWORD PTR [eax]
$LN9@SetStr:

; 3035 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00017	ff 70 10	 push	 DWORD PTR [eax+16]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN4@SetStr:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 66   : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
?SetStr@CPoly@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CPoly::SetStr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
;	COMDAT ?SetRandom@CPoly@@QAEXH@Z
_TEXT	SEGMENT
_iRandomType$ = 8					; size = 4
?SetRandom@CPoly@@QAEXH@Z PROC				; CPoly::SetRandom, COMDAT
; _this$ = ecx

; 18   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19   : 	m_iRandomType = iRandomType;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iRandomType$[ebp]
  00006	89 41 78	 mov	 DWORD PTR [ecx+120], eax

; 20   : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetRandom@CPoly@@QAEXH@Z ENDP				; CPoly::SetRandom
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
;	COMDAT ?Eval@CPoly@@QAEMXZ
_TEXT	SEGMENT
_iSp$1$ = -828						; size = 4
tv1359 = -824						; size = 4
tv1391 = -820						; size = 4
_this$1$ = -820						; size = 4
_t$3$ = -816						; size = 8
tv1333 = -816						; size = 8
tv761 = -816						; size = 8
_save$ = -808						; size = 800
__$ArrayPad$ = -4					; size = 4
?Eval@CPoly@@QAEMXZ PROC				; CPoly::Eval, COMDAT
; _this$ = ecx

; 69   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec 40 03 00
	00		 sub	 esp, 832		; 00000340H
  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00011	33 c4		 xor	 eax, esp
  00013	89 84 24 3c 03
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+832], eax
  0001a	8b c1		 mov	 eax, ecx

; 70   :     int stNow;
; 71   :     double save[POLY_MAXSTACK],t;
; 72   :     int iSp=0;

  0001c	33 d2		 xor	 edx, edx
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	89 44 24 14	 mov	 DWORD PTR _this$1$[esp+840], eax
  00024	89 54 24 0c	 mov	 DWORD PTR _iSp$1$[esp+840], edx

; 73   :     if (ErrorOccur)

  00028	38 50 20	 cmp	 BYTE PTR [eax+32], dl
  0002b	0f 85 90 04 00
	00		 jne	 $LN43@Eval
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 42   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00031	8b 70 28	 mov	 esi, DWORD PTR [eax+40]
  00034	8b 78 34	 mov	 edi, DWORD PTR [eax+52]
  00037	3b 70 2c	 cmp	 esi, DWORD PTR [eax+44]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 84   :     while (pos != tokenBase.end())

  0003a	0f 84 61 04 00
	00		 je	 $LN3@Eval
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1476 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00040	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@3ff0000000000000
  00048	8d 4c 24 20	 lea	 ecx, DWORD PTR _save$[esp+840]
  0004c	83 e9 10	 sub	 ecx, 16			; 00000010H
  0004f	89 4c 24 10	 mov	 DWORD PTR tv1359[esp+840], ecx
$LL2@Eval:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 87   : 	stNow=*pos;

  00053	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 78   :         ++_Ptr;

  00055	83 c6 04	 add	 esi, 4
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 89   : 	switch (stNow)

  00058	48		 dec	 eax
  00059	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  0005c	0f 87 5f 04 00
	00		 ja	 $LN43@Eval
  00062	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN99@Eval[eax*4]
$LN7@Eval:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 289  :         _Vector_iterator _Tmp = *this;

  00069	8b c7		 mov	 eax, edi

; 78   :         ++_Ptr;

  0006b	83 c7 08	 add	 edi, 8
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 92   : 		save[iSp++]=*posn++; break;

  0006e	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  00072	f2 0f 11 44 d4
	20		 movsd	 QWORD PTR _save$[esp+edx*8+840], xmm0
  00078	42		 inc	 edx
  00079	83 c1 08	 add	 ecx, 8
  0007c	e9 0b 04 00 00	 jmp	 $LN102@Eval
$LN8@Eval:

; 94   : 		save[iSp++]=

  00081	8b 44 24 14	 mov	 eax, DWORD PTR _this$1$[esp+840]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

  00085	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 94   : 		save[iSp++]=

  00087	8b 40 40	 mov	 eax, DWORD PTR [eax+64]
  0008a	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  0008d	8b 4c 24 10	 mov	 ecx, DWORD PTR tv1359[esp+840]
  00091	83 c1 08	 add	 ecx, 8
  00094	f2 0f 10 40 08	 movsd	 xmm0, QWORD PTR [eax+8]
  00099	f2 0f 11 44 d4
	20		 movsd	 QWORD PTR _save$[esp+edx*8+840], xmm0
  0009f	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 78   :         ++_Ptr;

  000a0	83 c6 04	 add	 esi, 4
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 97   : 		break;

  000a3	e9 e4 03 00 00	 jmp	 $LN102@Eval
$LN9@Eval:

; 98   : 		//case '+':
; 99   : 	    case POLY_PLU:
; 100  : 		iSp--;
; 101  : 		save[iSp-1]+=save[iSp]; break;

  000a8	f2 0f 10 44 d4
	18		 movsd	 xmm0, QWORD PTR _save$[esp+edx*8+832]
  000ae	4a		 dec	 edx
  000af	f2 0f 58 44 d4
	18		 addsd	 xmm0, QWORD PTR _save$[esp+edx*8+832]
  000b5	f2 0f 11 44 d4
	18		 movsd	 QWORD PTR _save$[esp+edx*8+832], xmm0
  000bb	e9 c9 03 00 00	 jmp	 $LN103@Eval
$LN10@Eval:

; 102  : 		//case '-':
; 103  : 	    case POLY_MIN:
; 104  : 		iSp--;
; 105  : 		save[iSp-1]-=save[iSp]; break;

  000c0	f2 0f 10 44 d4
	10		 movsd	 xmm0, QWORD PTR _save$[esp+edx*8+824]
  000c6	4a		 dec	 edx
  000c7	f2 0f 5c 44 d4
	20		 subsd	 xmm0, QWORD PTR _save$[esp+edx*8+840]
  000cd	f2 0f 11 44 d4
	18		 movsd	 QWORD PTR _save$[esp+edx*8+832], xmm0
  000d3	e9 b1 03 00 00	 jmp	 $LN103@Eval
$LN11@Eval:

; 106  : 		//case '*':
; 107  : 	    case POLY_MUL:
; 108  : 		iSp--;
; 109  : 		save[iSp-1]*=save[iSp]; break;

  000d8	f2 0f 10 44 d4
	18		 movsd	 xmm0, QWORD PTR _save$[esp+edx*8+832]
  000de	4a		 dec	 edx
  000df	f2 0f 59 44 d4
	18		 mulsd	 xmm0, QWORD PTR _save$[esp+edx*8+832]
  000e5	f2 0f 11 44 d4
	18		 movsd	 QWORD PTR _save$[esp+edx*8+832], xmm0
  000eb	e9 99 03 00 00	 jmp	 $LN103@Eval
$LN12@Eval:

; 110  : 		//case '%':
; 111  : 	    case POLY_MOD:
; 112  : 		iSp--;
; 113  : 		if (save[iSp]==0)

  000f0	f2 0f 10 44 d4
	18		 movsd	 xmm0, QWORD PTR _save$[esp+edx*8+832]
  000f6	4a		 dec	 edx
  000f7	83 e9 08	 sub	 ecx, 8
  000fa	89 54 24 0c	 mov	 DWORD PTR _iSp$1$[esp+840], edx
  000fe	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  00106	89 4c 24 10	 mov	 DWORD PTR tv1359[esp+840], ecx
  0010a	f2 0f 11 44 24
	18		 movsd	 QWORD PTR tv761[esp+840], xmm0
  00110	9f		 lahf
  00111	f6 c4 44	 test	 ah, 68			; 00000044H
  00114	0f 8b a7 03 00
	00		 jnp	 $LN43@Eval

; 114  : 		{
; 115  : 		    //THROW(new CEvalException("Divide by 0"));
; 116  : 		    return 0;
; 117  : 		}
; 118  : 		save[iSp-1]=fmod(save[iSp-1],save[iSp]); break;

  0011a	dd 44 d4 18	 fld	 QWORD PTR _save$[esp+edx*8+832]
  0011e	dd 44 24 18	 fld	 QWORD PTR tv761[esp+840]
  00122	e8 00 00 00 00	 call	 __CIfmod
$LN106@Eval:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 154  :         return _Ptr == _Right._Ptr;

  00127	8b 54 24 0c	 mov	 edx, DWORD PTR _iSp$1$[esp+840]
  0012b	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@3ff0000000000000
  00133	8b 4c 24 10	 mov	 ecx, DWORD PTR tv1359[esp+840]
  00137	dd 5c d4 18	 fstp	 QWORD PTR _save$[esp+edx*8+832]
  0013b	e9 54 03 00 00	 jmp	 $LN4@Eval
$LN14@Eval:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 122  : 		if (save[iSp]==0)

  00140	f2 0f 10 4c d4
	18		 movsd	 xmm1, QWORD PTR _save$[esp+edx*8+832]
  00146	4a		 dec	 edx
  00147	83 e9 08	 sub	 ecx, 8
  0014a	89 54 24 0c	 mov	 DWORD PTR _iSp$1$[esp+840], edx
  0014e	66 0f 2e 0d 00
	00 00 00	 ucomisd xmm1, QWORD PTR __real@0000000000000000
  00156	89 4c 24 10	 mov	 DWORD PTR tv1359[esp+840], ecx
  0015a	9f		 lahf
  0015b	f6 c4 44	 test	 ah, 68			; 00000044H
  0015e	0f 8b 5d 03 00
	00		 jnp	 $LN43@Eval

; 123  : 		{
; 124  : 		    //THROW(new CEvalException("Divide by 0"));
; 125  : 		    return 0;
; 126  : 		}
; 127  : 		save[iSp-1]/=save[iSp]; break;

  00164	f2 0f 10 44 d4
	18		 movsd	 xmm0, QWORD PTR _save$[esp+edx*8+832]
  0016a	f2 0f 5e c1	 divsd	 xmm0, xmm1
  0016e	f2 0f 11 44 d4
	18		 movsd	 QWORD PTR _save$[esp+edx*8+832], xmm0
  00174	e9 1b 03 00 00	 jmp	 $LN4@Eval
$LN16@Eval:

; 128  : 		//case '^':
; 129  : 	    case POLY_POW:
; 130  : 		iSp--;
; 131  : 		save[iSp-1]=pow(save[iSp-1],save[iSp]); break;

  00179	f2 0f 10 44 d4
	10		 movsd	 xmm0, QWORD PTR _save$[esp+edx*8+824]
  0017f	4a		 dec	 edx
  00180	83 e9 08	 sub	 ecx, 8
  00183	89 54 24 0c	 mov	 DWORD PTR _iSp$1$[esp+840], edx
  00187	89 4c 24 10	 mov	 DWORD PTR tv1359[esp+840], ecx
  0018b	f2 0f 10 4c d4
	20		 movsd	 xmm1, QWORD PTR _save$[esp+edx*8+840]
  00191	e8 00 00 00 00	 call	 __libm_sse2_pow_precise
  00196	8b 54 24 0c	 mov	 edx, DWORD PTR _iSp$1$[esp+840]
  0019a	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@3ff0000000000000
  001a2	8b 4c 24 10	 mov	 ecx, DWORD PTR tv1359[esp+840]
  001a6	f2 0f 11 44 d4
	18		 movsd	 QWORD PTR _save$[esp+edx*8+832], xmm0
  001ac	e9 e3 02 00 00	 jmp	 $LN4@Eval
$LN17@Eval:

; 132  : 	    case POLY_ROOT:
; 133  : 		if (save[iSp-1]<0)

  001b1	f2 0f 10 54 d4
	18		 movsd	 xmm2, QWORD PTR _save$[esp+edx*8+832]
  001b7	0f 57 c0	 xorps	 xmm0, xmm0
  001ba	66 0f 2f c2	 comisd	 xmm0, xmm2
  001be	0f 87 fd 02 00
	00		 ja	 $LN43@Eval

; 134  : 		{
; 135  : 		    //THROW(new CEvalException("Negative in root"));
; 136  : 		    return 0;
; 137  : 		}
; 138  : 		save[iSp-1]=sqrt(save[iSp-1]); break;

  001c4	0f 57 c9	 xorps	 xmm1, xmm1
  001c7	0f 28 c2	 movaps	 xmm0, xmm2
  001ca	66 0f 2e c8	 ucomisd xmm1, xmm0
  001ce	77 06		 ja	 SHORT $LN100@Eval
  001d0	f2 0f 51 c0	 sqrtsd	 xmm0, xmm0
  001d4	eb 05		 jmp	 SHORT $LN101@Eval
$LN100@Eval:
  001d6	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
$LN101@Eval:
  001db	8b 54 24 0c	 mov	 edx, DWORD PTR _iSp$1$[esp+840]
  001df	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@3ff0000000000000
  001e7	8b 4c 24 10	 mov	 ecx, DWORD PTR tv1359[esp+840]
  001eb	f2 0f 11 44 d4
	18		 movsd	 QWORD PTR _save$[esp+edx*8+832], xmm0
  001f1	e9 9e 02 00 00	 jmp	 $LN4@Eval
$LN19@Eval:

; 139  : 	    case POLY_COS:
; 140  : 		save[iSp-1]=cos(save[iSp-1]); break;

  001f6	f2 0f 10 44 d4
	18		 movsd	 xmm0, QWORD PTR _save$[esp+edx*8+832]
  001fc	e8 00 00 00 00	 call	 __libm_sse2_cos_precise
  00201	8b 54 24 0c	 mov	 edx, DWORD PTR _iSp$1$[esp+840]
  00205	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@3ff0000000000000
  0020d	8b 4c 24 10	 mov	 ecx, DWORD PTR tv1359[esp+840]
  00211	f2 0f 11 44 d4
	18		 movsd	 QWORD PTR _save$[esp+edx*8+832], xmm0
  00217	e9 78 02 00 00	 jmp	 $LN4@Eval
$LN20@Eval:

; 141  : 	    case POLY_SIN:
; 142  : 		save[iSp-1]=sin(save[iSp-1]); break;

  0021c	f2 0f 10 44 d4
	18		 movsd	 xmm0, QWORD PTR _save$[esp+edx*8+832]
  00222	e8 00 00 00 00	 call	 __libm_sse2_sin_precise
  00227	8b 54 24 0c	 mov	 edx, DWORD PTR _iSp$1$[esp+840]
  0022b	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@3ff0000000000000
  00233	8b 4c 24 10	 mov	 ecx, DWORD PTR tv1359[esp+840]
  00237	f2 0f 11 44 d4
	18		 movsd	 QWORD PTR _save$[esp+edx*8+832], xmm0
  0023d	e9 52 02 00 00	 jmp	 $LN4@Eval
$LN21@Eval:

; 143  : 	    case POLY_TAN:
; 144  : 		if (!(t=cos(save[iSp-1])))

  00242	f2 0f 10 44 d4
	18		 movsd	 xmm0, QWORD PTR _save$[esp+edx*8+832]
  00248	e8 00 00 00 00	 call	 __libm_sse2_cos_precise
  0024d	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  00255	9f		 lahf
  00256	f6 c4 44	 test	 ah, 68			; 00000044H
  00259	0f 8b 62 02 00
	00		 jnp	 $LN43@Eval

; 145  : 		{
; 146  : 		    //THROW (new CEvalException("Divide by 0"));
; 147  : 		    return 0;
; 148  : 		}
; 149  : 		save[iSp-1]=tan(save[iSp-1]); break;

  0025f	8b 44 24 0c	 mov	 eax, DWORD PTR _iSp$1$[esp+840]
  00263	f2 0f 10 44 c4
	18		 movsd	 xmm0, QWORD PTR _save$[esp+eax*8+832]
  00269	e8 00 00 00 00	 call	 __libm_sse2_tan_precise
  0026e	8b 54 24 0c	 mov	 edx, DWORD PTR _iSp$1$[esp+840]
  00272	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@3ff0000000000000
  0027a	8b 4c 24 10	 mov	 ecx, DWORD PTR tv1359[esp+840]
  0027e	f2 0f 11 44 d4
	18		 movsd	 QWORD PTR _save$[esp+edx*8+832], xmm0
  00284	e9 0b 02 00 00	 jmp	 $LN4@Eval
$LN23@Eval:

; 150  : 	    case POLY_CSC:
; 151  : 		if (!(t=sin(save[iSp-1])))

  00289	f2 0f 10 44 d4
	18		 movsd	 xmm0, QWORD PTR _save$[esp+edx*8+832]
  0028f	e8 00 00 00 00	 call	 __libm_sse2_sin_precise
$LN107@Eval:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 154  :         return _Ptr == _Right._Ptr;

  00294	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  0029c	9f		 lahf
  0029d	f6 c4 44	 test	 ah, 68			; 00000044H
  002a0	0f 8b 1b 02 00
	00		 jnp	 $LN43@Eval
  002a6	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@3ff0000000000000
  002ae	0f 28 cb	 movaps	 xmm1, xmm3
  002b1	8b 54 24 0c	 mov	 edx, DWORD PTR _iSp$1$[esp+840]
  002b5	f2 0f 5e c8	 divsd	 xmm1, xmm0
  002b9	8b 4c 24 10	 mov	 ecx, DWORD PTR tv1359[esp+840]
  002bd	f2 0f 11 4c d4
	18		 movsd	 QWORD PTR _save$[esp+edx*8+832], xmm1
  002c3	e9 cc 01 00 00	 jmp	 $LN4@Eval
$LN25@Eval:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 158  : 		if (!(t=cos(save[iSp-1])))

  002c8	f2 0f 10 44 d4
	18		 movsd	 xmm0, QWORD PTR _save$[esp+edx*8+832]
  002ce	e8 00 00 00 00	 call	 __libm_sse2_cos_precise

; 159  : 		{
; 160  : 		    //THROW(new CEvalException("Divide by 0"));
; 161  : 		    return 0;
; 162  : 		}
; 163  : 		save[iSp-1]=1/t; break;

  002d3	eb bf		 jmp	 SHORT $LN107@Eval
$LN27@Eval:

; 164  : 	    case POLY_COT:
; 165  : 		if (!(t=sin(save[iSp-1])))

  002d5	f2 0f 10 44 d4
	18		 movsd	 xmm0, QWORD PTR _save$[esp+edx*8+832]
  002db	e8 00 00 00 00	 call	 __libm_sse2_sin_precise
  002e0	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  002e8	f2 0f 11 44 24
	18		 movsd	 QWORD PTR _t$3$[esp+840], xmm0
  002ee	9f		 lahf
  002ef	f6 c4 44	 test	 ah, 68			; 00000044H
  002f2	0f 8b c9 01 00
	00		 jnp	 $LN43@Eval

; 166  : 		{
; 167  : 		    //THROW(new CEvalException("Divide by 0"));
; 168  : 		    return 0;
; 169  : 		}
; 170  : 		save[iSp-1]=cos(save[iSp-1])/t; break;

  002f8	8b 44 24 0c	 mov	 eax, DWORD PTR _iSp$1$[esp+840]
  002fc	f2 0f 10 44 c4
	18		 movsd	 xmm0, QWORD PTR _save$[esp+eax*8+832]
  00302	e8 00 00 00 00	 call	 __libm_sse2_cos_precise
  00307	f2 0f 5e 44 24
	18		 divsd	 xmm0, QWORD PTR _t$3$[esp+840]
$LN109@Eval:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 154  :         return _Ptr == _Right._Ptr;

  0030d	8b 54 24 0c	 mov	 edx, DWORD PTR _iSp$1$[esp+840]
  00311	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@3ff0000000000000
  00319	8b 4c 24 10	 mov	 ecx, DWORD PTR tv1359[esp+840]
  0031d	f2 0f 11 44 d4
	18		 movsd	 QWORD PTR _save$[esp+edx*8+832], xmm0
  00323	e9 6c 01 00 00	 jmp	 $LN4@Eval
$LN29@Eval:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 172  : 		if (save[iSp-1]<=0)

  00328	f2 0f 10 4c d4
	18		 movsd	 xmm1, QWORD PTR _save$[esp+edx*8+832]
  0032e	0f 57 c0	 xorps	 xmm0, xmm0
  00331	66 0f 2f c1	 comisd	 xmm0, xmm1
  00335	0f 83 86 01 00
	00		 jae	 $LN43@Eval

; 173  : 		{
; 174  : 		    //THROW( new CEvalException("Call Log with minus number"));
; 175  : 		    return 0;
; 176  : 		}
; 177  : 		save[iSp-1]=log(save[iSp-1]); break;

  0033b	0f 28 c1	 movaps	 xmm0, xmm1
  0033e	e8 00 00 00 00	 call	 __libm_sse2_log_precise
  00343	eb c8		 jmp	 SHORT $LN109@Eval
$LN31@Eval:

; 178  : 	    case POLY_LOG10:
; 179  : 		if (save[iSp-1]<=0)

  00345	f2 0f 10 4c d4
	18		 movsd	 xmm1, QWORD PTR _save$[esp+edx*8+832]
  0034b	0f 57 c0	 xorps	 xmm0, xmm0
  0034e	66 0f 2f c1	 comisd	 xmm0, xmm1
  00352	0f 83 69 01 00
	00		 jae	 $LN43@Eval

; 180  : 		{
; 181  : 		    //THROW( new CEvalException("Call Log with minus number"));
; 182  : 		    return 0;
; 183  : 		}
; 184  : 		save[iSp-1]=log10(save[iSp-1]); break;

  00358	0f 28 c1	 movaps	 xmm0, xmm1
  0035b	e8 00 00 00 00	 call	 __libm_sse2_log10_precise
  00360	eb ab		 jmp	 SHORT $LN109@Eval
$LN33@Eval:

; 185  : 	    case POLY_LOG:
; 186  : 		if (save[iSp-1]<=0)

  00362	f2 0f 10 54 d4
	18		 movsd	 xmm2, QWORD PTR _save$[esp+edx*8+832]
  00368	0f 57 c0	 xorps	 xmm0, xmm0
  0036b	66 0f 2f c2	 comisd	 xmm0, xmm2
  0036f	0f 83 4c 01 00
	00		 jae	 $LN43@Eval

; 187  : 		{
; 188  : 		    //THROW( new CEvalException("Call Log with minus number"));
; 189  : 		    return 0;
; 190  : 		}
; 191  : 		if (save[iSp-2]<=0 || save[iSp-2]==1)

  00375	f2 0f 10 09	 movsd	 xmm1, QWORD PTR [ecx]
  00379	66 0f 2f c1	 comisd	 xmm0, xmm1
  0037d	0f 83 3e 01 00
	00		 jae	 $LN43@Eval
  00383	66 0f 2e cb	 ucomisd xmm1, xmm3
  00387	9f		 lahf
  00388	f6 c4 44	 test	 ah, 68			; 00000044H
  0038b	0f 8b 30 01 00
	00		 jnp	 $LN43@Eval

; 192  : 		{
; 193  : 		    //THROW( new CEvalException("Call Log with minus number"));
; 194  : 		    return 0;
; 195  : 		}
; 196  : 
; 197  : 		save[iSp-2]=log(save[iSp-1])/log(save[iSp-2]);

  00391	0f 28 c2	 movaps	 xmm0, xmm2
  00394	e8 00 00 00 00	 call	 __libm_sse2_log_precise
  00399	8b 44 24 10	 mov	 eax, DWORD PTR tv1359[esp+840]
  0039d	f2 0f 11 44 24
	18		 movsd	 QWORD PTR tv1333[esp+840], xmm0
  003a3	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  003a7	e8 00 00 00 00	 call	 __libm_sse2_log_precise
  003ac	f2 0f 10 4c 24
	18		 movsd	 xmm1, QWORD PTR tv1333[esp+840]
  003b2	f2 0f 5e c8	 divsd	 xmm1, xmm0
  003b6	8b 4c 24 10	 mov	 ecx, DWORD PTR tv1359[esp+840]

; 198  : 		iSp--;

  003ba	8b 54 24 0c	 mov	 edx, DWORD PTR _iSp$1$[esp+840]

; 199  : 		break;

  003be	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@3ff0000000000000
  003c6	f2 0f 11 09	 movsd	 QWORD PTR [ecx], xmm1
  003ca	e9 b9 00 00 00	 jmp	 $LN104@Eval
$LN37@Eval:

; 200  : 	    case POLY_ABS:
; 201  : 		save[iSp-1]=fabs(save[iSp-1]);

  003cf	f2 0f 10 44 d4
	18		 movsd	 xmm0, QWORD PTR _save$[esp+edx*8+832]
  003d5	0f 54 05 00 00
	00 00		 andps	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  003dc	f2 0f 11 44 d4
	18		 movsd	 QWORD PTR _save$[esp+edx*8+832], xmm0

; 202  : 		break;

  003e2	e9 ad 00 00 00	 jmp	 $LN4@Eval
$LN38@Eval:

; 203  : 		case POLY_FLOOR:
; 204  : 		save[iSp-1]=floor(save[iSp-1]);

  003e7	dd 44 d4 18	 fld	 QWORD PTR _save$[esp+edx*8+832]
  003eb	83 ec 08	 sub	 esp, 8
  003ee	dd 1c 24	 fstp	 QWORD PTR [esp]
  003f1	e8 00 00 00 00	 call	 _floor
  003f6	83 c4 08	 add	 esp, 8

; 205  : 		break;

  003f9	e9 29 fd ff ff	 jmp	 $LN106@Eval
$LN39@Eval:

; 206  : 	    case POLY_IRAND:
; 207  : 		save[iSp-2]=my_irandom(save[iSp-2],save[iSp-1]);

  003fe	f2 0f 10 44 d4
	18		 movsd	 xmm0, QWORD PTR _save$[esp+edx*8+832]
  00404	83 ec 10	 sub	 esp, 16			; 00000010H
  00407	f2 0f 11 44 24
	08		 movsd	 QWORD PTR [esp+8], xmm0
  0040d	f2 0f 10 01	 movsd	 xmm0, QWORD PTR [ecx]
  00411	8b 4c 24 24	 mov	 ecx, DWORD PTR _this$1$[esp+856]
  00415	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0041a	e8 00 00 00 00	 call	 ?my_irandom@CPoly@@IAEHNN@Z ; CPoly::my_irandom
  0041f	8b 4c 24 10	 mov	 ecx, DWORD PTR tv1359[esp+840]

; 208  : 		iSp--;

  00423	8b 54 24 0c	 mov	 edx, DWORD PTR _iSp$1$[esp+840]

; 209  : 		break;

  00427	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@3ff0000000000000
  0042f	66 0f 6e c0	 movd	 xmm0, eax
  00433	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00437	eb 4b		 jmp	 SHORT $LN105@Eval
$LN40@Eval:

; 210  : 	    case POLY_FRAND:
; 211  : 		save[iSp-2]=my_frandom(save[iSp-2],save[iSp-1]);

  00439	f2 0f 10 44 d4
	18		 movsd	 xmm0, QWORD PTR _save$[esp+edx*8+832]
  0043f	83 ec 10	 sub	 esp, 16			; 00000010H
  00442	f2 0f 11 44 24
	08		 movsd	 QWORD PTR [esp+8], xmm0
  00448	f2 0f 10 01	 movsd	 xmm0, QWORD PTR [ecx]
  0044c	8b 4c 24 24	 mov	 ecx, DWORD PTR _this$1$[esp+856]
  00450	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00455	e8 00 00 00 00	 call	 ?my_frandom@CPoly@@IAENNN@Z ; CPoly::my_frandom
  0045a	8b 4c 24 10	 mov	 ecx, DWORD PTR tv1359[esp+840]

; 212  : 		iSp--;

  0045e	8b 54 24 0c	 mov	 edx, DWORD PTR _iSp$1$[esp+840]

; 213  : 		break;

  00462	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@3ff0000000000000
  0046a	dd 19		 fstp	 QWORD PTR [ecx]
  0046c	eb 1a		 jmp	 SHORT $LN104@Eval
$LN41@Eval:

; 214  : 	    case POLY_MINF:
; 215  : 		save[iSp-2]=(save[iSp-2]<save[iSp-1])?save[iSp-2]:save[iSp-1];

  0046e	f2 0f 10 01	 movsd	 xmm0, QWORD PTR [ecx]
  00472	f2 0f 5d 44 d4
	18		 minsd	 xmm0, QWORD PTR _save$[esp+edx*8+832]

; 216  : 		iSp--;
; 217  : 		break;

  00478	eb 0a		 jmp	 SHORT $LN105@Eval
$LN42@Eval:

; 218  : 	    case POLY_MAXF:
; 219  : 		save[iSp-2]=(save[iSp-2]>save[iSp-1])?save[iSp-2]:save[iSp-1];

  0047a	f2 0f 10 01	 movsd	 xmm0, QWORD PTR [ecx]
  0047e	f2 0f 5f 44 d4
	18		 maxsd	 xmm0, QWORD PTR _save$[esp+edx*8+832]
$LN105@Eval:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 154  :         return _Ptr == _Right._Ptr;

  00484	f2 0f 11 01	 movsd	 QWORD PTR [ecx], xmm0
$LN104@Eval:
  00488	4a		 dec	 edx
$LN103@Eval:
  00489	83 e9 08	 sub	 ecx, 8
$LN102@Eval:
  0048c	89 4c 24 10	 mov	 DWORD PTR tv1359[esp+840], ecx
  00490	89 54 24 0c	 mov	 DWORD PTR _iSp$1$[esp+840], edx
$LN4@Eval:
  00494	8b 44 24 14	 mov	 eax, DWORD PTR _this$1$[esp+840]
  00498	3b 70 2c	 cmp	 esi, DWORD PTR [eax+44]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 84   :     while (pos != tokenBase.end())

  0049b	0f 85 b2 fb ff
	ff		 jne	 $LL2@Eval
$LN3@Eval:

; 220  : 		iSp--;
; 221  : 		break;
; 222  : 		/*case POLY_MOD:
; 223  : 		  save[iSp-2]=fmod(save[iSp-2],save[iSp-1]);
; 224  : 		  iSp--;
; 225  : 		  break;*/
; 226  : 	    default:
; 227  : 		return 0;
; 228  : 		//THROW(new CEvalException("Token Error"));
; 229  : 	}
; 230  :     }
; 231  :     return float(save[iSp-1]);

  004a1	dd 44 d4 18	 fld	 QWORD PTR _save$[esp+edx*8+832]
  004a5	d9 5c 24 14	 fstp	 DWORD PTR tv1391[esp+840]
  004a9	d9 44 24 14	 fld	 DWORD PTR tv1391[esp+840]

; 232  : }

  004ad	5f		 pop	 edi
  004ae	5e		 pop	 esi
  004af	8b 8c 24 3c 03
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+832]
  004b6	33 cc		 xor	 ecx, esp
  004b8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004bd	8b e5		 mov	 esp, ebp
  004bf	5d		 pop	 ebp
  004c0	c3		 ret	 0
$LN43@Eval:
  004c1	8b 8c 24 44 03
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+840]
  004c8	d9 ee		 fldz
  004ca	5f		 pop	 edi
  004cb	5e		 pop	 esi
  004cc	33 cc		 xor	 ecx, esp
  004ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004d3	8b e5		 mov	 esp, ebp
  004d5	5d		 pop	 ebp
  004d6	c3		 ret	 0
  004d7	90		 npad	 1
$LN99@Eval:
  004d8	00 00 00 00	 DD	 $LN17@Eval
  004dc	00 00 00 00	 DD	 $LN11@Eval
  004e0	00 00 00 00	 DD	 $LN9@Eval
  004e4	00 00 00 00	 DD	 $LN16@Eval
  004e8	00 00 00 00	 DD	 $LN10@Eval
  004ec	00 00 00 00	 DD	 $LN14@Eval
  004f0	00 00 00 00	 DD	 $LN43@Eval
  004f4	00 00 00 00	 DD	 $LN43@Eval
  004f8	00 00 00 00	 DD	 $LN7@Eval
  004fc	00 00 00 00	 DD	 $LN8@Eval
  00500	00 00 00 00	 DD	 $LN43@Eval
  00504	00 00 00 00	 DD	 $LN19@Eval
  00508	00 00 00 00	 DD	 $LN20@Eval
  0050c	00 00 00 00	 DD	 $LN21@Eval
  00510	00 00 00 00	 DD	 $LN23@Eval
  00514	00 00 00 00	 DD	 $LN25@Eval
  00518	00 00 00 00	 DD	 $LN27@Eval
  0051c	00 00 00 00	 DD	 $LN33@Eval
  00520	00 00 00 00	 DD	 $LN29@Eval
  00524	00 00 00 00	 DD	 $LN31@Eval
  00528	00 00 00 00	 DD	 $LN37@Eval
  0052c	00 00 00 00	 DD	 $LN41@Eval
  00530	00 00 00 00	 DD	 $LN42@Eval
  00534	00 00 00 00	 DD	 $LN39@Eval
  00538	00 00 00 00	 DD	 $LN40@Eval
  0053c	00 00 00 00	 DD	 $LN12@Eval
  00540	00 00 00 00	 DD	 $LN38@Eval
?Eval@CPoly@@QAEMXZ ENDP				; CPoly::Eval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
;	COMDAT ?Analyze@CPoly@@QAEHPBD@Z
_TEXT	SEGMENT
$T2 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pszStr$ = 8						; size = 4
?Analyze@CPoly@@QAEHPBD@Z PROC				; CPoly::Analyze, COMDAT
; _this$ = ecx

; 235  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Analyze@CPoly@@QAEHPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b f1		 mov	 esi, ecx
  0002c	8b 55 08	 mov	 edx, DWORD PTR _pszStr$[ebp]

; 236  :     if (pszStr)

  0002f	85 d2		 test	 edx, edx
  00031	74 7a		 je	 SHORT $LN35@Analyze
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00033	8b ca		 mov	 ecx, edx

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00035	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0

; 4596 :         _My_data._Mysize = 0;

  0003c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00043	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0004a	c6 45 d8 00	 mov	 BYTE PTR $T2[ebp], 0

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0004e	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
$LL53@Analyze:
  00051	8a 01		 mov	 al, BYTE PTR [ecx]
  00053	41		 inc	 ecx
  00054	84 c0		 test	 al, al
  00056	75 f9		 jne	 SHORT $LL53@Analyze
  00058	2b cf		 sub	 ecx, edi

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0005a	51		 push	 ecx
  0005b	52		 push	 edx
  0005c	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  0005f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 237  : 	SetStr(pszStr);

  00064	8d 45 d8	 lea	 eax, DWORD PTR $T2[ebp]
  00067	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0006e	50		 push	 eax
  0006f	8b ce		 mov	 ecx, esi
  00071	e8 00 00 00 00	 call	 ?SetStr@CPoly@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CPoly::SetStr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00076	8b 55 ec	 mov	 edx, DWORD PTR $T2[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 237  : 	SetStr(pszStr);

  00079	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00080	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00083	72 28		 jb	 SHORT $LN35@Analyze
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00085	8b 4d d8	 mov	 ecx, DWORD PTR $T2[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00088	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00089	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0008b	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00091	72 10		 jb	 SHORT $LN45@Analyze

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00093	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00096	83 c2 23	 add	 edx, 35			; 00000023H
  00099	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0009b	83 c0 fc	 add	 eax, -4			; fffffffcH
  0009e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000a1	77 64		 ja	 SHORT $LN57@Analyze
$LN45@Analyze:

; 264  :         ::operator delete(_Ptr, _Bytes);

  000a3	52		 push	 edx
  000a4	51		 push	 ecx
  000a5	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000aa	83 c4 08	 add	 esp, 8
$LN35@Analyze:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 239  :     if (0 == strData.length())

  000ad	83 7e 70 00	 cmp	 DWORD PTR [esi+112], 0
  000b1	75 07		 jne	 SHORT $LN3@Analyze

; 240  : 	return true;

  000b3	b8 01 00 00 00	 mov	 eax, 1
  000b8	eb 30		 jmp	 SHORT $LN1@Analyze
$LN3@Analyze:

; 241  : 
; 242  :     //DisposeList();
; 243  :     ErrorOccur = false;
; 244  :     uiLookPos = 0;
; 245  :     iLookAhead = lexan();

  000ba	8b ce		 mov	 ecx, esi
  000bc	c6 46 20 00	 mov	 BYTE PTR [esi+32], 0
  000c0	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  000c7	e8 00 00 00 00	 call	 ?lexan@CPoly@@IAEHXZ	; CPoly::lexan

; 246  : 
; 247  :     expr();

  000cc	8b ce		 mov	 ecx, esi
  000ce	89 46 18	 mov	 DWORD PTR [esi+24], eax
  000d1	e8 00 00 00 00	 call	 ?expr@CPoly@@IAEXXZ	; CPoly::expr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

  000d6	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  000d9	3b 46 2c	 cmp	 eax, DWORD PTR [esi+44]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 249  :     if (tokenBase.empty())

  000dc	75 04		 jne	 SHORT $LN4@Analyze

; 250  :     {
; 251  : 	//THROW(new CParseException("No Data"));
; 252  : 	return false;

  000de	33 c0		 xor	 eax, eax
  000e0	eb 08		 jmp	 SHORT $LN1@Analyze
$LN4@Analyze:

; 253  :     }
; 254  : 
; 255  :     return !ErrorOccur;

  000e2	33 c0		 xor	 eax, eax
  000e4	38 46 20	 cmp	 BYTE PTR [esi+32], al
  000e7	0f 94 c0	 sete	 al
$LN1@Analyze:

; 256  : }

  000ea	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ed	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f4	59		 pop	 ecx
  000f5	5f		 pop	 edi
  000f6	5e		 pop	 esi
  000f7	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fa	33 cd		 xor	 ecx, ebp
  000fc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00101	8b e5		 mov	 esp, ebp
  00103	5d		 pop	 ebp
  00104	c2 04 00	 ret	 4
$LN57@Analyze:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00107	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN55@Analyze:
  0010c	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Analyze@CPoly@@QAEHPBD@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?Analyze@CPoly@@QAEHPBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Analyze@CPoly@@QAEHPBD@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Analyze@CPoly@@QAEHPBD@Z ENDP				; CPoly::Analyze
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
;	COMDAT ??1CPoly@@UAE@XZ
_TEXT	SEGMENT
??1CPoly@@UAE@XZ PROC					; CPoly::~CPoly, COMDAT
; _this$ = ecx

; 59   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CPoly@@6B@

; 60   :     Clear();

  00009	e8 00 00 00 00	 call	 ?Clear@CPoly@@QAEXXZ	; CPoly::Clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  0000e	8b 4e 74	 mov	 ecx, DWORD PTR [esi+116]
  00011	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00014	72 2c		 jb	 SHORT $LN15@CPoly
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00016	8b 46 60	 mov	 eax, DWORD PTR [esi+96]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00019	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0001a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00020	72 16		 jb	 SHORT $LN25@CPoly

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00022	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00025	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00028	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0002a	83 c0 fc	 add	 eax, -4			; fffffffcH
  0002d	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00030	0f 87 48 01 00
	00		 ja	 $LN119@CPoly

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00036	8b c2		 mov	 eax, edx
$LN25@CPoly:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00038	51		 push	 ecx
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003f	83 c4 08	 add	 esp, 8
$LN15@CPoly:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  00042	c7 46 70 00 00
	00 00		 mov	 DWORD PTR [esi+112], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00049	c7 46 74 0f 00
	00 00		 mov	 DWORD PTR [esi+116], 15	; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00050	c6 46 60 00	 mov	 BYTE PTR [esi+96], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00054	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  00057	85 c0		 test	 eax, eax
  00059	74 45		 je	 SHORT $LN34@CPoly

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0005b	8b 4e 54	 mov	 ecx, DWORD PTR [esi+84]
  0005e	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00060	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00063	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00069	72 16		 jb	 SHORT $LN50@CPoly

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0006b	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0006e	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00071	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00073	83 c0 fc	 add	 eax, -4			; fffffffcH
  00076	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00079	0f 87 ff 00 00
	00		 ja	 $LN119@CPoly

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0007f	8b c2		 mov	 eax, edx
$LN50@CPoly:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00081	51		 push	 ecx
  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  00088	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  0008f	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  00092	c7 46 50 00 00
	00 00		 mov	 DWORD PTR [esi+80], 0

; 1769 :             _Myend   = nullptr;

  00099	c7 46 54 00 00
	00 00		 mov	 DWORD PTR [esi+84], 0
$LN34@CPoly:

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  000a0	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  000a3	85 c0		 test	 eax, eax
  000a5	74 45		 je	 SHORT $LN58@CPoly

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000a7	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  000aa	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000ac	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000af	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000b5	72 16		 jb	 SHORT $LN74@CPoly

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000b7	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000ba	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000bd	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000bf	83 c0 fc	 add	 eax, -4			; fffffffcH
  000c2	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000c5	0f 87 b3 00 00
	00		 ja	 $LN119@CPoly

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000cb	8b c2		 mov	 eax, edx
$LN74@CPoly:

; 264  :         ::operator delete(_Ptr, _Bytes);

  000cd	51		 push	 ecx
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  000d4	c7 46 40 00 00
	00 00		 mov	 DWORD PTR [esi+64], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  000db	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  000de	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], 0

; 1769 :             _Myend   = nullptr;

  000e5	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
$LN58@CPoly:

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  000ec	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  000ef	85 c0		 test	 eax, eax
  000f1	74 41		 je	 SHORT $LN82@CPoly

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000f3	8b 4e 3c	 mov	 ecx, DWORD PTR [esi+60]
  000f6	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000f8	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000fb	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00101	72 12		 jb	 SHORT $LN98@CPoly

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00103	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00106	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00109	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0010b	83 c0 fc	 add	 eax, -4			; fffffffcH
  0010e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00111	77 6b		 ja	 SHORT $LN119@CPoly

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00113	8b c2		 mov	 eax, edx
$LN98@CPoly:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00115	51		 push	 ecx
  00116	50		 push	 eax
  00117	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  0011c	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00123	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  00126	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 1769 :             _Myend   = nullptr;

  0012d	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0
$LN82@CPoly:

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00134	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00137	85 c0		 test	 eax, eax
  00139	74 41		 je	 SHORT $LN106@CPoly

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0013b	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  0013e	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00140	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00143	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00149	72 12		 jb	 SHORT $LN122@CPoly

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0014b	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0014e	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00151	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00153	83 c0 fc	 add	 eax, -4			; fffffffcH
  00156	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00159	77 23		 ja	 SHORT $LN119@CPoly

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0015b	8b c2		 mov	 eax, edx
$LN122@CPoly:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0015d	51		 push	 ecx
  0015e	50		 push	 eax
  0015f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

  00164	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  0016b	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1768 :             _Mylast  = nullptr;

  0016e	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0

; 1769 :             _Myend   = nullptr;

  00175	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
$LN106@CPoly:
  0017c	5e		 pop	 esi
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 61   : }

  0017d	c3		 ret	 0
$LN119@CPoly:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0017e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN127@CPoly:
  00183	cc		 int	 3
??1CPoly@@UAE@XZ ENDP					; CPoly::~CPoly
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp
;	COMDAT ??0CPoly@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CPoly@@QAE@XZ PROC					; CPoly::CPoly, COMDAT
; _this$ = ecx

; 47   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CPoly@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CPoly@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0002f	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
  00036	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
  0003d	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 47   : {

  00044	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0004b	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
  00052	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  00059	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 47   : {

  00060	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00063	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00069	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00070	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0
  00077	c7 46 50 00 00
	00 00		 mov	 DWORD PTR [esi+80], 0
  0007e	c7 46 54 00 00
	00 00		 mov	 DWORD PTR [esi+84], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00085	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0

; 4596 :         _My_data._Mysize = 0;

  0008c	c7 46 70 00 00
	00 00		 mov	 DWORD PTR [esi+112], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00093	c7 46 74 0f 00
	00 00		 mov	 DWORD PTR [esi+116], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0009a	c6 46 60 00	 mov	 BYTE PTR [esi+96], 0
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 48   : 	m_iRandomType = RANDOM_TYPE_FREELY;

  0009e	c7 46 78 00 00
	00 00		 mov	 DWORD PTR [esi+120], 0

; 49   :     uiLookPos = 0;

  000a5	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0

; 50   :     ErrorOccur = true;

  000ac	c6 46 20 01	 mov	 BYTE PTR [esi+32], 1

; 51   :     lSymbol.clear();

  000b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b2	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 52   :     STSize = 0;

  000b5	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0

; 53   : 	MathSymbolCount = 0;

  000bc	c7 46 5c 00 00
	00 00		 mov	 DWORD PTR [esi+92], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  000c3	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000c6	2b c2		 sub	 eax, edx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 47   : {

  000c8	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vector

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  000cc	c1 f8 02	 sar	 eax, 2

; 1371 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  000cf	83 f8 32	 cmp	 eax, 50			; 00000032H
  000d2	73 07		 jae	 SHORT $LN46@CPoly

; 1372 :             if (_Newcapacity > max_size()) {
; 1373 :                 _Xlength();
; 1374 :             }
; 1375 : 
; 1376 :             _Reallocate_exactly(_Newcapacity);

  000d4	6a 32		 push	 50			; 00000032H
  000d6	e8 00 00 00 00	 call	 ?_Reallocate_exactly@?$vector@PAVCSymTable@@V?$allocator@PAVCSymTable@@@std@@@std@@AAEXI@Z ; std::vector<CSymTable *,std::allocator<CSymTable *> >::_Reallocate_exactly
$LN46@CPoly:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\poly\Poly.cpp

; 55   :     init();

  000db	8b ce		 mov	 ecx, esi
  000dd	e8 00 00 00 00	 call	 ?init@CPoly@@IAEXXZ	; CPoly::init

; 56   : }

  000e2	8b c6		 mov	 eax, esi
  000e4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ee	59		 pop	 ecx
  000ef	5e		 pop	 esi
  000f0	8b e5		 mov	 esp, ebp
  000f2	5d		 pop	 ebp
  000f3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CPoly@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 28	 add	 ecx, 40			; 00000028H
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0CPoly@@QAE@XZ$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 34	 add	 ecx, 52			; 00000034H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__unwindfunclet$??0CPoly@@QAE@XZ$2:
  00016	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 c1 40	 add	 ecx, 64			; 00000040H
  0001c	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCSymTable@@V?$allocator@PAVCSymTable@@@std@@@std@@QAE@XZ ; std::vector<CSymTable *,std::allocator<CSymTable *> >::~vector<CSymTable *,std::allocator<CSymTable *> >
__unwindfunclet$??0CPoly@@QAE@XZ$3:
  00021	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00027	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0CPoly@@QAE@XZ$4:
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 60	 add	 ecx, 96			; 00000060H
  00032	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00037	cc		 int	 3
  00038	cc		 int	 3
  00039	cc		 int	 3
  0003a	cc		 int	 3
  0003b	cc		 int	 3
__ehhandler$??0CPoly@@QAE@XZ:
  0003c	90		 npad	 1
  0003d	90		 npad	 1
  0003e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00042	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00045	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00048	33 c8		 xor	 ecx, eax
  0004a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CPoly@@QAE@XZ
  00054	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CPoly@@QAE@XZ ENDP					; CPoly::CPoly
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Old$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
$T1 = 12						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3244 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 3245 :         // assign [_Ptr, _Ptr + _Count)
; 3246 :         if (_Count <= _Mypair._Myval2._Myres) {

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	57		 push	 edi
  0000c	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0000f	89 4d fc	 mov	 DWORD PTR __Old$1$[ebp], ecx
  00012	3b d9		 cmp	 ebx, ecx
  00014	77 28		 ja	 SHORT $LN2@assign

; 2296 :         value_type* _Result = _Bx._Buf;

  00016	8b fe		 mov	 edi, esi

; 2319 :         return _BUF_SIZE <= _Myres;

  00018	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 2297 :         if (_Large_string_engaged()) {

  0001b	72 02		 jb	 SHORT $LN5@assign

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  0001d	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN5@assign:

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0001f	53		 push	 ebx
  00020	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 3247 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3248 :             _Mypair._Myval2._Mysize = _Count;

  00023	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00026	57		 push	 edi
  00027	e8 00 00 00 00	 call	 _memmove
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3249 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0002f	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 3259 :             },
; 3260 :             _Ptr);
; 3261 :     }

  00033	8b c6		 mov	 eax, esi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
$LN2@assign:

; 4508 :         if (_New_size > max_size()) {

  0003e	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  00044	0f 87 d4 00 00
	00		 ja	 $LN60@assign

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0004a	8b fb		 mov	 edi, ebx
  0004c	83 cf 0f	 or	 edi, 15			; 0000000fH
  0004f	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH

; 4489 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00055	76 15		 jbe	 SHORT $LN19@assign

; 4490 :             return _Max;

  00057	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0005c	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00067	83 c4 04	 add	 esp, 4
  0006a	eb 52		 jmp	 SHORT $LN58@assign
$LN19@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4493 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0006c	8b d1		 mov	 edx, ecx
  0006e	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00073	d1 ea		 shr	 edx, 1
  00075	2b c2		 sub	 eax, edx
  00077	3b c8		 cmp	 ecx, eax
  00079	76 15		 jbe	 SHORT $LN20@assign

; 4494 :             return _Max;

  0007b	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00080	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0008b	83 c4 04	 add	 esp, 4
  0008e	eb 2e		 jmp	 SHORT $LN58@assign
$LN20@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4497 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00090	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00093	3b f8		 cmp	 edi, eax
  00095	0f 42 f8	 cmovb	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4515 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00098	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0009b	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000a0	72 0b		 jb	 SHORT $LN27@assign

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a8	83 c4 04	 add	 esp, 4
  000ab	eb 11		 jmp	 SHORT $LN58@assign
$LN27@assign:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  000ad	85 c0		 test	 eax, eax
  000af	74 0b		 je	 SHORT $LN28@assign

; 85   :         return ::operator new(_Bytes);

  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000b7	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  000ba	eb 02		 jmp	 SHORT $LN58@assign
$LN28@assign:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000bc	33 c0		 xor	 eax, eax
$LN58@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000be	53		 push	 ebx
  000bf	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 4523 :         _Mypair._Myval2._Mysize = _New_size;

  000c2	89 45 0c	 mov	 DWORD PTR $T1[ebp], eax

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c5	50		 push	 eax

; 4523 :         _Mypair._Myval2._Mysize = _New_size;

  000c6	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 4524 :         _Mypair._Myval2._Myres  = _New_capacity;

  000c9	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000cc	e8 00 00 00 00	 call	 _memcpy

; 3258 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000d1	8b 7d 0c	 mov	 edi, DWORD PTR $T1[ebp]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4526 :         if (_BUF_SIZE <= _Old_capacity) {

  000d7	8b 45 fc	 mov	 eax, DWORD PTR __Old$1$[ebp]

; 3258 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000da	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 4526 :         if (_BUF_SIZE <= _Old_capacity) {

  000de	83 f8 10	 cmp	 eax, 16			; 00000010H
  000e1	72 29		 jb	 SHORT $LN13@assign

; 4527 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  000e3	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e6	8b 06		 mov	 eax, DWORD PTR [esi]

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000e8	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000ee	72 12		 jb	 SHORT $LN50@assign

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f0	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000f3	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000f6	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000f8	83 c0 fc	 add	 eax, -4			; fffffffcH
  000fb	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000fe	77 19		 ja	 SHORT $LN47@assign

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00100	8b c2		 mov	 eax, edx
$LN50@assign:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00102	51		 push	 ecx
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00109	83 c4 08	 add	 esp, 8
$LN13@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3254 :         return _Reallocate_for(

  0010c	89 3e		 mov	 DWORD PTR [esi], edi

; 3259 :             },
; 3260 :             _Ptr);
; 3261 :     }

  0010e	8b c6		 mov	 eax, esi
  00110	5f		 pop	 edi
  00111	5e		 pop	 esi
  00112	5b		 pop	 ebx
  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c2 08 00	 ret	 8
$LN47@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00119	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN60@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4509 :             _Xlen_string(); // result too long

  0011e	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN56@assign:
  00123	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 3002 :     _CONSTEXPR20_CONTAINER ~basic_string() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2319 :         return _BUF_SIZE <= _Myres;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 27		 jb	 SHORT $LN12@basic_stri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0000d	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN22@basic_stri

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN19@basic_stri

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN22@basic_stri:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN12@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi

; 3010 :     }

  00044	c3		 ret	 0
$LN19@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN27@basic_stri:
  0004a	cc		 int	 3
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2374 :     _Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlen_strin:
  0000a	cc		 int	 3
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN12@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 142  :     }

  00003	8b c1		 mov	 eax, ecx

; 65   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 66   :     {
; 67   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 141  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN6@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 96   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 91   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 74   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
END
