; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30137.0 

	TITLE	C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\Distribute\FileDir.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHQBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
PUBLIC	??0CDir@@QAE@XZ					; CDir::CDir
PUBLIC	??1CDir@@UAE@XZ					; CDir::~CDir
PUBLIC	?Destroy@CDir@@QAEXXZ				; CDir::Destroy
PUBLIC	?Create@CDir@@QAE_NPBD0H@Z			; CDir::Create
PUBLIC	?IsFolder@CDir@@IAE_NXZ				; CDir::IsFolder
PUBLIC	?Initialize@CDir@@IAEXXZ			; CDir::Initialize
PUBLIC	??_GCDir@@UAEPAXI@Z				; CDir::`scalar deleting destructor'
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_7CDir@@6B@					; CDir::`vftable'
PUBLIC	??_C@_03EMIMMIHL@?$CK?4?$CK@			; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CDir@@6B@					; CDir::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCDir@@@8				; CDir `RTTI Type Descriptor'
PUBLIC	??_R3CDir@@8					; CDir::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDir@@8					; CDir::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CDir@@8				; CDir::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_strchr:PROC
EXTRN	__stricmp:PROC
EXTRN	__imp__FindClose@4:PROC
EXTRN	__imp__FindFirstFileA@8:PROC
EXTRN	__imp__FindNextFileA@8:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_ECDir@@UAEPAXI@Z:PROC			; CDir::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memchr:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ??_R1A@?0A@EA@CDir@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CDir@@8 DD FLAT:??_R0?AVCDir@@@8		; CDir::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CDir@@8
rdata$r	ENDS
;	COMDAT ??_R2CDir@@8
rdata$r	SEGMENT
??_R2CDir@@8 DD	FLAT:??_R1A@?0A@EA@CDir@@8		; CDir::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CDir@@8
rdata$r	SEGMENT
??_R3CDir@@8 DD	00H					; CDir::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CDir@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDir@@@8
data$rs	SEGMENT
??_R0?AVCDir@@@8 DD FLAT:??_7type_info@@6B@		; CDir `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDir@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CDir@@6B@
rdata$r	SEGMENT
??_R4CDir@@6B@ DD 00H					; CDir::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDir@@@8
	DD	FLAT:??_R3CDir@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_03EMIMMIHL@?$CK?4?$CK@
CONST	SEGMENT
??_C@_03EMIMMIHL@?$CK?4?$CK@ DB '*.*', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7CDir@@6B@
CONST	SEGMENT
??_7CDir@@6B@ DD FLAT:??_R4CDir@@6B@			; CDir::`vftable'
	DD	FLAT:??_ECDir@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Create@CDir@@QAE_NPBD0H@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?Create@CDir@@QAE_NPBD0H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Create@CDir@@QAE_NPBD0H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Create@CDir@@QAE_NPBD0H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Create@CDir@@QAE_NPBD0H@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Create@CDir@@QAE_NPBD0H@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?Create@CDir@@QAE_NPBD0H@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?Create@CDir@@QAE_NPBD0H@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$?Create@CDir@@QAE_NPBD0H@Z$4
	DD	05H
	DD	FLAT:__unwindfunclet$?Create@CDir@@QAE_NPBD0H@Z$5
xdata$x	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 134  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 135  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 137  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 85   :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 138  :         _Throw_bad_array_new_length(); // add overflow
; 139  :     }
; 140  : 
; 141  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 85   :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 145  : 
; 146  : #ifdef _DEBUG
; 147  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 148  : #endif // _DEBUG
; 149  :     return _Ptr;
; 150  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCDir@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCDir@@UAEPAXI@Z PROC				; CDir::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CDir@@UAE@XZ		; CDir::~CDir
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN4@scalar
  00011	68 48 01 00 00	 push	 328			; 00000148H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GCDir@@UAEPAXI@Z ENDP				; CDir::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
;	COMDAT ?Initialize@CDir@@IAEXXZ
_TEXT	SEGMENT
?Initialize@CDir@@IAEXXZ PROC				; CDir::Initialize, COMDAT
; _this$ = ecx

; 102  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 103  : 	memset(&m_wfd, 0, sizeof(m_wfd));

  00003	68 40 01 00 00	 push	 320			; 00000140H
  00008	6a 00		 push	 0
  0000a	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 _memset
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH

; 104  : 	m_hFind = NULL;

  00016	c7 86 44 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+324], 0
  00020	5e		 pop	 esi

; 105  : }

  00021	c3		 ret	 0
?Initialize@CDir@@IAEXXZ ENDP				; CDir::Initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
;	COMDAT ?IsFolder@CDir@@IAE_NXZ
_TEXT	SEGMENT
?IsFolder@CDir@@IAE_NXZ PROC				; CDir::IsFolder, COMDAT
; _this$ = ecx

; 95   : 	if (m_wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	c0 e8 04	 shr	 al, 4
  00006	24 01		 and	 al, 1

; 96   : 		return true;
; 97   : 
; 98   : 	return false;
; 99   : }

  00008	c3		 ret	 0
?IsFolder@CDir@@IAE_NXZ ENDP				; CDir::IsFolder
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
;	COMDAT ?Create@CDir@@QAE_NPBD0H@Z
_TEXT	SEGMENT
tv3033 = -180						; size = 4
tv3032 = -176						; size = 4
$T2 = -172						; size = 4
tv3037 = -172						; size = 4
_c_szFilter$GSCopy$1$ = -168				; size = 4
_this$GSCopy$1$ = -164					; size = 4
_strSecondFilter$3 = -160				; size = 24
_strFirstFilter$4 = -136				; size = 24
_stQuery$ = -112					; size = 24
_strFilter$5 = -88					; size = 24
$T6 = -64						; size = 24
$T7 = -64						; size = 24
_stPath$ = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_c_szFilter$ = 8					; size = 4
_c_szPath$ = 12						; size = 4
_bCheckedExtension$ = 16				; size = 4
?Create@CDir@@QAE_NPBD0H@Z PROC				; CDir::Create, COMDAT
; _this$ = ecx

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Create@CDir@@QAE_NPBD0H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b c1		 mov	 eax, ecx
  00030	89 85 5c ff ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], eax
  00036	8b 7d 08	 mov	 edi, DWORD PTR _c_szFilter$[ebp]
  00039	8b 75 0c	 mov	 esi, DWORD PTR _c_szPath$[ebp]
  0003c	89 bd 58 ff ff
	ff		 mov	 DWORD PTR _c_szFilter$GSCopy$1$[ebp], edi

; 25   : 	Destroy();

  00042	e8 00 00 00 00	 call	 ?Destroy@CDir@@QAEXXZ	; CDir::Destroy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00047	8b ce		 mov	 ecx, esi

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00049	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _stPath$[ebp], 0

; 4596 :         _My_data._Mysize = 0;

  00050	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _stPath$[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00057	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _stPath$[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0005e	c6 45 d8 00	 mov	 BYTE PTR _stPath$[ebp], 0

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00062	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL763@Create:
  00065	8a 01		 mov	 al, BYTE PTR [ecx]
  00067	41		 inc	 ecx
  00068	84 c0		 test	 al, al
  0006a	75 f9		 jne	 SHORT $LL763@Create
  0006c	2b ca		 sub	 ecx, edx

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0006e	51		 push	 ecx
  0006f	56		 push	 esi
  00070	8d 4d d8	 lea	 ecx, DWORD PTR _stPath$[ebp]
  00073	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 29   : 	if (stPath.length())

  00078	8b 75 e8	 mov	 esi, DWORD PTR _stPath$[ebp+16]
  0007b	8b 5d ec	 mov	 ebx, DWORD PTR _stPath$[ebp+20]
  0007e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00085	85 f6		 test	 esi, esi
  00087	0f 84 51 01 00
	00		 je	 $LN66@Create
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2297 :         if (_Large_string_engaged()) {

  0008d	8b 4d d8	 mov	 ecx, DWORD PTR _stPath$[ebp]
  00090	8d 45 d8	 lea	 eax, DWORD PTR _stPath$[ebp]
  00093	83 fb 10	 cmp	 ebx, 16			; 00000010H
  00096	0f 43 c1	 cmovae	 eax, ecx
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 31   : 		char end = stPath[stPath.length() - 1];

  00099	8a 44 06 ff	 mov	 al, BYTE PTR [esi+eax-1]

; 32   : 
; 33   : 		if (end != '\\')

  0009d	3c 5c		 cmp	 al, 92			; 0000005cH
  0009f	0f 84 39 01 00
	00		 je	 $LN66@Create
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3862 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  000a5	3b f3		 cmp	 esi, ebx

; 3863 :         if (_Old_size < _Mypair._Myval2._Myres) {

  000a7	73 1a		 jae	 SHORT $LN56@Create

; 3864 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  000a9	8d 46 01	 lea	 eax, DWORD PTR [esi+1]

; 2297 :         if (_Large_string_engaged()) {

  000ac	83 fb 10	 cmp	 ebx, 16			; 00000010H

; 3864 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  000af	89 45 e8	 mov	 DWORD PTR _stPath$[ebp+16], eax

; 2296 :         value_type* _Result = _Bx._Buf;

  000b2	8d 45 d8	 lea	 eax, DWORD PTR _stPath$[ebp]

; 2297 :         if (_Large_string_engaged()) {

  000b5	0f 43 c1	 cmovae	 eax, ecx

; 3866 :             _Traits::assign(_Ptr[_Old_size], _Ch);

  000b8	66 c7 04 30 5c
	00		 mov	 WORD PTR [eax+esi], 92	; 0000005cH

; 3867 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());
; 3868 :             return;

  000be	e9 15 01 00 00	 jmp	 $LN776@Create
$LN56@Create:

; 4542 :         const size_type _Old_size = _My_data._Mysize;

  000c3	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  000c8	8b c1		 mov	 eax, ecx
  000ca	2b c6		 sub	 eax, esi

; 4543 :         if (max_size() - _Old_size < _Size_increase) {

  000cc	83 f8 01	 cmp	 eax, 1
  000cf	0f 82 c5 06 00
	00		 jb	 $LN779@Create

; 4545 :         }
; 4546 : 
; 4547 :         const size_type _New_size     = _Old_size + _Size_increase;

  000d5	8d 7e 01	 lea	 edi, DWORD PTR [esi+1]

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  000d8	83 cf 0f	 or	 edi, 15			; 0000000fH
  000db	3b f9		 cmp	 edi, ecx

; 4489 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  000dd	76 12		 jbe	 SHORT $LN71@Create

; 4490 :             return _Max;

  000df	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  000e4	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000ec	83 c4 04	 add	 esp, 4
  000ef	eb 4c		 jmp	 SHORT $LN775@Create
$LN71@Create:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4493 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  000f1	8b c3		 mov	 eax, ebx
  000f3	d1 e8		 shr	 eax, 1
  000f5	2b c8		 sub	 ecx, eax
  000f7	3b d9		 cmp	 ebx, ecx
  000f9	76 15		 jbe	 SHORT $LN72@Create

; 4494 :             return _Max;

  000fb	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00100	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0010b	83 c4 04	 add	 esp, 4
  0010e	eb 2d		 jmp	 SHORT $LN775@Create
$LN72@Create:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4497 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00110	03 c3		 add	 eax, ebx
  00112	3b f8		 cmp	 edi, eax
  00114	0f 42 f8	 cmovb	 edi, eax

; 4551 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00117	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0011a	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0011f	72 0b		 jb	 SHORT $LN79@Create

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00121	50		 push	 eax
  00122	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00127	83 c4 04	 add	 esp, 4
  0012a	eb 11		 jmp	 SHORT $LN775@Create
$LN79@Create:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  0012c	85 c0		 test	 eax, eax
  0012e	74 0b		 je	 SHORT $LN80@Create

; 85   :         return ::operator new(_Bytes);

  00130	50		 push	 eax
  00131	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00136	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  00139	eb 02		 jmp	 SHORT $LN775@Create
$LN80@Create:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  0013b	33 c0		 xor	 eax, eax
$LN775@Create:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4559 :         _My_data._Mysize      = _New_size;

  0013d	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]

; 4560 :         _My_data._Myres       = _New_capacity;

  00140	89 7d ec	 mov	 DWORD PTR _stPath$[ebp+20], edi
  00143	89 4d e8	 mov	 DWORD PTR _stPath$[ebp+16], ecx

; 4561 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  00146	8d 3c 06	 lea	 edi, DWORD PTR [esi+eax]
  00149	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  0014c	89 85 54 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  00152	03 c8		 add	 ecx, eax
  00154	89 bd 4c ff ff
	ff		 mov	 DWORD PTR tv3033[ebp], edi
  0015a	89 8d 50 ff ff
	ff		 mov	 DWORD PTR tv3032[ebp], ecx

; 4562 :         if (_BUF_SIZE <= _Old_capacity) {

  00160	56		 push	 esi
  00161	83 fb 10	 cmp	 ebx, 16			; 00000010H
  00164	72 4a		 jb	 SHORT $LN65@Create

; 4563 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  00166	8b 7d d8	 mov	 edi, DWORD PTR _stPath$[ebp]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00169	57		 push	 edi
  0016a	50		 push	 eax
  0016b	e8 00 00 00 00	 call	 _memcpy

; 3875 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

  00170	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR tv3033[ebp]

; 4565 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  00176	43		 inc	 ebx

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00177	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3875 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

  0017a	c6 00 5c	 mov	 BYTE PTR [eax], 92	; 0000005cH

; 3876 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  0017d	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR tv3032[ebp]
  00183	c6 00 00	 mov	 BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00186	81 fb 00 10 00
	00		 cmp	 ebx, 4096		; 00001000H
  0018c	72 16		 jb	 SHORT $LN102@Create

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0018e	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
  00191	83 c3 23	 add	 ebx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00194	2b f9		 sub	 edi, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00196	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  00199	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0019c	0f 87 fd 05 00
	00		 ja	 $LN742@Create

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  001a2	8b f9		 mov	 edi, ecx
$LN102@Create:

; 264  :         ::operator delete(_Ptr, _Bytes);

  001a4	53		 push	 ebx
  001a5	57		 push	 edi
  001a6	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001ab	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4567 :         } else {

  001ae	eb 19		 jmp	 SHORT $LN777@Create
$LN65@Create:

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  001b0	8d 4d d8	 lea	 ecx, DWORD PTR _stPath$[ebp]
  001b3	51		 push	 ecx
  001b4	50		 push	 eax
  001b5	e8 00 00 00 00	 call	 _memcpy

; 3876 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  001ba	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR tv3032[ebp]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  001c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3875 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

  001c3	c6 07 5c	 mov	 BYTE PTR [edi], 92	; 0000005cH

; 3876 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  001c6	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN777@Create:

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  001c9	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
  001cf	8b bd 58 ff ff
	ff		 mov	 edi, DWORD PTR _c_szFilter$GSCopy$1$[ebp]
  001d5	89 45 d8	 mov	 DWORD PTR _stPath$[ebp], eax
$LN776@Create:
  001d8	8b 5d ec	 mov	 ebx, DWORD PTR _stPath$[ebp+20]
  001db	8b 75 e8	 mov	 esi, DWORD PTR _stPath$[ebp+16]
$LN66@Create:
  001de	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _stQuery$[ebp], 0

; 4596 :         _My_data._Mysize = 0;

  001e5	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _stQuery$[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  001ec	c7 45 a4 0f 00
	00 00		 mov	 DWORD PTR _stQuery$[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  001f3	c6 45 90 00	 mov	 BYTE PTR _stQuery$[ebp], 0

; 2306 :         if (_Large_string_engaged()) {

  001f7	83 fb 10	 cmp	 ebx, 16			; 00000010H
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 37   : 	std::string stQuery;

  001fa	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2305 :         const value_type* _Result = _Bx._Buf;

  001fe	8d 45 d8	 lea	 eax, DWORD PTR _stPath$[ebp]

; 2306 :         if (_Large_string_engaged()) {

  00201	0f 43 45 d8	 cmovae	 eax, DWORD PTR _stPath$[ebp]

; 3124 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00205	8d 4d 90	 lea	 ecx, DWORD PTR _stQuery$[ebp]
  00208	56		 push	 esi
  00209	50		 push	 eax
  0020a	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 3175 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0020f	6a 03		 push	 3
  00211	68 00 00 00 00	 push	 OFFSET ??_C@_03EMIMMIHL@?$CK?4?$CK@
  00216	8d 4d 90	 lea	 ecx, DWORD PTR _stQuery$[ebp]
  00219	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 41   : 	m_wfd.dwFileAttributes |= FILE_ATTRIBUTE_DIRECTORY;

  0021e	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2305 :         const value_type* _Result = _Bx._Buf;

  00224	8d 45 90	 lea	 eax, DWORD PTR _stQuery$[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 41   : 	m_wfd.dwFileAttributes |= FILE_ATTRIBUTE_DIRECTORY;

  00227	83 c1 04	 add	 ecx, 4

; 42   : 	m_hFind = FindFirstFile(stQuery.c_str(), &m_wfd);

  0022a	51		 push	 ecx
  0022b	83 09 10	 or	 DWORD PTR [ecx], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2306 :         if (_Large_string_engaged()) {

  0022e	83 7d a4 10	 cmp	 DWORD PTR _stQuery$[ebp+20], 16 ; 00000010H
  00232	0f 43 45 90	 cmovae	 eax, DWORD PTR _stQuery$[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 42   : 	m_hFind = FindFirstFile(stQuery.c_str(), &m_wfd);

  00236	50		 push	 eax
  00237	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindFirstFileA@8
  0023d	8b b5 5c ff ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
  00243	89 86 44 01 00
	00		 mov	 DWORD PTR [esi+324], eax

; 43   : 
; 44   : 	if (m_hFind == INVALID_HANDLE_VALUE)

  00249	83 f8 ff	 cmp	 eax, -1
  0024c	0f 84 ae 04 00
	00		 je	 $LN752@Create
  00252	8d 5e 30	 lea	 ebx, DWORD PTR [esi+48]
  00255	89 9d 54 ff ff
	ff		 mov	 DWORD PTR tv3037[ebp], ebx
  0025b	0f 1f 44 00 00	 npad	 5
$LL4@Create:

; 45   : 		return true;
; 46   : 
; 47   : 	do
; 48   : 	{
; 49   : 		if (*m_wfd.cFileName == '.')

  00260	80 3b 2e	 cmp	 BYTE PTR [ebx], 46	; 0000002eH
  00263	0f 84 7f 04 00
	00		 je	 $LN2@Create

; 50   : 			continue;
; 51   : 
; 52   : 		if (IsFolder())

  00269	8b ce		 mov	 ecx, esi
  0026b	e8 00 00 00 00	 call	 ?IsFolder@CDir@@IAE_NXZ	; CDir::IsFolder
  00270	84 c0		 test	 al, al
  00272	74 30		 je	 SHORT $LN9@Create

; 54   : 			if (!OnFolder(c_szFilter, stPath.c_str(), m_wfd.cFileName))

  00274	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2305 :         const value_type* _Result = _Bx._Buf;

  0027a	8d 4d d8	 lea	 ecx, DWORD PTR _stPath$[ebp]

; 2319 :         return _BUF_SIZE <= _Myres;

  0027d	83 7d ec 10	 cmp	 DWORD PTR _stPath$[ebp+20], 16 ; 00000010H
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 54   : 			if (!OnFolder(c_szFilter, stPath.c_str(), m_wfd.cFileName))

  00281	53		 push	 ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2306 :         if (_Large_string_engaged()) {

  00282	0f 43 4d d8	 cmovae	 ecx, DWORD PTR _stPath$[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 54   : 			if (!OnFolder(c_szFilter, stPath.c_str(), m_wfd.cFileName))

  00286	8b 02		 mov	 eax, DWORD PTR [edx]
  00288	51		 push	 ecx
  00289	57		 push	 edi
  0028a	8b ca		 mov	 ecx, edx
  0028c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0028f	ff d0		 call	 eax
  00291	84 c0		 test	 al, al
  00293	0f 84 d3 04 00
	00		 je	 $LN755@Create

; 55   : 				return false;
; 56   : 		}

  00299	8b b5 5c ff ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
  0029f	e9 44 04 00 00	 jmp	 $LN2@Create
$LN9@Create:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h

; 502  :         return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));

  002a4	6a 2e		 push	 46			; 0000002eH
  002a6	53		 push	 ebx
  002a7	e8 00 00 00 00	 call	 _strchr
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 59   : 			const char * c_szExtension = strchr(m_wfd.cFileName, '.');

  002ac	8b d8		 mov	 ebx, eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h

; 502  :         return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));

  002ae	83 c4 08	 add	 esp, 8
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 60   : 			if (!c_szExtension)

  002b1	85 db		 test	 ebx, ebx
  002b3	0f 84 2c 04 00
	00		 je	 $LN772@Create

; 61   : 				continue;
; 62   : 
; 63   : 			// NOTE :   - [levites]
; 64   : 			//          TRUE  .
; 65   : 			//           CDir   Extension "wav", "gr2"   . - [levites]
; 66   : 			if (bCheckedExtension)

  002b9	83 7d 10 00	 cmp	 DWORD PTR _bCheckedExtension$[ebp], 0
  002bd	0f 84 88 03 00
	00		 je	 $LN620@Create
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  002c3	8b cf		 mov	 ecx, edi

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  002c5	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _strFilter$5[ebp], 0

; 4596 :         _My_data._Mysize = 0;

  002cc	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _strFilter$5[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  002d3	c7 45 bc 0f 00
	00 00		 mov	 DWORD PTR _strFilter$5[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  002da	c6 45 a8 00	 mov	 BYTE PTR _strFilter$5[ebp], 0

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  002de	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL764@Create:
  002e1	8a 01		 mov	 al, BYTE PTR [ecx]
  002e3	41		 inc	 ecx
  002e4	84 c0		 test	 al, al
  002e6	75 f9		 jne	 SHORT $LL764@Create
  002e8	2b ca		 sub	 ecx, edx

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  002ea	51		 push	 ecx
  002eb	57		 push	 edi
  002ec	8d 4d a8	 lea	 ecx, DWORD PTR _strFilter$5[ebp]
  002ef	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2306 :         if (_Large_string_engaged()) {

  002f4	83 7d bc 10	 cmp	 DWORD PTR _strFilter$5[ebp+20], 16 ; 00000010H
  002f8	8d 75 a8	 lea	 esi, DWORD PTR _strFilter$5[ebp]

; 645  :     if (_Start_at < _Hay_size) {

  002fb	8b 45 b8	 mov	 eax, DWORD PTR _strFilter$5[ebp+16]

; 2306 :         if (_Large_string_engaged()) {

  002fe	0f 43 75 a8	 cmovae	 esi, DWORD PTR _strFilter$5[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 68   : 				std::string strFilter = c_szFilter;

  00302	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 645  :     if (_Start_at < _Hay_size) {

  00306	85 c0		 test	 eax, eax
  00308	74 16		 je	 SHORT $LN290@Create

; 433  :         return static_cast<const _Elem*>(_CSTD memchr(_First, _Ch, _Count));

  0030a	50		 push	 eax
  0030b	6a 3b		 push	 59			; 0000003bH
  0030d	56		 push	 esi
  0030e	e8 00 00 00 00	 call	 _memchr
  00313	8b f8		 mov	 edi, eax
  00315	83 c4 0c	 add	 esp, 12			; 0000000cH

; 647  :         if (_Found_at) {

  00318	85 ff		 test	 edi, edi
  0031a	74 04		 je	 SHORT $LN290@Create

; 648  :             return static_cast<size_t>(_Found_at - _Haystack);

  0031c	2b fe		 sub	 edi, esi
  0031e	eb 03		 jmp	 SHORT $LN288@Create
$LN290@Create:

; 649  :         }
; 650  :     }
; 651  : 
; 652  :     return static_cast<size_t>(-1); // (npos) no match

  00320	83 cf ff	 or	 edi, -1
$LN288@Create:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 70   : 				if (iPos > 0)

  00323	85 ff		 test	 edi, edi
  00325	0f 8e 55 03 00
	00		 jle	 $LN14@Create
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0032b	8b b5 58 ff ff
	ff		 mov	 esi, DWORD PTR _c_szFilter$GSCopy$1$[ebp]
  00331	8b ce		 mov	 ecx, esi

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00333	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR $T7[ebp], 0

; 4596 :         _My_data._Mysize = 0;

  0033a	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T7[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00341	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR $T7[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00348	c6 45 c0 00	 mov	 BYTE PTR $T7[ebp], 0

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0034c	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0034f	90		 npad	 1
$LL765@Create:
  00350	8a 01		 mov	 al, BYTE PTR [ecx]
  00352	41		 inc	 ecx
  00353	84 c0		 test	 al, al
  00355	75 f9		 jne	 SHORT $LL765@Create
  00357	2b ca		 sub	 ecx, edx

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00359	51		 push	 ecx
  0035a	56		 push	 esi
  0035b	8d 4d c0	 lea	 ecx, DWORD PTR $T7[ebp]
  0035e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2342 :         return (_STD min)(_Size, _Mysize - _Off);

  00363	39 7d d0	 cmp	 DWORD PTR $T7[ebp+16], edi

; 2305 :         const value_type* _Result = _Bx._Buf;

  00366	8d 45 c0	 lea	 eax, DWORD PTR $T7[ebp]

; 2342 :         return (_STD min)(_Size, _Mysize - _Off);

  00369	8b cf		 mov	 ecx, edi

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0036b	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _strFirstFilter$4[ebp], 0

; 2342 :         return (_STD min)(_Size, _Mysize - _Off);

  00375	0f 42 4d d0	 cmovb	 ecx, DWORD PTR $T7[ebp+16]

; 2306 :         if (_Large_string_engaged()) {

  00379	83 7d d4 10	 cmp	 DWORD PTR $T7[ebp+20], 16 ; 00000010H

; 3224 :         return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);

  0037d	51		 push	 ecx

; 2306 :         if (_Large_string_engaged()) {

  0037e	0f 43 45 c0	 cmovae	 eax, DWORD PTR $T7[ebp]

; 3224 :         return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);

  00382	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _strFirstFilter$4[ebp]
  00388	50		 push	 eax
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 72   : 					std::string strFirstFilter = std::string(c_szFilter).substr(0, iPos);

  00389	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4596 :         _My_data._Mysize = 0;

  0038d	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _strFirstFilter$4[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00394	c7 45 8c 0f 00
	00 00		 mov	 DWORD PTR _strFirstFilter$4[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0039b	c6 85 78 ff ff
	ff 00		 mov	 BYTE PTR _strFirstFilter$4[ebp], 0

; 3224 :         return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);

  003a2	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  003a7	8b 55 d4	 mov	 edx, DWORD PTR $T7[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 72   : 					std::string strFirstFilter = std::string(c_szFilter).substr(0, iPos);

  003aa	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  003ae	83 fa 10	 cmp	 edx, 16			; 00000010H
  003b1	72 2c		 jb	 SHORT $LN355@Create
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003b3	8b 4d c0	 mov	 ecx, DWORD PTR $T7[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  003b6	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003b7	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  003b9	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  003bf	72 14		 jb	 SHORT $LN365@Create

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  003c1	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  003c4	83 c2 23	 add	 edx, 35			; 00000023H
  003c7	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003c9	83 c0 fc	 add	 eax, -4			; fffffffcH
  003cc	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  003cf	0f 87 ca 03 00
	00		 ja	 $LN742@Create
$LN365@Create:

; 264  :         ::operator delete(_Ptr, _Bytes);

  003d5	52		 push	 edx
  003d6	51		 push	 ecx
  003d7	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  003dc	83 c4 08	 add	 esp, 8
$LN355@Create:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 73   : 					std::string strSecondFilter = std::string(c_szFilter).substr(iPos+1, strlen(c_szFilter));

  003df	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
$LL766@Create:
  003e2	8a 06		 mov	 al, BYTE PTR [esi]
  003e4	46		 inc	 esi
  003e5	84 c0		 test	 al, al
  003e7	75 f9		 jne	 SHORT $LL766@Create
  003e9	2b f1		 sub	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  003eb	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR $T6[ebp], 0

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  003f2	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _c_szFilter$GSCopy$1$[ebp]

; 4596 :         _My_data._Mysize = 0;

  003f8	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T6[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  003ff	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR $T6[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00406	88 45 c0	 mov	 BYTE PTR $T6[ebp], al

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00409	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0040c	0f 1f 40 00	 npad	 4
$LL767@Create:
  00410	8a 01		 mov	 al, BYTE PTR [ecx]
  00412	41		 inc	 ecx
  00413	84 c0		 test	 al, al
  00415	75 f9		 jne	 SHORT $LL767@Create
  00417	2b ca		 sub	 ecx, edx

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00419	51		 push	 ecx
  0041a	ff b5 58 ff ff
	ff		 push	 DWORD PTR _c_szFilter$GSCopy$1$[ebp]
  00420	8d 4d c0	 lea	 ecx, DWORD PTR $T6[ebp]
  00423	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2324 :         if (_Mysize < _Off) {

  00428	8b 45 d0	 mov	 eax, DWORD PTR $T6[ebp+16]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 73   : 					std::string strSecondFilter = std::string(c_szFilter).substr(iPos+1, strlen(c_szFilter));

  0042b	47		 inc	 edi
  0042c	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00430	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _strSecondFilter$3[ebp], 0

; 4596 :         _My_data._Mysize = 0;

  0043a	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _strSecondFilter$3[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00444	c7 85 74 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR _strSecondFilter$3[ebp+20], 15 ; 0000000fH

; 2324 :         if (_Mysize < _Off) {

  0044e	3b c7		 cmp	 eax, edi
  00450	0f 82 4e 03 00
	00		 jb	 $LN754@Create

; 2342 :         return (_STD min)(_Size, _Mysize - _Off);

  00456	2b c7		 sub	 eax, edi

; 3224 :         return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);

  00458	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _strSecondFilter$3[ebp]

; 2342 :         return (_STD min)(_Size, _Mysize - _Off);

  0045e	3b c6		 cmp	 eax, esi
  00460	0f 42 f0	 cmovb	 esi, eax

; 2306 :         if (_Large_string_engaged()) {

  00463	83 7d d4 10	 cmp	 DWORD PTR $T6[ebp+20], 16 ; 00000010H
  00467	8d 45 c0	 lea	 eax, DWORD PTR $T6[ebp]
  0046a	0f 43 45 c0	 cmovae	 eax, DWORD PTR $T6[ebp]

; 3224 :         return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);

  0046e	56		 push	 esi
  0046f	03 c7		 add	 eax, edi
  00471	50		 push	 eax
  00472	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00477	8b 55 d4	 mov	 edx, DWORD PTR $T6[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 73   : 					std::string strSecondFilter = std::string(c_szFilter).substr(iPos+1, strlen(c_szFilter));

  0047a	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0047e	83 fa 10	 cmp	 edx, 16			; 00000010H
  00481	72 2c		 jb	 SHORT $LN431@Create
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00483	8b 4d c0	 mov	 ecx, DWORD PTR $T6[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00486	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00487	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00489	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0048f	72 14		 jb	 SHORT $LN441@Create

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00491	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00494	83 c2 23	 add	 edx, 35			; 00000023H
  00497	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00499	83 c0 fc	 add	 eax, -4			; fffffffcH
  0049c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0049f	0f 87 fa 02 00
	00		 ja	 $LN742@Create
$LN441@Create:

; 264  :         ::operator delete(_Ptr, _Bytes);

  004a5	52		 push	 edx
  004a6	51		 push	 ecx
  004a7	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  004ac	83 c4 08	 add	 esp, 8
$LN431@Create:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 74   : 					if (0 != strFirstFilter.compare(c_szExtension+1) && 0 != strSecondFilter.compare(c_szExtension+1))

  004af	8d 73 01	 lea	 esi, DWORD PTR [ebx+1]
  004b2	56		 push	 esi
  004b3	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _strFirstFilter$4[ebp]
  004b9	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHQBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
  004be	85 c0		 test	 eax, eax
  004c0	0f 84 d8 00 00
	00		 je	 $LN16@Create
  004c6	56		 push	 esi
  004c7	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _strSecondFilter$3[ebp]
  004cd	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHQBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
  004d2	85 c0		 test	 eax, eax
  004d4	0f 84 c4 00 00
	00		 je	 $LN16@Create
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  004da	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _strSecondFilter$3[ebp+20]
  004e0	83 fa 10	 cmp	 edx, 16			; 00000010H
  004e3	72 2f		 jb	 SHORT $LN458@Create
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  004e5	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _strSecondFilter$3[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  004eb	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  004ec	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  004ee	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  004f4	72 14		 jb	 SHORT $LN468@Create

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  004f6	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  004f9	83 c2 23	 add	 edx, 35			; 00000023H
  004fc	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  004fe	83 c0 fc	 add	 eax, -4			; fffffffcH
  00501	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00504	0f 87 95 02 00
	00		 ja	 $LN742@Create
$LN468@Create:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0050a	52		 push	 edx
  0050b	51		 push	 ecx
  0050c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00511	83 c4 08	 add	 esp, 8
$LN458@Create:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00514	8b 55 8c	 mov	 edx, DWORD PTR _strFirstFilter$4[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 75   : 						continue;

  00517	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0051b	83 fa 10	 cmp	 edx, 16			; 00000010H
  0051e	72 2f		 jb	 SHORT $LN485@Create
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00520	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _strFirstFilter$4[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00526	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00527	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00529	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0052f	72 14		 jb	 SHORT $LN495@Create

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00531	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00534	83 c2 23	 add	 edx, 35			; 00000023H
  00537	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00539	83 c0 fc	 add	 eax, -4			; fffffffcH
  0053c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0053f	0f 87 5a 02 00
	00		 ja	 $LN742@Create
$LN495@Create:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00545	52		 push	 edx
  00546	51		 push	 ecx
  00547	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0054c	83 c4 08	 add	 esp, 8
$LN485@Create:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  0054f	8b 55 bc	 mov	 edx, DWORD PTR _strFilter$5[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 75   : 						continue;

  00552	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00556	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00559	72 2c		 jb	 SHORT $LN769@Create
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0055b	8b 4d a8	 mov	 ecx, DWORD PTR _strFilter$5[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0055e	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0055f	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00561	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00567	72 14		 jb	 SHORT $LN522@Create

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00569	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0056c	83 c2 23	 add	 edx, 35			; 00000023H
  0056f	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00571	83 c0 fc	 add	 eax, -4			; fffffffcH
  00574	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00577	0f 87 22 02 00
	00		 ja	 $LN742@Create
$LN522@Create:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0057d	52		 push	 edx
  0057e	51		 push	 ecx
  0057f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00584	83 c4 08	 add	 esp, 8
$LN769@Create:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 88   : 	while (FindNextFile(m_hFind, &m_wfd));

  00587	8b bd 58 ff ff
	ff		 mov	 edi, DWORD PTR _c_szFilter$GSCopy$1$[ebp]
$LN771@Create:
  0058d	8b b5 5c ff ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
  00593	8b 9d 54 ff ff
	ff		 mov	 ebx, DWORD PTR tv3037[ebp]
  00599	e9 4a 01 00 00	 jmp	 $LN2@Create
$LN16@Create:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0059e	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _strSecondFilter$3[ebp+20]
  005a4	83 fa 10	 cmp	 edx, 16			; 00000010H
  005a7	72 2f		 jb	 SHORT $LN539@Create
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  005a9	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _strSecondFilter$3[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  005af	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  005b0	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  005b2	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  005b8	72 14		 jb	 SHORT $LN549@Create

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  005ba	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  005bd	83 c2 23	 add	 edx, 35			; 00000023H
  005c0	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  005c2	83 c0 fc	 add	 eax, -4			; fffffffcH
  005c5	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  005c8	0f 87 d1 01 00
	00		 ja	 $LN742@Create
$LN549@Create:

; 264  :         ::operator delete(_Ptr, _Bytes);

  005ce	52		 push	 edx
  005cf	51		 push	 ecx
  005d0	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  005d5	83 c4 08	 add	 esp, 8
$LN539@Create:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  005d8	8b 55 8c	 mov	 edx, DWORD PTR _strFirstFilter$4[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 76   : 				}

  005db	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  005df	83 fa 10	 cmp	 edx, 16			; 00000010H
  005e2	72 2f		 jb	 SHORT $LN17@Create
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  005e4	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _strFirstFilter$4[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  005ea	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  005eb	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  005ed	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  005f3	72 14		 jb	 SHORT $LN576@Create

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  005f5	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  005f8	83 c2 23	 add	 edx, 35			; 00000023H
  005fb	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  005fd	83 c0 fc	 add	 eax, -4			; fffffffcH
  00600	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00603	0f 87 96 01 00
	00		 ja	 $LN742@Create
$LN576@Create:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00609	52		 push	 edx
  0060a	51		 push	 ecx
  0060b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00610	83 c4 08	 add	 esp, 8
$LN17@Create:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00613	8b 55 bc	 mov	 edx, DWORD PTR _strFilter$5[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 82   : 			}

  00616	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  0061a	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0061d	72 2c		 jb	 SHORT $LN620@Create
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0061f	8b 4d a8	 mov	 ecx, DWORD PTR _strFilter$5[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00622	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00623	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00625	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0062b	72 14		 jb	 SHORT $LN630@Create

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0062d	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00630	83 c2 23	 add	 edx, 35			; 00000023H
  00633	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00635	83 c0 fc	 add	 eax, -4			; fffffffcH
  00638	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0063b	0f 87 5e 01 00
	00		 ja	 $LN742@Create
$LN630@Create:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00641	52		 push	 edx
  00642	51		 push	 ecx
  00643	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00648	83 c4 08	 add	 esp, 8
$LN620@Create:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 84   : 			if (!OnFile(stPath.c_str(), m_wfd.cFileName))

  0064b	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2305 :         const value_type* _Result = _Bx._Buf;

  00651	8d 4d d8	 lea	 ecx, DWORD PTR _stPath$[ebp]

; 2319 :         return _BUF_SIZE <= _Myres;

  00654	83 7d ec 10	 cmp	 DWORD PTR _stPath$[ebp+20], 16 ; 00000010H

; 2306 :         if (_Large_string_engaged()) {

  00658	0f 43 4d d8	 cmovae	 ecx, DWORD PTR _stPath$[ebp]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 84   : 			if (!OnFile(stPath.c_str(), m_wfd.cFileName))

  0065c	8b 02		 mov	 eax, DWORD PTR [edx]
  0065e	8d 5a 30	 lea	 ebx, DWORD PTR [edx+48]
  00661	53		 push	 ebx
  00662	51		 push	 ecx
  00663	8b ca		 mov	 ecx, edx
  00665	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00668	ff d0		 call	 eax
  0066a	84 c0		 test	 al, al
  0066c	0f 84 fa 00 00
	00		 je	 $LN755@Create
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00672	8b bd 58 ff ff
	ff		 mov	 edi, DWORD PTR _c_szFilter$GSCopy$1$[ebp]
  00678	8b b5 5c ff ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
  0067e	eb 68		 jmp	 SHORT $LN2@Create
$LN14@Create:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 79   : 					if (0 != stricmp(c_szExtension+1, c_szFilter))

  00680	8b bd 58 ff ff
	ff		 mov	 edi, DWORD PTR _c_szFilter$GSCopy$1$[ebp]
  00686	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  00689	57		 push	 edi
  0068a	50		 push	 eax
  0068b	e8 00 00 00 00	 call	 __stricmp
  00690	83 c4 08	 add	 esp, 8
  00693	85 c0		 test	 eax, eax
  00695	0f 84 78 ff ff
	ff		 je	 $LN17@Create
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  0069b	8b 55 bc	 mov	 edx, DWORD PTR _strFilter$5[ebp+20]
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 80   : 						continue;

  0069e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  006a2	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  006a5	0f 82 e2 fe ff
	ff		 jb	 $LN771@Create
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  006ab	8b 4d a8	 mov	 ecx, DWORD PTR _strFilter$5[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  006ae	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  006af	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  006b1	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  006b7	72 14		 jb	 SHORT $LN603@Create

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  006b9	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  006bc	83 c2 23	 add	 edx, 35			; 00000023H
  006bf	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  006c1	83 c0 fc	 add	 eax, -4			; fffffffcH
  006c4	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  006c7	0f 87 d2 00 00
	00		 ja	 $LN742@Create
$LN603@Create:

; 264  :         ::operator delete(_Ptr, _Bytes);

  006cd	52		 push	 edx
  006ce	51		 push	 ecx
  006cf	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 80   : 						continue;

  006d4	8b b5 5c ff ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  006da	83 c4 08	 add	 esp, 8
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 80   : 						continue;

  006dd	8b 9d 54 ff ff
	ff		 mov	 ebx, DWORD PTR tv3037[ebp]
  006e3	eb 03		 jmp	 SHORT $LN2@Create
$LN772@Create:

; 60   : 			if (!c_szExtension)

  006e5	8d 5e 30	 lea	 ebx, DWORD PTR [esi+48]
$LN2@Create:

; 88   : 	while (FindNextFile(m_hFind, &m_wfd));

  006e8	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  006eb	50		 push	 eax
  006ec	ff b6 44 01 00
	00		 push	 DWORD PTR [esi+324]
  006f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindNextFileA@8
  006f8	85 c0		 test	 eax, eax
  006fa	0f 85 60 fb ff
	ff		 jne	 $LL4@Create
$LN752@Create:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00700	b3 01		 mov	 bl, 1
$LN29@Create:
  00702	8b 55 a4	 mov	 edx, DWORD PTR _stQuery$[ebp+20]
  00705	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00708	72 28		 jb	 SHORT $LN708@Create
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0070a	8b 4d 90	 mov	 ecx, DWORD PTR _stQuery$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0070d	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0070e	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00710	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00716	72 10		 jb	 SHORT $LN718@Create

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00718	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0071b	83 c2 23	 add	 edx, 35			; 00000023H
  0071e	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00720	83 c0 fc	 add	 eax, -4			; fffffffcH
  00723	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00726	77 77		 ja	 SHORT $LN742@Create
$LN718@Create:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00728	52		 push	 edx
  00729	51		 push	 ecx
  0072a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0072f	83 c4 08	 add	 esp, 8
$LN708@Create:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00732	8b 55 ec	 mov	 edx, DWORD PTR _stPath$[ebp+20]

; 4633 :             _Mypair._Myval2._Mysize = 0;

  00735	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _stQuery$[ebp+16], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0073c	c7 45 a4 0f 00
	00 00		 mov	 DWORD PTR _stQuery$[ebp+20], 15 ; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00743	c6 45 90 00	 mov	 BYTE PTR _stQuery$[ebp], 0

; 2319 :         return _BUF_SIZE <= _Myres;

  00747	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0074a	72 2e		 jb	 SHORT $LN735@Create
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0074c	8b 4d d8	 mov	 ecx, DWORD PTR _stPath$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0074f	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00750	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00752	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00758	72 16		 jb	 SHORT $LN745@Create

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0075a	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0075d	83 c2 23	 add	 edx, 35			; 00000023H
  00760	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00762	83 c0 fc	 add	 eax, -4			; fffffffcH
  00765	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00768	77 35		 ja	 SHORT $LN742@Create
  0076a	eb 04		 jmp	 SHORT $LN745@Create
$LN755@Create:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  0076c	32 db		 xor	 bl, bl
  0076e	eb 92		 jmp	 SHORT $LN29@Create
$LN745@Create:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00770	52		 push	 edx
  00771	51		 push	 ecx
  00772	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00777	83 c4 08	 add	 esp, 8
$LN735@Create:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 90   : 	return true;

  0077a	8a c3		 mov	 al, bl

; 91   : }

  0077c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0077f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00786	59		 pop	 ecx
  00787	5f		 pop	 edi
  00788	5e		 pop	 esi
  00789	5b		 pop	 ebx
  0078a	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0078d	33 cd		 xor	 ecx, ebp
  0078f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00794	8b e5		 mov	 esp, ebp
  00796	5d		 pop	 ebp
  00797	c2 0c 00	 ret	 12			; 0000000cH
$LN779@Create:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4544 :             _Xlen_string(); // result too long

  0079a	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN742@Create:
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp

; 91   : }

  0079f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN754@Create:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 2325 :             _Xran();

  007a4	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN774@Create:
  007a9	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Create@CDir@@QAE_NPBD0H@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _stPath$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Create@CDir@@QAE_NPBD0H@Z$1:
  00008	8d 4d 90	 lea	 ecx, DWORD PTR _stQuery$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Create@CDir@@QAE_NPBD0H@Z$2:
  00010	8d 4d a8	 lea	 ecx, DWORD PTR _strFilter$5[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Create@CDir@@QAE_NPBD0H@Z$3:
  00018	8d 4d c0	 lea	 ecx, DWORD PTR $T7[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Create@CDir@@QAE_NPBD0H@Z$4:
  00020	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _strFirstFilter$4[ebp]
  00026	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Create@CDir@@QAE_NPBD0H@Z$5:
  0002b	8d 4d c0	 lea	 ecx, DWORD PTR $T6[ebp]
  0002e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00033	cc		 int	 3
  00034	cc		 int	 3
  00035	cc		 int	 3
  00036	cc		 int	 3
  00037	cc		 int	 3
__ehhandler$?Create@CDir@@QAE_NPBD0H@Z:
  00038	90		 npad	 1
  00039	90		 npad	 1
  0003a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00041	8b 8a 48 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-184]
  00047	33 c8		 xor	 ecx, eax
  00049	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004e	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00051	33 c8		 xor	 ecx, eax
  00053	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00058	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Create@CDir@@QAE_NPBD0H@Z
  0005d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Create@CDir@@QAE_NPBD0H@Z ENDP				; CDir::Create
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
;	COMDAT ?Destroy@CDir@@QAEXXZ
_TEXT	SEGMENT
?Destroy@CDir@@QAEXXZ PROC				; CDir::Destroy, COMDAT
; _this$ = ecx

; 16   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 17   : 	if (m_hFind)

  00003	8b 86 44 01 00
	00		 mov	 eax, DWORD PTR [esi+324]
  00009	85 c0		 test	 eax, eax
  0000b	74 07		 je	 SHORT $LN2@Destroy

; 18   : 		FindClose(m_hFind);

  0000d	50		 push	 eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindClose@4
$LN2@Destroy:

; 19   : 
; 20   : 	Initialize();

  00014	8b ce		 mov	 ecx, esi
  00016	5e		 pop	 esi
  00017	e9 00 00 00 00	 jmp	 ?Initialize@CDir@@IAEXXZ ; CDir::Initialize
?Destroy@CDir@@QAEXXZ ENDP				; CDir::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
;	COMDAT ??1CDir@@UAE@XZ
_TEXT	SEGMENT
??1CDir@@UAE@XZ PROC					; CDir::~CDir, COMDAT
; _this$ = ecx

; 11   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CDir@@6B@

; 12   : 	Destroy();

  00006	e9 00 00 00 00	 jmp	 ?Destroy@CDir@@QAEXXZ	; CDir::Destroy
??1CDir@@UAE@XZ ENDP					; CDir::~CDir
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\murat\Desktop\Siveps2-1-99-Project\source\client\Client\EterBase\FileDir.cpp
;	COMDAT ??0CDir@@QAE@XZ
_TEXT	SEGMENT
??0CDir@@QAE@XZ PROC					; CDir::CDir, COMDAT
; _this$ = ecx

; 6    : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CDir@@6B@

; 7    : 	Initialize();

  00009	e8 00 00 00 00	 call	 ?Initialize@CDir@@IAEXXZ ; CDir::Initialize

; 8    : }

  0000e	8b c6		 mov	 eax, esi
  00010	5e		 pop	 esi
  00011	c3		 ret	 0
??0CDir@@QAE@XZ ENDP					; CDir::CDir
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHQBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHQBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 4434 :     _NODISCARD _CONSTEXPR20_CONTAINER int compare(_In_z_ const _Elem* const _Ptr) const noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00005	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]

; 4434 :     _NODISCARD _CONSTEXPR20_CONTAINER int compare(_In_z_ const _Elem* const _Ptr) const noexcept /* strengthened */ {

  00008	8b d1		 mov	 edx, ecx
  0000a	57		 push	 edi

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0000b	8b fe		 mov	 edi, esi
  0000d	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
$LL19@compare:
  00010	8a 07		 mov	 al, BYTE PTR [edi]
  00012	47		 inc	 edi
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL19@compare
  00017	2b f9		 sub	 edi, ecx

; 2319 :         return _BUF_SIZE <= _Myres;

  00019	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H

; 2305 :         const value_type* _Result = _Bx._Buf;

  0001d	8b ca		 mov	 ecx, edx

; 2306 :         if (_Large_string_engaged()) {

  0001f	72 02		 jb	 SHORT $LN6@compare

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  00021	8b 0a		 mov	 ecx, DWORD PTR [edx]
$LN6@compare:

; 4435 :         // compare [0, size()) with [_Ptr, <null>)
; 4436 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  00023	8b 5a 10	 mov	 ebx, DWORD PTR [edx+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00026	3b fb		 cmp	 edi, ebx
  00028	8b d3		 mov	 edx, ebx
  0002a	0f 42 d7	 cmovb	 edx, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 392  :         return _CSTD memcmp(_First1, _First2, _Count);

  0002d	83 ea 04	 sub	 edx, 4
  00030	72 11		 jb	 SHORT $LN22@compare
$LL23@compare:
  00032	8b 01		 mov	 eax, DWORD PTR [ecx]
  00034	3b 06		 cmp	 eax, DWORD PTR [esi]
  00036	75 10		 jne	 SHORT $LN21@compare
  00038	83 c1 04	 add	 ecx, 4
  0003b	83 c6 04	 add	 esi, 4
  0003e	83 ea 04	 sub	 edx, 4
  00041	73 ef		 jae	 SHORT $LL23@compare
$LN22@compare:
  00043	83 fa fc	 cmp	 edx, -4			; fffffffcH
  00046	74 34		 je	 SHORT $LN20@compare
$LN21@compare:
  00048	8a 01		 mov	 al, BYTE PTR [ecx]
  0004a	3a 06		 cmp	 al, BYTE PTR [esi]
  0004c	75 27		 jne	 SHORT $LN24@compare
  0004e	83 fa fd	 cmp	 edx, -3			; fffffffdH
  00051	74 29		 je	 SHORT $LN20@compare
  00053	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00056	3a 46 01	 cmp	 al, BYTE PTR [esi+1]
  00059	75 1a		 jne	 SHORT $LN24@compare
  0005b	83 fa fe	 cmp	 edx, -2			; fffffffeH
  0005e	74 1c		 je	 SHORT $LN20@compare
  00060	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  00063	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  00066	75 0d		 jne	 SHORT $LN24@compare
  00068	83 fa ff	 cmp	 edx, -1
  0006b	74 0f		 je	 SHORT $LN20@compare
  0006d	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  00070	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  00073	74 07		 je	 SHORT $LN20@compare
$LN24@compare:
  00075	1b c0		 sbb	 eax, eax
  00077	83 c8 01	 or	 eax, 1
  0007a	eb 02		 jmp	 SHORT $LN25@compare
$LN20@compare:
  0007c	33 c0		 xor	 eax, eax
$LN25@compare:

; 592  :     if (_Ans != 0) {

  0007e	85 c0		 test	 eax, eax
  00080	75 12		 jne	 SHORT $LN13@compare

; 593  :         return _Ans;
; 594  :     }
; 595  : 
; 596  :     if (_Left_size < _Right_size) {

  00082	3b fb		 cmp	 edi, ebx
  00084	76 0a		 jbe	 SHORT $LN26@compare

; 4437 :     }

  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	83 c8 ff	 or	 eax, -1
  0008b	5b		 pop	 ebx
  0008c	5d		 pop	 ebp
  0008d	c2 04 00	 ret	 4
$LN26@compare:

; 600  :     if (_Left_size > _Right_size) {

  00090	1b c0		 sbb	 eax, eax
  00092	f7 d8		 neg	 eax
$LN13@compare:
  00094	5f		 pop	 edi

; 4437 :     }

  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	5d		 pop	 ebp
  00098	c2 04 00	 ret	 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHQBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Old$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
$T1 = 12						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3244 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 3245 :         // assign [_Ptr, _Ptr + _Count)
; 3246 :         if (_Count <= _Mypair._Myval2._Myres) {

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	57		 push	 edi
  0000c	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0000f	89 4d fc	 mov	 DWORD PTR __Old$1$[ebp], ecx
  00012	3b d9		 cmp	 ebx, ecx
  00014	77 28		 ja	 SHORT $LN2@assign

; 2296 :         value_type* _Result = _Bx._Buf;

  00016	8b fe		 mov	 edi, esi

; 2319 :         return _BUF_SIZE <= _Myres;

  00018	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 2297 :         if (_Large_string_engaged()) {

  0001b	72 02		 jb	 SHORT $LN5@assign

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  0001d	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN5@assign:

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0001f	53		 push	 ebx
  00020	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 3247 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3248 :             _Mypair._Myval2._Mysize = _Count;

  00023	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00026	57		 push	 edi
  00027	e8 00 00 00 00	 call	 _memmove
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3249 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0002f	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 3259 :             },
; 3260 :             _Ptr);
; 3261 :     }

  00033	8b c6		 mov	 eax, esi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
$LN2@assign:

; 4508 :         if (_New_size > max_size()) {

  0003e	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  00044	0f 87 d4 00 00
	00		 ja	 $LN60@assign

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0004a	8b fb		 mov	 edi, ebx
  0004c	83 cf 0f	 or	 edi, 15			; 0000000fH
  0004f	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH

; 4489 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00055	76 15		 jbe	 SHORT $LN19@assign

; 4490 :             return _Max;

  00057	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0005c	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00067	83 c4 04	 add	 esp, 4
  0006a	eb 52		 jmp	 SHORT $LN58@assign
$LN19@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4493 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0006c	8b d1		 mov	 edx, ecx
  0006e	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00073	d1 ea		 shr	 edx, 1
  00075	2b c2		 sub	 eax, edx
  00077	3b c8		 cmp	 ecx, eax
  00079	76 15		 jbe	 SHORT $LN20@assign

; 4494 :             return _Max;

  0007b	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00080	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0008b	83 c4 04	 add	 esp, 4
  0008e	eb 2e		 jmp	 SHORT $LN58@assign
$LN20@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4497 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00090	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00093	3b f8		 cmp	 edi, eax
  00095	0f 42 f8	 cmovb	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4515 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00098	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0009b	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000a0	72 0b		 jb	 SHORT $LN27@assign

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a8	83 c4 04	 add	 esp, 4
  000ab	eb 11		 jmp	 SHORT $LN58@assign
$LN27@assign:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  000ad	85 c0		 test	 eax, eax
  000af	74 0b		 je	 SHORT $LN28@assign

; 85   :         return ::operator new(_Bytes);

  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000b7	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  000ba	eb 02		 jmp	 SHORT $LN58@assign
$LN28@assign:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000bc	33 c0		 xor	 eax, eax
$LN58@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000be	53		 push	 ebx
  000bf	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 4523 :         _Mypair._Myval2._Mysize = _New_size;

  000c2	89 45 0c	 mov	 DWORD PTR $T1[ebp], eax

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c5	50		 push	 eax

; 4523 :         _Mypair._Myval2._Mysize = _New_size;

  000c6	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 4524 :         _Mypair._Myval2._Myres  = _New_capacity;

  000c9	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000cc	e8 00 00 00 00	 call	 _memcpy

; 3258 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000d1	8b 7d 0c	 mov	 edi, DWORD PTR $T1[ebp]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4526 :         if (_BUF_SIZE <= _Old_capacity) {

  000d7	8b 45 fc	 mov	 eax, DWORD PTR __Old$1$[ebp]

; 3258 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000da	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 4526 :         if (_BUF_SIZE <= _Old_capacity) {

  000de	83 f8 10	 cmp	 eax, 16			; 00000010H
  000e1	72 29		 jb	 SHORT $LN13@assign

; 4527 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  000e3	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e6	8b 06		 mov	 eax, DWORD PTR [esi]

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000e8	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000ee	72 12		 jb	 SHORT $LN50@assign

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f0	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000f3	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000f6	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000f8	83 c0 fc	 add	 eax, -4			; fffffffcH
  000fb	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000fe	77 19		 ja	 SHORT $LN47@assign

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00100	8b c2		 mov	 eax, edx
$LN50@assign:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00102	51		 push	 ecx
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00109	83 c4 08	 add	 esp, 8
$LN13@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3254 :         return _Reallocate_for(

  0010c	89 3e		 mov	 DWORD PTR [esi], edi

; 3259 :             },
; 3260 :             _Ptr);
; 3261 :     }

  0010e	8b c6		 mov	 eax, esi
  00110	5f		 pop	 edi
  00111	5e		 pop	 esi
  00112	5b		 pop	 ebx
  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c2 08 00	 ret	 8
$LN47@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00119	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN60@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4509 :             _Xlen_string(); // result too long

  0011e	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN56@assign:
  00123	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
tv533 = -12						; size = 4
__Old$1$ = -8						; size = 4
tv534 = -4						; size = 4
__Old_size$1$ = -4					; size = 4
__Ptr$ = 8						; size = 4
tv537 = 12						; size = 4
$T1 = 12						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 3152 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 3153 :         // append [_Ptr, _Ptr + _Count)
; 3154 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3155 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  00011	8b c2		 mov	 eax, edx
  00013	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00016	2b c1		 sub	 eax, ecx
  00018	89 4d fc	 mov	 DWORD PTR __Old_size$1$[ebp], ecx
  0001b	89 55 f8	 mov	 DWORD PTR __Old$1$[ebp], edx
  0001e	3b d8		 cmp	 ebx, eax
  00020	77 2e		 ja	 SHORT $LN2@append

; 3156 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00022	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00025	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 2296 :         value_type* _Result = _Bx._Buf;

  00028	8b c7		 mov	 eax, edi

; 2319 :         return _BUF_SIZE <= _Myres;

  0002a	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2297 :         if (_Large_string_engaged()) {

  0002d	72 02		 jb	 SHORT $LN5@append

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  0002f	8b 07		 mov	 eax, DWORD PTR [edi]
$LN5@append:

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00031	53		 push	 ebx
  00032	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 3157 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3158 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00035	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00038	56		 push	 esi
  00039	e8 00 00 00 00	 call	 _memmove
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3159 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00041	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0

; 3172 :     }

  00045	8b c7		 mov	 eax, edi
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8
$LN2@append:

; 4543 :         if (max_size() - _Old_size < _Size_increase) {

  00050	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00055	2b c1		 sub	 eax, ecx
  00057	3b c3		 cmp	 eax, ebx
  00059	0f 82 26 01 00
	00		 jb	 $LN68@append

; 4545 :         }
; 4546 : 
; 4547 :         const size_type _New_size     = _Old_size + _Size_increase;

  0005f	8d 34 19	 lea	 esi, DWORD PTR [ecx+ebx]

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00062	83 ce 0f	 or	 esi, 15			; 0000000fH
  00065	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 4489 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0006b	76 18		 jbe	 SHORT $LN19@append

; 4490 :             return _Max;

  0006d	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00072	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  00080	83 c4 04	 add	 esp, 4
  00083	eb 61		 jmp	 SHORT $LN66@append
$LN19@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4493 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00085	8b c2		 mov	 eax, edx
  00087	d1 e8		 shr	 eax, 1
  00089	89 45 0c	 mov	 DWORD PTR tv537[ebp], eax
  0008c	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00091	2b 45 0c	 sub	 eax, DWORD PTR tv537[ebp]
  00094	3b d0		 cmp	 edx, eax
  00096	76 18		 jbe	 SHORT $LN20@append

; 4494 :             return _Max;

  00098	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0009d	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  000ab	83 c4 04	 add	 esp, 4
  000ae	eb 36		 jmp	 SHORT $LN66@append
$LN20@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4497 :         return (_STD max)(_Masked, _Old + _Old / 2);

  000b0	8b 45 0c	 mov	 eax, DWORD PTR tv537[ebp]
  000b3	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  000b5	3b f0		 cmp	 esi, eax
  000b7	0f 42 f0	 cmovb	 esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4551 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  000ba	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000bd	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000c2	72 0e		 jb	 SHORT $LN27@append

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000ca	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  000cd	83 c4 04	 add	 esp, 4
  000d0	eb 14		 jmp	 SHORT $LN66@append
$LN27@append:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  000d2	85 c0		 test	 eax, eax
  000d4	74 0e		 je	 SHORT $LN28@append

; 85   :         return ::operator new(_Bytes);

  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 244  :         return _Traits::_Allocate(_Bytes);

  000dc	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]

; 85   :         return ::operator new(_Bytes);

  000df	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  000e2	eb 02		 jmp	 SHORT $LN66@append
$LN28@append:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000e4	33 c0		 xor	 eax, eax
$LN66@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4562 :         if (_BUF_SIZE <= _Old_capacity) {

  000e6	83 7d f8 10	 cmp	 DWORD PTR __Old$1$[ebp], 16 ; 00000010H
  000ea	8d 14 19	 lea	 edx, DWORD PTR [ecx+ebx]
  000ed	89 77 14	 mov	 DWORD PTR [edi+20], esi
  000f0	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  000f3	89 57 10	 mov	 DWORD PTR [edi+16], edx
  000f6	8d 14 1e	 lea	 edx, DWORD PTR [esi+ebx]
  000f9	89 45 0c	 mov	 DWORD PTR $T1[ebp], eax
  000fc	89 75 fc	 mov	 DWORD PTR tv534[ebp], esi
  000ff	89 55 f4	 mov	 DWORD PTR tv533[ebp], edx
  00102	51		 push	 ecx
  00103	72 56		 jb	 SHORT $LN13@append

; 4563 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  00105	8b 37		 mov	 esi, DWORD PTR [edi]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00107	56		 push	 esi
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 _memcpy
  0010e	53		 push	 ebx
  0010f	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00112	ff 75 fc	 push	 DWORD PTR tv534[ebp]
  00115	e8 00 00 00 00	 call	 _memcpy

; 3169 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0011a	8b 45 f4	 mov	 eax, DWORD PTR tv533[ebp]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0011d	83 c4 18	 add	 esp, 24			; 00000018H

; 4565 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  00120	8b 4d f8	 mov	 ecx, DWORD PTR __Old$1$[ebp]
  00123	41		 inc	 ecx

; 3169 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00124	c6 00 00	 mov	 BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00127	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0012d	72 12		 jb	 SHORT $LN52@append

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0012f	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  00132	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00135	2b f2		 sub	 esi, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00137	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  0013a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0013d	77 4b		 ja	 SHORT $LN49@append

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0013f	8b f2		 mov	 esi, edx
$LN52@append:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00141	51		 push	 ecx
  00142	56		 push	 esi
  00143	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3163 :         return _Reallocate_grow_by(

  00148	8b 45 0c	 mov	 eax, DWORD PTR $T1[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  0014b	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 3163 :         return _Reallocate_grow_by(

  0014e	89 07		 mov	 DWORD PTR [edi], eax

; 3172 :     }

  00150	8b c7		 mov	 eax, edi
  00152	5f		 pop	 edi
  00153	5e		 pop	 esi
  00154	5b		 pop	 ebx
  00155	8b e5		 mov	 esp, ebp
  00157	5d		 pop	 ebp
  00158	c2 08 00	 ret	 8
$LN13@append:

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0015b	57		 push	 edi
  0015c	50		 push	 eax
  0015d	e8 00 00 00 00	 call	 _memcpy
  00162	53		 push	 ebx
  00163	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00166	56		 push	 esi
  00167	e8 00 00 00 00	 call	 _memcpy

; 3169 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0016c	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0016f	83 c4 18	 add	 esp, 24			; 00000018H

; 3169 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00172	c6 00 00	 mov	 BYTE PTR [eax], 0

; 3163 :         return _Reallocate_grow_by(

  00175	8b 45 0c	 mov	 eax, DWORD PTR $T1[ebp]
  00178	89 07		 mov	 DWORD PTR [edi], eax

; 3172 :     }

  0017a	8b c7		 mov	 eax, edi
  0017c	5f		 pop	 edi
  0017d	5e		 pop	 esi
  0017e	5b		 pop	 ebx
  0017f	8b e5		 mov	 esp, ebp
  00181	5d		 pop	 ebp
  00182	c2 08 00	 ret	 8
$LN68@append:

; 4544 :             _Xlen_string(); // result too long

  00185	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN49@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0018a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN64@append:
  0018f	cc		 int	 3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 3002 :     _CONSTEXPR20_CONTAINER ~basic_string() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2319 :         return _BUF_SIZE <= _Myres;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 27		 jb	 SHORT $LN12@basic_stri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0000d	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN22@basic_stri

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN19@basic_stri

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN22@basic_stri:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN12@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi

; 3010 :     }

  00044	c3		 ret	 0
$LN19@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN27@basic_stri:
  0004a	cc		 int	 3
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 2337 :         _Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2374 :     _Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlen_strin:
  0000a	cc		 int	 3
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN12@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 142  :     }

  00003	8b c1		 mov	 eax, ecx

; 65   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 66   :     {
; 67   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 141  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN6@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 96   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 91   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 74   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
END
